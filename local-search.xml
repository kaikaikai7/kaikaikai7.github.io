<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dirsearch</title>
    <link href="/2023/10/18/CTF/%E5%B7%A5%E5%85%B7/dirsearch/"/>
    <url>/2023/10/18/CTF/%E5%B7%A5%E5%85%B7/dirsearch/</url>
    
    <content type="html"><![CDATA[<h1 id="常见用法">常见用法</h1><ul><li>dirsearch -u https://xxxx 扫描某个站点</li><li>dirsearch -u https://xxxx -r 递归扫描</li><li>dirsearch -u https://xxxx -r -t 30 线程控制请求速率扫描</li><li>dirsearch -u https://xxxx -r -t 30 --proxy 127.0.0.1:8080使用代理进行扫描</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备份文件</title>
    <link href="/2023/10/18/CTF/Web/%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6/"/>
    <url>/2023/10/18/CTF/Web/%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>常见的备份文件后缀名有:<code>.git .svn .swp .svn .~ .bak .bash_history</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP序列化和反序列化</title>
    <link href="/2023/10/18/CTF/Web/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/10/18/CTF/Web/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="序列化">1 序列化</h1><p>概念：在PHP中，序列化用于存储或传递 PHP的值的过程中，同时不丢失其类型和结构。</p><p>当调用<code>serialize()</code>函数序列化对象时，该函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，该方法会先被调用，然后才执行序列化操作。可以通过重载这个方法，从而自定义序列化行为。</p><p>public：属性被序列化的时候属性名会变成 <code>属性名</code></p><p>protected：属性被序列化的时候属性名会变成<code>\x00*\x00属性名</code></p><p>private：属性被序列化的时候属性名会变成<code>\x00类名\x00属性名</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;WuFei666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br>    <br><span class="hljs-comment">//输出结果</span><br>O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;WuFei666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>序列化对于不同类型得到的字符串格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$number</span> = <span class="hljs-number">34</span>;<br><span class="hljs-variable">$str</span> = <span class="hljs-string">&#x27;uusama&#x27;</span>;<br><span class="hljs-variable">$bool</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable">$null</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>);<br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$number</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$str</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$bool</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$null</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$arr</span>));<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">5</span>) <span class="hljs-string">&quot;i:34;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">13</span>) <span class="hljs-string">&quot;s:6:&quot;</span>uusama<span class="hljs-string">&quot;;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;b:1;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;N;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">30</span>) <span class="hljs-string">&quot;a:2:&#123;s:1:&quot;</span>a<span class="hljs-string">&quot;;i:1;s:1:&quot;</span>b<span class="hljs-string">&quot;;i:2;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="反序列化">2 反序列化</h1><p>概念：把序列化后的字符串恢复原样</p><p>若被反序列化的变量是一个对象，在成功重新构造对象之后，PHP会自动地试图去调用<code>__wakeup()</code>成员函数（如果存在的话）</p><p><code>__wakeup()</code>函数<strong>漏洞原理</strong>：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过<code>__wakeup()</code>的执行</p><p>参考教程：</p><ol type="1"><li><ahref="https://www.cnblogs.com/youyoui/p/8610068.html">深度剖析PHP序列化和反序列化- 悠悠i - 博客园 (cnblogs.com)</a></li><li><ahref="https://jiashi19.gitee.io/2023/09/18/ctf-web-php/">ctf-web练习(php)- Blog from js19 (gitee.io)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>phps文件</title>
    <link href="/2023/10/18/CTF/Web/phps%E6%96%87%E4%BB%B6/"/>
    <url>/2023/10/18/CTF/Web/phps%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>phps文件就是php的<strong>源代码文件</strong>，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的MIME类型的文件扩展名即可，但为了国际通用，所以才用了phps文件类型。</p><p>Detailed information for file extension PHPS:</p><p><strong>Primary association:</strong> <ahref="http://www.php.net/">PHP Source</a></p><p><strong>Company:</strong> <a href="http://www.php.net/">The PHPGroup</a></p><p><strong>File classification:</strong> Source Code</p><p><strong>Mime type:</strong> text/html,application/x-httpd-php-source, application/x-httpd-php3-source</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Robots协议</title>
    <link href="/2023/10/18/CTF/Web/Robots%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/18/CTF/Web/Robots%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><code>robots.txt</code>文件被网络爬虫用来检查是否允许它们抓取和索引该网站，或者只允许抓取和索引网站的部分内容。有时，这些文件会暴露<strong>目录结构</strong>，而不是保护内容不被抓取。</p><p>存放目录：<code>robots.txt</code>文件必须要存放在网站的根目录下，即通过<code>域名/robots.txt</code>可以访问此文件</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode Development</title>
    <link href="/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/"/>
    <url>/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1 Overview</h1><p>shellcode广泛用于许多涉及代码注入的攻击中。编写shellcode是相当有挑战性的。虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的。shellcode中涉及到几种有趣的技术。本实验室的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode。</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址。在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用函数时，其地址被推入堆栈（作为返回地址）。</p><h1 id="task-1-writing-shellcode">2 Task 1: Writing Shellcode</h1><h2 id="task-1.a-the-entire-process">2.1 Task 1.a: The EntireProcess</h2><ol type="1"><li><p>程序生命周期（源自CSAPP）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938146.png"alt="image-20231017191745744" /><figcaption aria-hidden="true">image-20231017191745744</figcaption></figure></li><li><p>大端模式和小端模式。大多数英特尔 CPU都使用小端模式，本实验也采用小端模式。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938147.png"alt="image-20231017191842781" /><figcaption aria-hidden="true">image-20231017191842781</figcaption></figure></li><li><p>使用nasm 编译汇编代码(mysh.s)，通过链接得到可执行文件。注：nasm是用于 Intel x86和 x64架构的汇编和反汇编程序。-felf32选项表明我们希望将代码编译为32位 ELF 二进制格式，-m elfi386选项表示生成 32 位 ELF 二进制文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938148.png"alt="image-20231017191935519" /><figcaption aria-hidden="true">image-20231017191935519</figcaption></figure></li><li><p>通过./mysh运行最终的可执行代码 mysh。执行前后使用echo$$得到当前shell进程的id，从而验证是否成功开启了新的shell。通过下图可以看到执行前后shell进程ID发生了变化。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938149.png"alt="image-20231017192027041" /><figcaption aria-hidden="true">image-20231017192027041</figcaption></figure></li><li><p>利用<code>objdump</code>进行反汇编，从可执行文件或目标文件中提取机器代码（从技术上讲，只有机器代码才称为shellcode，可执行文件中包含实际机器代码以外的数据）。<code>-Mintel</code>表示显示Intel格式的汇编代码，默认为AT&amp;T格式；<code>–-disassemble</code>表示反汇编，可以使用-d代替。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938150.png"alt="image-20231017192108808" /><figcaption aria-hidden="true">image-20231017192108808</figcaption></figure></li><li><p>使用 xxd 命令打印出二进制文件的内容，可以从打印输出的内容中找出shellcode 的机器码,方便进行复制。-p表示列之间不需要空格，-c20表示一行有20个字符。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938151.png"alt="image-20231017192203497" /><figcaption aria-hidden="true">image-20231017192203497</figcaption></figure></li><li><p>提取出目标序列，先复制到convert.py中，运行conver.py得到shellcode数组</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938152.png"alt="image-20231017192221909" /><figcaption aria-hidden="true">image-20231017192221909</figcaption></figure></li></ol><h2 id="task-1.b.-eliminating-zeros-from-the-code">2.2 Task 1.b.Eliminating Zeros from the Code</h2><ol type="1"><li><p>背景：Shellcode广泛应用于缓冲区溢出攻击。在许多情况下，漏洞是由字符串复制引起的，例如strcpy()函数。对于这些字符串复制函数，0x00被认为是字符串的末尾。因此，如果我们在shellcode的中间有一个零，字符串复制将不能将零后面的任何内容从这个shellcode复制到目标缓冲区，因此攻击将不能成功。</p></li><li><p>代码 mysh.s需要在四个不同的地方使用零。请指出所有这些地方，并解释代码如何使用零，但又不在代码中引入零。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171925789.png"alt="image-20231017192537333" /><figcaption aria-hidden="true">image-20231017192537333</figcaption></figure><ul><li>eax置0：相同值逐位异或得到全零</li><li>使用eax（第一步构造得到）作为字符串终止符，而不是直接使用0x00</li><li>edx置0：相同值逐位异或得到全零</li><li>eax=0x0000000b：直接赋值moveax,0x0000000b会出现截止符，所有先使用异或将eax置0，再将0x0b赋值给eax的低8位</li></ul></li><li><p>执行/bin/bash，并且不可以有多余的/。通常，要将此字符串推入堆栈，我们需要让长度为4 的倍数，因此我们要将字符串转换为 /bin////bash。</p><ul><li>目标：构造出字符串/bin/bash\0。使用移位操作得到字符串末尾0，避免strcpy失败。注：Push是四个字节对齐的，因此必须每次压栈四个字节或者一个字节一个字节赋值；构造argv[1]前需将eax置0。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938153.png"alt="image-20231017192751122" /><figcaption aria-hidden="true">image-20231017192751122</figcaption></figure><ul><li><p>先进行编译链接，然后反汇编查看机器代码，没有0x00</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938154.png"alt="image-20231017192810335" /><figcaption aria-hidden="true">image-20231017192810335</figcaption></figure></li><li><p>执行mysh_1b，成功得到一个shell。注：需要以管理员权限运行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938155.png"alt="image-20231017192830367" /><figcaption aria-hidden="true">image-20231017192830367</figcaption></figure></li></ul></li></ol><h2 id="task-1.c.-providing-arguments-for-system-calls">2.3 Task 1.c.Providing Arguments for System Calls</h2><ol type="1"><li><p>目标：使用execve实现以下命令的执行：/bin/sh -c "ls -la"</p></li><li><p>execve()函数原型：filename:准备载入当前进程空间的新程序的路径名。既可以是绝对路径，又可以是相对路径。argv[]:指定了传给新进程的命令行参数，该数组对应于c语言main函数的argv参数数组，格式也相同，argv[0]对应命令名，通常情况下该值与filename中的basename(就是绝对路径的最后一个)相同。envp[]:最后一个参数envp指定了新程序的环境列表。参数envp对应于新程序的environ数组。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938156.png"alt="image-20231017193028508" /><figcaption aria-hidden="true">image-20231017193028508</figcaption></figure></li><li><p>系统调用是通过<code>int 0x80</code>来实现的，对于该函数，寄存器eax放execve的系统调用号11；寄存器ebx放文件路径，即第一个参数；寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要<strong>以空指针(NULL)结束</strong>；寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p></li><li><p>构造参数数组，先将参数压入栈，再从右至左依次将参数指针压入栈。argv[3]=0，作为结尾空指针；argv[2]= "ls -la",使用移位操作构造0；argv[1] ="-c"，同样通过移位操作构造0；argv[0] =points"/bin//sh"。最后，依次将参数指针压入栈，把argv[]地址赋值给ecx。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938157.png"alt="image-20231017193216676" /><figcaption aria-hidden="true">image-20231017193216676</figcaption></figure></li><li><p>编译链接，运行可执行文件，成功运行目标命令</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938158.png"alt="image-20231017193236306" /><figcaption aria-hidden="true">image-20231017193236306</figcaption></figure></li></ol><h1 id="task-2-using-code-segment">3 Task 2: Using Code Segment</h1><ol type="1"><li><p>mysh2.s代码总体流程：执行jmp shorttwo语句，跳转到two中执行，two中调用one，再跳转到one中执行。这段汇编代码的主要目的是使用execve系统调用来执行/bin/sh程序。argv[]数组：argv[0]=字符串（shellcode）地址，存储于[ebx+8]位置；argv[1]=NULL指针，存储于[ebx+12]位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br>        pop ebx# ebx=字符串(shellcode)地址<br>        xor eax, eax# eax=0<br>        mov [ebx+7], al# [ebx+7]=0  前8字节内容：/bin/sh\0<br>        mov [ebx+8], ebx   # 赋值前：[ebx+8]=AAAA  赋值后：[ebx+8]=字符串(shellcode)地址<br>        mov [ebx+12], eax# 赋值后：[ebx+12]=BBBB 赋值后：[ebx+12]=0<br>        lea ecx, [ebx+8] # ecx=argv[]地址<br>        xor edx, edx# edx=0 即无环境变量<br>        mov al,  0x0b# eax=11（十进制）即系统调用号<br>        int 0x80# 执行系统调用<br>    two:<br>        call one# 调用one函数，将下一条语句地址压入栈，作为ret，再跳转到one中继续执行<br>        db &#x27;/bin/sh*AAAABBBB&#x27; # shellcode<br></code></pre></td></tr></table></figure></li><li><p>目标：执行命令<code>/usr/bin/env -i a=11 b=22</code>。该命令用于清除环境变量并为两个特定变量a 和 b 设置新的值。</p><ul><li><p>代码编写：代码工作主要集中在argv[]的构造，从参数1指针到参数5指针，地址递增，而栈空间是由高地址向低地址增长，符合从右至左依次入栈。其余部分与实例代码基本相同</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938159.png"alt="image-20231017193603321" /><figcaption aria-hidden="true">image-20231017193603321</figcaption></figure></li><li><p>编译链接执行，成功打印环境变量</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938160.png"alt="image-20231017193616472" /><figcaption aria-hidden="true">image-20231017193616472</figcaption></figure></li></ul></li></ol><h1 id="总结">4 总结</h1><h2 id="去除二进制代码中的零">4.1 去除二进制代码中的零</h2><ul><li><p>使用<code>xor eax，eax</code>代替<code>mov eax, 0</code></p></li><li><p>如果我们要存储0x0000099到 eax。我们不能只使用 moveax，0x99，因为第二个操作数实际上是0x0000099，它包含三个零。首先将 eax设置为零，然后为 al 寄存器分配一个1字节的数字0x99</p></li><li><p>使用移位操作，下面操作等价于将xyz\0赋给ebx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ebx, &quot;xyz#&quot;<br>shl ebx, 8<br>shr ebx, 8<br></code></pre></td></tr></table></figure></li></ul><h2 id="获取命令中使用的数据地址">4.2 获取命令中使用的数据地址</h2><ul><li>动态地在堆栈上构建所有必要的数据结构，因此可以从堆栈指针esp获取数据地址</li><li>数据存储在代码区中，其地址通过函数调用机制获取</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://gls.show/p/a10ed24d/#Task-2-Using-Code-Segment">SEED-lab：ShellcodeDevelopment Lab - 郭佳明的博客 (gls.show)</a></li><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-shellcode编写/#Task2">网络攻防-shellcode编写- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_33955922/article/details/53956547">Linux执行新程序：execve() 函数_execve函数-CSDN博客</a></li><li><ahref="https://blog.csdn.net/m0_55368674/article/details/128673160">系统调用功能号与execve函数详解_Razors_的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS攻击代码检测</title>
    <link href="/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导入模块">1 导入模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score, recall_score<br><span class="hljs-keyword">import</span> joblib<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br></code></pre></td></tr></table></figure><h1 id="数据预处理">2 数据预处理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取数据</span><br>normal_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/dmzo_nomal.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br>xss_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/xssed.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 创建标签</span><br>normal_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 0 表示正常语句</span><br>xss_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">1</span>     <span class="hljs-comment"># 1 表示攻击性语句</span><br><br><span class="hljs-comment"># 合并数据</span><br>data = pd.concat([normal_data, xss_data], ignore_index=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 转换为小写</span><br>data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">str</span>.lower()<br><br><span class="hljs-comment"># 打印前五行数据</span><br><span class="hljs-built_in">print</span>(data.head())<br><span class="hljs-comment"># 打印后五行数据</span><br><span class="hljs-built_in">print</span>(data.tail())<br><br><span class="hljs-comment"># 特征提取</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features</span>(<span class="hljs-params">text</span>):<br>    script_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;script&#x27;</span>, text, re.I))<br>    java_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;java&#x27;</span>, text, re.I))<br>    iframe_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;iframe&#x27;</span>, text, re.I))<br>    alert_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;alert&#x27;</span>, text, re.I))<br>    lt_count = text.count(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>    gt_count = text.count(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>    double_quote_count = text.count(<span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>    single_quote_count = text.count(<span class="hljs-string">&quot;\&#x27;&quot;</span>)<br>    percent_count = text.count(<span class="hljs-string">&#x27;%&#x27;</span>)<br>    left_parenthesis_count = text.count(<span class="hljs-string">&#x27;(&#x27;</span>)<br>    right_parenthesis_count = text.count(<span class="hljs-string">&#x27;)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> [script_count, java_count, iframe_count, lt_count,alert_count, gt_count, double_quote_count,<br>            single_quote_count, percent_count, left_parenthesis_count, right_parenthesis_count]<br><br>data[<span class="hljs-string">&#x27;features&#x27;</span>] = data[<span class="hljs-number">0</span>].apply(extract_features)<br></code></pre></td></tr></table></figure><h1 id="模型训练">3 模型训练</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据拆分为特征和标签</span><br>X = <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;features&#x27;</span>])<br>y = data[<span class="hljs-string">&#x27;label&#x27;</span>]<br><br><span class="hljs-comment"># 拆分数据集为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建SVM分类器</span><br>svm_classifier = SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>)<br><br><span class="hljs-comment"># 训练模型，并加入进度条</span><br>num_epochs = <span class="hljs-number">100</span>  <span class="hljs-comment"># 设置训练迭代次数</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(num_epochs), desc=<span class="hljs-string">&quot;Training SVM&quot;</span>):<br>    svm_classifier.fit(X_train, y_train)<br><br><span class="hljs-comment"># 保存训练好的模型到文件</span><br>joblib.dump(svm_classifier, <span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 预测测试集</span><br>y_pred = svm_classifier.predict(X_test)<br></code></pre></td></tr></table></figure><h1 id="模型评估">4 模型评估</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算准确率和召回率</span><br>accuracy = accuracy_score(y_test, y_pred)<br>recall = recall_score(y_test, y_pred)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;准确率: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;召回率: <span class="hljs-subst">&#123;recall:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="测试">5 测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载已保存的模型</span><br>loaded_model = joblib.load(<span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 输入数据测试</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_safe</span>(<span class="hljs-params">user_input, model</span>):<br>    features = extract_features(user_input)<br>    prediction = model.predict([features])<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;安全&quot;</span> <span class="hljs-keyword">if</span> prediction[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;不安全&quot;</span><br><br>user_input = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要检测的语句: &quot;</span>)<br><span class="hljs-built_in">print</span>(user_input)<br>user_input = user_input.lower()<br>result = is_safe(user_input, loaded_model)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;result&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>实践篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH4-软件漏洞-缓冲区溢出</title>
    <link href="/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">4.1 概述</h1><p><strong>漏洞定义：</strong>可以被攻击利用的系统弱点</p><p><strong>漏洞攻击过程：</strong>漏洞发现、漏洞分析、漏洞利用</p><p><strong>漏洞造成后果：</strong>以匿名身份直接获取系统最高权限；从普通用户提升为管理员用户；实施远程拒绝服务攻击等</p><h1 id="典型的漏洞类型">4.2 典型的漏洞类型</h1><h2 id="栈溢出">4.2.1 栈溢出</h2><h3 id="栈溢出原理">1.栈溢出原理</h3><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括代码段、数据段和堆栈段三部分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742321.png"alt="image-20231015162805933" /><figcaption aria-hidden="true">image-20231015162805933</figcaption></figure><p>程序在内存中的存放形式</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742323.png"alt="image-20231015163018123" /><figcaption aria-hidden="true">image-20231015163018123</figcaption></figure><ul><li>代码段(.text)：也称文本段(TextSegment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误(SegmentationFault)</li><li>数据段：包括已初始化的数据段(.data)和未初始化的数据段(.bss)，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。</li><li>堆（Heap）：向<strong>高</strong>地址扩展的数据结构，是不连续的内存区域。动态分配，其空间的分配和释放都由程序员控制。也就是说，堆的大小并不固定，可动态扩张或缩减，其分配由<code>malloc()</code>等这类实时内存分配函数来实现。当进程调用<code>malloc()</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free()</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>栈（Stack）：向<strong>低</strong>地址扩展的数据结构，是一块连续的内存区域。一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。由编译器自动管理，其分配方式有两种：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由<code>alloca()</code>函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需手工控制。</li></ul><p>实例：假设一个程序的函数调用顺序为：主函数main调用函数func1，函数func1调用函数func2。当这个程序被操作系统调入内存运行时，其对应的进程在内存中的映射结果如下图所示。进程的<strong>栈</strong>是由多个<strong>栈帧</strong>构成的，其中每个<strong>栈帧</strong>都对应一个<strong>函数调用</strong>。当调用函数时，新的栈帧被压入栈；当函数返回时，相应的栈帧从栈中弹出。各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。由于需要将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来了极大的隐患。</p><p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742324.png"alt="image-20231015163904871" /><figcaption aria-hidden="true">image-20231015163904871</figcaption></figure><p><strong>栈帧：</strong>某个函数运行时，机器需要分配一定的内存去进行函数内的各种操作，这个过程中分配的那部分栈称为栈帧。下图描述了栈帧的通用结构。栈帧是一段有界限的内存区间，由最顶端的两个指针界定，寄存器%ebp为帧指针，而寄存器%esp为栈指针。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742325.png"alt="image-20231015165704058" /><figcaption aria-hidden="true">image-20231015165704058</figcaption></figure><h3 id="函数调用机制">2.函数调用机制</h3><ol type="1"><li><p><strong>从右至左</strong>依次把被调函数需要的参数压入栈</p></li><li><p>使用call指令调用被调函数，并把call指令的下一条指令的地址作为返回地址压入栈中（该压栈操作隐含在call指令中）。call指令完成两项操作：一是将返回地址（call指令下一条指令地址）压入栈，二是跳转到调用函数入口处</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">call</span> 被调用函数地址<br><span class="hljs-meta"># 等价操作</span><br><span class="hljs-keyword">push</span> 返回地址<br><span class="hljs-keyword">jmp</span>  被调用函数地址<br></code></pre></td></tr></table></figure></li><li><p>进入被调函数执行。被调函数会先保存调用者函数的栈底地址（<code>push ebp</code>），然后进行栈帧切换，把调用者函数的栈顶切换成被调函数的栈底，即调用函数的栈顶就是当前被调函数的栈底（<code>mov ebp，esp</code>）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure></li><li><p>为局部变量和临时变量开辟存储空间。先定义的变量先入栈，后定义的变量后入栈。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>，xxx<br></code></pre></td></tr></table></figure></li><li><p>函数调用返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># 恢复栈帧<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br># 返回调用者函数执行<br><span class="hljs-keyword">ret</span>  # 等价于<span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：C程序每条语句对寄存器的影响情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">16</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, add(i, j));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">汇编</th><th style="text-align: center;">影响</th><th style="text-align: center;">受影响的寄存器取值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">mov dword ptr [i],0Ah</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818CC</td></tr><tr class="even"><td style="text-align: center;">mov dword ptr [j],10h</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818D3</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [j]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 00000010;EIP = 00A818D6</td></tr><tr class="even"><td style="text-align: center;">push eax</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF958;EIP = 00A818D7</td></tr><tr class="odd"><td style="text-align: center;">mov ecx,dword ptr [i]</td><td style="text-align: center;">ECX;EIP</td><td style="text-align: center;">ECX = 0000000A;EIP = 00A818DA</td></tr><tr class="even"><td style="text-align: center;">push ecx</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF954;EIP = 00A818DB</td></tr><tr class="odd"><td style="text-align: center;">push ebp</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF94C;EIP = 00A81771</td></tr><tr class="even"><td style="text-align: center;">mov ebp,esp</td><td style="text-align: center;">EBP=ESP;EIP</td><td style="text-align: center;">EBP = 00EFF94C;EIP = 00A81773</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [a]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000000A;EIP = 00A81794</td></tr><tr class="even"><td style="text-align: center;">add eax,dword ptr [b]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000001A;EIP = 00A81797</td></tr><tr class="odd"><td style="text-align: center;">mov esp,ebp</td><td style="text-align: center;">ESP=EBP；EIP</td><td style="text-align: center;">EIP = 00A817A9</td></tr><tr class="even"><td style="text-align: center;">pop ebp</td><td style="text-align: center;">EBP;ESP+4;EIP</td><td style="text-align: center;">EBP = 00B8F9CC;ESP = 00B8F8DC;EIP =00A817AA</td></tr><tr class="odd"><td style="text-align: center;">ret</td><td style="text-align: center;">ESP+4;EIP</td><td style="text-align: center;">ESP = 00B8F8E0;EIP = 00A818E0</td></tr><tr class="even"><td style="text-align: center;">add esp,8</td><td style="text-align: center;">ESP+8;EFL;EIP</td><td style="text-align: center;">ESP = 00B8F8E8;EFL = 00000206;EIP =00A818E3</td></tr></tbody></table><h2 id="堆溢出">4.2.2 堆溢出</h2><h2 id="格式化串漏洞">4.2.3 格式化串漏洞</h2><h2 id="整型溢出">4.2.4 整型溢出</h2><h2 id="释放再使用">4.2.5 释放再使用</h2><h1 id="溢出漏洞利用原理">4.3 溢出漏洞利用原理</h1><h2 id="溢出攻击的基本流程">4.3.1 溢出攻击的基本流程</h2><ol type="1"><li>注入恶意数据</li><li>溢出缓冲区</li><li>重定向控制流</li><li>执行有效载荷</li></ol><h2 id="溢出利用的关键技术">4.3.2 溢出利用的关键技术</h2><ul><li>溢出点定位</li><li>覆盖执行控制地址</li><li>覆盖异常处理结构</li><li>跳转地址的确定</li><li>Shellcode定位和跳转</li></ul><h1 id="漏洞利用保护机制">4.4 漏洞利用保护机制</h1><ul><li>GS编译保护机制</li><li>SafeSEH保护机制</li><li>DEP机制</li><li>ASLR机制</li></ul><p>参考教程：</p><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/186812518">一文理解缓冲区溢出- 知乎 (zhihu.com)</a></li><li>https://blog.csdn.net/xbb224007/article/details/80106961</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_3L</title>
    <link href="/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/"/>
    <url>/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-03-01">Lab 03-01</h1><h2 id="简要答案">简要答案</h2><p>Q1：找出这个恶意代码的导入函数与字符串列表?</p><p>Q2：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q3：这个恶意代码是否存在一些有用的网络特征码？如果存在，它们是什么？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122856.png"alt="image-20231014085930356" /><figcaption aria-hidden="true">image-20231014085930356</figcaption></figure><h2 id="详细分析">详细分析</h2><p>首先用PEiD打开<code>Lab03-01.exe</code>，可以看到<code>Lab03-01.exe</code>是加壳的</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122857.png"alt="image-20231012162113880" /><figcaption aria-hidden="true">image-20231012162113880</figcaption></figure><p>查看导入表，唯一的导入函数是<code>ExitProcess</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122858.png"alt="image-20231012162344159" /><figcaption aria-hidden="true">image-20231012162344159</figcaption></figure><p>Strings查看字符串，因为文件加壳，所以有很多不可识别字符串，但我们还是可以看到一些可能有用的信息，如：注册表、网址等。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122859.png"alt="image-20231013184322657" /><figcaption aria-hidden="true">image-20231013184322657</figcaption></figure><p>先运行进程监视器、进程浏览器、Wireshark，再运行<code>Lab03-01.exe</code>。使用进程浏览器查看<code>Lab03-01.exe</code>的Handles，发现其创建了一个互斥量，恶意程序经常进行该操作，从而在某个时刻独占某个计算机资源。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122860.png"alt="image-20231013184906179" /><figcaption aria-hidden="true">image-20231013184906179</figcaption></figure><p>再查看该程序的DLLs，下图框选的两个动态链接库说明程序有联网操作</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122861.png"alt="image-20231013185452760" /><figcaption aria-hidden="true">image-20231013185452760</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122863.png"alt="image-20231014085102970" /><figcaption aria-hidden="true">image-20231014085102970</figcaption></figure><p>使用进程监视器设置过滤条件，以查看恶意代码对文件系统和注册表的修改操作</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122864.png"alt="image-20231013185649467" /><figcaption aria-hidden="true">image-20231013185649467</figcaption></figure><p>Seed表明该程序可能会有一些随机数相关的操作；程序创建了一个可执行文件<code>vmx32to64</code>；加入了一个自启动项<code>VideoDriver</code>。我们经常需要筛选出一定数量的噪声，<code>HKLM\SOFTARE\Microsoft\Cryptography\RNG\Seed</code>键值上的 <code>RegSetValue</code>操作是典型的噪声。因为随机数发生器的种子会有软件在注册表中不停地更新。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122865.png"alt="image-20231013190041973" /><figcaption aria-hidden="true">image-20231013190041973</figcaption></figure><p>查看自启动项关联的可执行文件，比对大小（或比对md5值），发现刚好与<code>Lab03-01.exe</code>相同，可以判断它们就是同一个程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122866.png"alt="image-20231013191125258" /><figcaption aria-hidden="true">image-20231013191125258</figcaption></figure><p>查看wireshark，可以看到在不断进行www.practicalmalwareanalysis.com的域名解析</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122867.png"alt="image-20231013192113703" /><figcaption aria-hidden="true">image-20231013192113703</figcaption></figure><h1 id="lab-03-02">Lab 03-02</h1><h2 id="简要答案-1">简要答案</h2><p>Q1：你怎样才能让这个恶意代码自行安装？</p><p>Q2：在安装之后，你如何让这个恶意代码运行起来？</p><p>Q3：你怎么能找到这个恶意代码是在哪个进程下运行的？</p><p>Q4：你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？</p><p>Q5：这个恶意代码在主机上的感染迹象特征是什么？</p><p>Q6：这个恶意代码是否存在一些有用的网络特征码？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122868.png"alt="image-20231014104724395" /><figcaption aria-hidden="true">image-20231014104724395</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122869.png"alt="image-20231014104745673" /><figcaption aria-hidden="true">image-20231014104745673</figcaption></figure><h2 id="详细分析-1">详细分析</h2><p>使用PEiD分析其导出表、导入表。导出函数<code>ServiceMain</code>表明，这个恶意代码需要安装成一个服务，使其能够正常运行。这里包括了一些服务操作函数，比如<code>CreateService</code>，以及一些注册表操作函数，如函数<code>RegSetValueEX</code>。导入的网络操作函数，如<code>HttpSendRequest</code>等，表明恶意代码使用了HTTP。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122870.png"alt="image-20231014084906992" /><figcaption aria-hidden="true">image-20231014084906992</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122871.png"alt="image-20231014085536840" /><figcaption aria-hidden="true">image-20231014085536840</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122872.png"alt="image-20231014085613379" /><figcaption aria-hidden="true">image-20231014085613379</figcaption></figure><p>使用strings检查字符串列表。我们看到了一些有趣的字符串，包括注册表位置、域名、一些独特的字符串如<code>IPRIP</code>和<code>serve.html</code>，以及一些编码的字符串。动态分析基础技术可能会告诉我们这些字符串和导入函数如何被使用的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122873.png"alt="image-20231013193555611" /><figcaption aria-hidden="true">image-20231013193555611</figcaption></figure><p>先用Regshot对注册表做个基线快照，并且使用ProcessExplorer来监控在系统上运行的进程，然后使用<code>rundll32.exe</code>来安装恶意代码，在安装完恶意代码之后，我们使用ProcessExplorer，来确定<code>rundll32.exe</code>已经终止，不在进程列表中了。然后，我们用Regshot工具做第二个快照，来看看恶意代码是否已经在注册表中安装自身了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 利用rundll32.exe 工具，使用命令 rundll32.exe Lab03-01.dll,installA</span><br><span class="hljs-comment"># 运行恶意代码导出函数便可将恶意代码安装为一个服务。</span><br><span class="hljs-comment"># installA从前面静态分析中得到</span><br>rundll32.exe Lab03-02.dll,installA<br></code></pre></td></tr></table></figure><p>分析快照比对结果。发现恶意代码将自身安装为<code>IPRIP</code>服务，由于这个恶意代码是一个DLL文件，它依赖于一个可执行文件来执行它。事实上，我们在看到<code>ImagePath</code>被设置为<code>svchost.exe</code>，这意味着，这个恶意代码将会在一个<code>svchost.exe</code>进程中启动。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122874.png"alt="image-20231014094117030" /><figcaption aria-hidden="true">image-20231014094117030</figcaption></figure><p>根据字符串查找的线索检查注册表项，我们可以看到其他可能被使用的服务名称，比如<code>6to4 AppNgmt</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122875.png"alt="image-20231014094736934" /><figcaption aria-hidden="true">image-20231014094736934</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122876.png"alt="image-20231014094633180" /><figcaption aria-hidden="true">image-20231014094633180</figcaption></figure><p>开始进行动态分析，我们将运行procmon工具（并清除所有事件），启动ProcessExplorer，以及配置一个虚拟网络，包括ApateDNS、监听端口80的Netcat（因为我们在字符串列表中看到了HTTP）。由于这个恶意代码安装为<code>IPRIP</code>服务，我们可以使用Windows中的net命令来启动它，具体命令如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122877.png"alt="image-20231014095227121" /><figcaption aria-hidden="true">image-20231014095227121</figcaption></figure><p>使用进程浏览器查找恶意代码运行的进程，可以得到<code>Lab03-02.dll</code>是由PID为1052的<code>svchost.exe</code>进程加载的</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122878.png"alt="image-20231014095326064" /><figcaption aria-hidden="true">image-20231014095326064</figcaption></figure><p>在ProcessExplorer中，我们选择<code>View→Lower Pane View→DLLs</code>，选择运行为PID为1052的<code>svchost.exe</code>进程。当我们看到<code>Lab03-02.dll</code>被装载时证实了恶意代码在<code>svchost.exe</code>进程中运行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122879.png"alt="image-20231014100153686" /><figcaption aria-hidden="true">image-20231014100153686</figcaption></figure><p>接下来，我们将注意力转移到网络分析工具上。首先，我们检查ApateDNS，查看恶意代码是否执行了DNS请求。输出结果显示了一个向<code>practicalmalwareanazysis.com</code>的DNS请求，这也匹配到了静态分析得到的字符串列表。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122880.png"alt="image-20231014102157123" /><figcaption aria-hidden="true">image-20231014102157123</figcaption></figure><p>最后分析Netcat结果来完成我们的网络分析。我们看到，恶意代码执行了一个通过80端口的HTTPGET请求（我们让Netcat在80端口上监听，是因为我们在字符串列表中看到了HTTP）。我们多次运行这个测试，数据显示结果对每次运行都是一致的（未能成功观测到）。</p><h1 id="lab-03-03">Lab 03-03</h1><p>Q1：当你使用Process Explorer工具进行监视时，你注意到了什么?</p><p>Q2：你可以找出任何的内存修改行为吗?</p><p>Q3：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q4：这个恶意代码的目的是什么?</p><h2 id="简要答案-2">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122881.png"alt="image-20231014105200733" /><figcaption aria-hidden="true">image-20231014105200733</figcaption></figure><h2 id="详细分析-2">详细分析</h2><p>对于这个实验，我们首先启动ProcessExplorer和procmon工具。<code>Lab03-03.exe</code>可以从命令提示符运行，或者通过双击图标运行。一旦运行之后，<code>La03-03.exe</code>应该在ProcessExplorer中看得到。请注意它是如何创建子进程<code>svchost.exe</code>的，创建之后它便退出了，将<code>svchost.exe</code>进程继续作为一个“孤儿”进程(没有父进程的进程）执行。<code>svchost.exe</code>作为“孤儿”进程是极不寻常而且是高度可疑的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122882.png"alt="image-20231014110346346" /><figcaption aria-hidden="true">image-20231014110346346</figcaption></figure><p>查看该进程属性，从这个相同的属性页面中，我们选择Strings同时显示在磁盘镜像中和内存镜像中可执行文件的字符串列表。通过在Image和Memory单选按钮之间切换，可以看出两者镜像中的显著差异。内存镜像中有一些可疑字符串，如日志、键盘操作符，表明这个程序很可能是一个击键记录器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122883.png"alt="image-20231014110948757" /><figcaption aria-hidden="true">image-20231014110948757</figcaption></figure><p>为进行测试，创建文本文件，之后在进程监视器中设置过滤条件查看结果，发现该进程正在写一个日志文件，这与在<code>svchos.exe</code>“孤儿”进程的内存镜像视图中看到的一个字符串相同，打开该日志文件，显示出了刚才在记事本中的击键记录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122884.png"alt="image-20231014111326609" /><figcaption aria-hidden="true">image-20231014111326609</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122885.png"alt="image-20231014111416534" /><figcaption aria-hidden="true">image-20231014111416534</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122886.png"alt="image-20231014111459029" /><figcaption aria-hidden="true">image-20231014111459029</figcaption></figure><h1 id="lab-03-04">Lab 03-04</h1><h2 id="简要答案-3">简要答案</h2><p>Q1：当你运行这个文件时，会发生什么呢?</p><p>Q2：是什么原因造成动态分析无法有效实施?</p><p>Q3：是否有其他方式来运行这个程序?</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122887.png"alt="image-20231014112009958" /><figcaption aria-hidden="true">image-20231014112009958</figcaption></figure><h2 id="详细分析-3">详细分析</h2><p>我们开始使用静态分析基础技术，研究PE文件结构和字符串列表。我们看到这个恶意代码导入了一些联网功能函数、服务操作函数和注册表操作函数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122888.png"alt="image-20231014113403301" /><figcaption aria-hidden="true">image-20231014113403301</figcaption></figure><p>在下面的列表中，我们关注到一些有趣的字符串。我们看到域名、注册表位置;像DOWNLOAD、UPLOAD这样的命令字符串，以及HTTP/1.0字符串等。这些表明恶意代码可能是一个HTTP后门程序。字符串-cc、-re、-in应该是一些命令行参数（例如-in可能是install的缩写）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122889.png"alt="image-20231014113629375" /><figcaption aria-hidden="true">image-20231014113629375</figcaption></figure><p>启动进程浏览器，进程监视器。当我们运行恶意代码后，它立刻进行自我删除。进程浏览器中无特别行为，再查看进程监视器，设置过滤条件，发现该恶意代码创建了一个进程，从而实现自我删除。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122890.png"alt="image-20231014114225466" /><figcaption aria-hidden="true">image-20231014114225466</figcaption></figure><p>尝试使用命令行运行恶意代码，并使用我们在字符串列表中发现的一些命令行参数（-in、-re、-cc），但这些努力都以失败告终，结果程序还是会删除自身。</p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/04%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/04%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="沙箱">1 沙箱</h1><ul><li>沙盒技术：用于安全运行程序的安全环境，经常被用于执行和分析非可信的代码</li><li>作用：<ul><li>样本是否对硬盘读写，创建了什么文件</li><li>样本是否进行网络连接，连接什么端口</li><li>创建了哪些进程（系统/用户），进程有哪些API函数调用</li><li>相关的可疑文件大小和MD5</li><li>文件是否加壳压缩</li><li>是否是已知病毒</li></ul></li><li>缺点：<ul><li>只能简单地运行可执行程序，如果需要命令行运行，无法触发</li><li>不能记录所有事件，尤其是需要长时间等待的情况</li><li>恶意代码会进行虚拟机检测</li><li>运行环境需要特定的注册表项或文件</li><li>如果是一个DLL，无法正确调用执行</li><li>操作系统的限制</li><li>结论需要安全人员自己总结</li></ul></li></ul><h1 id="运行恶意代码">2 运行恶意代码</h1><ul><li><p>exe：命令行或双击</p></li><li><p>dll：命令行</p></li><li><p>rundll (window系统自带程序)执行以下步骤：</p><ul><li>分析命令行</li><li>通过 LoadLibrary( ) 加载指定的 DLL</li><li>通过 GetProcAddress( ) 获取<code>entrypoint</code> 函数的地址</li><li>调用<code>entrypoint</code>函数，并传递作为<code>optional arguments</code>的命令行尾</li><li>当<code>entrypoint</code>函数返回时，rundll.exe 将卸载 DLL并退出</li></ul></li><li><p>执行DLL文件中的导出函数</p><ul><li><code>C:\Windows\System32\rundll32.exe ipr32x.dll,Install ServiceName</code></li><li><code>C:\Windows\System32\rundll32.exe rip.dll,Install</code></li><li><code>C:\Windows\System32\rundll32.exe xyzzy.dll,#5</code></li></ul></li></ul><h1 id="进程监视器">3 进程监视器</h1><ul><li>ProcessMonitor是一款Windows平台下优秀的监视工具，该工具提供了一种可监视特定注册表、文件系统、网络、进程以及线程活动的方法</li><li>Process Monitor能够监视所有系统调用并迅速收集信息。因为WindowsOS总是有许多的系统调用，有时候我们获取到的东西毫无价值，</li><li>Process Monitor通过一个过滤选项卡来解决了这个问题。</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/procmon</p><h1 id="进程浏览器">4 进程浏览器</h1><ul><li>ProcessExplorer是一款用来执行动态分析的工具，它能够洞察到系统当前进程</li><li>在运行二进制文件之后创建的一个进程，单击进程可以帮助用户查看进程的变化</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</p><h1 id="regshot比较注册表快照">5 Regshot比较注册表快照</h1><p>快照比对方法：</p><ol type="1"><li>对“干净”资源列表做快照</li><li>运行恶意代码（提供较充分的运行时间5分钟）</li><li>对恶意代码运行后的“脏”资源列表做快照</li><li>对比“干净”和“脏”快照，获取恶意代码行为结果</li></ol><ul><li>资源名称列表中的差异：发现新建、删除的行为结果</li><li>资源内容的差异：完整性校验，发现修改的行为结果</li></ul><p><strong>缺点</strong>：无法分析中间行为，粗粒度</p><p><strong>下载地址</strong>：https://sourceforge.net/projects/regshot/</p><h1 id="模拟网络">6 模拟网络</h1><ul><li>目的：避免连接恶意代码的真实服务器（控制服务器）</li><li>工具：<ul><li>ApateDns(FireEye)：ApateDNS是一个用于控制DNS响应的工具，主要用在<strong>本地系统</strong>上的DNS服务器。ApateDNS可以将恶意软件生成的DNS请求重定向到UDP端口53上的指定IP地址的DNS响应。</li><li>nc(Netcat)：作为客户端，最简单的使用方法，”nc hostport”，能建立一个TCP连接，连向指定的主机和端口。作为服务端，“nc -l -p80”，监听任意指定端口的连接请求(inbound connection)，并可做同样的读写操作。很多恶意软件通过端口<strong>80（HTTP）</strong>和<strong>443（HTTPS）</strong>进行通信，因为在大多数系统上，这些端口不会被防火墙阻止。当执行动态恶意软件分析时，可以使用ApateDNS将由恶意软件创建的DNS请求重定向到正在服务器模式下运行Netcat的主机，侦听指定端口上的指定IP地址。</li><li>INetSim：INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。当恶意软件请求文件时，INetSim将返回该文件。当恶意软件扫描Web服务器时，INetSim将返回IISWeb服务器的名称以保持恶意软件运行。</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/24923630">动态恶意软件分析工具介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_1L</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在虚拟机中分析恶意代码</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机概述">1 虚拟机概述</h1><ul><li>概念：VirtualMachine，指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</li><li>软件：VMware(VMware ACE）、Xen、VirtualBox和KVM等，它们都能在Windows系统上虚拟出多个计算机。</li><li>虚拟机监视器（Virtual MachineMonitor，VMM）是虚拟机技术的核心，它是一层位于操作系统和计算机硬件之间的代码，用来将硬件平台分割成多个虚拟机。主要作用是隔离并且管理上层运行的多个虚拟机，仲裁它们对底层运行在特权模式硬件的访问，并为每个客户操作系统虚拟一套独立于实际硬件的虚拟硬件环境（包括：处理器、内存、I/O设备等）。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153628.png"alt="image-20231012110721542" /><figcaption aria-hidden="true">image-20231012110721542</figcaption></figure><h1 id="虚拟机网络模式">2 虚拟机网络模式</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153629.png"alt="image-20231012112120331" /><figcaption aria-hidden="true">image-20231012112120331</figcaption></figure><h2 id="bridged桥接模式">2.1 Bridged（桥接模式）</h2><ul><li>在bridged模式下，VMWare虚拟出来的虚拟机就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。主机网卡和虚拟网卡的IP地址处于同一个网段，子网掩码、网关、DNS等参数都相同。</li><li>在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153630.png"alt="image-20231012112631034" /><figcaption aria-hidden="true">image-20231012112631034</figcaption></figure><h2 id="nat地址转换模式">2.2 NAT（地址转换模式）</h2><ul><li>桥接模式配置简单，但如果网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了，这时候NAT模式是最好的选择。</li><li>NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153631.png"alt="image-20231012113616352" /><figcaption aria-hidden="true">image-20231012113616352</figcaption></figure><h2 id="host-only仅主机模式">2.3 Host-Only（仅主机模式）</h2><ul><li><p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMwareNetwork AdapterVMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153632.png"alt="image-20231012114151982" /><figcaption aria-hidden="true">image-20231012114151982</figcaption></figure></li></ul><h1 id="搭建虚拟机环境">3 搭建虚拟机环境</h1><ul><li>Apatedns：ApateDNS是一个用于控制DNS响应的工具，主要用在本地系统上的DNS服务器。ApateDNS可以欺骗由恶意软件生成的DNS请求至UDP端口53上的指定IP地址。</li><li>Inetsim：INetSim是一个基于Linux的工具，主要用于恶意软件分析，它可以模拟最常见的互联网服务，如http、https、DNS、FTP以及其他的。在Windows机器上执行动态恶意软件分析时，你可以使用和恶意软件分析机器在同一网络中的虚拟机来运行INetSim。INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/hyq20135317/p/5515675.html</li><li><ahref="https://blog.csdn.net/m0_46687377/article/details/120733392">恶意代码分析实战——使用Apatedns和Inetsim模拟网络环境_妙蛙种子吃了都会妙妙妙的妙脆角的博客-CSDN博客</a></li></ol><h1 id="使用vmware-进行恶意代码分析的风险">4 使用VMware进行恶意代码分析的风险</h1><ul><li>虚拟机探测：恶意代码使用反虚拟机技术，使分析变得更加困难</li><li>虚拟机逃逸：虚拟机软件本身具有漏洞，有可能被恶意代码利用</li><li>信息破坏：未知风险，无论如何使用非敏感机器</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/65103100">“桥接”和“NAT”方式区别 -知乎 (zhihu.com)</a></li><li><ahref="https://www.cnblogs.com/zhangweimee/p/9467436.html">Vmware虚拟机三种网络模式详解- 醉城、 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/02%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/02%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="反病毒引擎扫描">1 反病毒引擎扫描</h1><ul><li>原理：依靠一个已知恶意代码可识别片段的特征数据库（病毒文件特征库），以及基于行为与模式匹配的分析（启发式检测），来识别可疑文件</li><li>具体使用：<ul><li>使用反病毒软件进行检测</li><li>开源恶意代码扫描引擎ClamAV</li><li>从反病毒厂商获得已知恶意代码的分析报告和结果</li></ul></li></ul><h1 id="哈希值">2 哈希值</h1><ul><li>哈希是一种用来唯一标识恶意代码的常用方法</li><li>恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值（类似指纹）</li><li>常用哈希函数：MD5、SHA-1</li></ul><h1 id="查找字符串">3 查找字符串</h1><ul><li>程序中的字符串就是一段可打印的字符序列，其中会包含很多信息，比如弹出的消息，读取的位置，链接的URL等。</li><li>存储方式：ASCLL、Unicode</li><li>两种类型格式都以NULL结束符，表示字符串是完整的。ASCII字符串每个字符使用一个字节，Unicode使用两个字节。</li><li>然而有些时候检测到的也并非是真正的字符串，可能是内存地址，CPU指令序列。</li><li>使用：strings -查找目标文件或二进制文件中的可显示字符串（https://docs.oracle.com/cd/E56344_01/html/E54075/strings-1.html）</li></ul><h1 id="加壳与混淆恶意代码">4 加壳与混淆恶意代码</h1><ul><li>合法程序通常会包含很多字符串，而由被加壳或者混淆的恶意代码直接分析获得的可打印字符串则很少</li><li>加壳和混淆代码通常至少会包含LoadLibrary和GetProcAddress函数，它们是用来加载和使用其他函数功能的</li></ul><h2 id="文件加壳">4.1 文件加壳</h2><p>当加壳程序运行时，会首先运行一小段脱壳代码，来解压缩加壳的文件，然后再运行脱壳后的文件。左边文件是可执行程序源文件，右边是加壳后的可执行程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049831.png"alt="image-20231012102949934" /><figcaption aria-hidden="true">image-20231012102949934</figcaption></figure><h2 id="使用peid检测加壳">4.2 使用PEiD检测加壳</h2><p>检测加壳器的类型，或用来链接应用程序的编译器类型</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049832.png"alt="image-20231012103355802" /><figcaption aria-hidden="true">image-20231012103355802</figcaption></figure><h1 id="pe文件格式">5 PE文件格式</h1><ul><li>PE（PortableExecute）文件格式是windows可执行文件的总称，常见的有DLL，EXE，OCX，SYS等。</li><li>PE是指32位可执行文件，64位的可执行文件称为PE+或者PE32+，并非PE64。</li><li>PE文件以一个文件头开始，其中包含代码信息、应用程序类型、所需的库函数与空间要求。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049833.png"alt="image-20231012103534449" /><figcaption aria-hidden="true">image-20231012103534449</figcaption></figure><h1 id="链接库与函数">6 链接库与函数</h1><ul><li><strong>导入函数</strong>也叫引入函数，引入函数被该模块调用，但它又不在该模块中，调用模块中只包含该函数的一些信息，比如函数名以及它所在的模块（链接库）名等信息</li><li><strong>导入表</strong>，导入函数相关信息都保存在PE文件中的导入表中。要找到PE文件的导入表，必须先找到datadirectory，即数据目录</li></ul><h2 id="静态链接运行时链接与动态链接">6.1静态链接、运行时链接与动态链接</h2><ul><li><strong>静态</strong>链接：在生成可执行程序时，就把库中的内容加入到程序中。在程序运行前，先将其目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。</li><li><strong>动态</strong>链接：用户源程序编译后得到的一组目标模块，在装入内存时釆用边装入边链接的链接方式。装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要修改目标模中的相对地址。</li><li><strong>运行时</strong>链接：有些目标模块的链接，推迟到执行时才进行。即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并把它连接到调用者模块上。对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</li></ul><h2 id="dependency-walker">6.2 Dependency Walker</h2><ul><li><p>该工具用于探索动态链接函数</p></li><li><p>常见DLL程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049834.png"alt="image-20231012104028617" /><figcaption aria-hidden="true">image-20231012104028617</figcaption></figure></li></ul><h2 id="导入函数">6.3 导入函数</h2><p>PE文件头包含可执行文件使用的特定函数相关信息。导入函数描述可执行文件会使用哪些WindowsAPI函数，也就是可能会有什么样的操作。</p><h2 id="导出函数">6.4 导出函数</h2><p>用来与其他程序和代码进行交互时所使用的。一个DLL会出现一个或多个功能函数，然后将其导出，供别的程序导入并使用。</p><h1 id="pe文件头与节">7 PE文件头与节</h1><ul><li>.text：包含CPU执行指令。所有其他节存储数据和支持性的信息。一般来说，这是唯一可以执行的节，也应该是唯一包含代码的节。</li><li>.rdata：包含导入与导出函数信息，与DependencyWalker和PeView工具所获得的信息是相同的。还可以存储程序所使用的其他只读数据。有些文件包括.idata和.edata节来存储导入导出信息。</li><li>.data：包含程序的全局数据，可以从程序的任何地方访问到。本地数据并不存储在这个节中，而是在PE文件的某个其他位置上。</li><li>.rsrc：包含由可执行文件所使用的资源，不能执行，比如：图标、图片、菜单项、字符串等。字符串也可以存储在主程序中。存放在这是为提供多语种支持。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049835.png"alt="image-20231012104458546" /><figcaption aria-hidden="true">image-20231012104458546</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049836.png"alt="image-20231012104534105" /><figcaption aria-hidden="true">image-20231012104534105</figcaption></figure><p>参考教程：</p><p><ahref="https://zhuanlan.zhihu.com/p/24208568">常见恶意软件工具分析（一）- 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析技术入门</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/01%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/01%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="恶意代码基础知识">1 恶意代码基础知识</h1><h2 id="定义">1.1 定义</h2><p>使计算机按照攻击者的意图运行以达到恶意目的的<strong>指令集合</strong>（二进制执行文件，脚本语言代码，宏代码，寄生在文件、启动扇区的指令流）</p><h2 id="分类">1.2 分类</h2><ul><li>计算机病毒(Virus)：<ul><li>定义特征：通过感染文件(可执行文件、数据文件、电子邮件等)或磁盘引导扇区进行传播，一般<strong>需要</strong>宿主程序被执行或人为交互才能运行。</li><li>典型实例：Brain，Concept，CIH，勒索软件</li></ul></li><li>蠕虫(Worm)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播。</li><li>典型实例：Morris，CodeRed，Slammer</li></ul></li><li>启动器(Downloader)：<ul><li>定义特征：从远程主机下载到本地执行的轻量级恶意代码，不需要或仅需要极少的人为干预。代表性的开发工具有：JavaScript，VBScript，Java，以及ActiveX。启动其他恶意程序的恶意代码。</li><li>典型实例：SantyWorm等。</li></ul></li><li>后门(Backdoor)：<ul><li>定义特征：绕过正常的安全控制机制，从而为攻击者提供访问途径。</li><li>典型实例：Netcat，BO，冰河，Glupteba。</li></ul></li><li>特洛伊木马(Trojan)：<ul><li>定义特征：伪装成有用软件，隐藏其恶意目标，欺骗用户安装执行。</li><li>典型实例：Setiri，Emotet，Dridex，Ramnit</li></ul></li><li>僵尸程序(Bot)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播；使用一对多的命令与控制机制组成僵尸网络。</li><li>典型实例：Sdbot，Agobot，Mirai，Glupteba</li></ul></li><li>内核套件(Rootkit)：<ul><li>定义特征：通过替换或修改系统关键可执行文件（用户态），或者通过控制操作系统内核(内核态)，用以获取并保持最高控制权(rootaccess)。</li><li>典型实例：LRK，FU，hdef</li></ul></li><li>融合型恶意代码及Bootkit：<ul><li>定义特征：融合上述多种恶意代码技术，构成更具破坏性的恶意代码形态，如Bootkit。</li><li>典型实例：Nimda、Stuxnet、Flame、Duqu</li></ul></li></ul><h1 id="恶意代码分析技术">2 恶意代码分析技术</h1><table><thead><tr class="header"><th><strong>区别项</strong></th><th><strong>恶意代码分析</strong></th><th><strong>良性代码分析</strong></th></tr></thead><tbody><tr class="odd"><td>目的公开性</td><td>目的未知，需分析和推测其目的</td><td>一般情况下，目的是公开且明确的，可辅助分析过程</td></tr><tr class="even"><td>目的恶意性</td><td>恶意目的，需要受控环境</td><td>良性，无需受控环境</td></tr><tr class="odd"><td>是否存在源码</td><td>绝大多数情况无源码，二进制分析</td><td>开源软件存在源码，源码分析；闭源软件则需二进制分析</td></tr><tr class="even"><td>使用对抗分析技术</td><td>各种多样化对抗分析，博弈问题</td><td>一般无对抗分析，商业软件也引入对抗分析保护产权</td></tr></tbody></table><ul><li><strong>静态</strong>分析<ul><li>通过反病毒引擎扫描识别已知的恶意代码家族和变种名</li><li>逆向分析恶意代码模块构成，内部数据结构，关键控制流程等，理解恶意代码的机理，并提取特征码用于检测。</li><li>分析方法：恶意代码扫描、文件格式识别、字符串提取、二进制结构分析、反汇编、反编译、代码结构与逻辑分析、加壳识别和代码脱壳</li></ul></li><li><strong>动态</strong>分析<ul><li>通过在受控环境中执行目标代码，以获取目标代码的行为及运行结果。</li><li>分析方法：快照比对、动态行为监控(APIHooking)、网络监控、沙盒(sandbox)、动态跟踪调试</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer-Overflow Attack Lab (Server Version)</title>
    <link href="/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack%20Lab%20(Server%20Version)/"/>
    <url>/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack%20Lab%20(Server%20Version)/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1 Overview</h1><ul><li>缓冲区溢出是指程序试图将数据写入预先分配的固定长度缓冲区边界之外的情况。恶意用户可利用此漏洞改变程序的流控制，甚至执行任意代码。此漏洞是由于数据存储（如缓冲区）和控件存储（如返回地址）的混合造成的：数据部分的溢出会影响程序的控制流，因为溢出会改变返回地址。</li><li>本实验将提供四台不同的服务器，每台服务器运行一个带有缓冲区溢出漏洞的程序。实验任务是开发一个利用漏洞的程序，并最终获得这些服务器上的root权限。除了进行这些攻击实验之外，还将试验几种针对缓冲区溢出攻击的对策。学生需要评估这些计划是否有效，并解释原因。</li></ul><h1 id="实验环境搭建">2 实验环境搭建</h1><ol type="1"><li><p>关闭随机化地址策略，此步骤是为了保证程序每次执行时的初始地址不变，以便于进行多次实验和调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /sbin/sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049695.png"alt="image-20231011094531325" /><figcaption aria-hidden="true">image-20231011094531325</figcaption></figure></li><li><p>编译并拷贝。由于 Makefile中已经提供了编译命令，我们仅需执行下列指令即可，此处编译关闭了栈保护和不可执行堆栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make install<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049696.png"alt="image-20231011094543773" /><figcaption aria-hidden="true">image-20231011094543773</figcaption></figure></li><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dcbuild<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049697.png"alt="image-20231011094803752" /><figcaption aria-hidden="true">image-20231011094803752</figcaption></figure></li><li><p>运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dcup<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049698.png"alt="image-20231011094900036" /><figcaption aria-hidden="true">image-20231011094900036</figcaption></figure></li><li><p>查看是否开启成功，可以看到已有 4 个容器正在运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dockps<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049699.png"alt="image-20231011094928526" /><figcaption aria-hidden="true">image-20231011094928526</figcaption></figure></li></ol><h1 id="task-1-get-familiar-with-the-shellcode">3 Task 1: Get Familiarwith the Shellcode</h1><ol type="1"><li><p>目标：修改 shellcode，使其能够删除文件</p></li><li><p>根据提示，如果我们想让 shellcode 运行其他命令，只需修改第3行中的命令字符串即可。注意：修改过程中要保持shellcode长度不变，即末尾*位置不变，可以通过添加或删除空格实现。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049700.png"alt="image-20231011095123331" /><figcaption aria-hidden="true">image-20231011095123331</figcaption></figure></li><li><p>以修改 64 位代码为例，首先将<code>shellcode_64.py</code>复制到<code>my_shellcode_64.py</code>，方便后续查看原文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049701.png"alt="image-20231011095221851" /><figcaption aria-hidden="true">image-20231011095221851</figcaption></figure></li><li><p>修改命令为删除文件，上图为原代码，下图为修改后代码</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049702.png"alt="image-20231011095247870" /><figcaption aria-hidden="true">image-20231011095247870</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049704.png"alt="image-20231011095252811" /><figcaption aria-hidden="true">image-20231011095252811</figcaption></figure></li><li><p>步骤 1：创建删除测试文件；步骤 2：执行修改后的脚本文件，从而生成<code>codefile_64</code>；步骤 3：编译<code>call_shellcode.c</code>；步骤 4：先执行<code>a64.out</code>，然后查看当前目录文件，经过比对，发现成功删除<code>testfile</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049705.png"alt="image-20231011095437510" /><figcaption aria-hidden="true">image-20231011095437510</figcaption></figure></li><li><p><strong>小结</strong>：在攻击中，shellcode是一段用于利用软件漏洞的有效负载，shellcode 是 16进制的机器码，以其经常让攻击者获得shell 而得名。shellcode常常使用机器语言编写。 可在寄存器eip 溢出后，放入一段可让 CPU 执行的shellcode 机器码，让电脑可以执行攻击者的任意指令。</p></li></ol><h1 id="task-2-level-1-attack">4 Task 2: Level-1 Attack</h1><ol type="1"><li><p>目标：运行于 10.9.0.5（端口号为 9090），易受攻击的程序是一个 32位程序。</p></li><li><p>原理：栈底为高地址，栈顶为低地址，栈由高地址向低地址增长。栈帧储存的是一个函数在栈中的信息，一般来说相邻的栈帧的关系是父函数与子函数之间的关系，子函数的栈底指针会保存父函数栈底指针的地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049706.png"alt="image-20231011100137705" /><figcaption aria-hidden="true">image-20231011100137705</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049707.png"alt="image-20231011100144437" /><figcaption aria-hidden="true">image-20231011100144437</figcaption></figure></li><li><p>向目标服务器 10.9.0.5发送消息，然后观察服务器端打印出的信息，得到帧指针（ebp）：<code>0xffffd608</code>和 buffer地址：<code>0xffffd598</code>。重复两次，发现得到地址未发生变化，说明地址随机化已关闭。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049708.png"alt="image-20231011100354334" /><figcaption aria-hidden="true">image-20231011100354334</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049709.png"alt="image-20231011100401123" /><figcaption aria-hidden="true">image-20231011100401123</figcaption></figure></li><li><p>修改 exploit.py，具体如下：</p><ul><li><p>根据提供的 shellcode.txt 修改 shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049710.png"alt="image-20231011100544158" /><figcaption aria-hidden="true">image-20231011100544158</figcaption></figure></li><li><p>说明：填充若干长度的，这个机器码对应的指令是 NOP，也就是告诉 CPU什么也不做，然后跳到下一条指令。有了这一段 NOP的填充，只要返回地址能够命中临近shellcode任意位置，最后都可以跳转到shellcode 的起始处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049711.png"alt="image-20231011100622963" /><figcaption aria-hidden="true">image-20231011100622963</figcaption></figure></li><li><p>构建有效载荷，设置 start= 517-len(shellcode)，517 为content大小，该操作目的是将 content 结尾部分内容替换为攻击代码 shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049712.png"alt="image-20231011100730129" /><figcaption aria-hidden="true">image-20231011100730129</figcaption></figure></li><li><p>设置 ret=ebp(0xffffd608)+n(n&gt;=8),ebp 即为步骤3）得到的地址，因为关闭了地址随机化，所以每次值都一样。n&gt;=8 原因：32位下，前一个栈帧和返回内容各占 4 字节，使用当前栈帧加上大于 8的数，即可跳到 shellcode 前的覆盖区（填充了 NOP指令），之后代码可以逐步运行到 shellcode 的起始处。注意：n值不能过大，过大可能无法命中覆盖区，此处以n=8 为例。Offset 为偏移值=ebp地址(0xffffd608)- 缓冲区地址(0xffffd598)+4=116，用来指示 ret地址，从而用新 ret进行覆盖。注意：offset 为 10 进制数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049713.png"alt="image-20231011100919148" /><figcaption aria-hidden="true">image-20231011100919148</figcaption></figure></li></ul></li><li><p>生成 badfile，发送给服务器</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049714.png"alt="image-20231011100945179" /><figcaption aria-hidden="true">image-20231011100945179</figcaption></figure></li><li><p>观察到 shellcode 中代码成功执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049715.png"alt="image-20231011101010254" /><figcaption aria-hidden="true">image-20231011101010254</figcaption></figure></li><li><p>reverse shell</p><ul><li><p>修改 exploit.py 中shellcode，需要先注释掉之前的命令。新命令含义：在服务器机器上启动一个bash shell，其输入来自 TCP 连接，输出也重定向到 TCP连接，此处为10.9.0.1:7070。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049716.png"alt="image-20231011101057494" /><figcaption aria-hidden="true">image-20231011101057494</figcaption></figure></li><li><p>重新生成 badfile</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049717.png"alt="image-20231011101112647" /><figcaption aria-hidden="true">image-20231011101112647</figcaption></figure></li><li><p>在本机开启监听端口，对应 shellcode 中的 7070 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lnv 7070<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049718.png"alt="image-20231011101141673" /><figcaption aria-hidden="true">image-20231011101141673</figcaption></figure></li><li><p>将 badfile 发送给服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> badfile | nc 10.9.0.5 9090<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049719.png"alt="image-20231011101158575" /><figcaption aria-hidden="true">image-20231011101158575</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049720.png"alt="image-20231011101222506" /><figcaption aria-hidden="true">image-20231011101222506</figcaption></figure></li></ul></li></ol><h1 id="task-3-level-2-attack">5 Task 3: Level-2 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.6，端口号仍为 9090，易受攻击程序仍为 32位程序</p></li><li><p>向目标服务器 10.9.0.6送消息，然后观察服务器端打印出的信息。信息中仅包含 buffer地址(0xffffd2b8)，没有显示帧指针的值,即无法直接计算出 ret 地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049721.png"alt="image-20231011101500690" /><figcaption aria-hidden="true">image-20231011101500690</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049722.png"alt="image-20231011101505995" /><figcaption aria-hidden="true">image-20231011101505995</figcaption></figure></li><li><p>修改 exploit.py。ret=0xffffd2b8(buffer地址)+300(缓冲区最大容量)+8(前ebp+ret)=0xffffd3ec，加上的值只用大于等于308，能命中shellcode前填充区，让 shellcode 执行即可，此处以加 308为例。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049723.png"alt="image-20231011101548428" /><figcaption aria-hidden="true">image-20231011101548428</figcaption></figure></li><li><p><strong>难点</strong>：offset值如何设定。因为只能构建一个有效载荷，该有效载荷需要可用于此范围内的任何缓冲区大小。根据实验指导得知buffer_size的限制在：[100, 300]。并且，在 32位程序中，由于内存对齐的原因，在帧指针中存储的值总是四的倍数。因此我们直接将所有可能的位置都用新ret 地址进行覆盖。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049724.png"alt="image-20231011101948481" /><figcaption aria-hidden="true">image-20231011101948481</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-4-level-3-attack">6 Task 4: Level-3 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.7，开放端口为 9090，运行 64位程序</p></li><li><p>向目标服务器 10.9.0.7送消息，然后观察服务器端打印出的信息。观察到栈帧值和 buffer 地址变为了 8字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049725.png"alt="image-20231011102140559" /><figcaption aria-hidden="true">image-20231011102140559</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049726.png"alt="image-20231011102145762" /><figcaption aria-hidden="true">image-20231011102145762</figcaption></figure></li><li><p><strong>难点</strong>：64 位计算机中的地址范围为0x00-0x00007FFFFFFFFFFF，因此所有地址最高位的两个字节都是 0x00。而strcpy 函数遇到 0会停止，如果和前面的方法一样，则无法成功拷贝shellcode。解决方案：不再将 shellcode 放在 badfile结尾部分，而是将其放至 badfile 开头，令ret的值指向前面部分。由于是小端存储，在截止前ret前面内容及其非零部分已经被成功拷贝。</p></li><li><p>修改 exploit.py 中 shellcode，采用 task1 中使用的 64位shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049727.png"alt="image-20231011102413481" /><figcaption aria-hidden="true">image-20231011102413481</figcaption></figure></li><li><p>start 设置为 0（也可以是其他较小值，目的是让 shellcode 在ret前），使 shellcode 位于 badfile 开头</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049728.png"alt="image-20231011102436372" /><figcaption aria-hidden="true">image-20231011102436372</figcaption></figure></li><li><p>ret=buffer地址(0x00007fffffffe1e0)+start，此处为0x00007fffffffe1e0；offset=rbp(0x00007fffffffe2b0)-buffer(0x00007fffffffe1e0)+8(rbp占 8 字节)=216，offset 为 10 进制。ret 转为字节码的部分需要改为以 8为步长。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049729.png"alt="image-20231011102528980" /><figcaption aria-hidden="true">image-20231011102528980</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-5-level-4-attack">7 Task 5: Level-4 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.8，开放端口为 9090，运行 64位程序</p></li><li><p>向目标服务器 10.9.0.7 送消息，然后观察服务器端打印出的信息。发现buffer 大小仅为 96 字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049730.png"alt="image-20231011102717893" /><figcaption aria-hidden="true">image-20231011102717893</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049731.png"alt="image-20231011102722540" /><figcaption aria-hidden="true">image-20231011102722540</figcaption></figure></li><li><p>难点：buffer 大小过小，可能无法容纳shellcode，因此需要将shellcode 放在 badfile 结尾处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049732.png"alt="image-20231011102745704" /><figcaption aria-hidden="true">image-20231011102745704</figcaption></figure></li><li><p>offset=rbp-buffer+8=104,基本原理同上一个task。<strong>难点</strong>在于返回地址的设置，因为 ret 中 00的存在，结尾的shellcode 不能被成功拷贝，因此需要让 ret 指向主函数中 str数组中 shellcode的位置（注：此处对于 ret 设置不是很清楚）</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049733.png"alt="image-20231011103039147" /><figcaption aria-hidden="true">image-20231011103039147</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049734.png"alt="image-20231011102851075" /><figcaption aria-hidden="true">image-20231011102851075</figcaption></figure><ol start="5" type="1"><li>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</li></ol><h1 id="task-6-experimenting-with-the-address-randomization">8 Task 6:Experimenting with the Address Randomization</h1><ol type="1"><li><p>重新启用地址空间布局随机化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /sbin/sysctl -w kernel.randomize_va_space=2<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049735.png"alt="image-20231011103159396" /><figcaption aria-hidden="true">image-20231011103159396</figcaption></figure></li><li><p>向 level 1 和 level 3 中服务器发送 Hello消息，并发送多次，发现每次地址都在随机变化。<strong>ASLR会使缓冲区溢出攻击变得更加困难原因</strong>：意味着攻击者无法事先知道要攻击的特定内存地址，因为它们在每次启动时都会发生变化；不再能够确定可执行代码或关键数据的确切位置；迫使攻击者需要更复杂的技术来发现内存布局，增加了攻击的难度和成本。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049736.png"alt="image-20231011103317313" /><figcaption aria-hidden="true">image-20231011103317313</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049737.png"alt="image-20231011103323882" /><figcaption aria-hidden="true">image-20231011103323882</figcaption></figure></li><li><p>目标：10.9.0.5:9090，运行32位程序。<strong>解决方案</strong>：无限循环运行易受攻击的程序，暴力破解。Tip：在32 位 Linux 机器上，只能使用 19个位用于地址随机化。这还远远不够，如果我们运行足够多的攻击足够的次数，我们就能轻松击中目标。对于64位机器，用于随机化的位数会大大增加，意味着该方法可能不再有效。</p></li><li><p>使用 Level 1 中 exploit.py 重新生成badfile，在本机开启监听，执行暴力破解脚本，16923 次时成功破解。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049738.png"alt="image-20231011103637351" /><figcaption aria-hidden="true">image-20231011103637351</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049739.png"alt="image-20231011103642836" /><figcaption aria-hidden="true">image-20231011103642836</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049740.png"alt="image-20231011103650245" /><figcaption aria-hidden="true">image-20231011103650245</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049741.png"alt="image-20231011103708030" /><figcaption aria-hidden="true">image-20231011103708030</figcaption></figure></li></ol><h1 id="task-7-experimenting-with-other-countermeasures">9 Task 7:Experimenting with Other Countermeasures</h1><h2 id="task-7.a-turn-on-the-stackguard-protection">9.1 Task 7.a: Turnon the StackGuard Protection</h2><ol type="1"><li><p>进入 server-code 文件夹，去除 -fno-stack-protector 选项编译stack.c，然后将 badfile作为可执行文件输入。出现报错：<code>stack smashing</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049742.png"alt="image-20231011103821396" /><figcaption aria-hidden="true">image-20231011103821396</figcaption></figure></li><li><p>正常的函数调用时，函数调用栈的示意图</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049743.png"alt="image-20231011104543776" /><figcaption aria-hidden="true">image-20231011104543776</figcaption></figure></li><li><p>StackGuard如何发挥作用。由上图可以看到，缓冲区溢出攻击的核心点在于，由于程序没有检测边界，而攻击者利用这一点，覆盖函数的返回地址。如果我们有办法能检测到程序是否被修改，就可以作出一定的防御，比如检测到被修改，就退出。StackGuard的方法很简单，就是往返回地址后面插入一段特殊值(称之为canary)，在函数返回之前，首先检查这个特殊值是否被修改，如果被修改了，说明发生了缓冲区溢出攻击。更安全的方式是，插入这段特殊值，是随机值。但是，即便如此，攻击者仍然有办法绕过，那就是不修改这段值，而是直接修改返回地址，但是这很难做到，因为攻击者无法知道这段随机值到底是多长。另外由于随机化，攻击者也无法轻易复制这一段随机值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049744.png"alt="image-20231011104754440" /><figcaption aria-hidden="true">image-20231011104754440</figcaption></figure></li><li><p>总结：StackGuard是一种编译器扩展，可增强编译器生成的可执行代码，从而检测并阻止针对堆栈的缓冲区溢出攻击。其效果对程序的正常功能是透明的。要注意到程序是否经过StackGuard 增强，唯一的方法就是使程序执行具有未定义行为的 C 语句：StackGuard增强程序定义了在函数仍处于活动状态时写入函数返回地址的行为。</p></li></ol><h2 id="task-7.b-turn-on-the-non-executable-stack-protection">9.2 Task7.b: Turn on the Non-executable Stack Protection</h2><ol type="1"><li><p>进入 shellcode 文件夹，去除 -z execstack 编译call_shellcode.c并运行，出现报错：<code>Segmentation fault</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049745.png"alt="image-20231011103924910" /><figcaption aria-hidden="true">image-20231011103924910</figcaption></figure></li><li><p>需要注意的是，不可执行堆栈只能只能使 shellcode无法在堆栈上运行，但并不能完全防止缓冲区溢出攻击，因为利用缓冲区溢出漏洞后，还有其他方法运行恶意代码。return-tolibc攻击就是一个例子。</p></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-缓冲区溢出/#Task7">网络攻防-缓冲区溢出- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_39678161/article/details/119907828">【SEEDLabs 2.0】Buffer-Overflow Attack_buffer overflow attack lab (serverversion)_嗯嗯哈哈哈哈哈哈嗯嗯哈哈哈的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/344448144">StackGuard的作用 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="直观理解">1 直观理解</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550549.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="信息熵">2 信息熵</h1><ul><li><p>信息熵是度量样本集合纯度最常用的一种指标。</p></li><li><p>假定当前样本集合D中第k类样本所占的比例为<spanclass="math inline">\(\mathrm{p}_{\mathrm{k}}(\mathrm{k}=1,2,\ldots,|\mathrm{y}|)\)</span>，则D的信息熵定义为： <spanclass="math display">\[\operatorname{Ent}(D)=-\sum_{k=1}^{|y|} p_k \log _2 p_k\]</span></p></li><li><p>Ent(D)的值越小，则D的纯度越高</p></li></ul><h1 id="信息增益information-gain--id3决策树">3 信息增益（Informationgain）- ID3决策树</h1><ul><li><p>ID3（IterativeDichotomiser，迭代二分器）决策树学习算法，以信息增益准则来选择划分属性。</p></li><li><p>假定离散属性a有V个可能的取值<span class="math inline">\(\lbracea^1,a^2,...,a^V\rbrace\)</span>，若使用a来对样本集D进行划分，则会产生V个分支结点，其中第v个分支结点包含了D中所有在属性a上取值为<spanclass="math inline">\(a^v\)</span>的样本，即为<spanclass="math inline">\(D^v\)</span>。给分支结点赋予权重$$，样本数越多的分支结点的影响越大，信息增益越大，使用属性a对样本集D进行划分所获得的纯度提升越大。以属性a对数据集D进行划分所获得的信息增益为：<span class="math display">\[\operatorname{Gain}(\mathrm{D},\mathrm{a})=\operatorname{Ent}(\mathrm{D})-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Ent}\left(\mathrm{D}^{\mathrm{v}}\right)\]</span></p></li><li><p>信息增益准则对可取值数目较多的属性有所偏好，因为属性取值多则划分的更干净。但这可能导致出现一些荒谬错误，于是引入增益率。</p></li></ul><h1 id="增益率gain-ratio--c4.5决策树">4 增益率（Gain Ratio）-C4.5决策树</h1><p><span class="math display">\[\text { Gain\_ratio(D, a })=\frac{\operatorname{Gain}(\mathrm{D},\mathrm{a})}{\mathrm{IV}(\mathrm{a})}\]</span></p><p>其中， <span class="math display">\[\mathrm{IV}(\mathrm{a})=-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|} \log _2\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\]</span></p><ul><li>除以IV可以看做是一个归一化（标准化）过程，这里，属性a的可能取值数目越多，IV（a）值越大，信息增益除以IV后值越小，抵消了分支多的好处。但是这样一来，增益率会偏好分支少的属性，C4.5采用两步对此进行了折中改进：<ul><li>先对所有属性的信息增益进行从高到低排序，从候选划分属性中选出信息增益高于平均水平的</li><li>然后从中选出增益率高的</li></ul></li></ul><h1 id="基尼指数gini-index--cart决策树">5 基尼指数（Gini Index）-CART决策树</h1><ul><li><p>CART（Classification and RegressionTree）决策树使用基尼指数来选择划分属性，从属性集A中选择基尼指数最小的属性作为最优划分属性。从统计建模的角度出发考虑问题，前面都是用信息论角度去考虑。该算法既可用于分类，又可用于回归。</p></li><li><p>数据集D的纯度，用基尼值度量为（值越小，纯度越高）： <spanclass="math display">\[\operatorname{Gini}(\mathrm{D})=\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\sum_{\mathrm{k}^{\prime} \neq \mathrm{k}} \mathrm{p}_{\mathrm{k}}\mathrm{p}_{\mathrm{k}}^{\prime}=1-\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\mathrm{p}_{\mathrm{k}}^2\]</span></p></li><li><p>属性a的基尼指数定义为： <span class="math display">\[\operatorname{Gini} \_\operatorname{index}(\mathrm{D},\mathrm{a})=\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Gini}(\mathrm{D})\]</span></p></li></ul><h1 id="剪枝pruning">6 剪枝（pruning）</h1><p>在上面我们提到了信息增益、增益率、基尼系数三个不同的划分属性，有人会疑惑，不同的划分原则是否会对结果产生影响，研究表明划分选择的各种准则虽然对决策树的尺寸有较大的影响，但对泛化性能的影响有限。相比而言，剪枝方法和程度对决策树泛化性能的影响更为显著。决策树从上到下划分实际上完成的是从全部到局部的划分，分到局部时可能会受到噪音的影响，容易产生不必要的分枝而过拟合，剪枝是决策树对付“过拟合”的主要手段。</p><h2 id="预剪枝prepruning">6.1 预剪枝（prepruning）</h2><p>指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。示例：划分后精度变低了，则不划分进行剪枝，划分后精度没变化，遵循奥卡姆剃刀原则，不划分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550550.png"alt="image-20231009154011573" /><figcaption aria-hidden="true">image-20231009154011573</figcaption></figure><h2 id="后剪枝postpruning">6.2 后剪枝（postpruning）</h2><p>后剪枝是指先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。示例：由下到上，每一个结点都要考察是否剪，如果剪前剪后没有变化则不剪。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550551.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550552.png"alt="image-20231009154708121" /><figcaption aria-hidden="true">image-20231009154708121</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550553.png"alt="image-20231009154730453" /><figcaption aria-hidden="true">image-20231009154730453</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550554.png"alt="image-20231009154751919" /><figcaption aria-hidden="true">image-20231009154751919</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550555.png"alt="image-20231009154800431" /><figcaption aria-hidden="true">image-20231009154800431</figcaption></figure><h2 id="预剪枝vs后剪枝">6.3 预剪枝VS后剪枝</h2><p>（1）时间开销</p><ul><li>预剪枝：测试时间开销降低，训练时间开销降低</li><li>后剪枝：测试时间开销降低，训练时间开销增加</li></ul><p>（2）过/欠拟合风险：</p><ul><li>预剪枝：过拟合风险降低，欠拟合风险增加</li><li>后剪枝：过拟合风险降低，欠拟合风险基本不变</li></ul><p>（3）泛化性能：后剪枝通常优于预剪枝</p><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1Xp4y1U7vW/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=5a5397ea8e931fbb28195dfdfa5e1b03">【五分钟机器学习】可视化的决策过程：决策树Decision Tree_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/weixin_43182102/article/details/122106265">【机器学习sklearn】决策树（DecisionTree）算法-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>准确率、精确率、召回率</title>
    <link href="/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
    <url>/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="混淆矩阵">1 混淆矩阵</h1><table><thead><tr class="header"><th></th><th>实际正例</th><th>实际负例</th></tr></thead><tbody><tr class="odd"><td>预测正例</td><td>TP</td><td>FP</td></tr><tr class="even"><td>预测负例</td><td>FN</td><td>TN</td></tr></tbody></table><ul><li>TP（True Positives)：真正例，预测为正例而且实际上也是正例；</li><li>FP（False Positives)：假正例，预测为正例然而实际上却是负例；</li><li>FN（false Negatives)：假负例，预测为负例然而实际上却是正例；</li><li>TN（True Negatives)：真负例，预测为负例而且实际上也是负例。</li></ul><h1 id="准确率">2 准确率</h1><p><span class="math display">\[Accuracy=\frac{TP+TN}{TP+FP+FN+TN}\]</span></p><ul><li>定义：所有的预测正确（正类负类）的占总的比重。</li><li>虽然准确率能够判断总的正确率，但是在样本不均衡的情况下，并不能作为很好的指标来衡量结果。在样本不平衡的情况下，得到的高准确率没有任何意义，此时准确率就会失效。例如如果一个肿瘤科医生看病，不经检验就告诉每个患者他们没有患病，检查的准确率为99.6%！（癌症患病率约为0.4%）。</li></ul><h1 id="精确率">3 精确率</h1><p><span class="math display">\[Precision=\frac{TP}{TP+FP}\]</span></p><ul><li>定义：也叫查准率，即正确预测为正的占全部预测为正的比例(不准错，宁愿漏检，也不能让现有的预测有错)。</li><li>精确率代表对正样本结果中的预测准确程度，准确率则代表整体的预测准确程度，包括正样本和负样本。分母是预测到的正类，精确率的提出是让模型的现有预测结果尽可能不出错。应用场景例如美国刑事审判体系，疑罪从无。</li></ul><h1 id="召回率">4 召回率</h1><p><span class="math display">\[Recall=\frac{TP}{TP+FN}\]</span></p><ul><li>定义：也叫查全率，即正确预测为正的占全部实际为正的比例(不准漏，宁可错杀一千，也不放过一个)。</li><li>召回率(Recall)是针对原样本而言的，其含义是在实际为正的样本中被预测为正样本的概率。高召回率意味着更少的漏检，但会导致更多的误检。应用场景例如癌症筛查、排查安全隐患。</li></ul><h1 id="f-score">5 F-Score</h1><p><span class="math display">\[F_{Score}=(1+\beta^2)\frac{Precision \times Recall}{\beta^2 \timesPrecision+Recall}\]</span></p><ul><li>精确率和召回率互相影响，理想状态下肯定追求两个都高，但是实际情况是两者相互“制约”：追求精确率高，则召回率就低；追求召回率高，则通常会影响精确率。这样就需要综合考虑它们，最常见的方法就是F-score。也可以绘制出P-R曲线图，观察它们的分布情况。</li><li>F-Score：权衡精确率（Precision）和召回率（Recall），较为全面地评价一个分类器。F-Score是精确率和召回率的调和平均。F-Score越大说明模型质量更高。</li><li>关于β取值：<ul><li>β如果取1,表示Precision与Recall一样重要</li><li>β如果取小于1,表示Precision比Recall重要</li><li>β如果取大于1,表示Recall比Precision重要</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/lhxez6868/article/details/108150777">准确度(accuracy)、精确率（precision)、召回率（recall）、F1值谈谈我的看法_精确度和召回率-CSDN博客</a></li><li><ahref="https://zhuanlan.zhihu.com/p/369936908">准确率、精确率、召回率 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="svm直觉理解">1 SVM直觉理解</h1><p>概念：支持向量机<code>Supported Vector Machine</code>，基于线性划分，输出一个最优化的分隔超平面，该超平面不但能将两类正确分开，且使分类间隔最大</p><p>本质：量化两类数据差异</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404845.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="软硬间隔">2 软硬间隔</h1><ul><li>间隔距离体现两类数据差异大小</li><li>硬间隔：使⽤超平⾯进⾏分割数据的过程中，如果我们严格地让所有实例都不在最⼤间隔之间，只位于正确的⼀边。硬间隔分类有两个问题：⾸先，它只在数据是线性可分离的时候才有效；其次，它对异常值⾮常敏感。</li><li>软间隔：软间隔的⽬标是尽可能在保持最⼤间隔宽阔和限制间隔违例之间找到良好的平衡。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404846.png"alt="image-20231005102746477" /><figcaption aria-hidden="true">image-20231005102746477</figcaption></figure><h1 id="升维转换和核函数">3 升维转换和核函数</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404847.png"alt="image-20231005134734247" /><figcaption aria-hidden="true">image-20231005134734247</figcaption></figure><p>升维转换目的：处理低维度下无法方便分类的数据（直接采用可能导致维数灾难）</p><p>核函数：不用知晓具体的维度转换函数，直接获得数据的高维度差异度</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404848.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV16T4y1y7qj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d1182948f36423c63e7e3b31ad8c5163">【数之道】支持向量机SVM是什么，八分钟直觉理解其本质_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/qq_39763246/article/details/119926367">机器学习算法08 ——支持向量机SVM算法(核函数、手写数字识别案例)_svm算法案例_老板来碗小面加蛋~的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绪论</title>
    <link href="/2023/10/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/10/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">1 背景</h1><ul><li>数据爆炸但知识贫乏</li><li>商业数据到商业智能的进化</li><li>科学发展范式（经验科学、理论科学、计算科学、数据科学）</li></ul><h1 id="基本概念">2 基本概念</h1><p>定义：从数据中得到信息和知识的过程</p><h1 id="主要内容">3 主要内容</h1><ul><li>关联规则挖掘（啤酒和尿布）</li><li>分类<code>Predictive</code>：根据特征和观测数据建立数学模型，对新的数例进行判断的过程（监督式机器学习）<ul><li>标签分类</li><li>数值预测</li></ul></li><li>聚类<code>Descriptive</code>：仅根据刚刚的特征对数据进行聚类划分（非监督式机器学习）</li><li>回归：建立多个变量之间的定量关系</li></ul><p>Q：数据分类和数据聚类的概念如何区别？</p><p>数据分类，分类的类别是已知的，训练某种学习机器（即得到某种目标函数），使它能够对未知类别的样本进行分类；数据聚类，分类的类别是未知的，通过聚类分析将数据聚合成几个群体。</p><p>Q：数据、信息、知识的概念如何区分？</p><ul><li>数据：数据是未经加工处理的原始信息。</li><li>信息：信息是对原始的数据信息进行观察得出的一些结论。</li><li>知识：知识是对信息进行总结归纳，逻辑分析，得到的理解和某些事物的规律。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据挖掘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>视频网站基本原理</title>
    <link href="/2023/10/04/Python/Spider/video/%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/10/04/Python/Spider/video/%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="视频处理流程">1 视频处理流程</h1><ul><li>用户上传</li><li>转码（高清、标清）</li><li>切片处理（单个文件进行拆分)</li></ul><h1 id="m3u8文件">2 m3u8文件</h1><ul><li>视频播放顺序</li><li>视频存储位置</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310050925393.png"alt="image-20231004161812532" /><figcaption aria-hidden="true">image-20231004161812532</figcaption></figure><h1 id="抓取流程">3 抓取流程</h1><ol type="1"><li>找到m3u8文件</li><li>通过m3u8文件下载到ts文件</li><li>将ts文件合并为一个mp4文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式爬虫基础</title>
    <link href="/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310041406344.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>搭建一个分布式的机群，让其对一组资源进行分布联合爬取</p><h1 id="作用">2 作用</h1><p>提高爬取数据的效率</p><h1 id="实现">3 实现</h1><ul><li><p>环境准备</p><ul><li>安装<code>scrapy-redis</code>组件（原生的scrapy不能实现分布式爬虫,因为调度器和管道不能被分布式机群共享，所以需要配合该组件进行实现）</li><li><code>scrapy-redis</code>组件作用：给原生的scrapy框架提供可以被共享的调度器和管道</li></ul></li><li><p>实现流程：</p><ul><li><p>创建工程</p></li><li><p>创建爬虫文件</p></li><li><p>修改当前爬虫文件</p><ul><li>导入模块：<code>from scrapy_redis.spiders import RedisSpider</code></li><li>注释allowed_domains和start_urls</li><li>添加属性（共享的调度器队列名称）：<code>redis_key='xxx'</code></li><li>修改父类为：<code>RedisCrawlSpider</code></li></ul></li><li><p>修改配置文件</p><ul><li><p>指定管道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>:<span class="hljs-number">400</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指定调度器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 去重容器类：使用Redis的set集合来存储请求的指纹数据，从而实现请求去重的持久化</span><br>DUPEFILTER_CLASS= <span class="hljs-string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="hljs-comment"># 使用scrapy_redis组件自己的调度器</span><br>SCHEDULER=<span class="hljs-string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="hljs-comment"># 配置调度器是否持久化，即当爬虫结束，是否清空Redis请求队列和set指纹数据</span><br>SCHEDULER_PERSIST=<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li><li><p>指定redis服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">REDIS_HOST=<span class="hljs-string">&#x27;&#x27;</span><br>REDIS_PORT=<br></code></pre></td></tr></table></figure></li></ul></li><li><p>redis相关操作配置</p><ul><li>redis配置文件（redis.windows.conf）</li><li>结合配置文件开启redis服务：<code>redis-server 配置文件</code></li><li>启动客户端：<code>redis-cli</code></li></ul></li><li><p>执行工程：<code>scrapy runspider xxx.py</code>（spider目录下）</p></li><li><p>向调度器队列中放入一个起始url（客户端中执行）：<code>lpush redis_key start_urls</code></p></li></ul></li></ul><h1 id="redis存储的数据">4 redis存储的数据</h1><ul><li><p>spiderName:items</p><ul><li>list类型，保存爬虫获取到的数据item内容是json字符串。</li></ul></li><li><p>spiderName:dupefilter</p><ul><li>set类型，用于爬虫访问的URL去重内容，是40个字符的url的hash字符串</li></ul></li><li><p>spiderName:start_urls</p><ul><li>list类型，用于接收redis spider启动时的第一个url</li></ul></li><li><p>spiderName:requests</p><ul><li>zset类型，用于存放requests等待调度。内容是requests对象的序列化字符串</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于CrawlSpider的全站数据爬取</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ECrawlSpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ECrawlSpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><p>CrawlSpider：Spider的一个子类</p><h1 id="使用">2 使用</h1><ol type="1"><li><p>创建工程</p></li><li><p>cd project</p></li><li><p>创建爬虫文件（CrawlSpider）:<code>scrapy genspider -t crawl spiderName allowed_domains</code></p><ul><li>链接提取器：根据指定规则（allow="正则"）进行指定链接的提取</li><li>规则解析器：将链接提取器提取到的链接进行指定规则（callback）的解析操作</li><li>可以有多个链接提取器，规则解析器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy.linkextractors <span class="hljs-keyword">import</span> LinkExtractor<br><span class="hljs-keyword">from</span> scrapy.spiders <span class="hljs-keyword">import</span> CrawlSpider, Rule<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrawlspiderSpider</span>(<span class="hljs-title class_ inherited__">CrawlSpider</span>):<br>    name = <span class="hljs-string">&quot;crawlspider&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;xxx.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;http://xxx.com/&quot;</span>]<br><br>    link=LinkExtractor(allow=<span class="hljs-string">r&quot;Items/&quot;</span>)<br>    rules = (<br>        <span class="hljs-comment"># 规则解析器</span><br>        <span class="hljs-comment"># 链接提取器作为一个参数被作用到规则解析器里</span><br>        <span class="hljs-comment"># follow为ture时可以将链接提取器继续作用到链接提取器提取到的链接对应页面中</span><br>        Rule(link, callback=<span class="hljs-string">&quot;parse_item&quot;</span>, follow=<span class="hljs-literal">True</span>),<br>    )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_item</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="item">3 item</h1><p>当有多个item时，若需要判断item类型，使用：<code>item.__class__.__name__</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本配置（Edge版）</title>
    <link href="/2023/10/02/Python/Spider/selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/"/>
    <url>/2023/10/02/Python/Spider/selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>安装 selenium</p></li><li><p>下载浏览器引擎（需对应浏览器版本<code>浏览器 --&gt; 设置 --&gt; 关于 Microsoft Edge --&gt; 版本信息</code>）</p></li><li><p>文件重命名为： <code>MicrosoftWebDriver.exe</code></p></li><li><p>拷贝到python.exe目录下（例：<code>F:\Anaconda\install\envs\spider</code>）和浏览器目录下（例：<code>C:\Program Files (x86)\Microsoft\Edge\Application</code>）</p></li><li><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>driver = webdriver.Edge(<span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftWebDriver.exe&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)   <span class="hljs-comment"># 你要进入的网页</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>selenium</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Spider的全站数据爬取</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ESpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ESpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><p>将某网站中某模块下全部页码对应的页面数据进行爬取</p><h1 id="实现方式">2 实现方式</h1><ol type="1"><li><p>将所有页面url添加到start_urls列表中</p></li><li><p>手动实现请求发送（推荐）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohuaSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xiaohua&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;699pic.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/photo-264659.html&quot;</span>]<br><br>    <span class="hljs-comment"># 通用url模板</span><br>    url=<span class="hljs-string">&quot;https://699pic.com/photo/264659-%d.html&quot;</span><br>    page_num=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list=response.xpath(<span class="hljs-string">&#x27;/html/body/div[11]/div[4]/div/div&#x27;</span>)<br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            img_name=li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).extract_first()<br>            <span class="hljs-built_in">print</span>(img_name)<br><br>        <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>            new_url=<span class="hljs-built_in">format</span>(self.url%self.page_num)<br>            self.page_num+=<span class="hljs-number">1</span><br>            <span class="hljs-comment"># callback为回调函数，进行数据解析</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url,callback=self.parse)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中间件</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="下载中间件">1 下载中间件</h1><ul><li><p>位置：引擎和下载器之间</p></li><li><p>作用：批量拦截到整个工程中所有的请求和响应</p></li><li><p>拦截请求：</p><ul><li>UA伪装（UA池）:process_request</li><li>代理IP（代理池）:process_exception需要<code>return request</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拦截请求</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>      <span class="hljs-comment"># UA伪装</span><br>      request.headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>]= random.choice(self.user_agents)<br>      <span class="hljs-comment"># 仅测试使用</span><br>      <span class="hljs-comment"># request.meta[&#x27;proxy&#x27;] = &quot;http://182.34.33.244:9999&quot;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>  <br>  <span class="hljs-comment"># 拦截发生异常的请求</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_exception</span>(<span class="hljs-params">self, request, exception, spider</span>):<br>      <span class="hljs-comment"># 代理池一般在该方法中进行设置</span><br>      <span class="hljs-comment"># request.meta[&#x27;proxy&#x27;]=</span><br>      <span class="hljs-comment"># 重新发送该请求</span><br>      <span class="hljs-keyword">return</span> request<br></code></pre></td></tr></table></figure></li><li><p>拦截响应：</p><ul><li>篡改响应数据（应对动态加载）</li><li>判断网页数据是否为动态加载，可以通过禁用js观察数据是否能够加载出来得到</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):<br>    <span class="hljs-comment"># 获取爬虫类定义的浏览器对象</span><br>    driver=spider.driver<br>    <span class="hljs-comment"># 挑选出指定响应对象进行篡改</span><br>    <span class="hljs-comment"># 挑选过程：url---request---response</span><br>    <span class="hljs-keyword">if</span> request.url <span class="hljs-keyword">in</span> spider.module_urls:<br>        <span class="hljs-comment"># 基于selenium便捷地获取动态加载数据</span><br>        driver.get(request.url)<br>        sleep(<span class="hljs-number">1</span>)<br>        page_text=driver.page_source<br>        <span class="hljs-comment"># 实例化新的响应对象</span><br>        new_response=HtmlResponse(url=request.url,body=page_text,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,request=request)<br>        <span class="hljs-keyword">return</span> new_response<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure></li><li><p>需要在配置文件中开启中间件</p></li></ul><h1 id="爬虫中间件">2 爬虫中间件</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImagesPipeline</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/</url>
    
    <content type="html"><![CDATA[<h1 id="基于scrapy">1 基于scrapy</h1><ul><li>字符串：只需要基于xpath进行解析，提交管道进行持久化存储</li><li>图片：xpath解析出图片src属性值，再单独对该地址发送请求获取图片二进制类型的数据</li></ul><h1 id="imagespipeline">2 ImagesPipeline</h1><ul><li><p>只需解析出图片src属性值，提交给管道，管道就会对该地址进行请求并获得二进制响应数据</p></li><li><p>使用流程：</p><ul><li><p>数据解析（图片地址）</p></li><li><p>将item提交到管道</p></li><li><p>重写一个基于ImagesPipeline的一个管道类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-keyword">from</span> scrapy.pipelines.images <span class="hljs-keyword">import</span> ImagesPipeline<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">imgsPipeline</span>(<span class="hljs-title class_ inherited__">ImagesPipeline</span>):<br>    <span class="hljs-comment"># 根据图片地址进行图片数据的请求</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_media_requests</span>(<span class="hljs-params">self, item, info</span>):<br>        <span class="hljs-keyword">yield</span> scrapy.Request(item[<span class="hljs-string">&#x27;src&#x27;</span>])<br><br>    <span class="hljs-comment"># 指定图片存储的路径</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">file_path</span>(<span class="hljs-params">self, request, response=<span class="hljs-literal">None</span>, info=<span class="hljs-literal">None</span>, *, item=<span class="hljs-literal">None</span></span>):<br>        imgName=request.url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> imgName<br><br>    <span class="hljs-comment"># 返回给下一个将要执行的管道</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">item_completed</span>(<span class="hljs-params">self, results, item, info</span>):<br>        <span class="hljs-keyword">return</span> item<br><br></code></pre></td></tr></table></figure></li><li><p>配置文件：指定图片存储位置(<code>IMAGES_STORE = ''</code>)；开启管道</p></li></ul></li></ul><h1 id="图片懒加载">3 图片懒加载</h1><ul><li>懒加载，即延迟加载(Lazyload)。简单来说就是一个长页面中需要展示很多图像的时候，如果在进入页面的时候一次性把所有图片加载完，需要很长的时间。为了提升用户体验，我们使用懒加载，当图片出现在浏览器可视区域时，才加载图片。</li><li>遇到此类情况，进行数据解析时需要使用伪属性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>请求传参</title>
    <link href="/2023/10/01/Python/Spider/Scrapy/%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/"/>
    <url>/2023/10/01/Python/Spider/Scrapy/%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景">1 使用场景</h1><p>爬取解析的数据不在同一张页面中</p><h1 id="使用流程">2 使用流程</h1><ul><li>请求传参传的是item的对象</li><li><code>meta=&#123;'item':item&#125;</code>，可以将meta字典传递给请求对应的回调函数</li><li>回调函数接收item：<code>item=response.meta['item']</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BossSpider</span>(scrapy.Spider):<br>  name = <span class="hljs-string">&quot;boss&quot;</span><br>  <span class="hljs-comment"># allowed_domains = [&quot;zhipin.com&quot;]</span><br>  start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/264659-1.html&quot;</span>]<br>  url=<span class="hljs-string">&quot;https://699pic.com/tupian/264659-%d.html&quot;</span><br>  page_num=<span class="hljs-number">2</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>      li_list=response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;wrapper&quot;]/div[4]/div/div&#x27;</span>)<br>      <span class="hljs-comment"># print(li_list)</span><br>      <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>          pic_name=li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).get()<br>          pic_id_url=<span class="hljs-string">&quot;https://&quot;</span>+li.xpath(<span class="hljs-string">&#x27;./a/@href&#x27;</span>).get()<br>          item=BossproItem()<br>          item[<span class="hljs-string">&#x27;pic_name&#x27;</span>]=pic_name<br>          <span class="hljs-comment"># ！！！手动发送请求，meta请求传参</span><br>          <span class="hljs-keyword">yield</span> scrapy.Request(url=pic_id_url,callback=self.parse_detail,meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>:item&#125;)<br><br>      <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>          new_url=<span class="hljs-built_in">format</span>(self.url%self.page_num)<br>          self.page_num+=<span class="hljs-number">1</span><br>          <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url,callback=self.parse)<br><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_detail</span>(<span class="hljs-params">self,response</span>):<br>      <span class="hljs-comment"># 回调函数接收item</span><br>      item=response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>      <span class="hljs-comment"># print(item[&#x27;pic_name&#x27;])</span><br>      pic_id=response.xpath(<span class="hljs-string">&#x27;/html/body/div[12]/div[2]/div[1]/div/div[1]/div[1]/h1/span[2]/text()&#x27;</span>).get()<br>      item[<span class="hljs-string">&#x27;pic_id&#x27;</span>]=pic_id<br>      <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报错：unable to access &#39;xxxxx.git&#39; Recv failure Connection was reset</title>
    <link href="/2023/09/30/Git/%E6%8A%A5%E9%94%99%EF%BC%9Aunable%20to%20access%20&#39;xxxxx.git&#39;%20Recv%20failure%20Connection%20was%20reset/"/>
    <url>/2023/09/30/Git/%E6%8A%A5%E9%94%99%EF%BC%9Aunable%20to%20access%20&#39;xxxxx.git&#39;%20Recv%20failure%20Connection%20was%20reset/</url>
    
    <content type="html"><![CDATA[<h1 id="报错信息">1 报错信息</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309302011809.png"alt="image-20230930200808727" /><figcaption aria-hidden="true">image-20230930200808727</figcaption></figure><h1 id="解决方案">2 解决方案</h1><ul><li><p>报错原因：开启了代理，所以端口不对无法连接</p></li><li><p>解决：</p><ol type="1"><li><p>查看代理使用端口，如7890</p></li><li><p>配置git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># xxxx为端口号</span><br>git config --global http.proxy http://127.0.0.1:xxxx<br></code></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy持久化存储</title>
    <link href="/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <url>/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基于终端指令">1 基于终端指令</h1><ul><li>要求：只可以将parse方法的返回值存储到本地的文本文件</li><li>指令：<code>scrapy crawl spiderName -o filePath</code></li><li>注意：<ul><li>需在项目根目录下执行该命令</li><li>支持的文件格式：'json', 'jsonlines', 'jsonl', 'jl', 'csv', 'xml','marshal', 'pickle'</li></ul></li><li>优点：简介高效便捷</li><li>局限性较强（文件类型有限制）</li></ul><h1 id="基于管道">2 基于管道</h1><ul><li>编码流程：<ol type="1"><li>数据解析</li><li>item类中定义相关属性</li><li>将解析的数据封装为item类型的对象</li><li>提交item类型的对象给管道（先给优先级最高的管道，管道内依次传递），进行持久化存储</li><li>process_item对item类型对象进行处理</li><li>配置文件中开启管道</li></ol></li><li>优点：通用性强</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬虫文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>li_list = response.xpath(<span class="hljs-string">&quot;/html/body/div[8]/ul/li&quot;</span>)<br>            <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            name = li.xpath(<span class="hljs-string">&quot;./a/b/text()&quot;</span>).extract_first()  <span class="hljs-comment"># extract_first()提取第一项，没有则返回None</span><br>            category = li.xpath(<span class="hljs-string">&quot;./em/a/text()&quot;</span>).extract_first()<br>            time = li.xpath(<span class="hljs-string">&quot;./em/text()&quot;</span>).extract_first()<br>            <span class="hljs-comment"># 创建item对象</span><br>            item=GameItem()<br>            item[<span class="hljs-string">&#x27;name&#x27;</span>]=name<br>            item[<span class="hljs-string">&#x27;category&#x27;</span>]=category<br>            item[<span class="hljs-string">&#x27;time&#x27;</span>]=time<br>            <span class="hljs-comment"># 向管道提交item</span><br>            <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-comment"># 数据库存储</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLPipeline</span>:<br>    coon=<span class="hljs-literal">None</span><br>    cursor=<span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, item</span>):        self.coon=pymysql.Connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,port=<span class="hljs-number">3306</span>,user=<span class="hljs-string">&#x27;root&#x27;</span>,password=<span class="hljs-string">&quot;20030227XKY&quot;</span>,db=<span class="hljs-string">&quot;spider_learning&quot;</span>,charset=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        self.cursor=self.coon.cursor()<br>        <span class="hljs-keyword">try</span>:<br>            self.cursor.execute(<span class="hljs-string">&#x27;insert into game_info values(&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;)&#x27;</span>%(item[<span class="hljs-string">&#x27;name&#x27;</span>],item[<span class="hljs-string">&#x27;category&#x27;</span>],item[<span class="hljs-string">&#x27;time&#x27;</span>],item[<span class="hljs-string">&#x27;test&#x27;</span>]))<br>            self.coon.commit()<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br>            self.coon.rollback()<br><br>        <span class="hljs-keyword">return</span> item  <span class="hljs-comment"># 传递给下一个管道</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, item</span>):<br>        self.cursor.close()<br>        self.coon.close()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy基本使用与介绍</title>
    <link href="/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫工程化">1 爬虫工程化</h1><p>对爬虫的功能进行模块化开发，从而达到可以批量生产的效果。</p><h1 id="scrapy简介">2 Scrapy简介</h1><p>Scrapy是一个快速、高效率的网络爬虫框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy被广泛用于数据挖掘、监测和自动化测试。</p><p>官方文档：<ahref="https://docs.scrapy.org/en/latest/index.html">Scrapy 2.11documentation — Scrapy 2.11.0 documentation</a></p><h1 id="scrapy工作流程">3 Scrapy工作流程</h1><p><strong>基本爬虫工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201611.png"alt="image-20230929093956527" /><figcaption aria-hidden="true">image-20230929093956527</figcaption></figure><p><strong>Scrapy框架工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201612.png"alt="image-20230929093846194" /><figcaption aria-hidden="true">image-20230929093846194</figcaption></figure><ol type="1"><li>引擎：用来处理整个系统的数据流，触发事务。（核心）</li><li>spider（将url封装成request对象，发送给scheduler）</li><li>scheduler（得到request对象，进行过滤，压入队列，发送给downloader）</li><li>downloader（发送请求，将响应封装成response对象，传递给spider）</li><li>spider（进行数据解析）注：若还需要继续爬取，则重复前面几个步骤</li><li>pipeline（数据持久化存储）</li><li>下载器中间件、爬虫中间件</li></ol><h1 id="scrapy安装">4 Scrapy安装</h1><p>使用Anaconda Navigator创建虚拟环境，导入Scrapy包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201614.png"alt="image-20230929100319426" /><figcaption aria-hidden="true">image-20230929100319426</figcaption></figure><p>若终端能打印版本号，则说明已安装成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201615.png"alt="image-20230929100251091" /><figcaption aria-hidden="true">image-20230929100251091</figcaption></figure><h1 id="scrapy实例">5 Scrapy实例</h1><h2 id="创建项目">5.1 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># projectName自取，后续操作均在生成的项目根目录下进行</span><br>scrapy startproject projectName<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201616.png"alt="image-20230929101145588" /><figcaption aria-hidden="true">image-20230929101145588</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看项目根目录下目录结构</span><br>tree /f<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201617.png"alt="image-20230929102306107" /><figcaption aria-hidden="true">image-20230929102306107</figcaption></figure><h2 id="生成爬虫">5.2 生成爬虫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName,allowed_domains按需设置</span><br>scrapy genspider spiderName allowed_domains<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201618.png"alt="image-20230929103444499" /><figcaption aria-hidden="true">image-20230929103444499</figcaption></figure><h2 id="运行项目">5.3 运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName为前面设置的爬虫名字</span><br>scrapy crawl spiderName<br></code></pre></td></tr></table></figure><h2 id="配置项目">5.4 配置项目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># settings.py</span><br><br><span class="hljs-comment"># UA伪装，默认没有开启</span><br>USER_AGENT = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43&quot;</span><br><br><span class="hljs-comment"># 修改值为False，不遵从robots协议，默认值为Ture</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 设置日志级别：DEBUG、INFO、WARNING、ERROR、CRITCAL</span><br><span class="hljs-comment"># 需要自己在配置文件中添加</span><br>LOG_LEVEL = <span class="hljs-string">&quot;WARNING&quot;</span><br><br><span class="hljs-comment"># 开启管道，默认被注释</span><br><span class="hljs-comment"># key 管道路径</span><br><span class="hljs-comment"># value 管道优先级（数字越小，优先级越高）</span><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;game.pipelines.GamePipeline&quot;</span>: <span class="hljs-number">300</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基本流程">6 基本流程</h1><ol type="1"><li>创建项目</li><li>进入项目根目录</li><li>创建爬虫</li><li>修改start_urls</li><li>编写parse(self, response)<ul><li>默认xpath()返回Selector对象，需要进行数据提取。注意：<strong>xpath中不能有tbody标签</strong><ul><li>extract()：返回列表</li><li>extract_first()：返回第一个数据</li></ul></li><li>yield item</li></ul></li><li>在pipeline中完成数据存储</li><li>配置文件中启用管道</li><li>运行爬虫</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH3-口令攻击</title>
    <link href="/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/"/>
    <url>/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">3.1 概述</h1><h2 id="口令和身份认证">3.1.1 口令和身份认证</h2><ul><li><p>身份认证：用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终拒绝用户或者赋予用户一定的权限。</p></li><li><p>口令认证是身份认证的一种手段。</p></li><li><p>其他认证方式：磁卡或者智能卡认证、基于人的生理特征认证、基于地理位置的认证 。</p></li><li><p>认证过程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533483.png"alt="image-20230928144139441" /><figcaption aria-hidden="true">image-20230928144139441</figcaption></figure></li></ul><h2 id="口令攻击的分类">3.1.2 口令攻击的分类</h2><ul><li>口令分类：<ul><li>静态口令</li><li>动态口令：加入不确定因子进行散列</li></ul></li><li>口令攻击分类：<ul><li>针对口令强度的攻击</li><li>针对口令存储的攻击：文件、缓存、数据库</li><li>针对口令传输的攻击：在口令认证交互过程中，利用网络监听非法得到用户传送的口令</li></ul></li></ul><h1 id="针对口令强度的攻击">3.2 针对口令强度的攻击</h1><h2 id="强口令与弱口令">3.2.1 强口令与弱口令</h2><ul><li>较为安全的口令应该不容易被发现规律，并且有足够的长度。</li><li>对长度的要求随应用环境的不同而不同，应该使得攻击者在某个时间段内很难破解</li></ul><h2 id="针对口令强度的攻击-1">3.2.2 针对口令强度的攻击</h2><ul><li><p>强力攻击：穷举法</p></li><li><p>字典攻击：将使用概率较高的口令集中存放在字典文件中，通过不同的变异规则生成猜测字典。强力攻击的进阶版。</p></li><li><p>组合攻击：强力攻击+字典攻击。如：字典单词尾部串接任意个字母和数字。</p></li><li><p>撞库攻击：攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令。一般流程：拖库→洗库→撞库。</p></li><li><p>彩虹表破解：指拿着获取到的hash值通过查询彩虹表找出其原始值的攻击方式。狭义上，彩虹表一般是指以“hash值:原始值”为行组成的文件，如下图所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533484.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul><h1 id="针对口令存储的攻击">3.3 针对口令存储的攻击</h1><ul><li><p>不同系统的口令存储位置不同，有些存放在文件中，比如Linux系统的Shadow文件，Windows系统的SAM文件；有些存放在数据库中，比如Oracle数据库账户文件；有些则存放在注册表中，比如Windows平台下的许多应用软件。另外，在身份验证程序运行时，还会将口令或口令的密文加载到内存中，方便进行比较。</p></li><li><p>Linux shadow文件：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281535352.png"alt="image-20230928153443475" /><figcaption aria-hidden="true">image-20230928153443475</figcaption></figure></li><li><p>salt用途：使用salt时，相同的输入可能导致不同的散列。密码散列=单向散列循环（密码||随机字符串）。可以防止字典攻击、彩虹表攻击。</p></li></ul><h1 id="针对口令传输的攻击">3.4 针对口令传输的攻击</h1><h2 id="口令嗅探">3.4.1 口令嗅探</h2><ul><li>如果主机B处于主机A和FTP通信的信道上，就可以“窃听到”合法的用户名及口令。</li><li>802.3以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</li><li>网卡侦听模式：<ul><li>广播模式</li><li>组播模式</li><li>普通模式</li><li><strong>混杂模式</strong></li></ul></li></ul><h2 id="键盘记录">3.4.2 键盘记录</h2><ul><li>硬件截获：修改主机的键盘接口。</li><li>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来。</li></ul><h2 id="网络钓鱼">3.4.3 网络钓鱼</h2><p>“网络钓鱼（Phishing）”就是攻击者利用欺骗性的电子邮件和伪造的Web站点，骗取用户输入口令以及其他身份敏感信息。</p><h2 id="重放攻击">3.4.4 重放攻击</h2><ul><li>指攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</li><li>分类：简单重放、反向重放。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/lsdb/p/10038835.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nmap扫描工具基础</title>
    <link href="/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E5%AE%9E%E9%AA%8C%E7%AF%87/Nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E5%AE%9E%E9%AA%8C%E7%AF%87/Nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><h2 id="概述">1.1 概述</h2><p><code>Nmap</code>（“ Network Mapper”）是一个用于网络探测和安全审计的开源工具。它被设计用于快速扫描大型网络，尽管它对于单个主机也能正常工作。<code>Nmap</code>以新颖的方式使用原始<code>IP</code>数据包来确定网络上可用的主机、这些主机提供的服务（应用程序名称和版本）、它们运行的操作系统及其版本、正在使用中的数据包过滤器/防火墙的类型，以及数十个其他特性。</p><h2 id="功能">1.2 功能</h2><ul><li>主机发现</li><li>端口扫描</li><li>服务和版本检测</li><li>推断主机所用的操作系统</li></ul><h2 id="常见用法">1.3 常见用法</h2><ul><li><p><code>-iL</code> <inputfilename>(从列表中输入)：可将文件中的一堆主机名或地址读取出来进行扫描。</p></li><li><p><code>-iR</code> <hostnum>(随机选择目标)：可以指定随机生成多少个<code>IP</code>地址。如果为0，意味着无休止的扫描。</p></li><li><p><code>–exclude</code>：可以排除多个不需要扫描的主机。</p></li><li><p><code>–excludfile</code> <excludefile>(排除文件中的列表)：排除文件中的主机列表</p></li></ul><h2 id="时序">1.4 时序</h2><ul><li>-T0 偏执的：非常非常慢，用于IDS逃逸</li><li>-T1 猥琐的：相当慢，用于IDS逃逸</li><li>-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍</li><li>-T3 普通的：默认，根据目标的反应自动调整时间模式</li><li>-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标</li><li>-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口</li></ul><h1 id="主机发现">2 主机发现</h1><p><code>Nmap</code>会根据当前扫描的网络来改变它的扫描方式：</p><ul><li>本地网络发送 <code>ARP</code>数据包；</li><li>非本地网路依次发送：A) <code>ICMP echo</code>请求；B)<code>TCP SYN</code> 到端口 443；C) <code>TCP ACK</code>到端口 80；D)<code>ICMP timestap</code>请求。</li></ul><h2 id="sl列表扫描">2.1 -sL(列表扫描)</h2><p>列表扫描是主机发现的一种退化形式，它仅列出指定网络的每个主机，而不向目标主机发送任何数据包，即<strong>不进行主机发现</strong>。默认情况下，<code>Nmap</code>仍然在主机上执行<code>反向 DNS 解析</code>（<code>IP</code>→<code>域名</code>）以了解其名称。<code>Nmap</code>还在末尾报告<code>IP</code>地址的总数。由于这个想法是简单地打印目标主机列表，因此端口扫描、操作系统检测或主机发现等更高级别功能的选项不能与此结合。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048776.png"alt="image-20230924112236211" /><figcaption aria-hidden="true">image-20230924112236211</figcaption></figure><h2 id="sn无端口扫描">2.2 -sn(无端口扫描)</h2><p>该选项告诉<code>Nmap</code>在主机发现后不要进行端口扫描，而只打印出响应主机发现探测的可用主机。默认情况下，完成的默认主机发现<code>-sn</code>由<code>ICMP</code> 回显请求、端口 443 的<code>TCP SYN</code>、端口 80的<code>TCP ACK</code>以及<code>ICMP</code>时间戳请求组成。当由非特权用户执行时，仅将 SYN数据包发送（使用调用<code>connect</code>）到目标上的端口 80 和443。当特权用户尝试扫描本地以太网上的目标时，除非<code>--send-ip</code>指定，否则将使用<code>ARP</code>请求。该<code>-sn</code>选项可以与任何发现探测类型（<code>-P*</code>选项）以获得更大的灵活性。如果使用任何这些探测类型和端口号选项，则默认探测将被覆盖。当运行<code>Nmap</code>的源主机和目标网络之间存在严格的防火墙时，建议使用这些高级技术。否则，当防火墙丢弃探测或其响应时，主机可能会丢失。只利用ping扫描进行主机发现，不扫描目标主机的端口。在<code>Nmap</code>的早期版本中，<code>-sn</code>被称为<code>-sP</code>。·</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048778.png"alt="image-20230924114006070" /><figcaption aria-hidden="true">image-20230924114006070</figcaption></figure><h2 id="pn无-ping">2.3 -Pn(无 ping)</h2><p>该选项完全跳过主机发现阶段。通常情况下，<code>Nmap</code>使用此阶段来确定活动机器，以便进行更大规模的扫描，并衡量网络速度。与列表扫描一样，会跳过正确的主机发现，但<code>Nmap</code>不会停止并打印目标列表，而是继续执行请求的功能，就好像每个目标<code>IP</code>都处于活动状态一样。默认情况下，<code>Nmap</code>只对发现运行的主机执行重型探测，如端口扫描、版本检测或操作系统检测。对于本地以太网上的机器，仍然会执行<code>ARP</code> 扫描（除非指定<code>--disable-arp-ping</code>或<code>--send-ip</code>），因为<code>Nmap</code>需要 MAC 地址来进一步扫描目标主机。在<code>Nmap</code>的早期版本中，<code>-Pn</code>是 <code>-P0</code> 和<code>-PN</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048779.png"alt="image-20230925152253035" /><figcaption aria-hidden="true">image-20230925152253035</figcaption></figure><h2 id="ps-tcp-syn-ping">2.4 -PS <port list>(TCP SYN Ping)</h2><p>该选项会发送一个设置了<code>SYN</code>标志的空 TCP数据包。默认目标端口为 80。SYN标志向远程系统表明，您正试图建立连接。通常情况下，目标端口会被关闭，并回发一个<code>RST</code>（重置）数据包。如果端口碰巧是开放的，目标系统将采取TCP 三方握手的第二步，回应一个 <code>SYN/ACK</code> TCP数据包。然后，运行 <code>Nmap</code> 的机器会以 <code>RST</code>回应，而不是发送 <code>ACK</code>数据包（<code>ACK</code>数据包将完成三方握手并建立完整连接）来破坏新生连接。<code>Nmap</code>不关心端口是打开还是关闭。前面讨论的 <code>RST</code> 或<code>SYN/ACK</code>响应告诉 <code>Nmap</code>主机可用且有响应。注意：-PS和端口列表间无空格。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048780.png"alt="image-20230925152824970" /><figcaption aria-hidden="true">image-20230925152824970</figcaption></figure><h2 id="pa-tcp-ack-ping">2.5 -PA <port list>(TCP ACK Ping)</h2><p><code>TCP ACK ping</code> 与刚才讨论的 SYN ping非常相似。两者的区别在于设置的是 <code>TCP ACK</code> 标志，而不是<code>SYN</code>标志。同时提供<code>SYN</code> 和 <code>ACK</code>ping探测的原因是为了最大限度地绕过防火墙。该<code>-PA</code>选项使用与 SYN探测 (80) 相同的默认端口，并且还可以采用相同格式的目标端口列表。这种<code>ACK</code>数据包声称通过已建立的 TCP连接确认数据，但实际上并不存在这样的连接。因此，远程主机应始终响应一个<code>RST</code>数据包，在此过程中暴露自己的存在。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048781.png"alt="image-20230925153349280" /><figcaption aria-hidden="true">image-20230925153349280</figcaption></figure><h2 id="pu-udp-ping">2.6 -PU <port list> (UDP Ping)</h2><p>该方法会向指定端口发送<code>UDP</code>数据包。对于大多数端口，数据包都是空的，但有些端口会使用特定协议的有效载荷，这样更有可能得到响应。端口列表的格式与前面讨论过的-PS 和 -PA 选项相同。如果没有指定端口，默认值为40125。默认情况下使用的是一个非常不常用的端口，因为对于这种特殊的扫描类型来说，向开放端口发送数据通常是不可取的。一旦命中中目标计算机上的一个关闭端口，<code>UDP</code>探测器应返回一个 <code>ICMP</code>端口不可达数据包。这就向<code>Nmap</code>表明机器是正常运行的。许多其他类型的<code>ICMP</code>错误，如主机/网络不可到达或超过TTL，都表明主机已停机或不可到达。无响应也可以这样解释。如果到达的是开放端口，大多数服务会直接忽略空数据包，不返回任何响应。这就是默认探测端口为40125 的原因，该端口被使用的可能性很小。字符生成器<code>chargen</code>协议等少数服务会响应空 <code>UDP</code>数据包，从而向 <code>Nmap</code> 透露机器可用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048782.png"alt="image-20230925153850582" /><figcaption aria-hidden="true">image-20230925153850582</figcaption></figure><h2 id="py-sctp-init-ping">2.7 -PY <port list> (SCTP INIT Ping)</h2><p>该选项发送包含最小<code>INIT</code> 块的 <code>SCTP</code>数据包。<code>INIT</code>块向远程系统表明，您正试图建立关联。通常情况下，目标端口关闭，并将发送一个<code>ABORT</code> 块。如果端口碰巧是开放的，目标系统将采取<code>SCTP</code>四次握手的第二步，用一个 <code>INIT-ACK</code> chunk作为回应。如果运行 <code>Nmap</code>的机器有一个功能正常的<code>SCTP</code>协议栈，那么它就会通过响应一个<code>ABORT</code>数据块而不是发送一个<code>COOKIE-ECHO</code>数据块（这将是四路握手的下一步）来破坏连接。<code>ABORT</code>包由运行<code>Nmap</code>的机器内核发送，以响应意外的<code>INIT-ACK</code>，而不是由<code>Nmap</code> 本身发送。前面讨论过的<code>ABORT</code>或<code>INIT-ACK</code> 响应都会告诉<code>Nmap</code>，主机是可用的并有响应。</p><h2 id="pe--pp--pm-icmp-ping-types">2.8 -PE; -PP; -PM (ICMP PingTypes)</h2><p><code>Nmap</code> 向目标<code>IP</code>地址发送<code>ICMP</code>类型8（回显请求）数据包，期望从可用主机返回类型 0（回显应答）。不幸的是，对于网络浏览器来说，许多主机和防火墙现在会阻止这些数据包，而不是按照RFC1122 的要求进行响应。 因此，针对 Internet 上的未知目标，仅<code>ICMP</code>扫描很少足够可靠。但对于监控内部网络的系统管理员来说，它们可能是一种实用且有效的方法。使用该-PE选项启用此回显请求行为。<code>ICMP</code>标准（RFC792 和 RFC 950）还将时间戳请求、信息请求和地址掩码请求数据包分别指定为代码 13、15 和17。时间戳和地址掩码查询可以分别使用 -PP和-PM选项发送。</p><h2 id="po-ip-协议-ping">2.9 -PO <protocol list>(IP 协议 Ping)</h2><p><code>IP</code>协议 ping 是较新的主机发现选项之一，它发送的<code>IP</code>数据包在其 <code>IP</code>头中设置了指定的协议号。协议列表的格式与前面讨论的<code>TCP</code>、<code>UDP</code>和 <code>SCTP</code>主机发现选项中的端口列表相同。此主机发现方法查找使用与探针相同的协议的响应，或者查找表示目标主机不支持给定协议的<code>ICMP</code>协议不可达消息。无论哪种类型的响应都表明目标主机存活。</p><h2 id="prarp-ping">2.10 -PR(ARP Ping)</h2><p>当启动<code>Namp</code>主机发现时候，<code>Nmap</code>会对目标地址参数进行检查，如果与自身<code>IP</code>地址匹配到同一个子网内，<code>Nmap</code>会对该类目标采用<code>ARP</code>协议进行探测。即使命令参数规定的是其他探测手段，也会先使用<code>ARP</code>进行探测。这种方式效率高，速度快，但仅限于同一子网广播域中。<code>ARP</code>（AddressResolutionProtocol，地址解析协议）是用来将<code>IP</code>地址解析为<code>MAC</code>地址的协议。主机或三层网络设备上会维护一张<code>ARP</code>表，用于存储<code>IP</code>地址和<code>MAC</code>地址的映射关系，一般<code>ARP</code>表项包括动态<code>ARP</code>表项和静态<code>ARP</code>表项。</p><h2 id="disable-arp-ping-no-arp-or-nd-ping">2.11 --disable-arp-ping (NoARP or ND Ping)</h2><p><code>Nmap</code> 通常会发现本地连接的以太网主机的 <code>ARP</code>或 <code>IPv6</code>邻居发现 (ND)，即使使用了 <code>-Pn</code>或<code>-PE</code>等其他主机发现选项。要禁用这种隐式行为，请使用<code>--disable-arp-ping</code>选项。</p><h2 id="discovery-ignore-rst">2.12 --discovery-ignore-rst</h2><p>在某些情况下，防火墙可能会欺骗 <code>TCP</code> 重置(<code>RST</code>) 回复，以响应对未占用或不允许的地址的探测。由于<code>Nmap</code>通常会将 <code>RST</code>回复视为目标已启动的证明，这可能导致浪费扫描不存在的目标的时间。使用<code>--discovery-ignore-rst</code>会阻止<code>Nmap</code>在发现主机时考虑这些回复。您可能需要选择额外的主机发现选项，以确保在这种情况下不会错过目标。</p><h2 id="traceroute跟踪主机路径">2.13 --traceroute(跟踪主机路径)</h2><p><code>Traceroute</code>的工作原理是发送TTL（生存时间）较低的数据包，试图从扫描器和目标主机之间的中间跳诱发<code>ICMP</code>时间超限信息。标准的<code>traceroute</code> 实现以 1 的 TTL 开始，并递增 TTL直到到达目标主机。<code>Nmap</code>的<code>traceroute</code>从高TTL开始，然后递减TTL，直到TTL为零。这样做可以让<code>Nmap</code>采用巧妙的缓存算法，加快对多台主机的跟踪。根据网络条件，<code>Nmap</code>平均每台主机少发送5-10 个数据包。如果扫描的是单个子网（如192.168.0.0/24），<code>Nmap</code>可能只需向大多数主机发送两个数据包。</p><h1 id="端口扫描">3 端口扫描</h1><h2 id="端口状态">3.1 端口状态</h2><ul><li><code>open</code></li><li><code>closed</code></li><li><code>filterd</code></li><li><code>unfilterd</code></li><li><code>open|unfilterd</code></li><li><code>closed|unfilterd</code></li></ul><h2 id="概述-1">3.2 概述</h2><ul><li><p>虽然 Nmap试图生成准确的结果，但请记住，它的所有见解都是基于目标机器（或它们前面的防火墙）返回的数据包。这类主机可能不值得信任，它们发送的响应会迷惑或误导Nmap。更常见的是不符合 RFC 标准的主机，它们不会对 Nmap探测作出应有的响应。FIN、NULL 和 Xmas扫描特别容易出现这种问题。</p></li><li><p>大多数扫描类型只有特权用户才能使用。这是因为发送和接收原始数据包需要Unix 系统的 root 访问权限。</p></li><li><p>本节记录了 Nmap支持的十几种端口扫描技术。一次只能使用一种方法，除了 UDP 扫描 (-sU)和任何一种 SCTP 扫描类型 (-sY, -sZ) 可以与任何一种 TCP扫描类型结合使用。为便于记忆，端口扫描类型选项的形式为 -s<C>，其中 <C>是扫描名称中的一个突出字符，通常是第一个字符。唯一的例外是已废弃的 FTP反弹扫描 (-b)。默认情况下，Nmap 执行 SYN扫描，但如果用户没有发送原始数据包的适当权限（在 Unix 上需要 root访问权限），Nmap会用连接扫描代替。在本节列出的扫描中，非特权用户只能执行连接和 FTP反弹扫描。</p></li></ul><h2 id="ss-tcp-syn-scan">3.3 <code>-sS</code> (TCP SYN scan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048783.png"alt="image-20230928092641400" /><figcaption aria-hidden="true">image-20230928092641400</figcaption></figure><ul><li>半连接扫描基于TCP三次握手规则，探测服务端口是否开放。</li><li>服务端口开放，会返回 SYN/ACK 消息；如果收到 SYN 数据包（不含 ACK标志）的响应，端口也会被认为是开放的。这可能是由于一种极为罕见的 TCP功能造成的，这种功能被称为同时打开或分裂握手连接。</li><li>服务端口关闭，会返回RST消息。</li><li>如果数次重发后仍没响应，该端口就被标记为被过滤。如果收到ICMP不可到达错误(类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</li><li>优点：一般不会被目标主机的应用所记录。</li><li>缺点：运行Raw Socket时必须拥有管理员权限。</li></ul><h2 id="st-tcp-connect-scan">3.4 <code>-sT</code> (TCP connectscan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048784.png"alt="image-20230928092955007" /><figcaption aria-hidden="true">image-20230928092955007</figcaption></figure><ul><li>左边为服务端，右边为客户端。</li><li>当 无法使用SYN 扫描时，TCP 连接扫描是默认的 TCP扫描类型。当用户没有原始数据包权限时就是这种情况。</li><li>Nmap 不像大多数其他扫描类型那样写入原始数据包，而是通过发出 connect系统调用，使用此 API来获取每次连接尝试的状态信息，而不是从网上读取原始数据包响应。</li><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul><h2 id="su-udp-scans">3.5 <code>-sU</code> (UDP scans)</h2><ul><li>虽然互联网上大多数流行服务都是通过 TCP 协议运行的，但 UDP服务也被广泛部署。DNS、SNMP 和 DHCP（注册端口 53、161/162 和67/68）是最常见的三种服务。</li><li>UDP 扫描使用 -sU 选项激活。它可以与 SYN 扫描 (-sS) 等 TCP扫描类型结合使用，在同一运行过程中同时检查两种协议。</li><li>如果返回 ICMP 端口不可到达错误（类型 3，代码3），端口将被关闭。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、2、9、10 或13）会将端口标记为已过滤。</li><li>偶尔，服务会响应一个 UDP 数据包，证明它是开放的。</li><li>如果重传后没有收到响应，端口就会被归类为 "开放"|"已过滤"。</li><li>缺点：扫描速度慢。解决方案：并行扫描更多主机、先对常用端口进行快速扫描、从防火墙后面进行扫描，以及使用--host-timeout 跳过慢速主机。</li></ul><h2 id="sy-sctp-init-scan">3.6 <code>-sY</code> (SCTP INIT scan)</h2><ul><li>SCTP 是 TCP 和 UDP 协议的一种相对较新的替代协议，它结合了 TCP 和 UDP协议的大多数特性，并增加了新的功能，如multi-homing和multi-streaming。</li><li>这种技术通常被称为半开扫描，因为你不会打开一个完整的 SCTP关联。您发送的是 INIT块，就好像您要打开一个真正的关联，然后等待响应。</li><li>INIT-ACK 块表示端口正在监听（打开）。</li><li>ABORT 块则表示端口未监听。</li><li>如果数次重传后仍未收到响应，端口就会被标记为已被过滤。如果收到 ICMP不可到达错误（类型 3，代码 0、1、2、3、9、10 或13），端口也会被标记为已过滤。</li></ul><h2 id="sn--sf--sx-tcp-null-fin-and-xmas-scans">3.7 <code>-sN</code>;<code>-sF</code>; <code>-sX</code> (TCP NULL, FIN, and Xmas scans)</h2><ul><li>假设扫描系统遵循RFC标准，如果收到一个RST报文，该端口被认为是closed(关闭的)</li><li>没有响应则意味着端口是open|filtered(开放或者被过滤的)</li><li>如果收到ICMP不可到达错误(类型 3，代号1，2，3，9，10，或者13)，该端口就被标记为被过滤的。</li><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li><li>FIN扫描 (-sF)：只设置TCP FIN标志位。</li><li>Null扫描 (-sN)：不设置任何标志位(tcp标志头是0)</li><li>Xmas扫描 (-sX)：设置FIN，PSH，和URG标志位</li><li>除了探测报文的标志位不同，这三种扫描在行为上完全一致。</li><li>主要优势：它们可以偷偷穿过某些非状态防火墙和数据包过滤路由器。另一个优势是，这些扫描类型甚至比SYN 扫描更隐蔽。</li></ul><h2 id="sa-tcp-ack-scan">3.8 <code>-sA</code> (TCP ACK scan)</h2><ul><li>ACK 扫描探测包只设置 ACK 标志（除非使用 --scanflags）。</li><li>扫描未过滤系统时，打开和关闭的端口都会返回一个 RST 数据包。Nmap会将这些端口标记为未过滤端口，这意味着 ACK数据包可以到达这些端口，但无法确定这些端口是开放的还是关闭的。</li><li>没有响应或发送某些 ICMP 错误信息（类型 3，代码 0、1、2、3、9、10 或13）的端口会被标记为已过滤。</li></ul><h2 id="sw-tcp-window-scan">3.9 <code>-sW</code> (TCP Window scan)</h2><ul><li>窗口扫描与 ACK扫描完全相同，只是它利用某些系统的实现细节来区分开放端口和关闭端口。</li><li>在某些系统中，开放端口使用正窗口大小（即使是 RST数据包），而关闭端口的窗口大小为零。</li><li>这种扫描依赖于互联网上少数系统的实现细节，因此不能总是相信它。</li></ul><h2 id="sm-tcp-maimon-scan">3.10 <code>-sM</code> (TCP Maimon scan)</h2><ul><li>该技术与 NULL、FIN 和 Xmas 扫描完全相同，只是探针是 FIN/ACK。</li><li>根据 RFC 793（TCP），无论端口是开放还是关闭，都应该生成一个 RST数据包来响应这种探测。</li><li>不过，Uriel 注意到，如果端口是开放的，许多 BSD衍生系统会直接丢弃数据包。</li></ul><h2 id="scanflags-custom-tcp-scan">3.11 <code>--scanflags</code> (CustomTCP scan)</h2><ul><li>--scanflags 参数可以是一个数字标志值，如 9（PSH 和FIN），但使用符号名称更方便。</li><li>除了指定所需的标记外，还可以指定 TCP 扫描类型（如 -sA 或-sF）。</li></ul><h2 id="sz-sctp-cookie-echo-scan">3.12 <code>-sZ</code> (SCTP COOKIEECHO scan)</h2><ul><li>利用了 SCTP 实现应在开放端口上静默丢弃包含 COOKIE ECHO块的数据包，但在端口关闭时发送 ABORT 的事实。</li><li>这种扫描类型的优点是，它的端口扫描不像 INIT扫描那么明显。此外，非状态防火墙规则集可能会阻止 INIT 数据块，但不会阻止COOKIE ECHO 数据块。不要以为这样就能使端口扫描不可见；好的 IDS也能检测到 SCTP COOKIE ECHO 扫描。</li><li>缺点是 SCTP COOKIE ECHO扫描无法区分开放端口和过滤端口，因此在两种情况下都会出现 open|filtered状态。</li></ul><h2 id="si-idle-scan">3.13 <code>-sI</code><zombie host>[:<probeport>](idle scan)</h2><ul><li>这种先进的扫描方法允许对目标进行真正的盲 TCP端口扫描（这意味着不会从您的真实 IP地址向目标发送数据包）。相反，一种独特的侧信道攻击会利用僵尸主机上可预测的IP 碎片 ID 序列生成来收集目标机开放端口的信息。</li><li>这种扫描类型还允许绘制机器之间基于 IP 的信任关系图。</li><li>如果您想探测僵尸主机上的特定端口，以了解 IP ID的变化，您可以在僵尸主机后添加冒号和端口号。否则 Nmap 将使用默认用于 TCPping 的端口 (80)。</li></ul><h2 id="so-ip-protocol-scan">3.14 <code>-sO</code> (IP protocolscan)</h2><ul><li>IP 协议扫描允许您确定目标计算机支持哪些 IP 协议（TCP、ICMP、IGMP等）。</li><li>如果 Nmap 从目标主机收到任何协议的响应，Nmap就会将该协议标记为打开。</li><li>ICMP 协议不可到达错误（类型 3，代码2）会导致协议被标记为关闭，而端口不可到达（类型 3，代码3）会导致协议被标记为打开。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、9、10 或13）会导致协议被标记为已过滤（尽管它们同时证明 ICMP 是开放的）。</li><li>如果重传后仍未收到响应，则标记为协议已打开|已过滤</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048785.png"alt="image-20230928100330382" /><figcaption aria-hidden="true">image-20230928100330382</figcaption></figure><h2 id="bftp-bounce-scan">3.15 <code>-b</code><FTP relay host>(FTPbounce scan)</h2><ul><li>利用FTP 服务器对其他主机进行端口扫描。只需让 FTP服务器依次向目标主机的每个感兴趣的端口发送文件即可。</li><li>错误信息将说明端口是否开放。</li><li>这是一种绕过防火墙的好方法，因为企业的 FTP服务器通常比任何旧的互联网主机更容易访问其他内部主机。</li><li>该漏洞现已基本修复。</li></ul><h1 id="服务和版本检测">4 服务和版本检测</h1><h2 id="sv-version-detection">4.1 <code>-sV</code> (Versiondetection)</h2><p>-sR 是 -sV 的别名。</p><h2 id="allports-dont-exclude-any-ports-from-version-detection">4.2<code>--allports</code> (Don't exclude any ports from versiondetection)</h2><p>默认情况下，Nmap 版本检测会跳过 TCP 9100端口，因为有些打印机会简单地打印发送到该端口的任何内容，导致几十页的HTTP GET 请求、二进制 SSL 会话请求等。</p><h2 id="version-intensity-intensity-set-version-scan-intensity">4.3<code>--version-intensity &lt;intensity&gt;</code> (Set version scanintensity)</h2><p>执行版本扫描 (-sV) 时，Nmap 会发送一系列探针，每个探针的稀有度值介于1 到 9之间。编号较低的探针对各种常见服务有效，而编号较高的探针则很少有用。强度级别规定了应使用哪些探针。数字越大，正确识别服务的可能性就越大。不过，高强度扫描需要更长的时间。强度必须在0 到 9 之间。通过 nmap-service-probes ports指令向目标端口注册探针时，无论强度级别如何，都会尝试该探针。这样可以确保DNS 探测总是针对任何开放的 53 端口，SSL 探测针对 443 端口等。</p><h2 id="version-light-enable-light-mode">4.4<code>--version-light</code> (Enable light mode)</h2><p>这是 --version-intensity 2的别名。这种轻度模式使版本扫描速度更快，但识别服务的可能性略低。</p><h2 id="version-all-try-every-single-probe">4.5<code>--version-all</code> (Try every single probe)</h2><p>--version-intensity 9 的别名，确保对每个端口都进行一次探测。</p><h2 id="version-trace-trace-version-scan-activity">4.6<code>--version-trace</code> (Trace version scan activity)</h2><p>这会导致 Nmap 打印出大量关于版本扫描正在进行的调试信息。它是--packet-trace 的子集。</p><h1 id="操作系统检测">5 操作系统检测</h1><p>Nmap 最著名的功能之一是使用 TCP/IP 堆栈指纹进行远程操作系统检测。Nmap向远程主机发送一系列 TCP 和 UDP数据包，并检查响应中的几乎每一位。在执行了数十项测试（例如 TCP ISN采样、TCP 选项支持和排序、IP ID 采样以及初始窗口大小检查）后，Nmap将结果与它的结果进行比较 <code>nmap-os-db</code> 数据库包含 2,600多个已知操作系统指纹，如果匹配则打印出操作系统详细信息。</p><h2 id="o-enable-os-detection">5.1 <code>-O</code> (Enable OSdetection)</h2><p>启用操作系统检测</p><h2 id="osscan-limit-limit-os-detection-to-promising-targets">5.2<code>--osscan-limit</code> (Limit OS detection to promisingtargets)</h2><p>如果发现至少一个打开的 TCP 端口和一个关闭的 TCP端口，操作系统检测就会有效得多。设置此选项后，Nmap甚至不会尝试对不符合此标准的主机进行操作系统检测。这可以节省大量时间，特别是在对许多主机进行-Pn 扫描时。它只在使用 -O 或 -A 请求操作系统检测时才起作用。</p><h2 id="osscan-guess---fuzzy-guess-os-detection-results">5.3<code>--osscan-guess</code>; <code>--fuzzy</code> (Guess OS detectionresults)</h2><p>允许进行近似匹配</p><h2id="max-os-tries-set-the-maximum-number-of-os-detection-tries-against-a-target">5.4<code>--max-os-tries</code> (Set the maximum number of OS detectiontries against a target)</h2><p>当 Nmap对目标执行操作系统检测但未能找到完美匹配时，它通常会重复尝试。默认情况下，如果条件有利于提交操作系统指纹，Nmap会尝试五次；如果条件不太好，Nmap 会尝试两次。</p><h1 id="nmap常用命令">6 Nmap常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取远程主机的系统类型及开放端口</span><br>nmap -sS -P0 -sV -O &lt; target &gt;<br><span class="hljs-comment"># 其他选项</span><br><span class="hljs-comment"># -A 同时打开操作系统指纹和版本检测</span><br><span class="hljs-comment"># -v 详细输出扫描情况.</span><br>nmap -sS -P0 -A -v &lt; target &gt;<br></code></pre></td></tr></table></figure><p>参考资料：</p><ol type="1"><li><code>Nmap</code>官方文档：https://nmap.org/book/man.html</li><li>https://cshihong.github.io/2019/09/24/nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</li><li>https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=141607</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MD5 Collision Attack</title>
    <link href="/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/"/>
    <url>/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="md5算法流程">1 MD5算法流程</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032637.png"alt="MD5流程" /><figcaption aria-hidden="true">MD5流程</figcaption></figure><h1 id="实验过程">2 实验过程</h1><h2id="task-1generating-two-different-files-with-the-same-md5-hash">Task1：Generating Two Different Files with the Same MD5 Hash</h2><ul><li><p><strong>Question 1.</strong> If the length of your prefix file isnot multiple of 64, what is going to happen?</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032639.png"alt="image-20230927195026732" /><figcaption aria-hidden="true">image-20230927195026732</figcaption></figure><ol type="1"><li><p>步骤1：生成小于64字节（或其他不是64字节倍数）的前缀文件；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4&amp;步骤5：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032640.png"alt="image-20230927195104857" /><figcaption aria-hidden="true">image-20230927195104857</figcaption></figure></li><li><p>发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件，命令格式：<code>bless fileName</code>。结论：前64（0x40）字节使用了空字符填充；剩余部分内容大致相同，仅有少数字节不同，如下图中勾选部分。填充原因：MD5处理大小为64字节的块。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032641.png"alt="image-20230927195612726" /><figcaption aria-hidden="true">image-20230927195612726</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032642.png"alt="image-20230927195637940" /><figcaption aria-hidden="true">image-20230927195637940</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><p><strong>Question 2.</strong> Create a prefix file with exactly 64bytes, and run the collision tool again, and see what happens.</p><ol type="1"><li><p>步骤1：生成64字节的前缀文件（末尾会有一个换行符，所以实际输入字符为63个）；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032643.png"alt="image-20230927195753720" /><figcaption aria-hidden="true">image-20230927195753720</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032644.png"alt="image-20230927195811834" /><figcaption aria-hidden="true">image-20230927195811834</figcaption></figure></li><li><p>同样发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件。发现此次输出文件中未进行补零；同样，前缀部分完全相同，剩余部分除部分字节外大致相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032645.png"alt="image-20230927195827718" /><figcaption aria-hidden="true">image-20230927195827718</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032646.png"alt="image-20230927195848313" /><figcaption aria-hidden="true">image-20230927195848313</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><p><strong>Question 3.</strong> Are the data (128 bytes) generatedby md5collgen completely different for the two output files? Pleaseidentify all the bytes that are different.</p><p>answer：没有完全不同。Question 1中有5个字节不同，Question2中有6个字节不同。不同之处为上述图中勾画部分。</p></li></ul><h2 id="task-2-understanding-md5s-property">Task 2: Understanding MD5’sProperty</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032647.png"alt="image-20230927200007327" /><figcaption aria-hidden="true">image-20230927200007327</figcaption></figure><ol type="1"><li><p>MD5算法属性：给定两个输入M，N如果MD5(M) =MD5(N)，那么对于任何输入T，MD5(M || T) = MD5(N ||T)。因此，将特定的suffix添加到具有相同 MD5散列的任何两个不同消息中，通过连接原始消息和suffix消息，得到两个新的更长消息，这两个消息也具有相同的MD5 散列。</p></li><li><p>步骤1：构造前缀文件；步骤2：指定前缀，生成两个具有相同 MD5哈希值的文件；步骤3：检查输出文件是否相同；步骤4：构造后缀文件；步骤5&amp;步骤6：分别使用cat命令对两个文件（生成的输出文件+后缀文件）进行拼接；步骤7：查看各个文件MD5哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032648.png"alt="image-20230927200103119" /><figcaption aria-hidden="true">image-20230927200103119</figcaption></figure></li><li><p>结论：观察得到两个具有不同内容，但MD5哈希值相同的文件，拼接上同一个后缀之后，它们的MD5哈希值仍然相同。因此，给定两个输入M，N如果MD5(M)= MD5(N)，那么对于任何输入T，MD5(M || T) = MD5(N ||T)，该属性得证。注意：拼接后缀后的哈希值与原哈希值不同。</p></li></ol><h2id="task-3-generating-two-executable-files-with-the-same-md5-hash">Task3: Generating Two Executable Files with the Same MD5 Hash</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032649.png"alt="image-20230927200323704" /><figcaption aria-hidden="true">image-20230927200323704</figcaption></figure><ol type="1"><li><p>相关命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># The first command above saves the first 3200 bytes of a.out to prefix.</span><br><span class="hljs-comment"># The second command saves the last 100 bytes of a.out to suffix. </span><br><span class="hljs-comment"># The third command saves the data from the 3300th byte to the end # of the file a.out（左开右闭区间） to suffix.</span><br>$ <span class="hljs-built_in">head</span> -c 3200 a.out &gt; prefix<br>$ <span class="hljs-built_in">tail</span> -c 100 a.out &gt; suffix<br>$ <span class="hljs-built_in">tail</span> -c +3300 a.out &gt; suffix<br></code></pre></td></tr></table></figure></li><li><p>目标：创建两个 MD5 哈希值相同但输出不同的程序。</p></li><li><p>根据实验说明编写demo.c程序，并进行编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, xyz[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032650.png"alt="image-20230927200830144" /><figcaption aria-hidden="true">image-20230927200830144</figcaption></figure></li><li><p>使用bless查看demo.out文件，先找到数组位置，数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032651.png"alt="image-20230927200915995" /><figcaption aria-hidden="true">image-20230927200915995</figcaption></figure></li><li><p>截取前缀部分，作为demo_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032652.png"alt="image-20230927201000671" /><figcaption aria-hidden="true">image-20230927201000671</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5哈希值的文件(每个生成文件的最后128位是P和Q)。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032653.png"alt="image-20230927201015560" /><figcaption aria-hidden="true">image-20230927201015560</figcaption></figure></li><li><p>截取后缀部分（前缀部分+128字节开始），作为demo_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032654.png"alt="image-20230927201030131" /><figcaption aria-hidden="true">image-20230927201030131</figcaption></figure></li><li><p>使用第四步生成的文件分别和demo_suffix进行拼接，得到demo_out1s.bin和demo_out2s.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032655.png"alt="image-20230927201047554" /><figcaption aria-hidden="true">image-20230927201047554</figcaption></figure></li><li><p>步骤1得到demo_out1s.bin和demo_out2s.bin的内容不同，步骤2得到它们的哈希值相同。通过bless中对两个文件分析，发现中间128字节内容仅个别字节不同，大部分相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032656.png"alt="image-20230927201108023" /><figcaption aria-hidden="true">image-20230927201108023</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032657.png"alt="image-20230927201114742" /><figcaption aria-hidden="true">image-20230927201114742</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032658.png"alt="image-20230927201121256" /><figcaption aria-hidden="true">image-20230927201121256</figcaption></figure></li></ol><h2 id="task-4-making-the-two-programs-behave-differently">Task 4:Making the Two Programs Behave Differently</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032659.png"alt="image-20230927202206700" /><figcaption aria-hidden="true">image-20230927202206700</figcaption></figure><ol type="1"><li><p>目标：生成两个行为不同，但哈希值相同的目标程序。</p></li><li><p>根据实验指导，编写task4.c程序，并进行编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">200</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i] != b[i])<br>        &#123;<br>            flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is benign code!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is malicious code!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032660.png"alt="image-20230927202354382" /><figcaption aria-hidden="true">image-20230927202354382</figcaption></figure></li><li><p>使用bless查看task4.out文件，先找到数组位置，第一个数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。因此，前缀中包含了32个’A’。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032661.png"alt="image-20230927202409522" /><figcaption aria-hidden="true">image-20230927202409522</figcaption></figure></li><li><p>截取前缀部分，作为task4_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032662.png"alt="image-20230927202421078" /><figcaption aria-hidden="true">image-20230927202421078</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5 哈希值的文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032663.png"alt="image-20230927202429531" /><figcaption aria-hidden="true">image-20230927202429531</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032664.png"alt="image-20230927202441720" /><figcaption aria-hidden="true">image-20230927202441720</figcaption></figure></li><li><p>从GCC处开始（0x31c8），截取剩余部分，作为task4_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032665.png"alt="image-20230927202455398" /><figcaption aria-hidden="true">image-20230927202455398</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032666.png"alt="image-20230927202503922" /><figcaption aria-hidden="true">image-20230927202503922</figcaption></figure></li><li><p>把步骤4中生成的其中一个文件的后160个字节（32(字符A)+128(Padding)）截取出来，作为task4_middle文件的输入。根据代码逻辑，被选取出的文件在拼接成为一个可执行文件后，将执行善意代码，此处我们选取task4_out1.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032667.png"alt="image-20230927202526131" /><figcaption aria-hidden="true">image-20230927202526131</figcaption></figure></li><li><p>数组大小为200字节，因此还需要40字节的字符串,保存至task4_0xA。并且注意到，两个数组间有24字节的0x00字符，保存至task4_str0。特别注意：python生成时会在末尾自动加上0x0A，因此我们对生成的文件进行截取。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032668.png"alt="image-20230927202538212" /><figcaption aria-hidden="true">image-20230927202538212</figcaption></figure></li><li><p>按下表方式开始进行拼接（拼接过程中要维持编译文件原有结构，但拼接方式不唯一）：</p><table><thead><tr class="header"><th>前缀输出文件</th><th>数组a补充（40字节）</th><th>间隔（24字节）</th><th>数组b主体（160字节）</th><th>数组b补充（40字节）</th><th>后缀</th></tr></thead><tbody><tr class="odd"><td>task4_out1.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr><tr class="even"><td>task4_out2.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr></tbody></table><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032669.png"alt="image-20230927202618655" /><figcaption aria-hidden="true">image-20230927202618655</figcaption></figure></li><li><p>分别运行两个最终文件（task4_1/task4_2），此处需要先赋予执行权限。与之前推理结果一致，task4_1执行善意代码，task4_2执行恶意代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032670.png"alt="image-20230927202628947" /><figcaption aria-hidden="true">image-20230927202628947</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032671.png"alt="image-20230927202638045" /><figcaption aria-hidden="true">image-20230927202638045</figcaption></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/26/网络攻防-口令攻击/#实验-MD5碰撞">网络攻防-口令攻击- Sean's Blog (seanxz401.github.io)</a></li><li>https://www.cnblogs.com/skprimin/p/16177784.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Cryptography</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH2-信息收集技术</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集概述">2.1 信息收集概述</h1><h2 id="信息收集的内容">2.1.1 信息收集的内容</h2><ul><li>定义：信息收集是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动</li><li>内容：域名和IP地址；操作系统类型；开放端口；提供开放端口的服务或应用程序；防火墙、入侵检测等安全防范措施</li><li>分类：<ul><li>主动：通过直接访问、扫描网站，这种将流量流经网站的行为</li><li>被动：利用第三方的服务对目标进行访问了解，比例：Google搜索</li></ul></li></ul><h2 id="信息收集的方法">2.1.2 信息收集的方法</h2><ul><li>社会工程学</li><li>技术手段：公开信息收集、网络扫描、漏洞扫描、网络拓扑检测</li></ul><h1 id="公开信息收集">2.2 公开信息收集</h1><h2 id="利用web服务">2.2.1 利用web服务</h2><ul><li><p>网站公开邮箱（结合社会工程学）</p></li><li><p>目标域名、IP地址、网站模板、网络管理员信息、公司人员名单</p></li><li><p>网络拓扑结构图</p></li></ul><h2 id="利用搜索引擎服务">2.2.2 利用搜索引擎服务</h2><ul><li><p>基本语法</p><table><thead><tr class="header"><th><strong>And</strong></th><th><strong>与</strong></th></tr></thead><tbody><tr class="odd"><td><strong>OR</strong></td><td><strong>或</strong></td></tr><tr class="even"><td><strong>+</strong></td><td><strong>强制包含搜索项</strong></td></tr><tr class="odd"><td><strong>-</strong></td><td><strong>非，去掉搜索项</strong></td></tr><tr class="even"><td><strong>“”</strong></td><td><strong>包含一个完整的语义</strong></td></tr><tr class="odd"><td><strong>.</strong></td><td><strong>单个通配符</strong></td></tr><tr class="even"><td>*****</td><td><strong>任意通配符</strong></td></tr></tbody></table></li><li><p>搜索语法</p><table><thead><tr class="header"><th><strong>site</strong></th><th><strong>搜索具体服务器或域名的网页</strong></th></tr></thead><tbody><tr class="odd"><td><strong>filetype</strong></td><td><strong>搜索特定类型的文件</strong></td></tr><tr class="even"><td><strong>intitle</strong></td><td><strong>搜索网页标题</strong></td></tr><tr class="odd"><td><strong>inurl</strong></td><td><strong>搜索URL </strong></td></tr><tr class="even"><td><strong>intext</strong></td><td><strong>搜索正文</strong></td></tr><tr class="odd"><td><strong>link</strong></td><td><strong>搜索连接到指定网页的网页</strong></td></tr></tbody></table></li><li><p>https://zhuanlan.zhihu.com/p/142832509（谷歌黑客常用搜索语句一览）</p></li><li><p>搜索引擎：https://www.shodan.io/</p></li></ul><h2 id="利用whole服务">2.2.3 利用Whole服务</h2><ul><li>功能：查看已注册域名（域名登记人信息、联系电话和邮箱、域名注册时间和更新时间、权威DNS的IP地址）</li><li>使用方法：https://whois.chinaz.com/</li></ul><h2 id="利用dns域名服务">2.2.4 利用DNS域名服务</h2><ul><li>主服务器</li><li>辅助服务器（定期进行区域传送：允许一个辅域名服务器更新自己的区域数据）</li><li>缓存服务器</li></ul><p><strong>利用思路</strong>：</p><p>如果DNS配置不当，可能造成内部主机名和IP地址对的泄漏。即主DNS服务器允许任意IP地址从该服务器进行区域传送，进而泄露信息。</p><h2 id="cdn">2.2.5 CDN</h2><p>内容分发网络<code>CDN</code>是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。<code>CDN</code>可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的<code>CDN</code>服务器上，就可以更快到达他们的计算机。</p><h1 id="网络扫描">2.3 网络扫描</h1><h2 id="主机扫描">2.3.1 主机扫描</h2><h3 id="icmp扫描">2.3.1.1 ICMP扫描</h3><p><strong>ping扫描原理</strong>：</p><p>利用<code>ICMP协议</code>（响应请求/应答）进行工作</p><p><strong><code>ICMP</code>报文格式：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014073.png"alt="image-20230920161113121" /><figcaption aria-hidden="true">image-20230920161113121</figcaption></figure><p>类型域指明类型；代码域指明作用</p><p><strong>常见<code>ICMP</code>报文：</strong></p><table><thead><tr class="header"><th><strong>名称</strong></th><th><strong>类型</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>ICMP</code> DestinationUnreachable（目标不可达）</strong></td><td><strong>3</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> Source Quench</strong><strong>（源抑制）</strong></td><td><strong>4</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Redirection（重定向）</strong></td><td><strong>5</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> TimestampRequest/Reply（时间戳）</strong></td><td><strong>13/14</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Address MaskRequest/Reply（子网掩码）</strong></td><td><strong>17/18</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> EchoRequest/Reply（响应请求/应答）</strong></td><td><strong>8/0</strong></td></tr></tbody></table><p>注：根据RFC的定义，<code>TCP/IP</code>协议栈应该支持各种类型的<code>ICMP</code>报文。但事实上，在各个操作系统具体实现TCP/IP时，可能并没有完全遵循RFC标准。</p><h3 id="其他类型的主机扫描">2.3.1.2 其他类型的主机扫描</h3><ul><li>构造异常的<code>IP</code>包头</li><li>在<code>IP</code>头中设置无效的字段值</li><li>构造错误的数据分片</li><li>通过超长包探测内部路由器</li><li>反向映射探测</li></ul><h2 id="端口扫描">2.3.2 端口扫描</h2><p>参阅：https://nmap.org/man/zh/man-port-scanning-techniques.html</p><h3 id="connect扫描">2.3.2.1 Connect扫描</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014075.png"alt="image-20230920162546395" /><figcaption aria-hidden="true">image-20230920162546395</figcaption></figure><ul><li>即TCP Connect扫描。左边为服务端，右边为客户端。</li><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul><h3 id="syn扫描和fin扫描">2.3.2.2 SYN扫描和FIN扫描</h3><p><strong>SYN扫描</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014076.png"alt="image-20230920163233117" /><figcaption aria-hidden="true">image-20230920163233117</figcaption></figure><ul><li>半连接扫描基于TCP三次握手规则，探测服务端口是否开放。</li><li>服务端口开放，会返回<code>SYN/ACK</code>消息</li><li>服务端口关闭，会返回<code>RST</code>消息</li><li>如果数次重发后仍没响应，该端口就被标记为被过滤。如果收到<code>ICMP</code>不可到达错误(类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</li><li>优点：一般不会被目标主机的应用所记录</li><li>缺点：运行Raw Socket时必须拥有管理员权限</li></ul><p><strong>FIN扫描</strong></p><ul><li>假设扫描系统遵循RFC标准，如果收到一个<code>RST</code>报文，该端口被认为是closed(关闭的)</li><li>没有响应则意味着端口是open|filtered(开放或者被过滤的)</li><li>如果收到<code>ICMP</code>不可到达错误(类型 3，代号1，2，3，9，10，或者13)，该端口就被标记为被过滤的。</li><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li><li>FIN扫描 (-sF)：只设置<code>TCP FIN</code>标志位。</li><li>Null扫描 (-sN)：不设置任何标志位(tcp标志头是0)</li><li>Xmas扫描(-sX)：设置<code>FIN</code>，<code>PSH</code>，和<code>URG</code>标志位</li><li>除了探测报文的标志位不同，这三种扫描在行为上完全一致。</li></ul><h3 id="其他端口扫描技术">2.3.2.3 其他端口扫描技术</h3><ul><li><code>ACK</code>扫描：向目标主机的端口发送<code>ACK</code>包，如果收到<code>RST</code>包，说明该端口没有被防火墙屏蔽；不响应的端口或者发送特定的<code>ICMP</code>错误消息(类型3，代号1，2，3，9，10，或者13)的端口，标记为 filtered(被过滤的)。</li><li><code>IP</code>分段扫描</li><li>TCP FTP Proxy扫描</li></ul><h3 id="udp扫描">2.3.2.4 UDP扫描</h3><p>只需向目标主机<code>UDP</code>端口发送任意数据，如果端口没有开放，则返回一个“目标不可达”的<code>ICMP</code>报文</p><h2 id="系统类型扫描">2.3.3 系统类型扫描</h2><h3 id="利用端口扫描结果">2.3.3.1 利用端口扫描结果</h3><ul><li>由于现代操作系统往往提供一些自身特有的功能，而这些功能又很可能打开一些特定的端口</li><li>windows：135，137，139等</li><li>Lniux：512，513，514，2049等</li></ul><h3 id="利用banner">2.3.3.2 利用Banner</h3><p>服务程序接收到客户端的正常连接后所给出的欢迎信息</p><h3 id="tcpip协议栈指纹">2.3.3.3 TCP/IP协议栈指纹</h3><ul><li>不同的操作系统在实现<code>TCP/IP</code>协议栈时都或多或少地存在着差异。而这些差异，我们就称之为<code>TCP/IP</code>协议栈指纹</li><li>TCP指纹：<code>FIN</code>探测、<code>BOGUS</code>标记位探测、<code>SYN</code>泛洪测试等</li><li><code>IP</code>、<code>ICMP</code>指纹：<code>ICMP</code>错误信息查询、<code>ICMP</code>信息引用、<code>TOS</code>和<code>TTL</code></li></ul><h1 id="漏洞扫描">2.4 漏洞扫描</h1><h2 id="概念">2.4.1 概念</h2><ul><li><p>漏洞：在计算机安全领域，安全漏洞<code>SecurityHole</code>通常又称作脆弱性（vulnerability）</p></li><li><p>来源：</p><p>（1）硬件、软件或协议设计时的瑕疵 （2）硬件、软件或协议实现中的弱点（3）硬件、软件本身的瑕疵 （4）系统和网络的错误配置</p></li><li><p>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</p></li></ul><h2 id="分类">2.4.2 分类</h2><ul><li>主动式策略是<strong>基于网络</strong>的检测，通过执行一些脚本文件对系统进行攻击，并记录它的反应，从而发现其中的漏洞</li><li>被动式策略是<strong>基于主机</strong>的检测，对系统中不合适的设置、脆弱的口令以及其他同安全规则相抵触的对象进行检查</li></ul><h2 id="方法">2.4.3 方法</h2><ul><li>直接测试：指利用漏洞特点发现系统漏洞的方法</li><li>推断：它并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。采用推断方法的检测手段主要有版本检查、程序行为分析、操作系统堆栈指纹分析和时序分析等。</li><li>带凭证的测试：凭证是指访问服务所需要的用户名或者密码，包括UNIX的登录权限和从网络调用WindowsNT的<code>API</code>的能力。如果赋予测试进程目标系统的角色，将能够检查出更多的漏洞。</li></ul><h1 id="网络拓扑探测">2.5 网络拓扑探测</h1><h2 id="拓扑探测">2.5.1 拓扑探测</h2><ul><li><code>Traceroute</code>：<code>UDP</code>数据包、<code>TTL</code></li><li><code>SNMP</code>（简单网络管理协议）：不同类型网络设备之间客户机/服务器模式的简单通信协议<ul><li>Read：观察设备配置信息</li><li>Read/Write：有权写入信息</li></ul></li></ul><h2 id="网络设备识别">2.5.2 网络设备识别</h2><h3 id="利用专门搜索引擎">2.5.2.1 利用专门搜索引擎</h3><p>https://www.shodan.io/</p><p>https://www.zoomeye.org/</p><h3 id="基于设备指纹的设备类型探测">2.5.2.2基于设备指纹的设备类型探测</h3><p>主要介绍基于应用服务Banner的设备识别技术：</p><ul><li>FTP协议</li><li>SSH</li><li>Telnet</li><li>HTTP</li></ul><h3 id="网络实体ip地理位置定位">2.5.2.3 网络实体IP地理位置定位</h3><ul><li>基于查询信息的定位：通过查询机构注册的信息确定网络设备的地理位置</li><li>基于网络测量的定位：利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH1-网络攻击概述</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="网络安全威胁">1.1 网络安全威胁</h1><h2 id="事件">1.1.1 事件</h2><h2 id="成因">1.1.2 成因</h2><ul><li>技术因素<ul><li>协议缺陷：网络协议缺乏认证、加密等基本的安全特性</li><li>软件漏洞：软件规模庞大，复杂度提高，开发者安全知识缺乏</li><li>策略弱点：安全需求与应用需求不相一致，安全策略设计不当</li><li>硬件漏洞：硬件设计软件化使得软件漏洞同样出现在硬件之中</li></ul></li><li>人为因素<ul><li>攻击者：成分复杂，多数掌握着丰富的攻击资源</li><li>防御者：广大的网络应用人群缺少安全知识，专业人员数量、质量尚难满足对安全人才的迫切需求</li></ul></li></ul><h1 id="网络攻击技术">1.2 网络攻击技术</h1><h2 id="分类">1.2.1 分类</h2><ul><li>本地（物理）攻击：指攻击者通过实际接触被攻击的主机实施的各种攻击方法</li><li>主动攻击：指攻击者利用Web、FTP、Telnet等开放网络服务对目标实施的各种攻击</li><li>被动攻击：攻击者利用浏览器、邮件接收程序、文字处理程序等客户端应用程序漏洞或系统用户弱点，对目标实施的各种攻击</li><li>中间人攻击：指攻击者处于被攻击主机的某个网络应用的中间人位置，进行数据窃听、破坏或篡改等攻击</li></ul><p>注：主动与被动，主要是看是否需要对方采取动作</p><h2 id="步骤与方法">1.2.2 步骤与方法</h2><ul><li>信息收集</li><li>权限获取</li><li>安装后门</li><li>扩大影响</li><li>清除痕迹</li></ul><h1 id="网络攻击的发展趋势">1.3 网络攻击的发展趋势</h1><ul><li>攻击影响日益深远</li><li>攻击领域不断扩展</li><li>攻击技术愈加精细</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+PicGo搭建免费图床</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="操作步骤">1. 操作步骤</h1><h2 id="github">1.1 Github</h2><ul><li><p>新建仓库（注：必须为Public，勾选<code>Add a README file</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654111.png"alt="image-20230923153333076" /><figcaption aria-hidden="true">image-20230923153333076</figcaption></figure></li><li><p>生成token：点击<code>Github</code>右上角的用户头→<code>Settings</code>→<code>Developer settiings</code>→<code>Personal access tokens</code>→<code>Tokens(classic)</code>→<code>Generate new token</code>，在<code>Note</code>一栏输入创建的仓库名称，并勾选<code>repo</code>，最后在最下方点击<code>Generate token</code>按钮，就生成了对应的<code>Token</code>。注：新生成的<code>Token</code>只会显示一次，请妥善保存，如有遗失，重新生成即可。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654112.png"alt="image-20230923154939730" /><figcaption aria-hidden="true">image-20230923154939730</figcaption></figure></li></ul><h2 id="picgo">1.2 PicGo</h2><ul><li><p>下载PicGo所需版本</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654113.png"alt="image-20230923155129734" /><figcaption aria-hidden="true">image-20230923155129734</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654114.png"alt="image-20230923155430395" /><figcaption aria-hidden="true">image-20230923155430395</figcaption></figure></li><li><p>安装（略）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654115.png"alt="image-20230923155604890" /><figcaption aria-hidden="true">image-20230923155604890</figcaption></figure></li><li><p>配置</p><ul><li><p>为显示简捷，仅勾选GitHub</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654116.png"alt="image-20230923155808379" /><figcaption aria-hidden="true">image-20230923155808379</figcaption></figure></li><li><p><strong>特别注意</strong>：设定仓库名为账户+仓库名；自定义域名需要自己有域名才填写</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654117.png"alt="image-20230923165104951" /><figcaption aria-hidden="true">image-20230923165104951</figcaption></figure></li><li><p>点击<code>设为默认图床</code>，点击<code>确定</code></p></li></ul></li></ul><h2 id="typora">1.3 Typora</h2><p><code>文件</code>→<code>偏好设置</code>→<code>图像</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654118.png"alt="image-20230923163344947" /><figcaption aria-hidden="true">image-20230923163344947</figcaption></figure><h1 id="使用方法">2. 使用方法</h1><p>Typora：<code>格式</code>→<code>图像</code>→<code>上传所有本地图片</code></p><p>参考教程：</p><ol type="1"><li><ahref="https://cnhuazhu.top/butterfly/2021/02/20/GitHub+PicGo+jsDelivr搭建免费图床/">GitHub+PicGo+jsDelivr搭建免费图床| 花猪のBlog (cnhuazhu.top)</a></li><li>https://juejin.cn/post/6992451980379553828</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置指南</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="关于指南">1. 关于指南</h1><ul><li>本指南中提到的："<strong>站点配置</strong>" 指的 Hexo 博客目录下的<code>_config.yml</code>，"<strong>主题配置</strong>" 指的是<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>，注意区分；</li><li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>目录；</li></ul><h1 id="全局">2. 全局</h1><h2 id="覆盖配置">2.1 覆盖配置</h2><ul><li><p>在博客根目录下创建 <code>_config.fluid.yml</code> 文件，将主题的<code>_config.yml</code>（不是根目录下的<code>_config.yml</code>）全部配置复制过去，以后如果修改任何主题配置，都只需修改<code>_config.fluid.yml</code> 的配置即可；</p></li><li><p>只要存在于 <code>_config.fluid.yml</code>的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的;</p></li><li><p>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对<code>_config.fluid.yml</code> 同步修改;</p></li><li><p>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code>查看命令行输出;</p></li><li><p>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icon 注释掉，否则无法覆盖配置</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="博客标题">2.2 博客标题</h2><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的<code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。如需单独区别设置，可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏的相关配置</span><br><span class="hljs-comment"># Navigation bar</span><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class="hljs-comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;kaikaikai&#x27;s blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="导航菜单">2.3 导航菜单</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br> <span class="hljs-comment"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br> <span class="hljs-attr">menu:</span><br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>   <span class="hljs-comment">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="展示pv与uv统计">2.4 展示PV与UV统计</h2><p>页脚可以展示 PV 与 UV 统计数据，目前支持两种数据来源：<ahref="https://www.leancloud.cn/">LeanCloud</a>与 <ahref="http://busuanzi.ibruce.info/">不蒜子</a>。</p><p>相关<strong>主题配置</strong>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span>  <span class="hljs-comment"># 可选 leancloud | busuanzi  根据自己需求选择</span><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br></code></pre></td></tr></table></figure><h2 id="语言配置">2.5 语言配置</h2><p>不同语言会影响一些主题自带的文字。设置语言是在<strong>站点配置</strong>中，需要对应<code>fluid/languages/</code> 目录内的配置文件名:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h1 id="首页">3. 首页</h1><h2 id="文章摘要">3.1 文章摘要</h2><p>开关自动摘要（默认开启）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>若要手动指定摘要，使用 <code>&lt;!-- more --&gt;</code>MD文档里划分，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正文的一部分作为摘要<br>&lt;!-- more --&gt;<br>余下的正文<br></code></pre></td></tr></table></figure><p>或者在 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>里设置<code>excerpt</code> 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>TIP</p><ul><li><p>优先级: 手动摘要 &gt; 自动摘要</p></li><li><p>如果关闭自动摘要，并且没有设置手动摘要，摘要区域空白</p></li><li><p>无论哪种摘要都最多显示 3行，当屏幕宽度不足时会隐藏部分摘要。</p></li></ul><h2 id="文章跳转方式">3.2 文章跳转方式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 打开文章的标签方式</span><br>  <span class="hljs-comment"># The browser tag to open the post</span><br>  <span class="hljs-comment"># Available: _blank | _self</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br></code></pre></td></tr></table></figure><h2 id="文章信息">3.3 文章信息</h2><p>可配置隐藏包括发布时间、分类、标签。经过测试，如果首页的文章列表中没有略缩图和摘要，标题+文章信息的显示方式会使页面过于拥挤，所以给出此项配置供喜欢首页只显示文章标题的同学使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="隐藏文章">3.4 隐藏文章</h2><p>如果想把某些文章隐藏，<strong>不在首页和其他归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>隐藏后依然可以通过文章链接访问，所以可以用于一些需要链接跳转的特殊文章。</p><h2 id="归档文章">3.5 归档文章</h2><p>如果只是想让文章在首页隐藏，但仍<strong>需要在归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>archive: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">archive:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h2 id="文章排序">3.6 文章排序</h2><p>如果想手动将某些文章固定在首页靠前的位置，可以在安装<code>hexo-generator-index</code> &gt;= 2.0.0 版本的情况下，在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>sticky</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p><code>sticky</code>数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p><p>当文章设置了 <code>sticky</code>后，主题会默认在首页文章标题前增加一个图标，来标识这是一个置顶文章，你可以通过<strong>主题配置</strong>去关闭或修改这个功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-top&#x27;</span><br></code></pre></td></tr></table></figure><p><code>icon</code> 可以通过<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">自定义图标</a>修改为其他图标。</p><h1 id="文章页">4. 文章页</h1><h2 id="文章封面图">4.1 文章封面图</h2><p>对于单篇文章，在文章开头 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>index_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>和 Banner 配置相同，<code>/img/example.jpg</code> 对应的是存放在<code>/source/img/example.jpg</code>目录下的图片（目录也可自定义，但必须在 source 目录下）。</p><p>也可以使用外链 Url 的绝对路径。</p><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code>则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></td></tr></table></figure><p>当 <code>default_index_img</code> 和 <code>index_img</code>都为空时，该文章在首页将不显示图片。</p><h2 id="文章内容图片">4.2 文章内容图片</h2><p>本地图片存放位置同上。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">/img/example.jpg</span>)<br></code></pre></td></tr></table></figure><h2 id="代码块">4.3 代码块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">code:</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>copy_btn</code>: 是否开启复制代码的按钮</p><p><code>line_number</code>: 是否开启行号</p><p><code>highlight</code>: 是否开启代码高亮</p><p><code>lib</code>: 选择生成高亮的库，可选项:<code>highlightjs</code>、<code>prismjs</code>，对应下面两组配置，高亮的配置说明具体见<strong>主题配置</strong>中的注释</p><h2 id="latex-数学公式">4.4 LaTeX 数学公式</h2><ol type="1"><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure></li><li><p>更换 Markdown 渲染器(mathjax)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm uninstall hexo-renderer-marked --save<br>cnpm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></li><li><p>安装pandoc（需重启电脑）：<ahref="https://github.com/jgm/pandoc/blob/main/INSTALL.md">pandoc/INSTALL.mdat main · jgm/pandoc (github.com)</a></p></li></ol><h1 id="front-matter">5. Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>layout</code></td><td style="text-align: left;">布局</td><td style="text-align: left;"><ahref="https://hexo.io/zh-cn/docs/configuration#文章"><code>config.default_layout</code></a></td></tr><tr class="even"><td style="text-align: left;"><code>title</code></td><td style="text-align: left;">标题</td><td style="text-align: left;">文章的文件名</td></tr><tr class="odd"><td style="text-align: left;"><code>date</code></td><td style="text-align: left;">建立日期</td><td style="text-align: left;">文件建立日期</td></tr><tr class="even"><td style="text-align: left;"><code>updated</code></td><td style="text-align: left;">更新日期</td><td style="text-align: left;">文件更新日期</td></tr><tr class="odd"><td style="text-align: left;"><code>comments</code></td><td style="text-align: left;">开启文章的评论功能</td><td style="text-align: left;"><code>true</code></td></tr><tr class="even"><td style="text-align: left;"><code>tags</code></td><td style="text-align: left;">标签（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>categories</code></td><td style="text-align: left;">分类（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>permalink</code></td><td style="text-align: left;">覆盖文章的永久链接，永久链接应该以<code>/</code> 或 <code>.html</code> 结尾</td><td style="text-align: left;"><code>null</code></td></tr><tr class="odd"><td style="text-align: left;"><code>excerpt</code></td><td style="text-align: left;">纯文本的页面摘要。使用 <ahref="https://hexo.io/zh-cn/docs/tag-plugins#文章摘要和截断">该插件</a>来格式化文本</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>disableNunjucks</code></td><td style="text-align: left;">启用时禁用 Nunjucks 标签<code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a>的渲染功能</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;"><code>lang</code></td><td style="text-align: left;">设置语言以覆盖 <ahref="https://hexo.io/zh-cn/docs/internationalization#路径">自动检测</a></td><td style="text-align: left;">继承自 <code>_config.yml</code></td></tr><tr class="even"><td style="text-align: left;"><code>published</code></td><td style="text-align: left;">文章是否发布</td><td style="text-align: left;">对于 <code>_posts</code> 下的文章为<code>true</code>，对于 <code>_draft</code> 下的文章为<code>false</code></td></tr></tbody></table><h1 id="关于页">6. 关于页</h1><h2 id="创建关于页">6.1 创建关于页</h2><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加<code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>WARNING：<code>layout: about</code>必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p><h2 id="关于信息">6.2 关于信息</h2><p>在关于页介绍自己的基础信息，可以在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/avatar.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br></code></pre></td></tr></table></figure><h2 id="社交页图标">6.3 社交页图标</h2><p>在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-github-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://github.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;GitHub&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-douban-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://douban.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;豆瓣&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-wechat-fill&#x27;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 图标的<code>css class</code>，主题内置图标详见<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">这里</a></li><li><code>link</code>: 跳转链接</li><li><code>tip</code>: 鼠标悬浮在图标上显示的提示文字</li><li><code>qrcode</code>:二维码图片，当使用此字段后，点击不再跳转，而是悬浮二维码</li></ul><p>参考教程：</p><ol type="1"><li>https://fluid-dev.github.io/hexo-fluid-docs/guide/</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速搭建hexo博客</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备">1. 前期准备</h1><h2 id="安装node.js">1.1 安装Node.js</h2><p>官网链接：https://nodejs.org/en</p><p>安装教程：<ahref="https://blog.csdn.net/WHF__/article/details/129362462?spm=1001.2014.3001.5506">Node.js下载安装及环境配置教程【超详细】_nodejs下载-CSDN博客</a></p><p>npm运行报错解决方案：<ahref="https://blog.csdn.net/weixin_37861326/article/details/104295379?spm=1001.2014.3001.5506">npm运行时报错“因为在此系统上禁止运行脚本”解决办法_npm : 无法加载文件c:files.ps1,因为在此系__cris的博客-CSDN博客</a></p><h2 id="注册github账户">1.2 注册github账户</h2><h2 id="安装hexo">1.3 安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="快速搭建">2. 快速搭建</h1><h2 id="创建根目录">2.1 创建根目录</h2><p>本地创建一个文件夹，作为博客部署的空间，后续操作均基于该根目录</p><h2 id="初始化">2.2 初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><h2 id="启动本地服务">2.3 启动本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><h2 id="新建文章">2.4 新建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;My first blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="清理缓存">2.5 清理缓存</h2><p>注：每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用<code>hexo clean</code> 清除本地缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><h2 id="生成静态文件">2.6 生成静态文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h1 id="部署到github">3. 部署到github</h1><h2 id="新建仓库">3.1 新建仓库</h2><p>注：命名格式为固定要求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">账户名<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>(例：kaikaikai7<span class="hljs-selector-class">.github</span>.io)<br></code></pre></td></tr></table></figure><h2 id="安装插件">3.2 安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h2 id="修改配置文件">3.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Deployment部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/kaikaikai7/kaikaikai7.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="部署">3.4 部署</h2><p>注：页面结果以本地 <code>hexo s</code>为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h2 id="访问">3.5 访问</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>账户名.github.io/<br>（例：https:<span class="hljs-regexp">//</span>kaikaikai7.github.io/）<br></code></pre></td></tr></table></figure><h1 id="更换主题">4. 更换主题</h1><h2 id="主题官网">4.1 主题官网</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>hexo.io<span class="hljs-regexp">/themes/</span><br></code></pre></td></tr></table></figure><h2 id="下载主题">4.2 下载主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 主题地址.git themes/目录<br>（例：git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia）<br></code></pre></td></tr></table></figure><h2 id="修改配置文件-1">4.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Extensions部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure></li></ol><p>参考教程：</p><ol type="1"><li>https://www.bilibili.com/video/BV1Yb411a7ty/</li><li><ahref="https://cnhuazhu.top/butterfly/2021/01/21/Hexo快速搭建一个博客/">Hexo快速搭建一个博客| 花猪のBlog (cnhuazhu.top)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
